feedback from the context; for example, the lexical entry for borders world has been used to guide both syntactic parsing is s\np/np : ay.ax.border(x, y), which means (schuler, 2003) and semantic parsing (popescu et borders looks right for the first argument and left al., 2003; clarke et al., 2010).
to contrast, consider et al. (2010), which we discussed earlier.
the main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (dcs), which is both simple and expressive (section 2).
eisenciations due to data sparsity, and having an insuffi- stein et al. (2009) induces conjunctive formulae and ciently large k. uses them as features in another learning problem.
at the same time, representations such as funql (kate et al., 2005), which was used in clarke et al. (2010), are simpler but lack the full expressive power of lambda calculus.
table 3 shows that even dcs, which does not use prototypes, is comparable to the best previous system (kwiatkowski et al., 2010), and by adding a few prototypes, dcs+ offers a decisive edge (91.1% over 88.9% on geo).
ccg is one instantiation (steedman, 2000), which is used by many semantic parsers, e.g., zettlemoyer and collins (2005).
unlike standard semantic parsing, our end goal is only to generate the correct y, so we are free to choose the representation for z.
we first present a basic version (section 2.1) of dependency-based compositional semantics (dcs), which captures the core idea of using trees to represent formal semantics.
it is impossible to represent the semantics of this phrase with just a csp, so we introduce a new aggregate relation, notated e. consider a tree he:ci, whose root is connected to a child c via e. if the denotation of c is a set of values s, the parentâ€™s denotation is then a singleton set containing s. formally: figure 3(a) shows the dcs tree for our running example.
