input output
parsing: input/ref/Task1/A00-2018_akanksha.csv
<S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S>
    <S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'", "'91'"]
'90'
'91'
['90', '91']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees [16] that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established [5,9,10,15,17] &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'"]
'5'
['5']
parsed_discourse_facet ['method_citation']
<S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'"]
'90'
['90']
parsed_discourse_facet ['method_citation']
<S sid="48" ssid="17">Maximum-entropy models have two benefits for a parser builder.</S>
    <S sid="49" ssid="18">First, as already implicit in our discussion, factoring the probability computation into a sequence of values corresponding to various &amp;quot;features&amp;quot; suggests that the probability model should be easily changeable &#8212; just change the set of features used.</S>
    <S sid="51" ssid="20">Second, and this is a point we have not yet mentioned, the features used in these models need have no particular independence of one another.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'51'"]
'48'
'49'
'51'
['48', '49', '51']
parsed_discourse_facet ['method_citation']
<S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S>
    <S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
    <S sid="92" ssid="3">For runs with the generative model based upon Markov grammar statistics, the first pass uses the same statistics, but conditioned only on standard PCFG information.</S>
    <S sid="93" ssid="4">This allows the second pass to see expansions not present in the training corpus.</S>
    <S sid="94" ssid="5">We use the gathered statistics for all observed words, even those with very low counts, though obviously our deleted interpolation smoothing gives less emphasis to observed probabilities for rare words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'", "'91'", "'92'", "'93'", "'94'"]
'90'
'91'
'92'
'93'
'94'
['90', '91', '92', '93', '94']
parsed_discourse_facet ['method_citation']
NA
original cit marker offset is 0
new cit marker offset is 0



['0']
0
['0']
Error in Reference Offset
<S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'"]
'90'
['90']
parsed_discourse_facet ['method_citation']
<S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S>
    <S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
    <S sid="92" ssid="3">For runs with the generative model based upon Markov grammar statistics, the first pass uses the same statistics, but conditioned only on standard PCFG information.</S>
    <S sid="93" ssid="4">This allows the second pass to see expansions not present in the training corpus.</S>
    <S sid="94" ssid="5">We use the gathered statistics for all observed words, even those with very low counts, though obviously our deleted interpolation smoothing gives less emphasis to observed probabilities for rare words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'", "'91'", "'92'", "'93'", "'94'"]
'90'
'91'
'92'
'93'
'94'
['90', '91', '92', '93', '94']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="7">To compute a probability in a log-linear model one first defines a set of &amp;quot;features&amp;quot;, functions from the space of configurations over which one is trying to compute probabilities to integers that denote the number of times some pattern occurs in the input.</S>
    <S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S>
    <S sid="40" ssid="9">In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'40'"]
'38'
'39'
'40'
['38', '39', '40']
parsed_discourse_facet ['method_citation']
<S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'174'"]
'174'
['174']
parsed_discourse_facet ['result_citation']
<S sid="85" ssid="54">As partition-function calculation is typically the major on-line computational problem for maximum-entropy models, this simplifies the model significantly.</S>
original cit marker offset is 0
new cit marker offset is 0



["'85'"]
'85'
['85']
parsed_discourse_facet ['method_citation']
<S sid="63" ssid="32">As we discuss in more detail in Section 5, several different features in the context surrounding c are useful to include in H: the label, head pre-terminal and head of the parent of c (denoted as lp, tp, hp), the label of c's left sibling (lb for &amp;quot;before&amp;quot;), and the label of the grandparent of c (la).</S><S sid="143" ssid="34">The first is simply that if we first guess the pre-terminal, when we go to guess the head the first thing we can condition upon is the pre-terminal, i.e., we compute p(h I t).</S><S sid="146" ssid="37">The second major reason why first guessing the pre-terminal makes so much difference is that it can be used when backing off the lexical head in computing the probability of the rule expansion.</S>
original cit marker offset is 0
new cit marker offset is 0



["'63'", "'143'", "'146'"]
'63'
'143'
'146'
['63', '143', '146']
parsed_discourse_facet ['method_citation']
???<S sid="78" ssid="47">With some prior knowledge, non-zero values can greatly speed up this process because fewer iterations are required for convergence.</S>                                        <S sid="79" ssid="48">We comment on this because in our example we can substantially speed up the process by choosing values picked so that, when the maximum-entropy equation is expressed in the form of Equation 4, the gi have as their initial values the values of the corresponding terms in Equation 7.</S>
original cit marker offset is 0
new cit marker offset is 0



["'78'", "'79'"]
'78'
'79'
['78', '79']
parsed_discourse_facet ['method_citation']
<S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'"]
'90'
['90']
parsed_discourse_facet ['method_citation']
<S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'174'"]
'174'
['174']
parsed_discourse_facet ['result_citation']
parsing: input/res/Task1/A00-2018.annv3.csv
<S sid="116" ssid="7">This is as opposed to the &amp;quot;Markovgrammar&amp;quot; approach used in the current parser.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S><S sid="118" ssid="9">First, it uses a clustering scheme on words to give the system a &amp;quot;soft&amp;quot; clustering of heads and sub-heads.</S><S sid="119" ssid="10">(It is &amp;quot;soft&amp;quot; clustering in that a word can belong to more than one cluster with different weights - the weights express the probability of producing the word given that one is going to produce a word from that cluster.)</S>
original cit marker offset is 0
new cit marker offset is 0



["'116'", "'117'", "'118'", "'119'"]
'116'
'117'
'118'
'119'
['116', '117', '118', '119']
parsed_discourse_facet ['implication_citation', 'results_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S><S sid="129" ssid="20">It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.</S><S sid="178" ssid="5">The results of 13 achieved by combining the aforementioned three-best parsers also suggest that the limit on tree-bank trained parsers is much higher than previously thought.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'117'", "'129'", "'178'"]
'91'
'117'
'129'
'178'
['91', '117', '129', '178']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'91'", "'175'"]
'1'
'5'
'91'
'175'
['1', '5', '91', '175']
parsed_discourse_facet ['hypothesis_citation']
<S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S><S sid="40" ssid="9">In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.</S><S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S><S sid="129" ssid="20">It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'40'", "'120'", "'129'"]
'39'
'40'
'120'
'129'
['39', '40', '120', '129']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S><S sid="176" ssid="3">That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'120'", "'176'"]
'1'
'5'
'120'
'176'
['1', '5', '120', '176']
parsed_discourse_facet ['hypothesis_citation', 'results_citation']
<S sid="0">A Maximum-Entropy-Inspired Parser *</S><S sid="122" ssid="13">In this section we evaluate the effects of the various changes we have made by running various versions of our current program.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S><S sid="176" ssid="3">That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'122'", "'175'", "'176'"]
'0'
'122'
'175'
'176'
['0', '122', '175', '176']
parsed_discourse_facet ['aim_citation']
<S sid="6" ssid="2">This represents a 13% decrease in error rate over the best single-parser results on this corpus 9.</S><S sid="10" ssid="6">That is, the parser implements the function arg maxrp(7r s) = arg maxirp(7r, s) = arg maxrp(w).</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'10'", "'91'", "'174'"]
'6'
'10'
'91'
'174'
['6', '10', '91', '174']
parsed_discourse_facet ['hypothesis_citation']
<S sid="89" ssid="58">(Actually, we use a minor variant described in 4.)</S><S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'", "'90'", "'91'", "'117'"]
'89'
'90'
'91'
'117'
['89', '90', '91', '117']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="101" ssid="12">In keeping with the standard methodology 5, 9,10,15,17, we used the Penn Wall Street Journal tree-bank 16 with sections 2-21 for training, section 23 for testing, and section 24 for development (debugging and tuning).</S><S sid="102" ssid="13">Performance on the test corpus is measured using the standard measures from 5,9,10,17.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'101'", "'102'"]
'1'
'5'
'101'
'102'
['1', '5', '101', '102']
parsed_discourse_facet ['results_citation', 'implication_citation']
<S sid="102" ssid="13">Performance on the test corpus is measured using the standard measures from 5,9,10,17.</S><S sid="107" ssid="18">The results for the new parser as well as for the previous top-three individual parsers on this corpus are given in Figure 1.</S><S sid="108" ssid="19">As is typical, all of the standard measures tell pretty much the same story, with the new parser outperforming the other three parsers.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'102'", "'107'", "'108'", "'174'"]
'102'
'107'
'108'
'174'
['102', '107', '108', '174']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="18" ssid="7">The method that gives the best results, however, uses a Markov grammar &#8212; a method for assigning probabilities to any possible expansion using statistics gathered from the training corpus 6,10,15.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'18'", "'117'"]
'1'
'5'
'18'
'117'
['1', '5', '18', '117']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">A Maximum-Entropy-Inspired Parser *</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="12" ssid="1">The model assigns a probability to a parse by a top-down process of considering each constituent c in Ir and for each c first guessing the pre-terminal of c, t(c) (t for &amp;quot;tag&amp;quot;), then the lexical head of c, h(c), and then the expansion of c into further constituents e(c).</S><S sid="141" ssid="32">(For example, part-ofspeech tagging using the most probable preterminal for each word is 90% accurate 8.)</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'5'", "'12'", "'141'"]
'0'
'5'
'12'
'141'
['0', '5', '12', '141']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="97" ssid="8">The other four equations can be found in a longer version of this paper available on the author\s website (www.cs.brown.eduhiec).</S><S sid="143" ssid="34">The first is simply that if we first guess the pre-terminal, when we go to guess the head the first thing we can condition upon is the pre-terminal, i.e., we compute p(h I t).</S><S sid="173" ssid="64">However, a second-order grammar does slightly better and a third-order grammar does significantly better than the tree-bank parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'97'", "'143'", "'173'"]
'91'
'97'
'143'
'173'
['91', '97', '143', '173']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'91'", "'174'", "'175'"]
'1'
'91'
'174'
'175'
['1', '91', '174', '175']
parsed_discourse_facet ['hypothesis_citation']
<S sid="27" ssid="16">In the simplest of such models, a zeroorder Markov grammar, each label on the righthand side is generated conditioned only on / &#8212; that is, according to the distributions p(Li j1), p(M I 1), and p(Ri I 1).</S><S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S><S sid="49" ssid="18">First, as already implicit in our discussion, factoring the probability computation into a sequence of values corresponding to various &amp;quot;features&amp;quot; suggests that the probability model should be easily changeable &#8212; just change the set of features used.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'39'", "'49'", "'91'"]
'27'
'39'
'49'
'91'
['27', '39', '49', '91']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="1">The major problem confronting the author of a generative parser is what information to use to condition the probabilities required in the model, and how to smooth the empirically obtained probabilities to take the sting out of the sparse data problems that are inevitable with even the most modest conditioning.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S><S sid="180" ssid="7">From our perspective, perhaps the two most important numbers to come out of this research are the overall error reduction of 13% over the results in 9 and the intermediateresult improvement of nearly 2% on labeled precision/recall due to the simple idea of guessing the head\s pre-terminal before guessing the head.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'174'", "'175'", "'180'"]
'32'
'174'
'175'
'180'
['32', '174', '175', '180']
parsed_discourse_facet ['method_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



A00-2018
P04-1042
0
result_citation
['method_citation']
parsing: input/ref/Task1/A00-2018_sweta.csv
 <S sid="17" ssid="6">In Section 5 we present some results in which the possible expansions of a constituent are fixed in advanced by extracting a tree-bank grammar [3] from the training corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["17'"]
17'
['17']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees [16] that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established [5,9,10,15,17] &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S>
original cit marker offset is 0
new cit marker offset is 0



["5'"]
5'
['5']
parsed_discourse_facet ['method_citation']
 <S sid="17" ssid="6">In Section 5 we present some results in which the possible expansions of a constituent are fixed in advanced by extracting a tree-bank grammar [3] from the training corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["17'"]
17'
['17']
parsed_discourse_facet ['method_citation']
<S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S>
original cit marker offset is 0
new cit marker offset is 0



["120'"]
120'
['120']
parsed_discourse_facet ['method_citation']
<S sid="119" ssid="10">(It is &amp;quot;soft&amp;quot; clustering in that a word can belong to more than one cluster with different weights - the weights express the probability of producing the word given that one is going to produce a word from that cluster.)</S>
original cit marker offset is 0
new cit marker offset is 0



["119'"]
119'
['119']
parsed_discourse_facet ['method_citation']
<S sid="95" ssid="6">We guess the preterminals of words that are not observed in the training data using statistics on capitalization, hyphenation, word endings (the last two letters), and the probability that a given pre-terminal is realized using a previously unobserved word.</S>
original cit marker offset is 0
new cit marker offset is 0



["95'"]
95'
['95']
parsed_discourse_facet ['method_citation']
 <S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins [9].</S>
original cit marker offset is 0
new cit marker offset is 0



["175'"]
175'
['175']
parsed_discourse_facet ['method_citation']
<S sid="92" ssid="3">For runs with the generative model based upon Markov grammar statistics, the first pass uses the same statistics, but conditioned only on standard PCFG information.</S>
original cit marker offset is 0
new cit marker offset is 0



["92'"]
92'
['92']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established [5,9,10,15,17] &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S>
original cit marker offset is 0
new cit marker offset is 0



["1'"]
1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="17">This is indicated in Figure 2, where the model labeled &amp;quot;Best&amp;quot; has precision of 89.8% and recall of 89.6% for an average of 89.7%, 0.4% lower than the results on the official test corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["126'"]
126'
['126']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="1">The model assigns a probability to a parse by a top-down process of considering each constituent c in Ir and for each c first guessing the pre-terminal of c, t(c) (t for &amp;quot;tag&amp;quot;), then the lexical head of c, h(c), and then the expansion of c into further constituents e(c).</S>
original cit marker offset is 0
new cit marker offset is 0



["12'"]
12'
['12']
parsed_discourse_facet ['method_citation']
<S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["174'"]
174'
['174']
parsed_discourse_facet ['method_citation']
<S sid="63" ssid="32">As we discuss in more detail in Section 5, several different features in the context surrounding c are useful to include in H: the label, head pre-terminal and head of the parent of c (denoted as lp, tp, hp), the label of c's left sibling (lb for &amp;quot;before&amp;quot;), and the label of the grandparent of c (la).</S>
original cit marker offset is 0
new cit marker offset is 0



["63'"]
63'
['63']
parsed_discourse_facet ['method_citation']
<S sid="78" ssid="47">With some prior knowledge, non-zero values can greatly speed up this process because fewer iterations are required for convergence.</S>
original cit marker offset is 0
new cit marker offset is 0



["78'"]
78'
['78']
parsed_discourse_facet ['method_citation']
 <S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["91'"]
91'
['91']
parsed_discourse_facet ['method_citation']
<S sid="180" ssid="7">From our perspective, perhaps the two most important numbers to come out of this research are the overall error reduction of 13% over the results in [9] and the intermediateresult improvement of nearly 2% on labeled precision/recall due to the simple idea of guessing the head's pre-terminal before guessing the head.</S>
original cit marker offset is 0
new cit marker offset is 0



["180'"]
180'
['180']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A00-2018.annv3.csv
<S sid="116" ssid="7">This is as opposed to the &amp;quot;Markovgrammar&amp;quot; approach used in the current parser.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S><S sid="118" ssid="9">First, it uses a clustering scheme on words to give the system a &amp;quot;soft&amp;quot; clustering of heads and sub-heads.</S><S sid="119" ssid="10">(It is &amp;quot;soft&amp;quot; clustering in that a word can belong to more than one cluster with different weights - the weights express the probability of producing the word given that one is going to produce a word from that cluster.)</S>
original cit marker offset is 0
new cit marker offset is 0



["'116'", "'117'", "'118'", "'119'"]
'116'
'117'
'118'
'119'
['116', '117', '118', '119']
parsed_discourse_facet ['implication_citation', 'results_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S><S sid="129" ssid="20">It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.</S><S sid="178" ssid="5">The results of 13 achieved by combining the aforementioned three-best parsers also suggest that the limit on tree-bank trained parsers is much higher than previously thought.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'117'", "'129'", "'178'"]
'91'
'117'
'129'
'178'
['91', '117', '129', '178']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'91'", "'175'"]
'1'
'5'
'91'
'175'
['1', '5', '91', '175']
parsed_discourse_facet ['hypothesis_citation']
<S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S><S sid="40" ssid="9">In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.</S><S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S><S sid="129" ssid="20">It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'40'", "'120'", "'129'"]
'39'
'40'
'120'
'129'
['39', '40', '120', '129']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S><S sid="176" ssid="3">That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'120'", "'176'"]
'1'
'5'
'120'
'176'
['1', '5', '120', '176']
parsed_discourse_facet ['hypothesis_citation', 'results_citation']
<S sid="0">A Maximum-Entropy-Inspired Parser *</S><S sid="122" ssid="13">In this section we evaluate the effects of the various changes we have made by running various versions of our current program.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S><S sid="176" ssid="3">That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'122'", "'175'", "'176'"]
'0'
'122'
'175'
'176'
['0', '122', '175', '176']
parsed_discourse_facet ['aim_citation']
<S sid="6" ssid="2">This represents a 13% decrease in error rate over the best single-parser results on this corpus 9.</S><S sid="10" ssid="6">That is, the parser implements the function arg maxrp(7r s) = arg maxirp(7r, s) = arg maxrp(w).</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'10'", "'91'", "'174'"]
'6'
'10'
'91'
'174'
['6', '10', '91', '174']
parsed_discourse_facet ['hypothesis_citation']
<S sid="89" ssid="58">(Actually, we use a minor variant described in 4.)</S><S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'", "'90'", "'91'", "'117'"]
'89'
'90'
'91'
'117'
['89', '90', '91', '117']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="101" ssid="12">In keeping with the standard methodology 5, 9,10,15,17, we used the Penn Wall Street Journal tree-bank 16 with sections 2-21 for training, section 23 for testing, and section 24 for development (debugging and tuning).</S><S sid="102" ssid="13">Performance on the test corpus is measured using the standard measures from 5,9,10,17.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'101'", "'102'"]
'1'
'5'
'101'
'102'
['1', '5', '101', '102']
parsed_discourse_facet ['results_citation', 'implication_citation']
<S sid="102" ssid="13">Performance on the test corpus is measured using the standard measures from 5,9,10,17.</S><S sid="107" ssid="18">The results for the new parser as well as for the previous top-three individual parsers on this corpus are given in Figure 1.</S><S sid="108" ssid="19">As is typical, all of the standard measures tell pretty much the same story, with the new parser outperforming the other three parsers.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'102'", "'107'", "'108'", "'174'"]
'102'
'107'
'108'
'174'
['102', '107', '108', '174']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="18" ssid="7">The method that gives the best results, however, uses a Markov grammar &#8212; a method for assigning probabilities to any possible expansion using statistics gathered from the training corpus 6,10,15.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'18'", "'117'"]
'1'
'5'
'18'
'117'
['1', '5', '18', '117']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">A Maximum-Entropy-Inspired Parser *</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="12" ssid="1">The model assigns a probability to a parse by a top-down process of considering each constituent c in Ir and for each c first guessing the pre-terminal of c, t(c) (t for &amp;quot;tag&amp;quot;), then the lexical head of c, h(c), and then the expansion of c into further constituents e(c).</S><S sid="141" ssid="32">(For example, part-ofspeech tagging using the most probable preterminal for each word is 90% accurate 8.)</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'5'", "'12'", "'141'"]
'0'
'5'
'12'
'141'
['0', '5', '12', '141']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="97" ssid="8">The other four equations can be found in a longer version of this paper available on the author\s website (www.cs.brown.eduhiec).</S><S sid="143" ssid="34">The first is simply that if we first guess the pre-terminal, when we go to guess the head the first thing we can condition upon is the pre-terminal, i.e., we compute p(h I t).</S><S sid="173" ssid="64">However, a second-order grammar does slightly better and a third-order grammar does significantly better than the tree-bank parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'97'", "'143'", "'173'"]
'91'
'97'
'143'
'173'
['91', '97', '143', '173']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'91'", "'174'", "'175'"]
'1'
'91'
'174'
'175'
['1', '91', '174', '175']
parsed_discourse_facet ['hypothesis_citation']
<S sid="27" ssid="16">In the simplest of such models, a zeroorder Markov grammar, each label on the righthand side is generated conditioned only on / &#8212; that is, according to the distributions p(Li j1), p(M I 1), and p(Ri I 1).</S><S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S><S sid="49" ssid="18">First, as already implicit in our discussion, factoring the probability computation into a sequence of values corresponding to various &amp;quot;features&amp;quot; suggests that the probability model should be easily changeable &#8212; just change the set of features used.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'39'", "'49'", "'91'"]
'27'
'39'
'49'
'91'
['27', '39', '49', '91']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="1">The major problem confronting the author of a generative parser is what information to use to condition the probabilities required in the model, and how to smooth the empirically obtained probabilities to take the sting out of the sparse data problems that are inevitable with even the most modest conditioning.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S><S sid="180" ssid="7">From our perspective, perhaps the two most important numbers to come out of this research are the overall error reduction of 13% over the results in 9 and the intermediateresult improvement of nearly 2% on labeled precision/recall due to the simple idea of guessing the head\s pre-terminal before guessing the head.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'174'", "'175'", "'180'"]
'32'
'174'
'175'
'180'
['32', '174', '175', '180']
parsed_discourse_facet ['method_citation']



A00-2018
N03-2024
0
method_citation
['method_citation']



A00-2018
P05-1065
0
method_citation
['results_citation', 'implication_citation']



A00-2018
H05-1035
0
method_citation
['method_citation']



A00-2018
P04-1042
0
method_citation
['method_citation']
parsing: input/ref/Task1/A00-2018_vardha.csv
<S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees [16] that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established [5,9,10,15,17] &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'"]
'5'
['5']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees [16] that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established [5,9,10,15,17] &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'"]
'5'
['5']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'"]
'91'
['91']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'"]
'39'
['39']
parsed_discourse_facet ['method_citation']
<S sid="162" ssid="53">Given we are already at the 88% level of accuracy, we judge a 0.6% improvement to be very much worth while.</S>
original cit marker offset is 0
new cit marker offset is 0



["'162'"]
'162'
['162']
parsed_discourse_facet ['method_citation']
 <S sid="87" ssid="56">In a pure maximum-entropy model this is done by feature selection, as in Ratnaparkhi's maximum-entropy parser [17].</S>
original cit marker offset is 0
new cit marker offset is 0



["'87'"]
'87'
['87']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'"]
'91'
['91']
parsed_discourse_facet ['method_citation']
 <S sid="176" ssid="3">That the previous three best parsers on this test [5,9,17] all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'176'"]
'176'
['176']
parsed_discourse_facet ['method_citation']
<S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'174'"]
'174'
['174']
parsed_discourse_facet ['method_citation']
 <S sid="101" ssid="12">In keeping with the standard methodology [5, 9,10,15,17], we used the Penn Wall Street Journal tree-bank [16] with sections 2-21 for training, section 23 for testing, and section 24 for development (debugging and tuning).</S>
original cit marker offset is 0
new cit marker offset is 0



["'101'"]
'101'
['101']
parsed_discourse_facet ['method_citation']
<S sid="155" ssid="46">For example, in the Penn Treebank a vp with both main and auxiliary verbs has the structure shown in Figure 3.</S>
original cit marker offset is 0
new cit marker offset is 0



["'155'"]
'155'
['155']
parsed_discourse_facet ['method_citation']
  <S sid="17" ssid="6">In Section 5 we present some results in which the possible expansions of a constituent are fixed in advanced by extracting a tree-bank grammar [3] from the training corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'"]
'17'
['17']
parsed_discourse_facet ['method_citation']
<S sid="162" ssid="53">Given we are already at the 88% level of accuracy, we judge a 0.6% improvement to be very much worth while.</S>
original cit marker offset is 0
new cit marker offset is 0



["'162'"]
'162'
['162']
parsed_discourse_facet ['method_citation']
 <S sid="40" ssid="9">In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'"]
'40'
['40']
parsed_discourse_facet ['method_citation']
 <S sid="79" ssid="48">We comment on this because in our example we can substantially speed up the process by choosing values picked so that, when the maximum-entropy equation is expressed in the form of Equation 4, the gi have as their initial values the values of the corresponding terms in Equation 7.</S>
original cit marker offset is 0
new cit marker offset is 0



["'79'"]
'79'
['79']
parsed_discourse_facet ['method_citation']
    <S sid="40" ssid="9">In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'"]
'40'
['40']
parsed_discourse_facet ['method_citation']
    <S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins [9].</S>
original cit marker offset is 0
new cit marker offset is 0



["'175'"]
'175'
['175']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A00-2018.annv3.csv
<S sid="116" ssid="7">This is as opposed to the &amp;quot;Markovgrammar&amp;quot; approach used in the current parser.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S><S sid="118" ssid="9">First, it uses a clustering scheme on words to give the system a &amp;quot;soft&amp;quot; clustering of heads and sub-heads.</S><S sid="119" ssid="10">(It is &amp;quot;soft&amp;quot; clustering in that a word can belong to more than one cluster with different weights - the weights express the probability of producing the word given that one is going to produce a word from that cluster.)</S>
original cit marker offset is 0
new cit marker offset is 0



["'116'", "'117'", "'118'", "'119'"]
'116'
'117'
'118'
'119'
['116', '117', '118', '119']
parsed_discourse_facet ['implication_citation', 'results_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S><S sid="129" ssid="20">It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.</S><S sid="178" ssid="5">The results of 13 achieved by combining the aforementioned three-best parsers also suggest that the limit on tree-bank trained parsers is much higher than previously thought.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'117'", "'129'", "'178'"]
'91'
'117'
'129'
'178'
['91', '117', '129', '178']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'91'", "'175'"]
'1'
'5'
'91'
'175'
['1', '5', '91', '175']
parsed_discourse_facet ['hypothesis_citation']
<S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S><S sid="40" ssid="9">In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.</S><S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S><S sid="129" ssid="20">It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'40'", "'120'", "'129'"]
'39'
'40'
'120'
'129'
['39', '40', '120', '129']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S><S sid="176" ssid="3">That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'120'", "'176'"]
'1'
'5'
'120'
'176'
['1', '5', '120', '176']
parsed_discourse_facet ['hypothesis_citation', 'results_citation']
<S sid="0">A Maximum-Entropy-Inspired Parser *</S><S sid="122" ssid="13">In this section we evaluate the effects of the various changes we have made by running various versions of our current program.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S><S sid="176" ssid="3">That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'122'", "'175'", "'176'"]
'0'
'122'
'175'
'176'
['0', '122', '175', '176']
parsed_discourse_facet ['aim_citation']
<S sid="6" ssid="2">This represents a 13% decrease in error rate over the best single-parser results on this corpus 9.</S><S sid="10" ssid="6">That is, the parser implements the function arg maxrp(7r s) = arg maxirp(7r, s) = arg maxrp(w).</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'10'", "'91'", "'174'"]
'6'
'10'
'91'
'174'
['6', '10', '91', '174']
parsed_discourse_facet ['hypothesis_citation']
<S sid="89" ssid="58">(Actually, we use a minor variant described in 4.)</S><S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'", "'90'", "'91'", "'117'"]
'89'
'90'
'91'
'117'
['89', '90', '91', '117']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="101" ssid="12">In keeping with the standard methodology 5, 9,10,15,17, we used the Penn Wall Street Journal tree-bank 16 with sections 2-21 for training, section 23 for testing, and section 24 for development (debugging and tuning).</S><S sid="102" ssid="13">Performance on the test corpus is measured using the standard measures from 5,9,10,17.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'101'", "'102'"]
'1'
'5'
'101'
'102'
['1', '5', '101', '102']
parsed_discourse_facet ['results_citation', 'implication_citation']
<S sid="102" ssid="13">Performance on the test corpus is measured using the standard measures from 5,9,10,17.</S><S sid="107" ssid="18">The results for the new parser as well as for the previous top-three individual parsers on this corpus are given in Figure 1.</S><S sid="108" ssid="19">As is typical, all of the standard measures tell pretty much the same story, with the new parser outperforming the other three parsers.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'102'", "'107'", "'108'", "'174'"]
'102'
'107'
'108'
'174'
['102', '107', '108', '174']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="18" ssid="7">The method that gives the best results, however, uses a Markov grammar &#8212; a method for assigning probabilities to any possible expansion using statistics gathered from the training corpus 6,10,15.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'18'", "'117'"]
'1'
'5'
'18'
'117'
['1', '5', '18', '117']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">A Maximum-Entropy-Inspired Parser *</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="12" ssid="1">The model assigns a probability to a parse by a top-down process of considering each constituent c in Ir and for each c first guessing the pre-terminal of c, t(c) (t for &amp;quot;tag&amp;quot;), then the lexical head of c, h(c), and then the expansion of c into further constituents e(c).</S><S sid="141" ssid="32">(For example, part-ofspeech tagging using the most probable preterminal for each word is 90% accurate 8.)</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'5'", "'12'", "'141'"]
'0'
'5'
'12'
'141'
['0', '5', '12', '141']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="97" ssid="8">The other four equations can be found in a longer version of this paper available on the author\s website (www.cs.brown.eduhiec).</S><S sid="143" ssid="34">The first is simply that if we first guess the pre-terminal, when we go to guess the head the first thing we can condition upon is the pre-terminal, i.e., we compute p(h I t).</S><S sid="173" ssid="64">However, a second-order grammar does slightly better and a third-order grammar does significantly better than the tree-bank parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'97'", "'143'", "'173'"]
'91'
'97'
'143'
'173'
['91', '97', '143', '173']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'91'", "'174'", "'175'"]
'1'
'91'
'174'
'175'
['1', '91', '174', '175']
parsed_discourse_facet ['hypothesis_citation']
<S sid="27" ssid="16">In the simplest of such models, a zeroorder Markov grammar, each label on the righthand side is generated conditioned only on / &#8212; that is, according to the distributions p(Li j1), p(M I 1), and p(Ri I 1).</S><S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S><S sid="49" ssid="18">First, as already implicit in our discussion, factoring the probability computation into a sequence of values corresponding to various &amp;quot;features&amp;quot; suggests that the probability model should be easily changeable &#8212; just change the set of features used.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'39'", "'49'", "'91'"]
'27'
'39'
'49'
'91'
['27', '39', '49', '91']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="1">The major problem confronting the author of a generative parser is what information to use to condition the probabilities required in the model, and how to smooth the empirically obtained probabilities to take the sting out of the sparse data problems that are inevitable with even the most modest conditioning.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S><S sid="180" ssid="7">From our perspective, perhaps the two most important numbers to come out of this research are the overall error reduction of 13% over the results in 9 and the intermediateresult improvement of nearly 2% on labeled precision/recall due to the simple idea of guessing the head\s pre-terminal before guessing the head.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'174'", "'175'", "'180'"]
'32'
'174'
'175'
'180'
['32', '174', '175', '180']
parsed_discourse_facet ['method_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



A00-2018
W06-3119
0
method_citation
['hypothesis_citation']



A00-2018
N03-2024
0
method_citation
['method_citation']



A00-2018
P04-1042
0
method_citation
['method_citation']
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
parsing: input/ref/Task1/A00-2030_aakansha.csv
<S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'"]
'4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="49" ssid="9">By necessity, we adopted the strategy of hand marking only the semantics.</S>
    <S sid="50" ssid="10">Figure 4 shows an example of the semantic annotation, which was the only type of manual annotation we performed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'49'", "'50'"]
'49'
'50'
['49', '50']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="6">For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'"]
'16'
['16']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="6">An integrated model can limit the propagation of errors by making all decisions jointly.</S>
    <S sid="24" ssid="7">For this reason, we focused on designing an integrated model in which tagging, namefinding, parsing, and semantic interpretation decisions all have the opportunity to mutually influence each other.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'24'"]
'23'
'24'
['23', '24']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="6">An integrated model can limit the propagation of errors by making all decisions jointly.</S>
    <S sid="24" ssid="7">For this reason, we focused on designing an integrated model in which tagging, namefinding, parsing, and semantic interpretation decisions all have the opportunity to mutually influence each other.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'24'"]
'23'
'24'
['23', '24']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="6">An integrated model can limit the propagation of errors by making all decisions jointly.</S>
    <S sid="24" ssid="7">For this reason, we focused on designing an integrated model in which tagging, namefinding, parsing, and semantic interpretation decisions all have the opportunity to mutually influence each other.</S><S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'24'", "'33'", "'34'"]
'23'
'24'
'33'
'34'
['23', '24', '33', '34']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
    <S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["'60'", "'61'"]
'60'
'61'
['60', '61']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'"]
'33'
['33']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S>
    <S sid="12" ssid="2">The Template Element (TE) task identifies organizations, persons, locations, and some artifacts (rocket and airplane-related artifacts).</S><S sid="16" ssid="6">For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'16'"]
'11'
'12'
'16'
['11', '12', '16']
parsed_discourse_facet ['method_citation']
<S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'105'"]
'105'
['105']
parsed_discourse_facet ['result_citation']
<S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
    <S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["'60'", "'61'"]
'60'
'61'
['60', '61']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="6">For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'"]
'16'
['16']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A00-2030.annv3.csv
<S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="40" ssid="8">Further details are discussed in the section Tree Augmentation.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="65" ssid="6">We illustrate the generation process by walking through a few of the steps of the parse shown in Figure 3.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'40'", "'52'", "'65'"]
'11'
'40'
'52'
'65'
['11', '40', '52', '65']
parsed_discourse_facet ['aim_citation']
<S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S><S sid="23" ssid="6">An integrated model can limit the propagation of errors by making all decisions jointly.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="62" ssid="3">For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'23'", "'61'", "'62'"]
'18'
'23'
'61'
'62'
['18', '23', '61', '62']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="107" ssid="4">The semantic training corpus was produced by students according to a simple set of guidelines.</S><S sid="108" ssid="5">This simple semantic annotation was the only source of task knowledge used to configure the model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'11'", "'107'", "'108'"]
'10'
'11'
'107'
'108'
['10', '11', '107', '108']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="30" ssid="13">Although each model differed in its detailed probability structure, we believed that the essential elements of all three models could be generalized in a single probability model.</S><S sid="31" ssid="14">If the single generalized model could then be extended to semantic analysis, all necessary sentence level processing would be contained in that model.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="94" ssid="13">Given a new sentence, the outcome of this search process is a tree structure that encodes both the syntactic and semantic structure of the sentence.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'31'", "'52'", "'94'"]
'30'
'31'
'52'
'94'
['30', '31', '52', '94']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="41" ssid="1">To train our integrated model, we required a large corpus of augmented parse trees.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'41'", "'60'"]
'33'
'34'
'41'
'60'
['33', '34', '41', '60']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="6">For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.</S><S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'18'", "'58'", "'60'"]
'16'
'18'
'58'
'60'
['16', '18', '58', '60']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'34'", "'58'", "'61'"]
'1'
'34'
'58'
'61'
['1', '34', '58', '61']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'52'", "'58'"]
'33'
'34'
'52'
'58'
['33', '34', '52', '58']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="62" ssid="3">For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'61'", "'62'", "'101'"]
'32'
'61'
'62'
'101'
['32', '61', '62', '101']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'58'", "'61'", "'101'"]
'32'
'58'
'61'
'101'
['32', '58', '61', '101']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'33'", "'52'", "'58'"]
'2'
'33'
'52'
'58'
['2', '33', '52', '58']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'51'", "'52'"]
'1'
'2'
'51'
'52'
['1', '2', '51', '52']
parsed_discourse_facet ['hypothesis_citation']
<S sid="28" ssid="11">Finally, our newly constructed parser, like that of (Collins 1997), was based on a generative statistical model.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S><S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'", "'52'", "'60'", "'105'"]
'28'
'52'
'60'
'105'
['28', '52', '60', '105']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="50" ssid="10">Figure 4 shows an example of the semantic annotation, which was the only type of manual annotation we performed.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'50'", "'51'", "'52'"]
'10'
'50'
'51'
'52'
['10', '50', '51', '52']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'6'", "'58'", "'105'"]
'2'
'6'
'58'
'105'
['2', '6', '58', '105']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'34'", "'51'", "'58'"]
'10'
'34'
'51'
'58'
['10', '34', '51', '58']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'58'", "'61'", "'101'"]
'2'
'58'
'61'
'101'
['2', '58', '61', '101']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'11'", "'104'"]
'1'
'2'
'11'
'104'
['1', '2', '11', '104']
parsed_discourse_facet ['aim_citation']
<S sid="0">A Novel Use of Statistical Parsing to Extract Information from Text</S><S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'60'"]
'0'
'1'
'2'
'60'
['0', '1', '2', '60']
parsed_discourse_facet ['hypothesis_citation']
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
parsing: input/ref/Task1/A00-2030_sweta.csv
<S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S>
original cit marker offset is 0
new cit marker offset is 0



["18'"]
18'
['18']
parsed_discourse_facet ['method_citation']
<S sid="100" ssid="5">Given multiple constituents that cover identical spans in the chart, only those constituents with probabilities within a While our focus throughout the project was on TE and TR, we became curious about how well the model did at part-of-speech tagging, syntactic parsing, and at name finding.</S>
original cit marker offset is 0
new cit marker offset is 0



["100'"]
100'
['100']
parsed_discourse_facet ['method_citation']
<S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["52'"]
52'
['52']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["34'"]
34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S>
original cit marker offset is 0
new cit marker offset is 0



["1'"]
1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["61'"]
61'
['61']
parsed_discourse_facet ['method_citation']
<S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["104'"]
104'
['104']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S>
original cit marker offset is 0
new cit marker offset is 0



["32'"]
32'
['32']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["2'"]
2'
['2']
parsed_discourse_facet ['method_citation']
 <S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["61'"]
61'
['61']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["33'"]
33'
['33']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["34'"]
34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="1">Since 1995, a few statistical parsing algorithms (Magerman, 1995; Collins, 1996 and 1997; Charniak, 1997; Rathnaparki, 1997) demonstrated a breakthrough in parsing accuracy, as measured against the University of Pennsylvania TREEBANK as a gold standard.</S>
original cit marker offset is 0
new cit marker offset is 0



["3'"]
3'
['3']
parsed_discourse_facet ['method_citation']
<S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["52'"]
52'
['52']
parsed_discourse_facet ['method_citation']
<S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["104'"]
104'
['104']
parsed_discourse_facet ['method_citation']
<S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["104'"]
104'
['104']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.<
original cit marker offset is 0
new cit marker offset is 0



["2'"]
2'
['2']
parsed_discourse_facet ['method_citation']
<S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction
original cit marker offset is 0
new cit marker offset is 0



["104'"]
104'
['104']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["2'"]
2'
['2']
parsed_discourse_facet ['method_citation']
<S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["61'"]
61'
['61']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A00-2030.annv3.csv
<S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="40" ssid="8">Further details are discussed in the section Tree Augmentation.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="65" ssid="6">We illustrate the generation process by walking through a few of the steps of the parse shown in Figure 3.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'40'", "'52'", "'65'"]
'11'
'40'
'52'
'65'
['11', '40', '52', '65']
parsed_discourse_facet ['aim_citation']
<S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S><S sid="23" ssid="6">An integrated model can limit the propagation of errors by making all decisions jointly.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="62" ssid="3">For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'23'", "'61'", "'62'"]
'18'
'23'
'61'
'62'
['18', '23', '61', '62']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="107" ssid="4">The semantic training corpus was produced by students according to a simple set of guidelines.</S><S sid="108" ssid="5">This simple semantic annotation was the only source of task knowledge used to configure the model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'11'", "'107'", "'108'"]
'10'
'11'
'107'
'108'
['10', '11', '107', '108']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="30" ssid="13">Although each model differed in its detailed probability structure, we believed that the essential elements of all three models could be generalized in a single probability model.</S><S sid="31" ssid="14">If the single generalized model could then be extended to semantic analysis, all necessary sentence level processing would be contained in that model.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="94" ssid="13">Given a new sentence, the outcome of this search process is a tree structure that encodes both the syntactic and semantic structure of the sentence.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'31'", "'52'", "'94'"]
'30'
'31'
'52'
'94'
['30', '31', '52', '94']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="41" ssid="1">To train our integrated model, we required a large corpus of augmented parse trees.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'41'", "'60'"]
'33'
'34'
'41'
'60'
['33', '34', '41', '60']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="6">For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.</S><S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'18'", "'58'", "'60'"]
'16'
'18'
'58'
'60'
['16', '18', '58', '60']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'34'", "'58'", "'61'"]
'1'
'34'
'58'
'61'
['1', '34', '58', '61']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'52'", "'58'"]
'33'
'34'
'52'
'58'
['33', '34', '52', '58']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="62" ssid="3">For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'61'", "'62'", "'101'"]
'32'
'61'
'62'
'101'
['32', '61', '62', '101']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'58'", "'61'", "'101'"]
'32'
'58'
'61'
'101'
['32', '58', '61', '101']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'33'", "'52'", "'58'"]
'2'
'33'
'52'
'58'
['2', '33', '52', '58']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'51'", "'52'"]
'1'
'2'
'51'
'52'
['1', '2', '51', '52']
parsed_discourse_facet ['hypothesis_citation']
<S sid="28" ssid="11">Finally, our newly constructed parser, like that of (Collins 1997), was based on a generative statistical model.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S><S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'", "'52'", "'60'", "'105'"]
'28'
'52'
'60'
'105'
['28', '52', '60', '105']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="50" ssid="10">Figure 4 shows an example of the semantic annotation, which was the only type of manual annotation we performed.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'50'", "'51'", "'52'"]
'10'
'50'
'51'
'52'
['10', '50', '51', '52']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'6'", "'58'", "'105'"]
'2'
'6'
'58'
'105'
['2', '6', '58', '105']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'34'", "'51'", "'58'"]
'10'
'34'
'51'
'58'
['10', '34', '51', '58']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'58'", "'61'", "'101'"]
'2'
'58'
'61'
'101'
['2', '58', '61', '101']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'11'", "'104'"]
'1'
'2'
'11'
'104'
['1', '2', '11', '104']
parsed_discourse_facet ['aim_citation']
<S sid="0">A Novel Use of Statistical Parsing to Extract Information from Text</S><S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'60'"]
'0'
'1'
'2'
'60'
['0', '1', '2', '60']
parsed_discourse_facet ['hypothesis_citation']
IGNORE THIS: key error 1



A00-2030
H05-1094
0
method_citation
['method_citation']



A00-2030
N07-2041
0
method_citation
['method_citation', 'hypothesis_citation']



A00-2030
P07-1055
0
method_citation
['hypothesis_citation']



A00-2030
W05-0636
0
method_citation
['aim_citation']



A00-2030
N06-1037
0
method_citation
['hypothesis_citation']
parsing: input/ref/Task1/A00-2030_vardha.csv
 <S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'"]
'11'
['11']
parsed_discourse_facet ['method_citation']
<S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'"]
'52'
['52']
parsed_discourse_facet ['method_citation']
<S sid="50" ssid="10">Figure 4 shows an example of the semantic annotation, which was the only type of manual annotation we performed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'"]
'50'
['50']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'34'"]
'34'
['34']
parsed_discourse_facet ['method_citation']
 <S sid="106" ssid="3">We were able to use the Penn TREEBANK to estimate the syntactic parameters; no additional syntactic training was required.</S>
original cit marker offset is 0
new cit marker offset is 0



["'106'"]
'106'
['106']
parsed_discourse_facet ['method_citation']
 <S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'"]
'6'
['6']
parsed_discourse_facet ['method_citation']
 <S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'"]
'6'
['6']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'34'"]
'34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="2">The Template Element (TE) task identifies organizations, persons, locations, and some artifacts (rocket and airplane-related artifacts).</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'"]
'12'
['12']
parsed_discourse_facet ['method_citation']
 <S sid="3" ssid="1">Since 1995, a few statistical parsing algorithms (Magerman, 1995; Collins, 1996 and 1997; Charniak, 1997; Rathnaparki, 1997) demonstrated a breakthrough in parsing accuracy, as measured against the University of Pennsylvania TREEBANK as a gold standard.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'"]
'3'
['3']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'34'"]
'34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'"]
'32'
['32']
parsed_discourse_facet ['method_citation']
 <S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="94" ssid="13">Given a new sentence, the outcome of this search process is a tree structure that encodes both the syntactic and semantic structure of the sentence.</S>
original cit marker offset is 0
new cit marker offset is 0



["'94'"]
'94'
['94']
parsed_discourse_facet ['method_citation']
    <S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'"]
'6'
['6']
parsed_discourse_facet ['method_citation']
 <S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
 <S sid="26" ssid="9">We were already using a generative statistical model for part-of-speech tagging (Weischedel et al. 1993), and more recently, had begun using a generative statistical model for name finding (Bikel et al.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'"]
'26'
['26']
parsed_discourse_facet ['method_citation']
    <S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'"]
'6'
['6']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="2">Currently, the prevailing architecture for dividing sentential processing is a four-stage pipeline consisting of: Since we were interested in exploiting recent advances in parsing, replacing the syntactic analysis stage of the standard pipeline with a modern statistical parser was an obvious possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A00-2030.annv3.csv
<S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="40" ssid="8">Further details are discussed in the section Tree Augmentation.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="65" ssid="6">We illustrate the generation process by walking through a few of the steps of the parse shown in Figure 3.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'40'", "'52'", "'65'"]
'11'
'40'
'52'
'65'
['11', '40', '52', '65']
parsed_discourse_facet ['aim_citation']
<S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S><S sid="23" ssid="6">An integrated model can limit the propagation of errors by making all decisions jointly.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="62" ssid="3">For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'23'", "'61'", "'62'"]
'18'
'23'
'61'
'62'
['18', '23', '61', '62']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="107" ssid="4">The semantic training corpus was produced by students according to a simple set of guidelines.</S><S sid="108" ssid="5">This simple semantic annotation was the only source of task knowledge used to configure the model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'11'", "'107'", "'108'"]
'10'
'11'
'107'
'108'
['10', '11', '107', '108']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="30" ssid="13">Although each model differed in its detailed probability structure, we believed that the essential elements of all three models could be generalized in a single probability model.</S><S sid="31" ssid="14">If the single generalized model could then be extended to semantic analysis, all necessary sentence level processing would be contained in that model.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="94" ssid="13">Given a new sentence, the outcome of this search process is a tree structure that encodes both the syntactic and semantic structure of the sentence.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'31'", "'52'", "'94'"]
'30'
'31'
'52'
'94'
['30', '31', '52', '94']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="41" ssid="1">To train our integrated model, we required a large corpus of augmented parse trees.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'41'", "'60'"]
'33'
'34'
'41'
'60'
['33', '34', '41', '60']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="6">For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.</S><S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'18'", "'58'", "'60'"]
'16'
'18'
'58'
'60'
['16', '18', '58', '60']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'34'", "'58'", "'61'"]
'1'
'34'
'58'
'61'
['1', '34', '58', '61']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'52'", "'58'"]
'33'
'34'
'52'
'58'
['33', '34', '52', '58']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="62" ssid="3">For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'61'", "'62'", "'101'"]
'32'
'61'
'62'
'101'
['32', '61', '62', '101']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'58'", "'61'", "'101'"]
'32'
'58'
'61'
'101'
['32', '58', '61', '101']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'33'", "'52'", "'58'"]
'2'
'33'
'52'
'58'
['2', '33', '52', '58']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'51'", "'52'"]
'1'
'2'
'51'
'52'
['1', '2', '51', '52']
parsed_discourse_facet ['hypothesis_citation']
<S sid="28" ssid="11">Finally, our newly constructed parser, like that of (Collins 1997), was based on a generative statistical model.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S><S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'", "'52'", "'60'", "'105'"]
'28'
'52'
'60'
'105'
['28', '52', '60', '105']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="50" ssid="10">Figure 4 shows an example of the semantic annotation, which was the only type of manual annotation we performed.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'50'", "'51'", "'52'"]
'10'
'50'
'51'
'52'
['10', '50', '51', '52']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'6'", "'58'", "'105'"]
'2'
'6'
'58'
'105'
['2', '6', '58', '105']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'34'", "'51'", "'58'"]
'10'
'34'
'51'
'58'
['10', '34', '51', '58']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'58'", "'61'", "'101'"]
'2'
'58'
'61'
'101'
['2', '58', '61', '101']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'11'", "'104'"]
'1'
'2'
'11'
'104'
['1', '2', '11', '104']
parsed_discourse_facet ['aim_citation']
<S sid="0">A Novel Use of Statistical Parsing to Extract Information from Text</S><S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'60'"]
'0'
'1'
'2'
'60'
['0', '1', '2', '60']
parsed_discourse_facet ['hypothesis_citation']



A00-2030
W10-2924
0
method_citation
['results_citation']
parsing: input/ref/Task1/A97-1014_swastika.csv
<S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



['168']
168
['168']
parsed_discourse_facet ['aim_citation']
<S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



['168']
168
['168']
parsed_discourse_facet ['aim_citation']
<S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S>
original cit marker offset is 0
new cit marker offset is 0



['151']
151
['151']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S>
original cit marker offset is 0
new cit marker offset is 0



['15']
15
['15']
parsed_discourse_facet ['result_citation']
<S sid="47" ssid="37">Argument structure can be represented in terms of unordered trees (with crossing branches).</S>
original cit marker offset is 0
new cit marker offset is 0



['47']
47
['47']
parsed_discourse_facet ['method_citation']
<S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



['167']
167
['167']
parsed_discourse_facet ['method_citation']
<S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



['168']
168
['168']
parsed_discourse_facet ['aim_citation']
<S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks') for stochastic grammar induction.</S>
original cit marker offset is 0
new cit marker offset is 0



['4']
4
['4']
parsed_discourse_facet ['aim_citation']
<S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



['160']
160
['160']
parsed_discourse_facet ['method_citation']
<S sid="127" ssid="8">As the need for certain functionalities becomes obvious with growing annotation experience, we have decided to implement the tool in two stages.</S>
original cit marker offset is 0
new cit marker offset is 0



['127']
127
['127']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="29">Consider the German sentence (1) daran wird ihn Anna erkennen, &amp;di er weint at-it will him Anna recognise that he cries 'Anna will recognise him at his cry' A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



['39']
39
['39']
parsed_discourse_facet ['method_citation']
<S sid="72" ssid="17">In order to avoid inconsistencies, the corpus is annotated in two stages: basic annotation and nfirtellte714.</S>
original cit marker offset is 0
new cit marker offset is 0



['72']
72
['72']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks') for stochastic grammar induction.</S>
original cit marker offset is 0
new cit marker offset is 0



['4']
4
['4']
parsed_discourse_facet ['aim_citation']
<S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks') for stochastic grammar induction.</S>
original cit marker offset is 0
new cit marker offset is 0



['4']
4
['4']
parsed_discourse_facet ['aim_citation']
parsing: input/res/Task1/A97-1014.annv3.csv
<S sid="13" ssid="3">The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S><S sid="169" ssid="11">Since the combinatorics of syntactic constructions creates a. demand for very large corpora., efficiency of annotation is an important. criterion for the success of the developed methodology and tools.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'137'", "'168'", "'169'"]
'13'
'137'
'168'
'169'
['13', '137', '168', '169']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="2">Realworld texts annotated with different strata of linguistic information can be used for grammar induction.</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'137'", "'140'", "'165'"]
'12'
'137'
'140'
'165'
['12', '137', '140', '165']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="28">Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S><S sid="141" ssid="22">The corpus is stored in a SQL database.</S><S sid="143" ssid="24">Sentences annotated in previous steps are used as training material for further processing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'140'", "'141'", "'143'"]
'38'
'140'
'141'
'143'
['38', '140', '141', '143']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="48" ssid="38">In order to reduce their ambiguity potential, rather simple, \flat\ trees should be employed, while more information can be expressed by a rich system of function labels.</S><S sid="51" ssid="41">This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.</S><S sid="53" ssid="43">A tree meeting these requirements is given below: Adv V NP NP V CPL NP V damn wird ihn Anna erkennen, dais er \vein!</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'48'", "'51'", "'53'"]
'15'
'48'
'51'
'53'
['15', '48', '51', '53']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="15">The underlying argument SirlteilITC is not represented directly, but can be recovered from the tree and trace-filler annotations.</S><S sid="39" ssid="29">Consider the German sentence (1) daran wird ihn Anna erkennen, &amp;di er weint at-it will him Anna recognise that he cries \Anna will recognise him at his cry\ A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes.</S><S sid="47" ssid="37">Argument structure can be represented in terms of unordered trees (with crossing branches).</S><S sid="51" ssid="41">This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'", "'39'", "'47'", "'51'"]
'25'
'39'
'47'
'51'
['25', '39', '47', '51']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="28">Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.</S><S sid="50" ssid="40">Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.</S><S sid="52" ssid="42">(Hudson, 1984).</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'50'", "'52'", "'167'"]
'38'
'50'
'52'
'167'
['38', '50', '52', '167']
parsed_discourse_facet ['method_citation']
<S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'151'", "'165'", "'167'", "'168'"]
'151'
'165'
'167'
'168'
['151', '165', '167', '168']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="1" ssid="1">We describe an annotation scheme and a tool developed for creating linguistically annotated corpora for non-configurational languages.</S><S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks\) for stochastic grammar induction.</S><S sid="159" ssid="1">As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'4'", "'159'", "'165'"]
'1'
'4'
'159'
'165'
['1', '4', '159', '165']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="0">An Annotation Scheme for Free Word Order Languages</S><S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="159" ssid="1">As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.</S><S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'15'", "'159'", "'160'"]
'0'
'15'
'159'
'160'
['0', '15', '159', '160']
parsed_discourse_facet ['hypothesis_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="71" ssid="16">However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.</S><S sid="80" ssid="25">Separable verb prefixes are labeled SVP.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'71'", "'80'", "'167'"]
'15'
'71'
'80'
'167'
['15', '71', '80', '167']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks\) for stochastic grammar induction.</S><S sid="13" ssid="3">The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.</S><S sid="150" ssid="31">To keep the human annotator from missing errors made by the tagger, we additionally calculate the strongest competitor for each label G. If its probability is close to the winner (closeness is defined by a threshold on the quotient), the assignment is regarded as unreliable, and the annotator is asked to confirm the assignment.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'13'", "'150'", "'168'"]
'4'
'13'
'150'
'168'
['4', '13', '150', '168']
parsed_discourse_facet ['hypothesis_citation']
<S sid="12" ssid="2">Realworld texts annotated with different strata of linguistic information can be used for grammar induction.</S><S sid="33" ssid="23">(Lehmann et al., 1996), (Marcus et al., 1994), (Sampson, 1995)).</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'33'", "'137'", "'140'"]
'12'
'33'
'137'
'140'
['12', '33', '137', '140']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="14">The typical treebank architecture is as follows: Structures: A context-free backbone is augmented with trace-filler representations of non-local dependencies.</S><S sid="31" ssid="21">Due to the substantial differences between existing models of constituent structure, the question arises of how the theory independencf requirement, can be satisfied.</S><S sid="149" ssid="30">During annotation, the highest rated grammatical function labels Gi are calculated using the Viterbi algorithm and assigned to the structure, i.e., we calculate argma.x11 PQ (Ti 1Z-1, Ti.-2) PQ (Gi ITi).</S><S sid="158" ssid="39">Owing to the partial automation, the average annotation efficiency improves by 25% (from around 4 minutes to 3 minutes per sentence).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'31'", "'149'", "'158'"]
'24'
'31'
'149'
'158'
['24', '31', '149', '158']
parsed_discourse_facet ['method_citation']
<S sid="50" ssid="40">Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.</S><S sid="52" ssid="42">(Hudson, 1984).</S><S sid="74" ssid="19">During the first phase, the focus is on annotating correct structures and a coarse-grained classification of grammatical functions, which represent the following areas of information: Dependency type: complements are further classified according to features such as category and case: clausal complements (OC), accusative objects (OA), datives (DA), etc.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'52'", "'74'", "'167'"]
'50'
'52'
'74'
'167'
['50', '52', '74', '167']
parsed_discourse_facet ['method_citation']



A97-1014
I05-6010
0
result_citation
['method_citation']



A97-1014
C10-1061
0
method_citation
['method_citation']



A97-1014
P05-1039
0
aim_citation
['method_citation', 'results_citation']



A97-1014
P03-1013
0
method_citation
['hypothesis_citation']
parsing: input/ref/Task1/A97-1014_sweta.csv
<S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["168'"]
168'
['168']
parsed_discourse_facet ['method_citation']
<S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["165'"]
165'
['165']
parsed_discourse_facet ['method_citation']
<S sid="145" ssid="26">This amount of data suffices as training material to reliably assign the grammatical functions if the user determines the elements of a phrase and its type (step 1 of the list above).</S>
original cit marker offset is 0
new cit marker offset is 0



["145'"]
145'
['145']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.<
original cit marker offset is 0
new cit marker offset is 0



["15'"]
15'
['15']
parsed_discourse_facet ['method_citation']
<S sid="41" ssid="31">Apart from this rather technical problem, two further arguments speak against phrase structure as the structural pivot of the annotation scheme: Finally, the structural handling of free word order means stating well-formedness constraints on structures involving many trace-filler dependencies, which has proved tedious.</S>
original cit marker offset is 0
new cit marker offset is 0



["41'"]
41'
['41']
parsed_discourse_facet ['method_citation']
<S sid="47" ssid="37">Argument structure can be represented in terms of unordered trees (with crossing branches).</S>
original cit marker offset is 0
new cit marker offset is 0



["47'"]
47'
['47']
parsed_discourse_facet ['method_citation']
<S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["167'"]
167'
['167']
parsed_discourse_facet ['method_citation']
 <S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["167'"]
167'
['167']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="29">Consider the German sentence (1) daran wird ihn Anna erkennen, &amp;di er weint at-it will him Anna recognise that he cries 'Anna will recognise him at his cry' A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["39'"]
39'
['39']
parsed_discourse_facet ['method_citation']
<S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["160'"]
160'
['160']
parsed_discourse_facet ['method_citation']
<S sid="166" ssid="8">Syntactically annotated corpora of German have been missing until now.</S>
original cit marker offset is 0
new cit marker offset is 0



["166'"]
166'
['166']
parsed_discourse_facet ['method_citation']
<S sid="166" ssid="8">Syntactically annotated corpora of German have been missing until now.</S>
original cit marker offset is 0
new cit marker offset is 0



["166'"]
166'
['166']
parsed_discourse_facet ['method_citation']
<S sid="143" ssid="24">Sentences annotated in previous steps are used as training material for further processing.</S>
original cit marker offset is 0
new cit marker offset is 0



["143'"]
143'
['143']
parsed_discourse_facet ['method_citation']
  <S sid="71" ssid="16">However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["71'"]
71'
['71']
parsed_discourse_facet ['method_citation']
  <S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["167'"]
167'
['167']
parsed_discourse_facet ['method_citation']
<S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S>
original cit marker offset is 0
new cit marker offset is 0



["151'"]
151'
['151']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A97-1014.annv3.csv
<S sid="13" ssid="3">The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S><S sid="169" ssid="11">Since the combinatorics of syntactic constructions creates a. demand for very large corpora., efficiency of annotation is an important. criterion for the success of the developed methodology and tools.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'137'", "'168'", "'169'"]
'13'
'137'
'168'
'169'
['13', '137', '168', '169']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="2">Realworld texts annotated with different strata of linguistic information can be used for grammar induction.</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'137'", "'140'", "'165'"]
'12'
'137'
'140'
'165'
['12', '137', '140', '165']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="28">Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S><S sid="141" ssid="22">The corpus is stored in a SQL database.</S><S sid="143" ssid="24">Sentences annotated in previous steps are used as training material for further processing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'140'", "'141'", "'143'"]
'38'
'140'
'141'
'143'
['38', '140', '141', '143']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="48" ssid="38">In order to reduce their ambiguity potential, rather simple, \flat\ trees should be employed, while more information can be expressed by a rich system of function labels.</S><S sid="51" ssid="41">This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.</S><S sid="53" ssid="43">A tree meeting these requirements is given below: Adv V NP NP V CPL NP V damn wird ihn Anna erkennen, dais er \vein!</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'48'", "'51'", "'53'"]
'15'
'48'
'51'
'53'
['15', '48', '51', '53']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="15">The underlying argument SirlteilITC is not represented directly, but can be recovered from the tree and trace-filler annotations.</S><S sid="39" ssid="29">Consider the German sentence (1) daran wird ihn Anna erkennen, &amp;di er weint at-it will him Anna recognise that he cries \Anna will recognise him at his cry\ A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes.</S><S sid="47" ssid="37">Argument structure can be represented in terms of unordered trees (with crossing branches).</S><S sid="51" ssid="41">This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'", "'39'", "'47'", "'51'"]
'25'
'39'
'47'
'51'
['25', '39', '47', '51']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="28">Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.</S><S sid="50" ssid="40">Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.</S><S sid="52" ssid="42">(Hudson, 1984).</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'50'", "'52'", "'167'"]
'38'
'50'
'52'
'167'
['38', '50', '52', '167']
parsed_discourse_facet ['method_citation']
<S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'151'", "'165'", "'167'", "'168'"]
'151'
'165'
'167'
'168'
['151', '165', '167', '168']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="1" ssid="1">We describe an annotation scheme and a tool developed for creating linguistically annotated corpora for non-configurational languages.</S><S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks\) for stochastic grammar induction.</S><S sid="159" ssid="1">As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'4'", "'159'", "'165'"]
'1'
'4'
'159'
'165'
['1', '4', '159', '165']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="0">An Annotation Scheme for Free Word Order Languages</S><S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="159" ssid="1">As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.</S><S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'15'", "'159'", "'160'"]
'0'
'15'
'159'
'160'
['0', '15', '159', '160']
parsed_discourse_facet ['hypothesis_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="71" ssid="16">However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.</S><S sid="80" ssid="25">Separable verb prefixes are labeled SVP.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'71'", "'80'", "'167'"]
'15'
'71'
'80'
'167'
['15', '71', '80', '167']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks\) for stochastic grammar induction.</S><S sid="13" ssid="3">The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.</S><S sid="150" ssid="31">To keep the human annotator from missing errors made by the tagger, we additionally calculate the strongest competitor for each label G. If its probability is close to the winner (closeness is defined by a threshold on the quotient), the assignment is regarded as unreliable, and the annotator is asked to confirm the assignment.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'13'", "'150'", "'168'"]
'4'
'13'
'150'
'168'
['4', '13', '150', '168']
parsed_discourse_facet ['hypothesis_citation']
<S sid="12" ssid="2">Realworld texts annotated with different strata of linguistic information can be used for grammar induction.</S><S sid="33" ssid="23">(Lehmann et al., 1996), (Marcus et al., 1994), (Sampson, 1995)).</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'33'", "'137'", "'140'"]
'12'
'33'
'137'
'140'
['12', '33', '137', '140']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="14">The typical treebank architecture is as follows: Structures: A context-free backbone is augmented with trace-filler representations of non-local dependencies.</S><S sid="31" ssid="21">Due to the substantial differences between existing models of constituent structure, the question arises of how the theory independencf requirement, can be satisfied.</S><S sid="149" ssid="30">During annotation, the highest rated grammatical function labels Gi are calculated using the Viterbi algorithm and assigned to the structure, i.e., we calculate argma.x11 PQ (Ti 1Z-1, Ti.-2) PQ (Gi ITi).</S><S sid="158" ssid="39">Owing to the partial automation, the average annotation efficiency improves by 25% (from around 4 minutes to 3 minutes per sentence).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'31'", "'149'", "'158'"]
'24'
'31'
'149'
'158'
['24', '31', '149', '158']
parsed_discourse_facet ['method_citation']
<S sid="50" ssid="40">Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.</S><S sid="52" ssid="42">(Hudson, 1984).</S><S sid="74" ssid="19">During the first phase, the focus is on annotating correct structures and a coarse-grained classification of grammatical functions, which represent the following areas of information: Dependency type: complements are further classified according to features such as category and case: clausal complements (OC), accusative objects (OA), datives (DA), etc.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'52'", "'74'", "'167'"]
'50'
'52'
'74'
'167'
['50', '52', '74', '167']
parsed_discourse_facet ['method_citation']
IGNORE THIS: key error 1
IGNORE THIS: key error 1



A97-1014
E99-1016
0
method_citation
['method_citation']



A97-1014
I05-6010
0
method_citation
['method_citation']



A97-1014
C10-1061
0
method_citation
['method_citation']



A97-1014
P05-1039
0
method_citation
['method_citation', 'results_citation']



A97-1014
P03-1013
0
method_citation
['hypothesis_citation']
parsing: input/ref/Task1/A97-1014_vardha.csv
<S sid="72" ssid="17">In order to avoid inconsistencies, the corpus is annotated in two stages: basic annotation and nfirtellte714.</S>
original cit marker offset is 0
new cit marker offset is 0



["'72'"]
'72'
['72']
parsed_discourse_facet ['method_citation']
 <S sid="144" ssid="25">We distinguish five degrees of automation: So far, about 1100 sentences of our corpus have been annotated.</S>
original cit marker offset is 0
new cit marker offset is 0



["'144'"]
'144'
['144']
parsed_discourse_facet ['method_citation']
<S sid="14" ssid="4">Corpora annotated with syntactic structures are commonly referred to as trctbank.5.</S>
original cit marker offset is 0
new cit marker offset is 0



["'14'"]
'14'
['14']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'"]
'15'
['15']
parsed_discourse_facet ['method_citation']
  <S sid="36" ssid="26">As for free word order languages, the following features may cause problems: sition between the two poles.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
 <S sid="24" ssid="14">The typical treebank architecture is as follows: Structures: A context-free backbone is augmented with trace-filler representations of non-local dependencies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
 <S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["'160'"]
'160'
['160']
parsed_discourse_facet ['method_citation']
 <S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S>
original cit marker offset is 0
new cit marker offset is 0



["'151'"]
'151'
['151']
parsed_discourse_facet ['method_citation']
 <S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks') for stochastic grammar induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'"]
'4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["'160'"]
'160'
['160']
parsed_discourse_facet ['method_citation']
 <S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'167'"]
'167'
['167']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="29">Consider the German sentence (1) daran wird ihn Anna erkennen, &amp;di er weint at-it will him Anna recognise that he cries 'Anna will recognise him at his cry' A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'"]
'39'
['39']
parsed_discourse_facet ['method_citation']
 <S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S>
original cit marker offset is 0
new cit marker offset is 0



["'151'"]
'151'
['151']
parsed_discourse_facet ['method_citation']
<S sid="71" ssid="16">However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'71'"]
'71'
['71']
parsed_discourse_facet ['method_citation']
 <S sid="144" ssid="25">We distinguish five degrees of automation: So far, about 1100 sentences of our corpus have been annotated.</S>
original cit marker offset is 0
new cit marker offset is 0



["'144'"]
'144'
['144']
parsed_discourse_facet ['method_citation']
<S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["'160'"]
'160'
['160']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A97-1014.annv3.csv
<S sid="13" ssid="3">The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S><S sid="169" ssid="11">Since the combinatorics of syntactic constructions creates a. demand for very large corpora., efficiency of annotation is an important. criterion for the success of the developed methodology and tools.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'137'", "'168'", "'169'"]
'13'
'137'
'168'
'169'
['13', '137', '168', '169']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="2">Realworld texts annotated with different strata of linguistic information can be used for grammar induction.</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'137'", "'140'", "'165'"]
'12'
'137'
'140'
'165'
['12', '137', '140', '165']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="28">Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S><S sid="141" ssid="22">The corpus is stored in a SQL database.</S><S sid="143" ssid="24">Sentences annotated in previous steps are used as training material for further processing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'140'", "'141'", "'143'"]
'38'
'140'
'141'
'143'
['38', '140', '141', '143']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="48" ssid="38">In order to reduce their ambiguity potential, rather simple, \flat\ trees should be employed, while more information can be expressed by a rich system of function labels.</S><S sid="51" ssid="41">This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.</S><S sid="53" ssid="43">A tree meeting these requirements is given below: Adv V NP NP V CPL NP V damn wird ihn Anna erkennen, dais er \vein!</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'48'", "'51'", "'53'"]
'15'
'48'
'51'
'53'
['15', '48', '51', '53']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="15">The underlying argument SirlteilITC is not represented directly, but can be recovered from the tree and trace-filler annotations.</S><S sid="39" ssid="29">Consider the German sentence (1) daran wird ihn Anna erkennen, &amp;di er weint at-it will him Anna recognise that he cries \Anna will recognise him at his cry\ A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes.</S><S sid="47" ssid="37">Argument structure can be represented in terms of unordered trees (with crossing branches).</S><S sid="51" ssid="41">This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'", "'39'", "'47'", "'51'"]
'25'
'39'
'47'
'51'
['25', '39', '47', '51']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="28">Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.</S><S sid="50" ssid="40">Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.</S><S sid="52" ssid="42">(Hudson, 1984).</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'50'", "'52'", "'167'"]
'38'
'50'
'52'
'167'
['38', '50', '52', '167']
parsed_discourse_facet ['method_citation']
<S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'151'", "'165'", "'167'", "'168'"]
'151'
'165'
'167'
'168'
['151', '165', '167', '168']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="1" ssid="1">We describe an annotation scheme and a tool developed for creating linguistically annotated corpora for non-configurational languages.</S><S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks\) for stochastic grammar induction.</S><S sid="159" ssid="1">As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'4'", "'159'", "'165'"]
'1'
'4'
'159'
'165'
['1', '4', '159', '165']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="0">An Annotation Scheme for Free Word Order Languages</S><S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="159" ssid="1">As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.</S><S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'15'", "'159'", "'160'"]
'0'
'15'
'159'
'160'
['0', '15', '159', '160']
parsed_discourse_facet ['hypothesis_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="71" ssid="16">However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.</S><S sid="80" ssid="25">Separable verb prefixes are labeled SVP.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'71'", "'80'", "'167'"]
'15'
'71'
'80'
'167'
['15', '71', '80', '167']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks\) for stochastic grammar induction.</S><S sid="13" ssid="3">The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.</S><S sid="150" ssid="31">To keep the human annotator from missing errors made by the tagger, we additionally calculate the strongest competitor for each label G. If its probability is close to the winner (closeness is defined by a threshold on the quotient), the assignment is regarded as unreliable, and the annotator is asked to confirm the assignment.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'13'", "'150'", "'168'"]
'4'
'13'
'150'
'168'
['4', '13', '150', '168']
parsed_discourse_facet ['hypothesis_citation']
<S sid="12" ssid="2">Realworld texts annotated with different strata of linguistic information can be used for grammar induction.</S><S sid="33" ssid="23">(Lehmann et al., 1996), (Marcus et al., 1994), (Sampson, 1995)).</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'33'", "'137'", "'140'"]
'12'
'33'
'137'
'140'
['12', '33', '137', '140']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="14">The typical treebank architecture is as follows: Structures: A context-free backbone is augmented with trace-filler representations of non-local dependencies.</S><S sid="31" ssid="21">Due to the substantial differences between existing models of constituent structure, the question arises of how the theory independencf requirement, can be satisfied.</S><S sid="149" ssid="30">During annotation, the highest rated grammatical function labels Gi are calculated using the Viterbi algorithm and assigned to the structure, i.e., we calculate argma.x11 PQ (Ti 1Z-1, Ti.-2) PQ (Gi ITi).</S><S sid="158" ssid="39">Owing to the partial automation, the average annotation efficiency improves by 25% (from around 4 minutes to 3 minutes per sentence).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'31'", "'149'", "'158'"]
'24'
'31'
'149'
'158'
['24', '31', '149', '158']
parsed_discourse_facet ['method_citation']
<S sid="50" ssid="40">Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.</S><S sid="52" ssid="42">(Hudson, 1984).</S><S sid="74" ssid="19">During the first phase, the focus is on annotating correct structures and a coarse-grained classification of grammatical functions, which represent the following areas of information: Dependency type: complements are further classified according to features such as category and case: clausal complements (OC), accusative objects (OA), datives (DA), etc.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'52'", "'74'", "'167'"]
'50'
'52'
'74'
'167'
['50', '52', '74', '167']
parsed_discourse_facet ['method_citation']
IGNORE THIS: key error 1
IGNORE THIS: key error 1



A97-1014
I05-6010
0
method_citation
['method_citation']



A97-1014
P05-1039
0
method_citation
['method_citation', 'results_citation']



A97-1014
P03-1013
0
method_citation
['hypothesis_citation']



A97-1014
W04-1505
0
method_citation
['method_citation']
parsing: input/ref/Task1/D09-1092_swastika.csv
<S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



['193']
193
['193']
parsed_discourse_facet ['result_citation']
<S sid="114" ssid="63">Ideally, the &#8220;glue&#8221; documents in g will be sufficient to align the topics across languages, and will cause comparable documents in S to have similar distributions over topics even though they are modeled independently.</S>
original cit marker offset is 0
new cit marker offset is 0



['114']
114
['114']
parsed_discourse_facet ['aim_citation']
<S sid="138" ssid="87">We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.</S>
original cit marker offset is 0
new cit marker offset is 0



['138']
138
['138']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="14">In this paper, we use two polylingual corpora to answer various critical questions related to polylingual topic models.</S>
original cit marker offset is 0
new cit marker offset is 0



['18']
18
['18']
parsed_discourse_facet ['method_citation']
<S sid="55" ssid="4">The EuroParl corpus consists of parallel texts in eleven western European languages: Danish, German, Greek, English, Spanish, Finnish, French, Italian, Dutch, Portuguese and Swedish.</S>
original cit marker offset is 0
new cit marker offset is 0



['55']
55
['55']
parsed_discourse_facet ['method_citation']
<S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['192']
192
['192']
parsed_discourse_facet ['result_citation']
<S sid="119" ssid="68">The lower the divergence, the more similar the distributions are to each other.</S>
original cit marker offset is 0
new cit marker offset is 0



['119']
119
['119']
parsed_discourse_facet ['result_citation']
<S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S>
original cit marker offset is 0
new cit marker offset is 0



['148']
148
['148']
parsed_discourse_facet ['method_citation']
<S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



['193']
193
['193']
parsed_discourse_facet ['result_citation']
<S sid="184" ssid="18">Interestingly, we find that almost all languages in our corpus, including several pairs that have historically been in conflict, show average JS divergences of between approximately 0.08 and 0.12 for T = 400, consistent with our findings for EuroParl translations.</S>
original cit marker offset is 0
new cit marker offset is 0



['184']
184
['184']
parsed_discourse_facet ['result_citation']
<S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



['193']
193
['193']
parsed_discourse_facet ['result_citation']
<S sid="163" ssid="112">Performance continues to improve with longer documents, most likely due to better topic inference.</S>
original cit marker offset is 0
new cit marker offset is 0



['163']
163
['163']
parsed_discourse_facet ['result_citation']
<S sid="184" ssid="18">Interestingly, we find that almost all languages in our corpus, including several pairs that have historically been in conflict, show average JS divergences of between approximately 0.08 and 0.12 for T = 400, consistent with our findings for EuroParl translations.</S>
original cit marker offset is 0
new cit marker offset is 0



['184']
184
['184']
parsed_discourse_facet ['result_citation']
<S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S>
original cit marker offset is 0
new cit marker offset is 0



['148']
148
['148']
parsed_discourse_facet ['method_citation']
<S sid="184" ssid="18">Interestingly, we find that almost all languages in our corpus, including several pairs that have historically been in conflict, show average JS divergences of between approximately 0.08 and 0.12 for T = 400, consistent with our findings for EuroParl translations.</S>
original cit marker offset is 0
new cit marker offset is 0



['184']
184
['184']
parsed_discourse_facet ['result_citation']
<S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



['193']
193
['193']
parsed_discourse_facet ['result_citation']
<S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['192']
192
['192']
parsed_discourse_facet ['result_citation']
<S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['105']
105
['105']
parsed_discourse_facet ['method_citation']
    <S sid="10" ssid="6">We demonstrate its utility and explore its characteristics using two polylingual corpora: proceedings of the European parliament (in eleven languages) and a collection of Wikipedia articles (in twelve languages).</S>
original cit marker offset is 0
new cit marker offset is 0



['10']
10
['10']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/D09-1092.annv3.csv
<S sid="21" ssid="17">The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.</S><S sid="142" ssid="91">EN &#8220;comitology&#8221; and IT lang Topics at P = 0.01 &#8220;comitalogia&#8221;) that simply were not in the lexica.</S><S sid="185" ssid="19">Subtle differences of sentiment may be below the granularity of the model. sadwrn blaned gallair at lloeren mytholeg space nasa sojus flug mission &#948;&#953;&#945;&#963;&#964;&#951;&#956;&#953;&#954;&#972; sts nasa &#945;&#947;&#947;&#955; small space mission launch satellite nasa spacecraft sojuz nasa apollo ensimm&#352;inen space lento spatiale mission orbite mars satellite spatial &#1514;&#1497;&#1504;&#1499;&#1493;&#1514; &#1488; &#1512;&#1493;&#1491;&#1499; &#1500;&#1500; &#1495; &#1509;&#1512; &#1488;&#1492; &#1500;&#1500;&#1495;&#1492; spaziale missione programma space sojuz stazione misja kosmicznej stacji misji space nasa &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080;&#1081; &#1089;&#1086;&#1102;&#1079; &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1075;&#1086; &#1089;&#1087;&#1091;&#1090;&#1085;&#1080;&#1082; &#1089;&#1090;&#1072;&#1085;&#1094;&#1080;&#1080; uzay soyuz ay uzaya salyut sovyetler sbaen madrid el la jos6 sbaeneg de spanischer spanischen spanien madrid la &#953;&#963;&#960;&#945;&#957;&#943;&#945;&#962; &#953;&#963;&#960;&#945;&#957;&#943;&#945; de &#953;&#963;&#960;&#945;&#957;&#972;&#962; &#957;&#964;&#949; &#956;&#945;&#948;&#961;&#943;&#964;&#951; de spanish spain la madrid y espanja de espanjan madrid la real espagnol espagne madrid espagnole juan y de spagna spagnolo spagnola madrid el de hiszpa&#324;ski hiszpanii la juan y &#1076;&#1077; &#1084;&#1072;&#1076;&#1088;&#1080;&#1076; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1080; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1103; &#1080;&#1089;&#1087;&#1072;&#1085;&#1089;&#1082;&#1080;&#1081; de ispanya ispanyol madrid la kOba real bardd gerddi iaith beirdd fardd gymraeg dichter schriftsteller literatur gedichte gedicht werk &#960;&#959;&#953;&#951;&#964;&#942;&#962; &#960;&#959;&#943;&#951;&#963;&#951; &#960;&#959;&#953;&#951;&#964;&#942; &#941;&#961;&#947;&#959; &#960;&#959;&#953;&#951;&#964;&#941;&#962; &#960;&#959;&#953;&#942;&#956;&#945;&#964;&#945; poet poetry literature literary poems poem runoilija kirjailija kirjallisuuden kirjoitti runo julkaisi poste 6crivain litt6rature po6sie litt6raire ses Overall, these scores indicate that although individual pages may show disagreement, Wikipedia is on average consistent between languages.</S><S sid="186" ssid="20">Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'142'", "'185'", "'186'"]
'21'
'142'
'185'
'186'
['21', '142', '185', '186']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="78" ssid="27">Although the model does not distinguish between topic assignment variables within a given document tuple (so it is technically incorrect to speak of different posterior distributions over topics for different documents in a given tuple), we can nevertheless divide topic assignment variables between languages and use them to estimate a Dirichlet-multinomial posterior distribution for each language in each tuple.</S><S sid="172" ssid="6">Second, because comparable texts may not use exactly the same topics, it becomes crucially important to be able to characterize differences in topic prevalence at the document level (do different languages have different perspectives on the same article?) and at the language-wide level (which topics do particular languages focus on?).</S><S sid="177" ssid="11">In the English version of Wikipedia we dropped all articles that were not linked to by any other language in our set.</S><S sid="186" ssid="20">Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'78'", "'172'", "'177'", "'186'"]
'78'
'172'
'177'
'186'
['78', '172', '177', '186']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="58">One simple way to achieve this topic alignment is to add a small set of comparable document tuples that provide sufficient &#8220;glue&#8221; to bind the topics together.</S><S sid="128" ssid="77">Although the PLTM is clearly not a substitute for a machine translation system&#8212;it has no way to represent syntax or even multi-word phrases&#8212;it is clear from the examples in figure 2 that the sets of high probability words in different languages for a given topic are likely to include translations.</S><S sid="137" ssid="86">For every topic t we select a small number K of the most probable words in English (e) and in each &#8220;translation&#8221; language (E): Wte and Wtt, respectively.</S><S sid="138" ssid="87">We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.</S>
original cit marker offset is 0
new cit marker offset is 0



["'109'", "'128'", "'137'", "'138'"]
'109'
'128'
'137'
'138'
['109', '128', '137', '138']
parsed_discourse_facet ['method_citation']
<S sid="0">Polylingual Topic Models</S><S sid="2" ssid="2">Meanwhile, massive collections of interlinked documents in dozens of languages, such as Wikipedia, are now widely available, calling for tools that can characterize content in many languages.</S><S sid="25" ssid="1">Bilingual topic models for parallel texts with word-to-word alignments have been studied previously using the HM-bitam model (Zhao and Xing, 2007).</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'25'", "'30'"]
'0'
'2'
'25'
'30'
['0', '2', '25', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S><S sid="21" ssid="17">The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.</S><S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'22'", "'148'"]
'20'
'21'
'22'
'148'
['20', '21', '22', '148']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="9" ssid="5">In this paper, we present the polylingual topic model (PLTM).</S><S sid="92" ssid="41">We perform five estimation runs for each document and then calculate standard errors using a bootstrap method.</S><S sid="107" ssid="56">No paper is exactly comparable to any other paper, but they are all roughly topically similar.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'92'", "'107'", "'192'"]
'9'
'92'
'107'
'192'
['9', '92', '107', '192']
parsed_discourse_facet ['hypothesis_citation']
<S sid="118" ssid="67">We calculate the Jensen-Shannon divergence between the topic distributions for each pair of individual documents in S that were originally part of the same tuple prior to separation.</S><S sid="119" ssid="68">The lower the divergence, the more similar the distributions are to each other.</S><S sid="121" ssid="70">Table 3 shows mean JS divergences for each value of p. As expected, JS divergence is greater than that obtained when all tuples are left intact.</S><S sid="122" ssid="71">Divergence drops significantly when the proportion of &#8220;glue&#8221; tuples increases from 0.01 to 0.25.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'", "'119'", "'121'", "'122'"]
'118'
'119'
'121'
'122'
['118', '119', '121', '122']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="36" ssid="2">Each tuple is a set of documents that are loosely equivalent to each other, but written in different languages, e.g., corresponding Wikipedia articles in French, English and German.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'36'", "'105'", "'192'"]
'3'
'36'
'105'
'192'
['3', '36', '105', '192']
parsed_discourse_facet ['aim_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="18" ssid="14">In this paper, we use two polylingual corpora to answer various critical questions related to polylingual topic models.</S><S sid="65" ssid="14">This topic provides an illustration of the variation in technical terminology captured by PLTM, including the wide array of acronyms used by different languages.</S><S sid="99" ssid="48">Figure 5 shows the proportion of all tokens in English and Finnish assigned to each topic under LDA and PLTM with 800 topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'18'", "'65'", "'99'"]
'3'
'18'
'65'
'99'
['3', '18', '65', '99']
parsed_discourse_facet ['hypothesis_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="4" ssid="4">We explore the model&#8217;s characteristics using two large corpora, each with over ten different languages, and demonstrate its usefulness in supporting machine translation and tracking topic trends across languages.</S><S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'4'", "'19'", "'30'"]
'3'
'4'
'19'
'30'
['3', '4', '19', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</S><S sid="155" ssid="104">Finally, for each pair of languages (&#8220;query&#8221; and &#8220;target&#8221;) we calculate the difference between the topic distribution for each held-out document in the query language and the topic distribution for each held-out document in the target language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'30'", "'77'", "'155'"]
'22'
'30'
'77'
'155'
['22', '30', '77', '155']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="31" ssid="7">They also provide little analysis of the differences between polylingual and single-language topic models.</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'30'", "'31'", "'154'"]
'22'
'30'
'31'
'154'
['22', '30', '31', '154']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S><S sid="155" ssid="104">Finally, for each pair of languages (&#8220;query&#8221; and &#8220;target&#8221;) we calculate the difference between the topic distribution for each held-out document in the query language and the topic distribution for each held-out document in the target language.</S><S sid="156" ssid="105">We use both Jensen-Shannon divergence and cosine distance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'154'", "'155'", "'156'"]
'6'
'154'
'155'
'156'
['6', '154', '155', '156']
parsed_discourse_facet ['aim_citation', 'implication_citation']
<S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S><S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S><S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'20'", "'148'", "'154'"]
'19'
'20'
'148'
'154'
['19', '20', '148', '154']
parsed_discourse_facet ['method_citation', 'implication_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'30'", "'35'", "'105'"]
'6'
'30'
'35'
'105'
['6', '30', '35', '105']
parsed_discourse_facet ['aim_citation']
<S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S><S sid="169" ssid="3">In this section, we explore two questions relating to comparable text corpora and polylingual topic modeling.</S><S sid="170" ssid="4">First, we explore whether comparable document tuples support the alignment of fine-grained topics, as demonstrated earlier using parallel documents.</S><S sid="171" ssid="5">This property is useful for building machine translation systems as well as for human readers who are either learning new languages or analyzing texts in languages they do not know.</S>
original cit marker offset is 0
new cit marker offset is 0



["'35'", "'169'", "'170'", "'171'"]
'35'
'169'
'170'
'171'
['35', '169', '170', '171']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="75">These results demonstrate that PLTM is appropriate for aligning topics in corpora that have only a small subset of comparable documents.</S><S sid="147" ssid="96">These aligned document pairs could then be fed into standard machine translation systems as training data.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S><S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'", "'147'", "'192'", "'193'"]
'126'
'147'
'192'
'193'
['126', '147', '192', '193']
parsed_discourse_facet ['results_citation']
<S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="85" ssid="34">Smoothed histograms of inter&#8722;language JS divergence A topic model specifies a probability distribution over documents, or in the case of PLTM, document tuples.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S><S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'85'", "'105'", "'193'"]
'30'
'85'
'105'
'193'
['30', '85', '105', '193']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="24" ssid="20">By linking topics across languages, polylingual topic models can increase cross-cultural understanding by providing readers with the ability to characterize the contents of collections in unfamiliar languages and identify trends in topic prevalence.</S><S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'24'", "'77'", "'192'"]
'3'
'24'
'77'
'192'
['3', '24', '77', '192']
parsed_discourse_facet ['method_citation', 'aim_citation']



D09-1092
P11-2084
0
method_citation
['method_citation']



D09-1092
N12-1007
0
result_citation
['method_citation', 'results_citation']



D09-1092
D10-1025
0
method_citation
['method_citation', 'implication_citation']



D09-1092
W11-2133
0
result_citation
['results_citation']
parsing: input/ref/Task1/D09-1092_sweta.csv
 <S sid="32" ssid="8">Outside of the field of topic modeling, Kawaba et al. (Kawaba et al., 2008) use a Wikipedia-based model to perform sentiment analysis of blog posts.</S>
original cit marker offset is 0
new cit marker offset is 0



["32'"]
32'
['32']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">Additionally, PLTM assumes that each &#8220;topic&#8221; consists of a set of discrete distributions over words&#8212;one for each language l = 1, ... , L. In other words, rather than using a single set of topics &#934; = {&#966;1, ... , &#966;T}, as in LDA, there are L sets of language-specific topics, &#934;1, ... , &#934;L, each of which is drawn from a language-specific symmetric Dirichlet with concentration parameter &#946;l.</S>
original cit marker offset is 0
new cit marker offset is 0



["39'"]
39'
['39']
parsed_discourse_facet ['method_citation']
<S sid="138" ssid="87">We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.</S>
original cit marker offset is 0
new cit marker offset is 0



["138'"]
138'
['138']
parsed_discourse_facet ['method_citation']
 <S sid="196" ssid="5">When applied to comparable document collections such as Wikipedia, PLTM supports data-driven analysis of differences and similarities across all languages for readers who understand any one language.</S>
original cit marker offset is 0
new cit marker offset is 0



["196'"]
196'
['196']
parsed_discourse_facet ['method_citation']
<S sid="111" ssid="60">In order to simulate this scenario we create a set of variations of the EuroParl corpus by treating some documents as if they have no parallel/comparable texts &#8211; i.e., we put each of these documents in a single-document tuple.</S>
original cit marker offset is 0
new cit marker offset is 0



["111'"]
111'
['111']
parsed_discourse_facet ['method_citation']
<S sid="128" ssid="77">Although the PLTM is clearly not a substitute for a machine translation system&#8212;it has no way to represent syntax or even multi-word phrases&#8212;it is clear from the examples in figure 2 that the sets of high probability words in different languages for a given topic are likely to include translations.</S>
original cit marker offset is 0
new cit marker offset is 0



["128'"]
128'
['128']
parsed_discourse_facet ['method_citation']
<S sid="122" ssid="71">Divergence drops significantly when the proportion of &#8220;glue&#8221; tuples increases from 0.01 to 0.25.</S>
original cit marker offset is 0
new cit marker offset is 0



["122'"]
122'
['122']
parsed_discourse_facet ['method_citation']
 <S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S>
original cit marker offset is 0
new cit marker offset is 0



["35'"]
35'
['35']
parsed_discourse_facet ['method_citation']
 <S sid="110" ssid="59">Continuing with the example above, one might extract a set of connected Wikipedia articles related to the focus of the journal and then train PLTM on a joint corpus consisting of journal papers and Wikipedia articles.</S>
original cit marker offset is 0
new cit marker offset is 0



["110'"]
110'
['110']
parsed_discourse_facet ['method_citation']
<S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["30'"]
30'
['30']
parsed_discourse_facet ['method_citation']
    <S sid="146" ssid="95">In addition to enhancing lexicons by aligning topic-specific vocabulary, PLTM may also be useful for adapting machine translation systems to new domains by finding translations or near translations in an unstructured corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["146'"]
146'
['146']
parsed_discourse_facet ['method_citation']
<S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</
original cit marker offset is 0
new cit marker offset is 0



["77'"]
77'
['77']
parsed_discourse_facet ['method_citation']
 <S sid="156" ssid="105">We use both Jensen-Shannon divergence and cosine distance.</S>
original cit marker offset is 0
new cit marker offset is 0



["156'"]
156'
['156']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="7">They also provide little analysis of the differences between polylingual and single-language topic models.</S>
original cit marker offset is 0
new cit marker offset is 0



["31'"]
31'
['31']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S>
original cit marker offset is 0
new cit marker offset is 0



["19'"]
19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="131" ssid="80">We evaluate sets of high-probability words in each topic and multilingual &#8220;synsets&#8221; by comparing them to entries in human-constructed bilingual dictionaries, as done by Haghighi et al. (2008).</S>
original cit marker offset is 0
new cit marker offset is 0



["131'"]
131'
['131']
parsed_discourse_facet ['method_citation']
<S sid="196" ssid="5">When applied to comparable document collections such as Wikipedia, PLTM supports data-driven analysis of differences and similarities across all languages for readers who understand any one language.</S>
original cit marker offset is 0
new cit marker offset is 0



["196'"]
196'
['196']
parsed_discourse_facet ['method_citation']
<S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["192'"]
192'
['192']
parsed_discourse_facet ['method_citation']
<S sid="195" ssid="4">Additionally, PLTM can support the creation of bilingual lexica for low resource language pairs, providing candidate translations for more computationally intense alignment processes without the sentence-aligned translations typically used in such tasks.</S>
original cit marker offset is 0
new cit marker offset is 0



["195'"]
195'
['195']
parsed_discourse_facet ['method_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["6'"]
6'
['6']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/D09-1092.annv3.csv
<S sid="21" ssid="17">The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.</S><S sid="142" ssid="91">EN &#8220;comitology&#8221; and IT lang Topics at P = 0.01 &#8220;comitalogia&#8221;) that simply were not in the lexica.</S><S sid="185" ssid="19">Subtle differences of sentiment may be below the granularity of the model. sadwrn blaned gallair at lloeren mytholeg space nasa sojus flug mission &#948;&#953;&#945;&#963;&#964;&#951;&#956;&#953;&#954;&#972; sts nasa &#945;&#947;&#947;&#955; small space mission launch satellite nasa spacecraft sojuz nasa apollo ensimm&#352;inen space lento spatiale mission orbite mars satellite spatial &#1514;&#1497;&#1504;&#1499;&#1493;&#1514; &#1488; &#1512;&#1493;&#1491;&#1499; &#1500;&#1500; &#1495; &#1509;&#1512; &#1488;&#1492; &#1500;&#1500;&#1495;&#1492; spaziale missione programma space sojuz stazione misja kosmicznej stacji misji space nasa &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080;&#1081; &#1089;&#1086;&#1102;&#1079; &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1075;&#1086; &#1089;&#1087;&#1091;&#1090;&#1085;&#1080;&#1082; &#1089;&#1090;&#1072;&#1085;&#1094;&#1080;&#1080; uzay soyuz ay uzaya salyut sovyetler sbaen madrid el la jos6 sbaeneg de spanischer spanischen spanien madrid la &#953;&#963;&#960;&#945;&#957;&#943;&#945;&#962; &#953;&#963;&#960;&#945;&#957;&#943;&#945; de &#953;&#963;&#960;&#945;&#957;&#972;&#962; &#957;&#964;&#949; &#956;&#945;&#948;&#961;&#943;&#964;&#951; de spanish spain la madrid y espanja de espanjan madrid la real espagnol espagne madrid espagnole juan y de spagna spagnolo spagnola madrid el de hiszpa&#324;ski hiszpanii la juan y &#1076;&#1077; &#1084;&#1072;&#1076;&#1088;&#1080;&#1076; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1080; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1103; &#1080;&#1089;&#1087;&#1072;&#1085;&#1089;&#1082;&#1080;&#1081; de ispanya ispanyol madrid la kOba real bardd gerddi iaith beirdd fardd gymraeg dichter schriftsteller literatur gedichte gedicht werk &#960;&#959;&#953;&#951;&#964;&#942;&#962; &#960;&#959;&#943;&#951;&#963;&#951; &#960;&#959;&#953;&#951;&#964;&#942; &#941;&#961;&#947;&#959; &#960;&#959;&#953;&#951;&#964;&#941;&#962; &#960;&#959;&#953;&#942;&#956;&#945;&#964;&#945; poet poetry literature literary poems poem runoilija kirjailija kirjallisuuden kirjoitti runo julkaisi poste 6crivain litt6rature po6sie litt6raire ses Overall, these scores indicate that although individual pages may show disagreement, Wikipedia is on average consistent between languages.</S><S sid="186" ssid="20">Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'142'", "'185'", "'186'"]
'21'
'142'
'185'
'186'
['21', '142', '185', '186']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="78" ssid="27">Although the model does not distinguish between topic assignment variables within a given document tuple (so it is technically incorrect to speak of different posterior distributions over topics for different documents in a given tuple), we can nevertheless divide topic assignment variables between languages and use them to estimate a Dirichlet-multinomial posterior distribution for each language in each tuple.</S><S sid="172" ssid="6">Second, because comparable texts may not use exactly the same topics, it becomes crucially important to be able to characterize differences in topic prevalence at the document level (do different languages have different perspectives on the same article?) and at the language-wide level (which topics do particular languages focus on?).</S><S sid="177" ssid="11">In the English version of Wikipedia we dropped all articles that were not linked to by any other language in our set.</S><S sid="186" ssid="20">Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'78'", "'172'", "'177'", "'186'"]
'78'
'172'
'177'
'186'
['78', '172', '177', '186']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="58">One simple way to achieve this topic alignment is to add a small set of comparable document tuples that provide sufficient &#8220;glue&#8221; to bind the topics together.</S><S sid="128" ssid="77">Although the PLTM is clearly not a substitute for a machine translation system&#8212;it has no way to represent syntax or even multi-word phrases&#8212;it is clear from the examples in figure 2 that the sets of high probability words in different languages for a given topic are likely to include translations.</S><S sid="137" ssid="86">For every topic t we select a small number K of the most probable words in English (e) and in each &#8220;translation&#8221; language (E): Wte and Wtt, respectively.</S><S sid="138" ssid="87">We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.</S>
original cit marker offset is 0
new cit marker offset is 0



["'109'", "'128'", "'137'", "'138'"]
'109'
'128'
'137'
'138'
['109', '128', '137', '138']
parsed_discourse_facet ['method_citation']
<S sid="0">Polylingual Topic Models</S><S sid="2" ssid="2">Meanwhile, massive collections of interlinked documents in dozens of languages, such as Wikipedia, are now widely available, calling for tools that can characterize content in many languages.</S><S sid="25" ssid="1">Bilingual topic models for parallel texts with word-to-word alignments have been studied previously using the HM-bitam model (Zhao and Xing, 2007).</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'25'", "'30'"]
'0'
'2'
'25'
'30'
['0', '2', '25', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S><S sid="21" ssid="17">The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.</S><S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'22'", "'148'"]
'20'
'21'
'22'
'148'
['20', '21', '22', '148']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="9" ssid="5">In this paper, we present the polylingual topic model (PLTM).</S><S sid="92" ssid="41">We perform five estimation runs for each document and then calculate standard errors using a bootstrap method.</S><S sid="107" ssid="56">No paper is exactly comparable to any other paper, but they are all roughly topically similar.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'92'", "'107'", "'192'"]
'9'
'92'
'107'
'192'
['9', '92', '107', '192']
parsed_discourse_facet ['hypothesis_citation']
<S sid="118" ssid="67">We calculate the Jensen-Shannon divergence between the topic distributions for each pair of individual documents in S that were originally part of the same tuple prior to separation.</S><S sid="119" ssid="68">The lower the divergence, the more similar the distributions are to each other.</S><S sid="121" ssid="70">Table 3 shows mean JS divergences for each value of p. As expected, JS divergence is greater than that obtained when all tuples are left intact.</S><S sid="122" ssid="71">Divergence drops significantly when the proportion of &#8220;glue&#8221; tuples increases from 0.01 to 0.25.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'", "'119'", "'121'", "'122'"]
'118'
'119'
'121'
'122'
['118', '119', '121', '122']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="36" ssid="2">Each tuple is a set of documents that are loosely equivalent to each other, but written in different languages, e.g., corresponding Wikipedia articles in French, English and German.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'36'", "'105'", "'192'"]
'3'
'36'
'105'
'192'
['3', '36', '105', '192']
parsed_discourse_facet ['aim_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="18" ssid="14">In this paper, we use two polylingual corpora to answer various critical questions related to polylingual topic models.</S><S sid="65" ssid="14">This topic provides an illustration of the variation in technical terminology captured by PLTM, including the wide array of acronyms used by different languages.</S><S sid="99" ssid="48">Figure 5 shows the proportion of all tokens in English and Finnish assigned to each topic under LDA and PLTM with 800 topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'18'", "'65'", "'99'"]
'3'
'18'
'65'
'99'
['3', '18', '65', '99']
parsed_discourse_facet ['hypothesis_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="4" ssid="4">We explore the model&#8217;s characteristics using two large corpora, each with over ten different languages, and demonstrate its usefulness in supporting machine translation and tracking topic trends across languages.</S><S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'4'", "'19'", "'30'"]
'3'
'4'
'19'
'30'
['3', '4', '19', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</S><S sid="155" ssid="104">Finally, for each pair of languages (&#8220;query&#8221; and &#8220;target&#8221;) we calculate the difference between the topic distribution for each held-out document in the query language and the topic distribution for each held-out document in the target language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'30'", "'77'", "'155'"]
'22'
'30'
'77'
'155'
['22', '30', '77', '155']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="31" ssid="7">They also provide little analysis of the differences between polylingual and single-language topic models.</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'30'", "'31'", "'154'"]
'22'
'30'
'31'
'154'
['22', '30', '31', '154']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S><S sid="155" ssid="104">Finally, for each pair of languages (&#8220;query&#8221; and &#8220;target&#8221;) we calculate the difference between the topic distribution for each held-out document in the query language and the topic distribution for each held-out document in the target language.</S><S sid="156" ssid="105">We use both Jensen-Shannon divergence and cosine distance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'154'", "'155'", "'156'"]
'6'
'154'
'155'
'156'
['6', '154', '155', '156']
parsed_discourse_facet ['aim_citation', 'implication_citation']
<S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S><S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S><S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'20'", "'148'", "'154'"]
'19'
'20'
'148'
'154'
['19', '20', '148', '154']
parsed_discourse_facet ['method_citation', 'implication_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'30'", "'35'", "'105'"]
'6'
'30'
'35'
'105'
['6', '30', '35', '105']
parsed_discourse_facet ['aim_citation']
<S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S><S sid="169" ssid="3">In this section, we explore two questions relating to comparable text corpora and polylingual topic modeling.</S><S sid="170" ssid="4">First, we explore whether comparable document tuples support the alignment of fine-grained topics, as demonstrated earlier using parallel documents.</S><S sid="171" ssid="5">This property is useful for building machine translation systems as well as for human readers who are either learning new languages or analyzing texts in languages they do not know.</S>
original cit marker offset is 0
new cit marker offset is 0



["'35'", "'169'", "'170'", "'171'"]
'35'
'169'
'170'
'171'
['35', '169', '170', '171']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="75">These results demonstrate that PLTM is appropriate for aligning topics in corpora that have only a small subset of comparable documents.</S><S sid="147" ssid="96">These aligned document pairs could then be fed into standard machine translation systems as training data.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S><S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'", "'147'", "'192'", "'193'"]
'126'
'147'
'192'
'193'
['126', '147', '192', '193']
parsed_discourse_facet ['results_citation']
<S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="85" ssid="34">Smoothed histograms of inter&#8722;language JS divergence A topic model specifies a probability distribution over documents, or in the case of PLTM, document tuples.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S><S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'85'", "'105'", "'193'"]
'30'
'85'
'105'
'193'
['30', '85', '105', '193']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="24" ssid="20">By linking topics across languages, polylingual topic models can increase cross-cultural understanding by providing readers with the ability to characterize the contents of collections in unfamiliar languages and identify trends in topic prevalence.</S><S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'24'", "'77'", "'192'"]
'3'
'24'
'77'
'192'
['3', '24', '77', '192']
parsed_discourse_facet ['method_citation', 'aim_citation']



D09-1092
P11-2084
0
method_citation
['method_citation']



D09-1092
N12-1007
0
method_citation
['method_citation', 'results_citation']



D09-1092
D10-1025
0
method_citation
['method_citation', 'implication_citation']



D09-1092
W11-2133
0
method_citation
['results_citation']
parsing: input/ref/Task1/D09-1092_vardha.csv
<S sid="17" ssid="13">We argue that topic modeling is both a useful and appropriate tool for leveraging correspondences between semantically comparable documents in multiple different languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'"]
'17'
['17']
parsed_discourse_facet ['method_citation']
 <S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
    <S sid="138" ssid="87">We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'"]
'138'
['138']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">We demonstrate its utility and explore its characteristics using two polylingual corpora: proceedings of the European parliament (in eleven languages) and a collection of Wikipedia articles (in twelve languages).</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
   <S sid="55" ssid="4">The EuroParl corpus consists of parallel texts in eleven western European languages: Danish, German, Greek, English, Spanish, Finnish, French, Italian, Dutch, Portuguese and Swedish.</S>
original cit marker offset is 0
new cit marker offset is 0



["'55'"]
'55'
['55']
parsed_discourse_facet ['method_citation']
 sid="9" ssid="5">In this paper, we present the polylingual topic model (PLTM).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
Error in Reference Offset
<S sid="118" ssid="67">We calculate the Jensen-Shannon divergence between the topic distributions for each pair of individual documents in S that were originally part of the same tuple prior to separation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'"]
'118'
['118']
parsed_discourse_facet ['method_citation']
<S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'35'"]
'35'
['35']
parsed_discourse_facet ['method_citation']
<S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'35'"]
'35'
['35']
parsed_discourse_facet ['method_citation']
 <S sid="55" ssid="4">The EuroParl corpus consists of parallel texts in eleven western European languages: Danish, German, Greek, English, Spanish, Finnish, French, Italian, Dutch, Portuguese and Swedish.</S>
original cit marker offset is 0
new cit marker offset is 0



["'55'"]
'55'
['55']
parsed_discourse_facet ['method_citation']
<S sid="102" ssid="51">In contrast, PLTM assigns a significant number of tokens to almost all 800 topics, in very similar proportions in both languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'102'"]
'102'
['102']
parsed_discourse_facet ['method_citation']
 <S sid="38" ssid="4">This is unlike LDA, in which each document is assumed to have its own document-specific distribution over topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'"]
'38'
['38']
parsed_discourse_facet ['method_citation']
 <S sid="156" ssid="105">We use both Jensen-Shannon divergence and cosine distance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'156'"]
'156'
['156']
parsed_discourse_facet ['method_citation']
    <S sid="36" ssid="2">Each tuple is a set of documents that are loosely equivalent to each other, but written in different languages, e.g., corresponding Wikipedia articles in French, English and German.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
  <S sid="170" ssid="4">First, we explore whether comparable document tuples support the alignment of fine-grained topics, as demonstrated earlier using parallel documents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'170'"]
'170'
['170']
parsed_discourse_facet ['method_citation']
    <S sid="29" ssid="5">A recent extended abstract, developed concurrently by Ni et al. (Ni et al., 2009), discusses a multilingual topic model similar to the one presented here.</S>
original cit marker offset is 0
new cit marker offset is 0



["'29'"]
'29'
['29']
parsed_discourse_facet ['method_citation']
  <S sid="170" ssid="4">First, we explore whether comparable document tuples support the alignment of fine-grained topics, as demonstrated earlier using parallel documents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'170'"]
'170'
['170']
parsed_discourse_facet ['method_citation']
<S sid="168" ssid="2">However, the growth of the web, and in particular Wikipedia, has made comparable text corpora &#8211; documents that are topically similar but are not direct translations of one another &#8211; considerably more abundant than true parallel corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'168'"]
'168'
['168']
parsed_discourse_facet ['method_citation']
    <S sid="29" ssid="5">A recent extended abstract, developed concurrently by Ni et al. (Ni et al., 2009), discusses a multilingual topic model similar to the one presented here.</S>
original cit marker offset is 0
new cit marker offset is 0



["'29'"]
'29'
['29']
parsed_discourse_facet ['method_citation']
 <S sid="110" ssid="59">Continuing with the example above, one might extract a set of connected Wikipedia articles related to the focus of the journal and then train PLTM on a joint corpus consisting of journal papers and Wikipedia articles.</S>
original cit marker offset is 0
new cit marker offset is 0



["'110'"]
'110'
['110']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/D09-1092.annv3.csv
<S sid="21" ssid="17">The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.</S><S sid="142" ssid="91">EN &#8220;comitology&#8221; and IT lang Topics at P = 0.01 &#8220;comitalogia&#8221;) that simply were not in the lexica.</S><S sid="185" ssid="19">Subtle differences of sentiment may be below the granularity of the model. sadwrn blaned gallair at lloeren mytholeg space nasa sojus flug mission &#948;&#953;&#945;&#963;&#964;&#951;&#956;&#953;&#954;&#972; sts nasa &#945;&#947;&#947;&#955; small space mission launch satellite nasa spacecraft sojuz nasa apollo ensimm&#352;inen space lento spatiale mission orbite mars satellite spatial &#1514;&#1497;&#1504;&#1499;&#1493;&#1514; &#1488; &#1512;&#1493;&#1491;&#1499; &#1500;&#1500; &#1495; &#1509;&#1512; &#1488;&#1492; &#1500;&#1500;&#1495;&#1492; spaziale missione programma space sojuz stazione misja kosmicznej stacji misji space nasa &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080;&#1081; &#1089;&#1086;&#1102;&#1079; &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1075;&#1086; &#1089;&#1087;&#1091;&#1090;&#1085;&#1080;&#1082; &#1089;&#1090;&#1072;&#1085;&#1094;&#1080;&#1080; uzay soyuz ay uzaya salyut sovyetler sbaen madrid el la jos6 sbaeneg de spanischer spanischen spanien madrid la &#953;&#963;&#960;&#945;&#957;&#943;&#945;&#962; &#953;&#963;&#960;&#945;&#957;&#943;&#945; de &#953;&#963;&#960;&#945;&#957;&#972;&#962; &#957;&#964;&#949; &#956;&#945;&#948;&#961;&#943;&#964;&#951; de spanish spain la madrid y espanja de espanjan madrid la real espagnol espagne madrid espagnole juan y de spagna spagnolo spagnola madrid el de hiszpa&#324;ski hiszpanii la juan y &#1076;&#1077; &#1084;&#1072;&#1076;&#1088;&#1080;&#1076; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1080; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1103; &#1080;&#1089;&#1087;&#1072;&#1085;&#1089;&#1082;&#1080;&#1081; de ispanya ispanyol madrid la kOba real bardd gerddi iaith beirdd fardd gymraeg dichter schriftsteller literatur gedichte gedicht werk &#960;&#959;&#953;&#951;&#964;&#942;&#962; &#960;&#959;&#943;&#951;&#963;&#951; &#960;&#959;&#953;&#951;&#964;&#942; &#941;&#961;&#947;&#959; &#960;&#959;&#953;&#951;&#964;&#941;&#962; &#960;&#959;&#953;&#942;&#956;&#945;&#964;&#945; poet poetry literature literary poems poem runoilija kirjailija kirjallisuuden kirjoitti runo julkaisi poste 6crivain litt6rature po6sie litt6raire ses Overall, these scores indicate that although individual pages may show disagreement, Wikipedia is on average consistent between languages.</S><S sid="186" ssid="20">Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'142'", "'185'", "'186'"]
'21'
'142'
'185'
'186'
['21', '142', '185', '186']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="78" ssid="27">Although the model does not distinguish between topic assignment variables within a given document tuple (so it is technically incorrect to speak of different posterior distributions over topics for different documents in a given tuple), we can nevertheless divide topic assignment variables between languages and use them to estimate a Dirichlet-multinomial posterior distribution for each language in each tuple.</S><S sid="172" ssid="6">Second, because comparable texts may not use exactly the same topics, it becomes crucially important to be able to characterize differences in topic prevalence at the document level (do different languages have different perspectives on the same article?) and at the language-wide level (which topics do particular languages focus on?).</S><S sid="177" ssid="11">In the English version of Wikipedia we dropped all articles that were not linked to by any other language in our set.</S><S sid="186" ssid="20">Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'78'", "'172'", "'177'", "'186'"]
'78'
'172'
'177'
'186'
['78', '172', '177', '186']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="58">One simple way to achieve this topic alignment is to add a small set of comparable document tuples that provide sufficient &#8220;glue&#8221; to bind the topics together.</S><S sid="128" ssid="77">Although the PLTM is clearly not a substitute for a machine translation system&#8212;it has no way to represent syntax or even multi-word phrases&#8212;it is clear from the examples in figure 2 that the sets of high probability words in different languages for a given topic are likely to include translations.</S><S sid="137" ssid="86">For every topic t we select a small number K of the most probable words in English (e) and in each &#8220;translation&#8221; language (E): Wte and Wtt, respectively.</S><S sid="138" ssid="87">We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.</S>
original cit marker offset is 0
new cit marker offset is 0



["'109'", "'128'", "'137'", "'138'"]
'109'
'128'
'137'
'138'
['109', '128', '137', '138']
parsed_discourse_facet ['method_citation']
<S sid="0">Polylingual Topic Models</S><S sid="2" ssid="2">Meanwhile, massive collections of interlinked documents in dozens of languages, such as Wikipedia, are now widely available, calling for tools that can characterize content in many languages.</S><S sid="25" ssid="1">Bilingual topic models for parallel texts with word-to-word alignments have been studied previously using the HM-bitam model (Zhao and Xing, 2007).</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'25'", "'30'"]
'0'
'2'
'25'
'30'
['0', '2', '25', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S><S sid="21" ssid="17">The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.</S><S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'22'", "'148'"]
'20'
'21'
'22'
'148'
['20', '21', '22', '148']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="9" ssid="5">In this paper, we present the polylingual topic model (PLTM).</S><S sid="92" ssid="41">We perform five estimation runs for each document and then calculate standard errors using a bootstrap method.</S><S sid="107" ssid="56">No paper is exactly comparable to any other paper, but they are all roughly topically similar.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'92'", "'107'", "'192'"]
'9'
'92'
'107'
'192'
['9', '92', '107', '192']
parsed_discourse_facet ['hypothesis_citation']
<S sid="118" ssid="67">We calculate the Jensen-Shannon divergence between the topic distributions for each pair of individual documents in S that were originally part of the same tuple prior to separation.</S><S sid="119" ssid="68">The lower the divergence, the more similar the distributions are to each other.</S><S sid="121" ssid="70">Table 3 shows mean JS divergences for each value of p. As expected, JS divergence is greater than that obtained when all tuples are left intact.</S><S sid="122" ssid="71">Divergence drops significantly when the proportion of &#8220;glue&#8221; tuples increases from 0.01 to 0.25.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'", "'119'", "'121'", "'122'"]
'118'
'119'
'121'
'122'
['118', '119', '121', '122']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="36" ssid="2">Each tuple is a set of documents that are loosely equivalent to each other, but written in different languages, e.g., corresponding Wikipedia articles in French, English and German.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'36'", "'105'", "'192'"]
'3'
'36'
'105'
'192'
['3', '36', '105', '192']
parsed_discourse_facet ['aim_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="18" ssid="14">In this paper, we use two polylingual corpora to answer various critical questions related to polylingual topic models.</S><S sid="65" ssid="14">This topic provides an illustration of the variation in technical terminology captured by PLTM, including the wide array of acronyms used by different languages.</S><S sid="99" ssid="48">Figure 5 shows the proportion of all tokens in English and Finnish assigned to each topic under LDA and PLTM with 800 topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'18'", "'65'", "'99'"]
'3'
'18'
'65'
'99'
['3', '18', '65', '99']
parsed_discourse_facet ['hypothesis_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="4" ssid="4">We explore the model&#8217;s characteristics using two large corpora, each with over ten different languages, and demonstrate its usefulness in supporting machine translation and tracking topic trends across languages.</S><S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'4'", "'19'", "'30'"]
'3'
'4'
'19'
'30'
['3', '4', '19', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</S><S sid="155" ssid="104">Finally, for each pair of languages (&#8220;query&#8221; and &#8220;target&#8221;) we calculate the difference between the topic distribution for each held-out document in the query language and the topic distribution for each held-out document in the target language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'30'", "'77'", "'155'"]
'22'
'30'
'77'
'155'
['22', '30', '77', '155']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="31" ssid="7">They also provide little analysis of the differences between polylingual and single-language topic models.</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'30'", "'31'", "'154'"]
'22'
'30'
'31'
'154'
['22', '30', '31', '154']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S><S sid="155" ssid="104">Finally, for each pair of languages (&#8220;query&#8221; and &#8220;target&#8221;) we calculate the difference between the topic distribution for each held-out document in the query language and the topic distribution for each held-out document in the target language.</S><S sid="156" ssid="105">We use both Jensen-Shannon divergence and cosine distance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'154'", "'155'", "'156'"]
'6'
'154'
'155'
'156'
['6', '154', '155', '156']
parsed_discourse_facet ['aim_citation', 'implication_citation']
<S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S><S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S><S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'20'", "'148'", "'154'"]
'19'
'20'
'148'
'154'
['19', '20', '148', '154']
parsed_discourse_facet ['method_citation', 'implication_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'30'", "'35'", "'105'"]
'6'
'30'
'35'
'105'
['6', '30', '35', '105']
parsed_discourse_facet ['aim_citation']
<S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S><S sid="169" ssid="3">In this section, we explore two questions relating to comparable text corpora and polylingual topic modeling.</S><S sid="170" ssid="4">First, we explore whether comparable document tuples support the alignment of fine-grained topics, as demonstrated earlier using parallel documents.</S><S sid="171" ssid="5">This property is useful for building machine translation systems as well as for human readers who are either learning new languages or analyzing texts in languages they do not know.</S>
original cit marker offset is 0
new cit marker offset is 0



["'35'", "'169'", "'170'", "'171'"]
'35'
'169'
'170'
'171'
['35', '169', '170', '171']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="75">These results demonstrate that PLTM is appropriate for aligning topics in corpora that have only a small subset of comparable documents.</S><S sid="147" ssid="96">These aligned document pairs could then be fed into standard machine translation systems as training data.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S><S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'", "'147'", "'192'", "'193'"]
'126'
'147'
'192'
'193'
['126', '147', '192', '193']
parsed_discourse_facet ['results_citation']
<S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="85" ssid="34">Smoothed histograms of inter&#8722;language JS divergence A topic model specifies a probability distribution over documents, or in the case of PLTM, document tuples.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S><S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'85'", "'105'", "'193'"]
'30'
'85'
'105'
'193'
['30', '85', '105', '193']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="24" ssid="20">By linking topics across languages, polylingual topic models can increase cross-cultural understanding by providing readers with the ability to characterize the contents of collections in unfamiliar languages and identify trends in topic prevalence.</S><S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'24'", "'77'", "'192'"]
'3'
'24'
'77'
'192'
['3', '24', '77', '192']
parsed_discourse_facet ['method_citation', 'aim_citation']



D09-1092
P11-2084
0
method_citation
['method_citation']



D09-1092
N12-1007
0
method_citation
['method_citation', 'results_citation']
parsing: input/ref/Task1/D10-1044_aakansha.csv
<S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'144'"]
'144'
['144']
parsed_discourse_facet ['method_citation']
<S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S>
    <S sid="96" ssid="33">We used it to score all phrase pairs in the OUT table, in order to provide a feature for the instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'95'", "'96'"]
'95'
'96'
['95', '96']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="6">In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'62'"]
'62'
['62']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'"]
'28'
['28']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'"]
'23'
['23']
parsed_discourse_facet ['method_citation']
<S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'144'"]
'144'
['144']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="6">In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'"]
'28'
['28']
parsed_discourse_facet ['method_citation']
<S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



["'75'"]
'75'
['75']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S>
original cit marker offset is 0
new cit marker offset is 0



["'31'"]
'31'
['31']
parsed_discourse_facet ['method_citation']
<S sid="22" ssid="19">Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'"]
'22'
['22']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'"]
'23'
['23']
parsed_discourse_facet ['method_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'62'"]
'62'
['62']
parsed_discourse_facet ['method_citation']
<S sid="119" ssid="23">The 2nd block contains the IR system, which was tuned by selecting text in multiples of the size of the EMEA training corpus, according to dev set performance.</S>
    <S sid="120" ssid="24">This significantly underperforms log-linear combination.</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'120'"]
'119'
'120'
['119', '120']
parsed_discourse_facet ['result_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S>
    <S sid="24" ssid="21">Sentence pairs are the natural instances for SMT, but sentences often contain a mix of domain-specific and general language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'24'"]
'23'
'24'
['23', '24']
parsed_discourse_facet ['method_citation']
<S sid="40" ssid="4">We focus here instead on adapting the two most important features: the language model (LM), which estimates the probability p(wIh) of a target word w following an ngram h; and the translation models (TM) p(slt) and p(t1s), which give the probability of source phrase s translating to target phrase t, and vice versa.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'"]
'40'
['40']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/D10-1044.annv3.csv
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="10" ssid="7">This is a standard adaptation problem for SMT.</S><S sid="14" ssid="11">There is a fairly large body of work on SMT adaptation.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'10'", "'14'", "'31'"]
'0'
'10'
'14'
'31'
['0', '10', '14', '31']
parsed_discourse_facet ['results_citation']
<S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S><S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S><S sid="132" ssid="1">We have already mentioned the closely related work by Matsoukas et al (2009) on discriminative corpus weighting, and Jiang and Zhai (2007) on (nondiscriminative) instance weighting.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'65'", "'95'", "'132'", "'152'"]
'65'
'95'
'132'
'152'
['65', '95', '132', '152']
parsed_discourse_facet ['method_citation']
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="4" ssid="1">Domain adaptation is a common concern when optimizing empirical NLP applications.</S><S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S><S sid="143" ssid="12">Other work includes transferring latent topic distributions from source to target language for LM adaptation, (Tam et al., 2007) and adapting features at the sentence level to different categories of sentence (Finch and Sumita, 2008).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'4'", "'141'", "'143'"]
'0'
'4'
'141'
'143'
['0', '4', '141', '143']
parsed_discourse_facet ['aim_citation']
<S sid="24" ssid="21">Sentence pairs are the natural instances for SMT, but sentences often contain a mix of domain-specific and general language.</S><S sid="25" ssid="22">For instance, the sentence Similar improvements in haemoglobin levels were reported in the scientific literature for other epoetins would likely be considered domain-specific despite the presence of general phrases like were reported in.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'31'", "'62'"]
'24'
'25'
'31'
'62'
['24', '25', '31', '62']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="51" ssid="15">For the LM, adaptive weights are set as follows: where &#945; is a weight vector containing an element &#945;i for each domain (just IN and OUT in our case), pi are the corresponding domain-specific models, and &#732;p(w, h) is an empirical distribution from a targetlanguage training corpus&#8212;we used the IN dev set for this.</S><S sid="71" ssid="8">Finally, we incorporate the instance-weighting model into a general linear combination, and learn weights and mixing parameters simultaneously. where c&#955;(s, t) is a modified count for pair (s, t) in OUT, u(s|t) is a prior distribution, and y is a prior weight.</S><S sid="72" ssid="9">The original OUT counts co(s, t) are weighted by a logistic function w&#955;(s, t): To motivate weighting joint OUT counts as in (6), we begin with the &#8220;ideal&#8221; objective for setting multinomial phrase probabilities 0 = {p(s|t), dst}, which is the likelihood with respect to the true IN distribution pi(s, t).</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'51'", "'71'", "'72'"]
'50'
'51'
'71'
'72'
['50', '51', '71', '72']
parsed_discourse_facet ['method_citation']
<S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S><S sid="67" ssid="4">We extend the Matsoukas et al approach in several ways.</S><S sid="151" ssid="8">In future work we plan to try this approach with more competitive SMT systems, and to extend instance weighting to other standard SMT components such as the LM, lexical phrase weights, and lexicalized distortion.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'65'", "'67'", "'151'", "'152'"]
'65'
'67'
'151'
'152'
['65', '67', '151', '152']
parsed_discourse_facet ['method_citation']
<S sid="49" ssid="13">This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="145" ssid="2">Each out-of-domain phrase pair is characterized by a set of simple features intended to reflect how useful it will be.</S><S sid="147" ssid="4">These estimates are in turn combined linearly with relative-frequency estimates from an in-domain phrase table.</S>
original cit marker offset is 0
new cit marker offset is 0



["'49'", "'50'", "'145'", "'147'"]
'49'
'50'
'145'
'147'
['49', '50', '145', '147']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="2">Even when there is training data available in the domain of interest, there is often additional data from other domains that could in principle be used to improve performance.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="54" ssid="18">However, we note that the final conditional estimates p(s|t) from a given phrase table maximize the likelihood of joint empirical phrase pair counts over a word-aligned corpus.</S><S sid="133" ssid="2">It is difficult to directly compare the Matsoukas et al results with ours, since our out-of-domain corpus is homogeneous; given heterogeneous training data, however, it would be trivial to include Matsoukas-style identity features in our instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'50'", "'54'", "'133'"]
'5'
'50'
'54'
'133'
['5', '50', '54', '133']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="44" ssid="8">When OUT is large and distinct, its contribution can be controlled by training separate IN and OUT models, and weighting their combination.</S><S sid="49" ssid="13">This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'44'", "'49'", "'50'"]
'30'
'44'
'49'
'50'
['30', '44', '49', '50']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'", "'30'", "'50'", "'141'"]
'28'
'30'
'50'
'141'
['28', '30', '50', '141']
parsed_discourse_facet ['aim_citation']
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="33" ssid="30">The paper is structured as follows.</S><S sid="105" ssid="9">Compared to the EMEA/EP setting, the two domains in the NIST setting are less homogeneous and more similar to each other; there is also considerably more IN text available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'30'", "'33'", "'105'"]
'0'
'30'
'33'
'105'
['0', '30', '33', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="52" ssid="16">It is not immediately obvious how to formulate an equivalent to equation (1) for an adapted TM, because there is no well-defined objective for learning TMs from parallel corpora.</S><S sid="53" ssid="17">This has led previous workers to adopt ad hoc linear weighting schemes (Finch and Sumita, 2008; Foster and Kuhn, 2007; L&#168;u et al., 2007).</S><S sid="74" ssid="11">(7) &#966; s,t This is a somewhat less direct objective than used by Matsoukas et al, who make an iterative approximation to expected TER.</S><S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'", "'53'", "'74'", "'75'"]
'52'
'53'
'74'
'75'
['52', '53', '74', '75']
parsed_discourse_facet ['method_citation']
<S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="60" ssid="24">The matching sentence pairs are then added to the IN corpus, and the system is re-trained.</S><S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'31'", "'60'", "'65'"]
'30'
'31'
'60'
'65'
['30', '31', '60', '65']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="16">The idea of distinguishing between general and domain-specific examples is due to Daum&#180;e and Marcu (2006), who used a maximum-entropy model with latent variables to capture the degree of specificity.</S><S sid="21" ssid="18">This highly effective approach is not directly applicable to the multinomial models used for core SMT components, which have no natural method for combining split features, so we rely on an instance-weighting approach (Jiang and Zhai, 2007) to downweight domain-specific examples in OUT.</S><S sid="22" ssid="19">Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.</S><S sid="89" ssid="26">We used 22 features for the logistic weighting model, divided into two groups: one intended to reflect the degree to which a phrase pair belongs to general language, and one intended to capture similarity to the IN domain.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'21'", "'22'", "'89'"]
'19'
'21'
'22'
'89'
['19', '21', '22', '89']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'30'", "'144'", "'152'"]
'23'
'30'
'144'
'152'
['23', '30', '144', '152']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="8" ssid="5">), which precludes a single universal approach to adaptation.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S><S sid="142" ssid="11">There has also been some work on adapting the word alignment model prior to phrase extraction (Civera and Juan, 2007; Wu et al., 2005), and on dynamically choosing a dev set (Xu et al., 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'31'", "'62'", "'142'"]
'8'
'31'
'62'
'142'
['8', '31', '62', '142']
parsed_discourse_facet ['hypothesis_citation']
<S sid="51" ssid="15">For the LM, adaptive weights are set as follows: where &#945; is a weight vector containing an element &#945;i for each domain (just IN and OUT in our case), pi are the corresponding domain-specific models, and &#732;p(w, h) is an empirical distribution from a targetlanguage training corpus&#8212;we used the IN dev set for this.</S><S sid="119" ssid="23">The 2nd block contains the IR system, which was tuned by selecting text in multiples of the size of the EMEA training corpus, according to dev set performance.</S><S sid="134" ssid="3">Although these authors report better gains than ours, they are with respect to a non-adapted baseline.</S><S sid="148" ssid="5">Mixing, smoothing, and instance-feature weights are learned at the same time using an efficient maximum-likelihood procedure that relies on only a small in-domain development corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'119'", "'134'", "'148'"]
'51'
'119'
'134'
'148'
['51', '119', '134', '148']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S><S sid="55" ssid="19">This suggests a direct parallel to (1): where &#732;p(s, t) is a joint empirical distribution extracted from the IN dev set using the standard procedure.2 An alternative form of linear combination is a maximum a posteriori (MAP) combination (Bacchiani et al., 2004).</S><S sid="68" ssid="5">First, we learn weights on individual phrase pairs rather than sentences.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'55'", "'68'", "'152'"]
'23'
'55'
'68'
'152'
['23', '55', '68', '152']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="40" ssid="4">We focus here instead on adapting the two most important features: the language model (LM), which estimates the probability p(wIh) of a target word w following an ngram h; and the translation models (TM) p(slt) and p(t1s), which give the probability of source phrase s translating to target phrase t, and vice versa.</S><S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S><S sid="137" ssid="6">At first glance, this seems only peripherally related to our work, since the specific/general distinction is made for features rather than instances.</S><S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'", "'95'", "'137'", "'144'"]
'40'
'95'
'137'
'144'
['40', '95', '137', '144']
parsed_discourse_facet ['method_citation']



D10-1044
P12-1048
0
method_citation
['method_citation']



D10-1044
P14-2093
0
method_citation
['hypothesis_citation', 'method_citation']



D10-1044
P12-1099
0
method_citation
['method_citation', 'aim_citation']



D10-1044
P13-1126
0
method_citation
['method_citation', 'hypothesis_citation']



D10-1044
D11-1033
0
method_citation
['method_citation', 'aim_citation']



D10-1044
P14-1012
0
method_citation
['method_citation']
parsing: input/ref/Task1/D10-1044_swastika.csv
<S sid="9" ssid="6">In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.</S>
original cit marker offset is 0
new cit marker offset is 0



['9']
9
['9']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="6">In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.</S>
original cit marker offset is 0
new cit marker offset is 0



['9']
9
['9']
parsed_discourse_facet ['aim_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



['62']
62
['62']
parsed_discourse_facet ['method_citation']
<S sid="71" ssid="8">Finally, we incorporate the instance-weighting model into a general linear combination, and learn weights and mixing parameters simultaneously. where c&#955;(s, t) is a modified count for pair (s, t) in OUT, u(s|t) is a prior distribution, and y is a prior weight.</S>
original cit marker offset is 0
new cit marker offset is 0



['71']
71
['71']
parsed_discourse_facet ['method_citation']
<S sid="96" ssid="33">We used it to score all phrase pairs in the OUT table, in order to provide a feature for the instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



['96']
96
['96']
parsed_discourse_facet ['aim_citation']
<S sid="71" ssid="8">Finally, we incorporate the instance-weighting model into a general linear combination, and learn weights and mixing parameters simultaneously. where c&#955;(s, t) is a modified count for pair (s, t) in OUT, u(s|t) is a prior distribution, and y is a prior weight.</S>
original cit marker offset is 0
new cit marker offset is 0



['71']
71
['71']
parsed_discourse_facet ['result_citation']
<S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



['144']
144
['144']
parsed_discourse_facet ['result_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



['62']
62
['62']
parsed_discourse_facet ['method_citation']
<S sid="45" ssid="9">An easy way to achieve this is to put the domain-specific LMs and TMs into the top-level log-linear model and learn optimal weights with MERT (Och, 2003).</S>
original cit marker offset is 0
new cit marker offset is 0



['45']
45
['45']
parsed_discourse_facet ['method_citation']
<S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



['75']
75
['75']
parsed_discourse_facet ['method_citation']
<S sid="22" ssid="19">Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.</S>
original cit marker offset is 0
new cit marker offset is 0



['22']
22
['22']
parsed_discourse_facet ['method_citation']
<S sid="96" ssid="33">We used it to score all phrase pairs in the OUT table, in order to provide a feature for the instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



['96']
96
['96']
parsed_discourse_facet ['aim_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



['62']
62
['62']
parsed_discourse_facet ['method_citation']
  <S sid="42" ssid="6">The natural baseline approach is to concatenate data from IN and OUT.</S>
original cit marker offset is 0
new cit marker offset is 0



['42']
42
['42']
parsed_discourse_facet ['aim_citation']
<S sid="96" ssid="33">We used it to score all phrase pairs in the OUT table, in order to provide a feature for the instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



['96']
96
['96']
parsed_discourse_facet ['aim_citation']
parsing: input/res/Task1/D10-1044.annv3.csv
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="10" ssid="7">This is a standard adaptation problem for SMT.</S><S sid="14" ssid="11">There is a fairly large body of work on SMT adaptation.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'10'", "'14'", "'31'"]
'0'
'10'
'14'
'31'
['0', '10', '14', '31']
parsed_discourse_facet ['results_citation']
<S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S><S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S><S sid="132" ssid="1">We have already mentioned the closely related work by Matsoukas et al (2009) on discriminative corpus weighting, and Jiang and Zhai (2007) on (nondiscriminative) instance weighting.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'65'", "'95'", "'132'", "'152'"]
'65'
'95'
'132'
'152'
['65', '95', '132', '152']
parsed_discourse_facet ['method_citation']
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="4" ssid="1">Domain adaptation is a common concern when optimizing empirical NLP applications.</S><S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S><S sid="143" ssid="12">Other work includes transferring latent topic distributions from source to target language for LM adaptation, (Tam et al., 2007) and adapting features at the sentence level to different categories of sentence (Finch and Sumita, 2008).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'4'", "'141'", "'143'"]
'0'
'4'
'141'
'143'
['0', '4', '141', '143']
parsed_discourse_facet ['aim_citation']
<S sid="24" ssid="21">Sentence pairs are the natural instances for SMT, but sentences often contain a mix of domain-specific and general language.</S><S sid="25" ssid="22">For instance, the sentence Similar improvements in haemoglobin levels were reported in the scientific literature for other epoetins would likely be considered domain-specific despite the presence of general phrases like were reported in.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'31'", "'62'"]
'24'
'25'
'31'
'62'
['24', '25', '31', '62']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="51" ssid="15">For the LM, adaptive weights are set as follows: where &#945; is a weight vector containing an element &#945;i for each domain (just IN and OUT in our case), pi are the corresponding domain-specific models, and &#732;p(w, h) is an empirical distribution from a targetlanguage training corpus&#8212;we used the IN dev set for this.</S><S sid="71" ssid="8">Finally, we incorporate the instance-weighting model into a general linear combination, and learn weights and mixing parameters simultaneously. where c&#955;(s, t) is a modified count for pair (s, t) in OUT, u(s|t) is a prior distribution, and y is a prior weight.</S><S sid="72" ssid="9">The original OUT counts co(s, t) are weighted by a logistic function w&#955;(s, t): To motivate weighting joint OUT counts as in (6), we begin with the &#8220;ideal&#8221; objective for setting multinomial phrase probabilities 0 = {p(s|t), dst}, which is the likelihood with respect to the true IN distribution pi(s, t).</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'51'", "'71'", "'72'"]
'50'
'51'
'71'
'72'
['50', '51', '71', '72']
parsed_discourse_facet ['method_citation']
<S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S><S sid="67" ssid="4">We extend the Matsoukas et al approach in several ways.</S><S sid="151" ssid="8">In future work we plan to try this approach with more competitive SMT systems, and to extend instance weighting to other standard SMT components such as the LM, lexical phrase weights, and lexicalized distortion.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'65'", "'67'", "'151'", "'152'"]
'65'
'67'
'151'
'152'
['65', '67', '151', '152']
parsed_discourse_facet ['method_citation']
<S sid="49" ssid="13">This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="145" ssid="2">Each out-of-domain phrase pair is characterized by a set of simple features intended to reflect how useful it will be.</S><S sid="147" ssid="4">These estimates are in turn combined linearly with relative-frequency estimates from an in-domain phrase table.</S>
original cit marker offset is 0
new cit marker offset is 0



["'49'", "'50'", "'145'", "'147'"]
'49'
'50'
'145'
'147'
['49', '50', '145', '147']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="2">Even when there is training data available in the domain of interest, there is often additional data from other domains that could in principle be used to improve performance.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="54" ssid="18">However, we note that the final conditional estimates p(s|t) from a given phrase table maximize the likelihood of joint empirical phrase pair counts over a word-aligned corpus.</S><S sid="133" ssid="2">It is difficult to directly compare the Matsoukas et al results with ours, since our out-of-domain corpus is homogeneous; given heterogeneous training data, however, it would be trivial to include Matsoukas-style identity features in our instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'50'", "'54'", "'133'"]
'5'
'50'
'54'
'133'
['5', '50', '54', '133']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="44" ssid="8">When OUT is large and distinct, its contribution can be controlled by training separate IN and OUT models, and weighting their combination.</S><S sid="49" ssid="13">This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'44'", "'49'", "'50'"]
'30'
'44'
'49'
'50'
['30', '44', '49', '50']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'", "'30'", "'50'", "'141'"]
'28'
'30'
'50'
'141'
['28', '30', '50', '141']
parsed_discourse_facet ['aim_citation']
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="33" ssid="30">The paper is structured as follows.</S><S sid="105" ssid="9">Compared to the EMEA/EP setting, the two domains in the NIST setting are less homogeneous and more similar to each other; there is also considerably more IN text available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'30'", "'33'", "'105'"]
'0'
'30'
'33'
'105'
['0', '30', '33', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="52" ssid="16">It is not immediately obvious how to formulate an equivalent to equation (1) for an adapted TM, because there is no well-defined objective for learning TMs from parallel corpora.</S><S sid="53" ssid="17">This has led previous workers to adopt ad hoc linear weighting schemes (Finch and Sumita, 2008; Foster and Kuhn, 2007; L&#168;u et al., 2007).</S><S sid="74" ssid="11">(7) &#966; s,t This is a somewhat less direct objective than used by Matsoukas et al, who make an iterative approximation to expected TER.</S><S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'", "'53'", "'74'", "'75'"]
'52'
'53'
'74'
'75'
['52', '53', '74', '75']
parsed_discourse_facet ['method_citation']
<S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="60" ssid="24">The matching sentence pairs are then added to the IN corpus, and the system is re-trained.</S><S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'31'", "'60'", "'65'"]
'30'
'31'
'60'
'65'
['30', '31', '60', '65']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="16">The idea of distinguishing between general and domain-specific examples is due to Daum&#180;e and Marcu (2006), who used a maximum-entropy model with latent variables to capture the degree of specificity.</S><S sid="21" ssid="18">This highly effective approach is not directly applicable to the multinomial models used for core SMT components, which have no natural method for combining split features, so we rely on an instance-weighting approach (Jiang and Zhai, 2007) to downweight domain-specific examples in OUT.</S><S sid="22" ssid="19">Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.</S><S sid="89" ssid="26">We used 22 features for the logistic weighting model, divided into two groups: one intended to reflect the degree to which a phrase pair belongs to general language, and one intended to capture similarity to the IN domain.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'21'", "'22'", "'89'"]
'19'
'21'
'22'
'89'
['19', '21', '22', '89']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'30'", "'144'", "'152'"]
'23'
'30'
'144'
'152'
['23', '30', '144', '152']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="8" ssid="5">), which precludes a single universal approach to adaptation.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S><S sid="142" ssid="11">There has also been some work on adapting the word alignment model prior to phrase extraction (Civera and Juan, 2007; Wu et al., 2005), and on dynamically choosing a dev set (Xu et al., 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'31'", "'62'", "'142'"]
'8'
'31'
'62'
'142'
['8', '31', '62', '142']
parsed_discourse_facet ['hypothesis_citation']
<S sid="51" ssid="15">For the LM, adaptive weights are set as follows: where &#945; is a weight vector containing an element &#945;i for each domain (just IN and OUT in our case), pi are the corresponding domain-specific models, and &#732;p(w, h) is an empirical distribution from a targetlanguage training corpus&#8212;we used the IN dev set for this.</S><S sid="119" ssid="23">The 2nd block contains the IR system, which was tuned by selecting text in multiples of the size of the EMEA training corpus, according to dev set performance.</S><S sid="134" ssid="3">Although these authors report better gains than ours, they are with respect to a non-adapted baseline.</S><S sid="148" ssid="5">Mixing, smoothing, and instance-feature weights are learned at the same time using an efficient maximum-likelihood procedure that relies on only a small in-domain development corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'119'", "'134'", "'148'"]
'51'
'119'
'134'
'148'
['51', '119', '134', '148']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S><S sid="55" ssid="19">This suggests a direct parallel to (1): where &#732;p(s, t) is a joint empirical distribution extracted from the IN dev set using the standard procedure.2 An alternative form of linear combination is a maximum a posteriori (MAP) combination (Bacchiani et al., 2004).</S><S sid="68" ssid="5">First, we learn weights on individual phrase pairs rather than sentences.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'55'", "'68'", "'152'"]
'23'
'55'
'68'
'152'
['23', '55', '68', '152']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="40" ssid="4">We focus here instead on adapting the two most important features: the language model (LM), which estimates the probability p(wIh) of a target word w following an ngram h; and the translation models (TM) p(slt) and p(t1s), which give the probability of source phrase s translating to target phrase t, and vice versa.</S><S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S><S sid="137" ssid="6">At first glance, this seems only peripherally related to our work, since the specific/general distinction is made for features rather than instances.</S><S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'", "'95'", "'137'", "'144'"]
'40'
'95'
'137'
'144'
['40', '95', '137', '144']
parsed_discourse_facet ['method_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



D10-1044
P14-2093
0
method_citation
['hypothesis_citation', 'method_citation']



D10-1044
P12-1099
0
method_citation
['method_citation', 'aim_citation']
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
parsing: input/ref/Task1/D10-1044_sweta.csv
<S sid="4" ssid="1">Domain adaptation is a common concern when optimizing empirical NLP applications.</S>
original cit marker offset is 0
new cit marker offset is 0



["4'"]
4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="132" ssid="1">We have already mentioned the closely related work by Matsoukas et al (2009) on discriminative corpus weighting, and Jiang and Zhai (2007) on (nondiscriminative) instance weighting.</S>
original cit marker offset is 0
new cit marker offset is 0



["132'"]
132'
['132']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="4">For developers of Statistical Machine Translation (SMT) systems, an additional complication is the heterogeneous nature of SMT components (word-alignment model, language model, translation model, etc.</S>
original cit marker offset is 0
new cit marker offset is 0



["7'"]
7'
['7']
parsed_discourse_facet ['method_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["62'"]
62'
['62']
parsed_discourse_facet ['method_citation']
<S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S>
original cit marker offset is 0
new cit marker offset is 0



["50'"]
50'
['50']
parsed_discourse_facet ['method_citation']
<S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["152'"]
152'
['152']
parsed_discourse_facet ['method_citation']
<S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["144'"]
144'
['144']
parsed_discourse_facet ['method_citation']
 <S sid="9" ssid="6">In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.</S>
original cit marker offset is 0
new cit marker offset is 0



["9'"]
9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



["75'"]
75'
['75']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S>
original cit marker offset is 0
new cit marker offset is 0



["28'"]
28'
['28']
parsed_discourse_facet ['method_citation']
<S sid="97" ssid="1">We carried out translation experiments in two different settings.</S>
original cit marker offset is 0
new cit marker offset is 0



["97'"]
97'
['97']
parsed_discourse_facet ['method_citation']
<S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



["75'"]
75'
['75']
parsed_discourse_facet ['method_citation']
<S sid="143" ssid="12">Other work includes transferring latent topic distributions from source to target language for LM adaptation, (Tam et al., 2007) and adapting features at the sentence level to different categories of sentence (Finch and Sumita, 2008).</S>
original cit marker offset is 0
new cit marker offset is 0



["143'"]
143'
['143']
parsed_discourse_facet ['method_citation']
<S sid="153" ssid="10">Finally, we intend to explore more sophisticated instanceweighting features for capturing the degree of generality of phrase pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["153'"]
153'
['153']
parsed_discourse_facet ['method_citation']
<S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["144'"]
144'
['144']
parsed_discourse_facet ['method_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["62'"]
62'
['62']
parsed_discourse_facet ['method_citation']
<S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["141'"]
141'
['141']
parsed_discourse_facet ['method_citation']
 <S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S>
original cit marker offset is 0
new cit marker offset is 0



["28'"]
28'
['28']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="1">Standard SMT systems have a hierarchical parameter structure: top-level log-linear weights are used to combine a small set of complex features, interpreted as log probabilities, many of which have their own internal parameters and objectives.</S>
original cit marker offset is 0
new cit marker offset is 0



["37'"]
37'
['37']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/D10-1044.annv3.csv
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="10" ssid="7">This is a standard adaptation problem for SMT.</S><S sid="14" ssid="11">There is a fairly large body of work on SMT adaptation.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'10'", "'14'", "'31'"]
'0'
'10'
'14'
'31'
['0', '10', '14', '31']
parsed_discourse_facet ['results_citation']
<S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S><S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S><S sid="132" ssid="1">We have already mentioned the closely related work by Matsoukas et al (2009) on discriminative corpus weighting, and Jiang and Zhai (2007) on (nondiscriminative) instance weighting.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'65'", "'95'", "'132'", "'152'"]
'65'
'95'
'132'
'152'
['65', '95', '132', '152']
parsed_discourse_facet ['method_citation']
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="4" ssid="1">Domain adaptation is a common concern when optimizing empirical NLP applications.</S><S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S><S sid="143" ssid="12">Other work includes transferring latent topic distributions from source to target language for LM adaptation, (Tam et al., 2007) and adapting features at the sentence level to different categories of sentence (Finch and Sumita, 2008).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'4'", "'141'", "'143'"]
'0'
'4'
'141'
'143'
['0', '4', '141', '143']
parsed_discourse_facet ['aim_citation']
<S sid="24" ssid="21">Sentence pairs are the natural instances for SMT, but sentences often contain a mix of domain-specific and general language.</S><S sid="25" ssid="22">For instance, the sentence Similar improvements in haemoglobin levels were reported in the scientific literature for other epoetins would likely be considered domain-specific despite the presence of general phrases like were reported in.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'31'", "'62'"]
'24'
'25'
'31'
'62'
['24', '25', '31', '62']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="51" ssid="15">For the LM, adaptive weights are set as follows: where &#945; is a weight vector containing an element &#945;i for each domain (just IN and OUT in our case), pi are the corresponding domain-specific models, and &#732;p(w, h) is an empirical distribution from a targetlanguage training corpus&#8212;we used the IN dev set for this.</S><S sid="71" ssid="8">Finally, we incorporate the instance-weighting model into a general linear combination, and learn weights and mixing parameters simultaneously. where c&#955;(s, t) is a modified count for pair (s, t) in OUT, u(s|t) is a prior distribution, and y is a prior weight.</S><S sid="72" ssid="9">The original OUT counts co(s, t) are weighted by a logistic function w&#955;(s, t): To motivate weighting joint OUT counts as in (6), we begin with the &#8220;ideal&#8221; objective for setting multinomial phrase probabilities 0 = {p(s|t), dst}, which is the likelihood with respect to the true IN distribution pi(s, t).</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'51'", "'71'", "'72'"]
'50'
'51'
'71'
'72'
['50', '51', '71', '72']
parsed_discourse_facet ['method_citation']
<S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S><S sid="67" ssid="4">We extend the Matsoukas et al approach in several ways.</S><S sid="151" ssid="8">In future work we plan to try this approach with more competitive SMT systems, and to extend instance weighting to other standard SMT components such as the LM, lexical phrase weights, and lexicalized distortion.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'65'", "'67'", "'151'", "'152'"]
'65'
'67'
'151'
'152'
['65', '67', '151', '152']
parsed_discourse_facet ['method_citation']
<S sid="49" ssid="13">This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="145" ssid="2">Each out-of-domain phrase pair is characterized by a set of simple features intended to reflect how useful it will be.</S><S sid="147" ssid="4">These estimates are in turn combined linearly with relative-frequency estimates from an in-domain phrase table.</S>
original cit marker offset is 0
new cit marker offset is 0



["'49'", "'50'", "'145'", "'147'"]
'49'
'50'
'145'
'147'
['49', '50', '145', '147']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="2">Even when there is training data available in the domain of interest, there is often additional data from other domains that could in principle be used to improve performance.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="54" ssid="18">However, we note that the final conditional estimates p(s|t) from a given phrase table maximize the likelihood of joint empirical phrase pair counts over a word-aligned corpus.</S><S sid="133" ssid="2">It is difficult to directly compare the Matsoukas et al results with ours, since our out-of-domain corpus is homogeneous; given heterogeneous training data, however, it would be trivial to include Matsoukas-style identity features in our instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'50'", "'54'", "'133'"]
'5'
'50'
'54'
'133'
['5', '50', '54', '133']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="44" ssid="8">When OUT is large and distinct, its contribution can be controlled by training separate IN and OUT models, and weighting their combination.</S><S sid="49" ssid="13">This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'44'", "'49'", "'50'"]
'30'
'44'
'49'
'50'
['30', '44', '49', '50']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'", "'30'", "'50'", "'141'"]
'28'
'30'
'50'
'141'
['28', '30', '50', '141']
parsed_discourse_facet ['aim_citation']
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="33" ssid="30">The paper is structured as follows.</S><S sid="105" ssid="9">Compared to the EMEA/EP setting, the two domains in the NIST setting are less homogeneous and more similar to each other; there is also considerably more IN text available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'30'", "'33'", "'105'"]
'0'
'30'
'33'
'105'
['0', '30', '33', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="52" ssid="16">It is not immediately obvious how to formulate an equivalent to equation (1) for an adapted TM, because there is no well-defined objective for learning TMs from parallel corpora.</S><S sid="53" ssid="17">This has led previous workers to adopt ad hoc linear weighting schemes (Finch and Sumita, 2008; Foster and Kuhn, 2007; L&#168;u et al., 2007).</S><S sid="74" ssid="11">(7) &#966; s,t This is a somewhat less direct objective than used by Matsoukas et al, who make an iterative approximation to expected TER.</S><S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'", "'53'", "'74'", "'75'"]
'52'
'53'
'74'
'75'
['52', '53', '74', '75']
parsed_discourse_facet ['method_citation']
<S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="60" ssid="24">The matching sentence pairs are then added to the IN corpus, and the system is re-trained.</S><S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'31'", "'60'", "'65'"]
'30'
'31'
'60'
'65'
['30', '31', '60', '65']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="16">The idea of distinguishing between general and domain-specific examples is due to Daum&#180;e and Marcu (2006), who used a maximum-entropy model with latent variables to capture the degree of specificity.</S><S sid="21" ssid="18">This highly effective approach is not directly applicable to the multinomial models used for core SMT components, which have no natural method for combining split features, so we rely on an instance-weighting approach (Jiang and Zhai, 2007) to downweight domain-specific examples in OUT.</S><S sid="22" ssid="19">Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.</S><S sid="89" ssid="26">We used 22 features for the logistic weighting model, divided into two groups: one intended to reflect the degree to which a phrase pair belongs to general language, and one intended to capture similarity to the IN domain.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'21'", "'22'", "'89'"]
'19'
'21'
'22'
'89'
['19', '21', '22', '89']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'30'", "'144'", "'152'"]
'23'
'30'
'144'
'152'
['23', '30', '144', '152']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="8" ssid="5">), which precludes a single universal approach to adaptation.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S><S sid="142" ssid="11">There has also been some work on adapting the word alignment model prior to phrase extraction (Civera and Juan, 2007; Wu et al., 2005), and on dynamically choosing a dev set (Xu et al., 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'31'", "'62'", "'142'"]
'8'
'31'
'62'
'142'
['8', '31', '62', '142']
parsed_discourse_facet ['hypothesis_citation']
<S sid="51" ssid="15">For the LM, adaptive weights are set as follows: where &#945; is a weight vector containing an element &#945;i for each domain (just IN and OUT in our case), pi are the corresponding domain-specific models, and &#732;p(w, h) is an empirical distribution from a targetlanguage training corpus&#8212;we used the IN dev set for this.</S><S sid="119" ssid="23">The 2nd block contains the IR system, which was tuned by selecting text in multiples of the size of the EMEA training corpus, according to dev set performance.</S><S sid="134" ssid="3">Although these authors report better gains than ours, they are with respect to a non-adapted baseline.</S><S sid="148" ssid="5">Mixing, smoothing, and instance-feature weights are learned at the same time using an efficient maximum-likelihood procedure that relies on only a small in-domain development corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'119'", "'134'", "'148'"]
'51'
'119'
'134'
'148'
['51', '119', '134', '148']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S><S sid="55" ssid="19">This suggests a direct parallel to (1): where &#732;p(s, t) is a joint empirical distribution extracted from the IN dev set using the standard procedure.2 An alternative form of linear combination is a maximum a posteriori (MAP) combination (Bacchiani et al., 2004).</S><S sid="68" ssid="5">First, we learn weights on individual phrase pairs rather than sentences.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'55'", "'68'", "'152'"]
'23'
'55'
'68'
'152'
['23', '55', '68', '152']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="40" ssid="4">We focus here instead on adapting the two most important features: the language model (LM), which estimates the probability p(wIh) of a target word w following an ngram h; and the translation models (TM) p(slt) and p(t1s), which give the probability of source phrase s translating to target phrase t, and vice versa.</S><S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S><S sid="137" ssid="6">At first glance, this seems only peripherally related to our work, since the specific/general distinction is made for features rather than instances.</S><S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'", "'95'", "'137'", "'144'"]
'40'
'95'
'137'
'144'
['40', '95', '137', '144']
parsed_discourse_facet ['method_citation']



D10-1044
P12-1048
0
method_citation
['method_citation']



D10-1044
P14-2093
0
method_citation
['hypothesis_citation', 'method_citation']



D10-1044
P13-1126
0
method_citation
['method_citation', 'hypothesis_citation']
parsing: input/ref/Task1/E03-1005_aakansha.csv
<S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'105'"]
'105'
['105']
parsed_discourse_facet ['method_citation']
<S sid="145" ssid="10">This paper showed that a PCFG-reduction of DOP in combination with a new notion of the best parse tree results in fast processing times and very competitive accuracy on the Wall Street Journal treebank.</S>
original cit marker offset is 0
new cit marker offset is 0



["'145'"]
'145'
['145']
parsed_discourse_facet ['method_citation']
<S sid="80" ssid="32">DOP1 has a serious bias: its subtree estimator provides more probability to nodes with more subtrees (Bonnema et al. 1999).</S>
original cit marker offset is 0
new cit marker offset is 0



["'80'"]
'80'
['80']
parsed_discourse_facet ['method_citation']
<S sid="143" ssid="8">While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.</S>
original cit marker offset is 0
new cit marker offset is 0



["'143'"]
'143'
['143']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S><S sid="141" ssid="6">This is roughly an 11% relative reduction in error rate over Charniak (2000) and Bods PCFG-reduction reported in Table 1.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'", "'141'"]
'140'
'141'
['140', '141']
parsed_discourse_facet ['result_citation']
<S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['result_citation']
<S sid="102" ssid="5">In case the shortest derivation is not unique, Bod (2000b) proposes to back off to a frequency ordering of the subtrees.</S>
    <S sid="103" ssid="6">That is, all subtrees of each root label are assigned a rank according to their frequency in the treebank: the most frequent subtree (or subtrees) of each root label gets rank 1, the second most frequent subtree gets rank 2, etc.</S>
original cit marker offset is 0
new cit marker offset is 0



["'102'", "'103'"]
'102'
'103'
['102', '103']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['result_citation']
<S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['result_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'"]
'46'
['46']
parsed_discourse_facet ['method_citation']
<S sid="85" ssid="37">For example, Bod (2001) samples a fixed number of subtrees of each depth, which has the effect of assigning roughly equal weight to each node in the training data, and roughly exponentially less probability for larger trees (see Goodman 2002: 12).</S>
    <S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S>
original cit marker offset is 0
new cit marker offset is 0



["'85'", "'86'"]
'85'
'86'
['85', '86']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['result_citation']
<S sid="115" ssid="18">The only thing that needs to be changed for Simplicity-DOP is that all subtrees should be assigned equal probabilities.</S>
original cit marker offset is 0
new cit marker offset is 0



["'115'"]
'115'
['115']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/E03-1005.annv3.csv
<S sid="52" ssid="4">The probability of a parse tree T is the sum of the probabilities of its distinct derivations.</S><S sid="75" ssid="27">This means that summing up over derivations of a tree in DOP yields the same probability as summing over all the isomorphic derivations in the PCFG.</S><S sid="77" ssid="29">But Goodman shows that with his PCFG-reduction he can efficiently compute the aforementioned maximum constituents parse.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'", "'75'", "'77'", "'105'"]
'52'
'75'
'77'
'105'
['52', '75', '77', '105']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Together with a PCFGreduction of DOP we obtain improved accuracy and efficiency on the Wall Street Journal treebank Our results show an 11% relative reduction in error rate over previous models, and an average processing time of 3.6 seconds per WSJ sentence.</S><S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'38'", "'39'", "'105'"]
'3'
'38'
'39'
'105'
['3', '38', '39', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="40" ssid="37">Goodman (2002) furthermore showed how Bonnema et al. \s (1999) and Bod\s (2001) estimators can be incorporated in his PCFGreduction, but did not report any experiments with these reductions.</S><S sid="79" ssid="31">While Bod (2001) needed to use a very large sample from the WSJ subtrees to do this, Goodman\s method can do the same job with a more compact grammar.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'", "'79'", "'134'", "'135'"]
'40'
'79'
'134'
'135'
['40', '79', '134', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="143" ssid="8">While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.</S><S sid="144" ssid="9">While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'87'", "'143'", "'144'"]
'38'
'87'
'143'
'144'
['38', '87', '143', '144']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S><S sid="106" ssid="9">What is more important, is, that the best parse trees predicted by Simplicity-DOP are quite different from the best parse trees predicted by Likelihood-DOP.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'", "'99'", "'100'", "'106'"]
'46'
'99'
'100'
'106'
['46', '99', '100', '106']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'99'", "'134'", "'135'"]
'38'
'99'
'134'
'135'
['38', '99', '134', '135']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="34">Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="85" ssid="37">For example, Bod (2001) samples a fixed number of subtrees of each depth, which has the effect of assigning roughly equal weight to each node in the training data, and roughly exponentially less probability for larger trees (see Goodman 2002: 12).</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'85'", "'86'"]
'37'
'39'
'85'
'86'
['37', '39', '85', '86']
parsed_discourse_facet ['method_citation']
<S sid="44" ssid="41">But while Bod\s estimator obtains state-of-the-art results on the WSJ, comparable to Charniak (2000) and Collins (2000), Bonnema et al. \s estimator performs worse and is comparable to Collins (1996).</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S><S sid="144" ssid="9">While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'134'", "'135'", "'144'"]
'44'
'134'
'135'
'144'
['44', '134', '135', '144']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="21">However, the problem of computing the most probable parse turns out to be NP-hard (Sima\an 1996), mainly because the same parse tree can be generated by exponentially many derivations.</S><S sid="25" ssid="22">Many implementations of DOP1 therefore estimate the most probable parse by Monte Carlo techniques (Bod 1998; Chappelier &amp; Rajman 2000), or by Viterbi n-best search (Bod 2001), or by restricting the set of subtrees (Sima\an 1999; Chappelier et al. 2002).</S><S sid="97" ssid="49">In this paper, we will estimate the most probable parse by computing the 10,000 most probable derivations by means of Viterbi n-best, from which the most likely parse is estimated by summing up the probabilities of the derivations that generate the same parse.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'97'", "'135'"]
'24'
'25'
'97'
'135'
['24', '25', '97', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'105'", "'134'"]
'38'
'39'
'105'
'134'
['38', '39', '105', '134']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S><S sid="98" ssid="1">Most DOP models, such as in Bod (1993), Goodman (1996), Bonnema et al. (1997), Sima\an (2000) and Collins &amp; Duffy (2002), use a likelihood criterion in defining the best parse tree: they take (some notion of) the most likely (i.e. most probable) tree as a candidate for the best tree of a sentence.</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'", "'98'", "'99'", "'100'"]
'46'
'98'
'99'
'100'
['46', '98', '99', '100']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="2" ssid="2">This paper proposes an integration of the two models which outperforms each of them separately.</S><S sid="82" ssid="34">Bonnema et al. (1999) show that as a consequence too much weight is given to larger subtrees, and that the parse accuracy of DOP1 deteriorates if (very) large subtrees are included.</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'82'", "'87'", "'99'"]
'2'
'82'
'87'
'99'
['2', '82', '87', '99']
parsed_discourse_facet ['hypothesis_citation']
<S sid="12" ssid="9">This approach has now gained wide usage, as exemplified by the work of Collins (1996, 1999), Charniak (1996, 1997), Johnson (1998), Chiang (2000), and many others.</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="88" ssid="40">In this paper, we will test a simple extension of Goodman\s compact PCFG-reduction of DOP which has the same property as the normalization proposed in Bod (2001) in that it assigns roughly equal weight to each node in the training data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'86'", "'87'", "'88'"]
'12'
'86'
'87'
'88'
['12', '86', '87', '88']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'86'", "'134'", "'135'"]
'38'
'86'
'134'
'135'
['38', '86', '134', '135']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="36" ssid="33">As an alternative, Bonnema et al. (1999) propose a subtree estimator which reduces the probability of a tree by a factor of two for each non-root non-terminal it contains.</S><S sid="37" ssid="34">Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="90" ssid="42">Then we slightly modify the PCFG-reduction in figure 2 as follows: We will also test the proposal by Bonnema et al. (1999) which reduces the probability of a subtree by a factor of two for each non-root nonterminal it contains.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'", "'37'", "'86'", "'90'"]
'36'
'37'
'86'
'90'
['36', '37', '86', '90']
parsed_discourse_facet ['method_citation']



E03-1005
N06-1045
0
method_citation
['method_citation']



E03-1005
P11-1086
0
method_citation
['method_citation']



E03-1005
P07-1051
0
method_citation
['results_citation', 'method_citation']
parsing: input/ref/Task1/E03-1005_swastika.csv
<S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



['105']
105
['105']
parsed_discourse_facet ['result_citation']
    <S sid="41" ssid="38">This paper presents the first published results with Goodman's PCFG-reductions of both Bonnema et al. 's (1999) and Bod's (2001) estimators on the WSJ.</S>
original cit marker offset is 0
new cit marker offset is 0



['41']
41
['41']
parsed_discourse_facet ['aim_citation']
<S sid="80" ssid="32">DOP1 has a serious bias: its subtree estimator provides more probability to nodes with more subtrees (Bonnema et al. 1999).</S>
original cit marker offset is 0
new cit marker offset is 0



['80']
80
['80']
parsed_discourse_facet ['result_citation']
<S sid="143" ssid="8">While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.</S>
original cit marker offset is 0
new cit marker offset is 0



['143']
143
['143']
parsed_discourse_facet ['method_citation']
<S sid="146" ssid="11">This paper also re-affirmed that the coarsegrained approach of using all subtrees from a treebank outperforms the fine-grained approach of specifically modeling lexical-syntactic depen dencies (as e.g. in Collins 1999 and Charniak 2000).</S>
original cit marker offset is 0
new cit marker offset is 0



['146']
146
['146']
parsed_discourse_facet ['method_citation']
    <S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



['140']
140
['140']
parsed_discourse_facet ['result_citation']
<S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



['105']
105
['105']
parsed_discourse_facet ['result_citation']
    <S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



['140']
140
['140']
parsed_discourse_facet ['result_citation']
<S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S>
original cit marker offset is 0
new cit marker offset is 0



['100']
100
['100']
parsed_discourse_facet ['result_citation']
    <S sid="30" ssid="27">Bod (2000a) solved this problem by training the subtree probabilities by a maximum likelihood procedure based on Expectation-Maximization.</S>
original cit marker offset is 0
new cit marker offset is 0



['30']
30
['30']
parsed_discourse_facet ['method_citation']
    <S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



['140']
140
['140']
parsed_discourse_facet ['result_citation']
    <S sid="30" ssid="27">Bod (2000a) solved this problem by training the subtree probabilities by a maximum likelihood procedure based on Expectation-Maximization.</S>
original cit marker offset is 0
new cit marker offset is 0



['30']
30
['30']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/E03-1005.annv3.csv
<S sid="52" ssid="4">The probability of a parse tree T is the sum of the probabilities of its distinct derivations.</S><S sid="75" ssid="27">This means that summing up over derivations of a tree in DOP yields the same probability as summing over all the isomorphic derivations in the PCFG.</S><S sid="77" ssid="29">But Goodman shows that with his PCFG-reduction he can efficiently compute the aforementioned maximum constituents parse.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'", "'75'", "'77'", "'105'"]
'52'
'75'
'77'
'105'
['52', '75', '77', '105']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Together with a PCFGreduction of DOP we obtain improved accuracy and efficiency on the Wall Street Journal treebank Our results show an 11% relative reduction in error rate over previous models, and an average processing time of 3.6 seconds per WSJ sentence.</S><S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'38'", "'39'", "'105'"]
'3'
'38'
'39'
'105'
['3', '38', '39', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="40" ssid="37">Goodman (2002) furthermore showed how Bonnema et al. \s (1999) and Bod\s (2001) estimators can be incorporated in his PCFGreduction, but did not report any experiments with these reductions.</S><S sid="79" ssid="31">While Bod (2001) needed to use a very large sample from the WSJ subtrees to do this, Goodman\s method can do the same job with a more compact grammar.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'", "'79'", "'134'", "'135'"]
'40'
'79'
'134'
'135'
['40', '79', '134', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="143" ssid="8">While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.</S><S sid="144" ssid="9">While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'87'", "'143'", "'144'"]
'38'
'87'
'143'
'144'
['38', '87', '143', '144']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S><S sid="106" ssid="9">What is more important, is, that the best parse trees predicted by Simplicity-DOP are quite different from the best parse trees predicted by Likelihood-DOP.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'", "'99'", "'100'", "'106'"]
'46'
'99'
'100'
'106'
['46', '99', '100', '106']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'99'", "'134'", "'135'"]
'38'
'99'
'134'
'135'
['38', '99', '134', '135']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="34">Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="85" ssid="37">For example, Bod (2001) samples a fixed number of subtrees of each depth, which has the effect of assigning roughly equal weight to each node in the training data, and roughly exponentially less probability for larger trees (see Goodman 2002: 12).</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'85'", "'86'"]
'37'
'39'
'85'
'86'
['37', '39', '85', '86']
parsed_discourse_facet ['method_citation']
<S sid="44" ssid="41">But while Bod\s estimator obtains state-of-the-art results on the WSJ, comparable to Charniak (2000) and Collins (2000), Bonnema et al. \s estimator performs worse and is comparable to Collins (1996).</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S><S sid="144" ssid="9">While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'134'", "'135'", "'144'"]
'44'
'134'
'135'
'144'
['44', '134', '135', '144']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="21">However, the problem of computing the most probable parse turns out to be NP-hard (Sima\an 1996), mainly because the same parse tree can be generated by exponentially many derivations.</S><S sid="25" ssid="22">Many implementations of DOP1 therefore estimate the most probable parse by Monte Carlo techniques (Bod 1998; Chappelier &amp; Rajman 2000), or by Viterbi n-best search (Bod 2001), or by restricting the set of subtrees (Sima\an 1999; Chappelier et al. 2002).</S><S sid="97" ssid="49">In this paper, we will estimate the most probable parse by computing the 10,000 most probable derivations by means of Viterbi n-best, from which the most likely parse is estimated by summing up the probabilities of the derivations that generate the same parse.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'97'", "'135'"]
'24'
'25'
'97'
'135'
['24', '25', '97', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'105'", "'134'"]
'38'
'39'
'105'
'134'
['38', '39', '105', '134']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S><S sid="98" ssid="1">Most DOP models, such as in Bod (1993), Goodman (1996), Bonnema et al. (1997), Sima\an (2000) and Collins &amp; Duffy (2002), use a likelihood criterion in defining the best parse tree: they take (some notion of) the most likely (i.e. most probable) tree as a candidate for the best tree of a sentence.</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'", "'98'", "'99'", "'100'"]
'46'
'98'
'99'
'100'
['46', '98', '99', '100']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="2" ssid="2">This paper proposes an integration of the two models which outperforms each of them separately.</S><S sid="82" ssid="34">Bonnema et al. (1999) show that as a consequence too much weight is given to larger subtrees, and that the parse accuracy of DOP1 deteriorates if (very) large subtrees are included.</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'82'", "'87'", "'99'"]
'2'
'82'
'87'
'99'
['2', '82', '87', '99']
parsed_discourse_facet ['hypothesis_citation']
<S sid="12" ssid="9">This approach has now gained wide usage, as exemplified by the work of Collins (1996, 1999), Charniak (1996, 1997), Johnson (1998), Chiang (2000), and many others.</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="88" ssid="40">In this paper, we will test a simple extension of Goodman\s compact PCFG-reduction of DOP which has the same property as the normalization proposed in Bod (2001) in that it assigns roughly equal weight to each node in the training data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'86'", "'87'", "'88'"]
'12'
'86'
'87'
'88'
['12', '86', '87', '88']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'86'", "'134'", "'135'"]
'38'
'86'
'134'
'135'
['38', '86', '134', '135']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="36" ssid="33">As an alternative, Bonnema et al. (1999) propose a subtree estimator which reduces the probability of a tree by a factor of two for each non-root non-terminal it contains.</S><S sid="37" ssid="34">Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="90" ssid="42">Then we slightly modify the PCFG-reduction in figure 2 as follows: We will also test the proposal by Bonnema et al. (1999) which reduces the probability of a subtree by a factor of two for each non-root nonterminal it contains.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'", "'37'", "'86'", "'90'"]
'36'
'37'
'86'
'90'
['36', '37', '86', '90']
parsed_discourse_facet ['method_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



E03-1005
N06-1045
0
result_citation
['method_citation']



E03-1005
P11-1086
0
method_citation
['method_citation']
IGNORE THIS: Key error 5
parsing: input/ref/Task1/E03-1005_sweta.csv
<S sid="20" ssid="17">Thus the major innovations of DOP are: 2. the use of arbitrarily large fragments rather than restricted ones Both have gained or are gaining wide usage, and are also becoming relevant for theoretical linguistics (see Bod et al. 2003a).</S>
original cit marker offset is 0
new cit marker offset is 0



["20'"]
20'
['20']
parsed_discourse_facet ['method_citation']
 <S sid="74" ssid="26">Goodman's main theorem is that this construction produces PCFG derivations isomorphic to DOP derivations with equal probability.</S>
original cit marker offset is 0
new cit marker offset is 0



["74'"]
74'
['74']
parsed_discourse_facet ['method_citation']
<S sid="44" ssid="41">But while Bod's estimator obtains state-of-the-art results on the WSJ, comparable to Charniak (2000) and Collins (2000), Bonnema et al. 's estimator performs worse and is comparable to Collins (1996).</S>
original cit marker offset is 0
new cit marker offset is 0



["44'"]
44'
['44']
parsed_discourse_facet ['method_citation']
<S sid="143" ssid="8">While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.</S>
original cit marker offset is 0
new cit marker offset is 0



["143'"]
143'
['143']
parsed_discourse_facet ['method_citation']
<S sid="145" ssid="10">This paper showed that a PCFG-reduction of DOP in combination with a new notion of the best parse tree results in fast processing times and very competitive accuracy on the Wall Street Journal treebank.</S>
original cit marker offset is 0
new cit marker offset is 0



["145'"]
145'
['145']
parsed_discourse_facet ['method_citation']
<S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S>
original cit marker offset is 0
new cit marker offset is 0



["134'"]
134'
['134']
parsed_discourse_facet ['method_citation']
<S sid="22" ssid="19">DOP1 combines subtrees from a treebank by means of node-substitution and computes the probability of a tree from the normalized frequencies of the subtrees (see Section 2 for a full definition).</S>
original cit marker offset is 0
new cit marker offset is 0



["22'"]
22'
['22']
parsed_discourse_facet ['method_citation']
<S sid="133" ssid="14">It should be mentioned that the best precision and recall scores reported in Bod (2001) are slightly better than the ones reported here (the difference is only 0.2% for sentences 100 words).</S>
original cit marker offset is 0
new cit marker offset is 0



["133'"]
133'
['133']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="22">Many implementations of DOP1 therefore estimate the most probable parse by Monte Carlo techniques (Bod 1998; Chappelier &amp; Rajman 2000), or by Viterbi n-best search (Bod 2001), or by restricting the set of subtrees (Sima'an 1999; Chappelier et al. 2002).</S>
original cit marker offset is 0
new cit marker offset is 0



["25'"]
25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="35">Although Bod's method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S>
original cit marker offset is 0
new cit marker offset is 0



["38'"]
38'
['38']
parsed_discourse_facet ['method_citation']
 <S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S>
original cit marker offset is 0
new cit marker offset is 0



["100'"]
100'
['100']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="29">However, ML-DOP suffers from overlearning if the subtrees are trained on the same treebank trees as they are derived from.</S>
original cit marker offset is 0
new cit marker offset is 0



["32'"]
32'
['32']
parsed_discourse_facet ['method_citation']
 <S sid="130" ssid="11">While the PCFG reduction of Bod (2001) obtains state-of-the-art results on the WSJ, comparable to Charniak (2000), Bonnema et al. 's estimator performs worse and is comparable to Collins (1996).</S>
original cit marker offset is 0
new cit marker offset is 0



["130'"]
130'
['130']
parsed_discourse_facet ['method_citation']
 <S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



["140'"]
140'
['140']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="24">Goodman (1996, 1998) developed a polynomial time PCFG-reduction of DOP1 whose size is linear in the size of the training set, thus converting the exponential number of subtrees to a compact grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["27'"]
27'
['27']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/E03-1005.annv3.csv
<S sid="52" ssid="4">The probability of a parse tree T is the sum of the probabilities of its distinct derivations.</S><S sid="75" ssid="27">This means that summing up over derivations of a tree in DOP yields the same probability as summing over all the isomorphic derivations in the PCFG.</S><S sid="77" ssid="29">But Goodman shows that with his PCFG-reduction he can efficiently compute the aforementioned maximum constituents parse.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'", "'75'", "'77'", "'105'"]
'52'
'75'
'77'
'105'
['52', '75', '77', '105']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Together with a PCFGreduction of DOP we obtain improved accuracy and efficiency on the Wall Street Journal treebank Our results show an 11% relative reduction in error rate over previous models, and an average processing time of 3.6 seconds per WSJ sentence.</S><S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'38'", "'39'", "'105'"]
'3'
'38'
'39'
'105'
['3', '38', '39', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="40" ssid="37">Goodman (2002) furthermore showed how Bonnema et al. \s (1999) and Bod\s (2001) estimators can be incorporated in his PCFGreduction, but did not report any experiments with these reductions.</S><S sid="79" ssid="31">While Bod (2001) needed to use a very large sample from the WSJ subtrees to do this, Goodman\s method can do the same job with a more compact grammar.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'", "'79'", "'134'", "'135'"]
'40'
'79'
'134'
'135'
['40', '79', '134', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="143" ssid="8">While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.</S><S sid="144" ssid="9">While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'87'", "'143'", "'144'"]
'38'
'87'
'143'
'144'
['38', '87', '143', '144']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S><S sid="106" ssid="9">What is more important, is, that the best parse trees predicted by Simplicity-DOP are quite different from the best parse trees predicted by Likelihood-DOP.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'", "'99'", "'100'", "'106'"]
'46'
'99'
'100'
'106'
['46', '99', '100', '106']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'99'", "'134'", "'135'"]
'38'
'99'
'134'
'135'
['38', '99', '134', '135']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="34">Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="85" ssid="37">For example, Bod (2001) samples a fixed number of subtrees of each depth, which has the effect of assigning roughly equal weight to each node in the training data, and roughly exponentially less probability for larger trees (see Goodman 2002: 12).</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'85'", "'86'"]
'37'
'39'
'85'
'86'
['37', '39', '85', '86']
parsed_discourse_facet ['method_citation']
<S sid="44" ssid="41">But while Bod\s estimator obtains state-of-the-art results on the WSJ, comparable to Charniak (2000) and Collins (2000), Bonnema et al. \s estimator performs worse and is comparable to Collins (1996).</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S><S sid="144" ssid="9">While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'134'", "'135'", "'144'"]
'44'
'134'
'135'
'144'
['44', '134', '135', '144']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="21">However, the problem of computing the most probable parse turns out to be NP-hard (Sima\an 1996), mainly because the same parse tree can be generated by exponentially many derivations.</S><S sid="25" ssid="22">Many implementations of DOP1 therefore estimate the most probable parse by Monte Carlo techniques (Bod 1998; Chappelier &amp; Rajman 2000), or by Viterbi n-best search (Bod 2001), or by restricting the set of subtrees (Sima\an 1999; Chappelier et al. 2002).</S><S sid="97" ssid="49">In this paper, we will estimate the most probable parse by computing the 10,000 most probable derivations by means of Viterbi n-best, from which the most likely parse is estimated by summing up the probabilities of the derivations that generate the same parse.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'97'", "'135'"]
'24'
'25'
'97'
'135'
['24', '25', '97', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'105'", "'134'"]
'38'
'39'
'105'
'134'
['38', '39', '105', '134']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S><S sid="98" ssid="1">Most DOP models, such as in Bod (1993), Goodman (1996), Bonnema et al. (1997), Sima\an (2000) and Collins &amp; Duffy (2002), use a likelihood criterion in defining the best parse tree: they take (some notion of) the most likely (i.e. most probable) tree as a candidate for the best tree of a sentence.</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'", "'98'", "'99'", "'100'"]
'46'
'98'
'99'
'100'
['46', '98', '99', '100']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="2" ssid="2">This paper proposes an integration of the two models which outperforms each of them separately.</S><S sid="82" ssid="34">Bonnema et al. (1999) show that as a consequence too much weight is given to larger subtrees, and that the parse accuracy of DOP1 deteriorates if (very) large subtrees are included.</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'82'", "'87'", "'99'"]
'2'
'82'
'87'
'99'
['2', '82', '87', '99']
parsed_discourse_facet ['hypothesis_citation']
<S sid="12" ssid="9">This approach has now gained wide usage, as exemplified by the work of Collins (1996, 1999), Charniak (1996, 1997), Johnson (1998), Chiang (2000), and many others.</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="88" ssid="40">In this paper, we will test a simple extension of Goodman\s compact PCFG-reduction of DOP which has the same property as the normalization proposed in Bod (2001) in that it assigns roughly equal weight to each node in the training data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'86'", "'87'", "'88'"]
'12'
'86'
'87'
'88'
['12', '86', '87', '88']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'86'", "'134'", "'135'"]
'38'
'86'
'134'
'135'
['38', '86', '134', '135']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="36" ssid="33">As an alternative, Bonnema et al. (1999) propose a subtree estimator which reduces the probability of a tree by a factor of two for each non-root non-terminal it contains.</S><S sid="37" ssid="34">Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="90" ssid="42">Then we slightly modify the PCFG-reduction in figure 2 as follows: We will also test the proposal by Bonnema et al. (1999) which reduces the probability of a subtree by a factor of two for each non-root nonterminal it contains.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'", "'37'", "'86'", "'90'"]
'36'
'37'
'86'
'90'
['36', '37', '86', '90']
parsed_discourse_facet ['method_citation']



E03-1005
P11-1086
0
method_citation
['method_citation']



E03-1005
P04-1013
0
method_citation
['method_citation']



E03-1005
W06-2905
0
method_citation
['hypothesis_citation', 'method_citation']



E03-1005
P05-1022
0
method_citation
['method_citation']
parsing: input/ref/Task1/J01-2004_aakansha.csv
<S sid="372" ssid="128">The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.</S>
original cit marker offset is 0
new cit marker offset is 0



["'372'"]
'372'
['372']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="5">This paper will examine language modeling for speech recognition from a natural language processing point of view.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'"]
'17'
['17']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="302" ssid="58">In the beam search approach outlined above, we can estimate the string's probability in the same manner, by summing the probabilities of the parses that the algorithm finds.</S>
original cit marker offset is 0
new cit marker offset is 0



["'302'"]
'302'
['302']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



["'31'"]
'31'
['31']
parsed_discourse_facet ['method_citation']
<S sid="79" ssid="37">This underspecification of the nonterminal predictions (e.g., VP-VBD in the example in Figure 2, as opposed to NP), allows lexical items to become part of the left context, and so be used to condition production probabilities, even the production probabilities of constituents that dominate them in the unfactored tree.</S>
    <S sid="80" ssid="38">It also brings words further downstream into the look-ahead at the point of specification.</S>
original cit marker offset is 0
new cit marker offset is 0



["'79'", "'80'"]
'79'
'80'
['79', '80']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="138" ssid="42">Our approach is found to yield very accurate parses efficiently, and, in addition, to lend itself straightforwardly to estimating word probabilities on-line, that is, in a single pass from left to right.</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'"]
'138'
['138']
parsed_discourse_facet ['method_citation']
<S sid="291" ssid="47">Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'291'"]
'291'
['291']
parsed_discourse_facet ['method_citation']
<S sid="372" ssid="128">The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.</S>
original cit marker offset is 0
new cit marker offset is 0



['372']
372
['372']
parsed_discourse_facet ['method_citation']
<S sid="209" ssid="113">This parser is essentially a stochastic version of the top-down parser described in Aho, Sethi, and Ullman (1986).</S>
    <S sid="210" ssid="114">It uses a PCFG with a conditional probability model of the sort defined in the previous section.</S>
original cit marker offset is 0
new cit marker offset is 0



["'209'", "'210'"]
'209'
'210'
['209', '210']
parsed_discourse_facet ['method_citation']
<S sid="372" ssid="128">The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.</S>
original cit marker offset is 0
new cit marker offset is 0



["'372'"]
'372'
['372']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S>
    <S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S><S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'32'"]
'20'
'21'
'32'
['20', '21', '32']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'31'"]
'31'
['31']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="21">Because the rooted partial derivation is fully connected, all of the conditioning information that might be extracted from the top-down left context has already been specified, and a conditional probability model built on this information will not impose any additional burden on the search.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'"]
'33'
['33']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/J01-2004.annv3.csv
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S><S sid="16" ssid="4">While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.</S><S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S><S sid="93" ssid="51">The standard language model used in many speech recognition systems is the trigram model, i.e., a Markov model of order 2, which can be characterized by the following equation: To smooth the trigram models that are used in this paper, we interpolate the probability estimates of higher-order Markov models with lower-order Markov models (Jelinek and Mercer 1980).</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'16'", "'31'", "'93'"]
'15'
'16'
'31'
'93'
['15', '16', '31', '93']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S><S sid="16" ssid="4">While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.</S><S sid="141" ssid="45">We will then present empirical results in two domains: one to compare with previous work in the parsing literature, and the other to compare with previous work using parsing for language modeling for speech recognition, in particular with the Chelba and Jelinek results mentioned above.</S><S sid="399" ssid="12">In addition, as mentioned above, we would like to further test our language model in speech recognition tasks, to see if the perplexity improvement that we have seen can lead to significant reductions in word error rate.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'16'", "'141'", "'399'"]
'15'
'16'
'141'
'399'
['15', '16', '141', '399']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S><S sid="143" ssid="47">It has been shown repeatedly&#8212;e.g., Briscoe and Carroll (1993), Charniak (1997), Collins (1997), Inui et al. (1997), Johnson (1998)&#8212;that conditioning the probabilities of structures on the context within which they appear, for example on the lexical head of a constituent (Charniak 1997; Collins 1997), on the label of its parent nonterminal (Johnson 1998), or, ideally, on both and many other things besides, leads to a much better parsing model and results in higher parsing accuracies.</S><S sid="277" ssid="33">The first set of results looks at the performance of the parser on the standard corpora for statistical parsing trials: Sections 2-21 (989,860 words, 39,832 sentences) of the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) served as the training data, Section 24 (34,199 words, 1,346 sentences) as the held-out data for parameter estimation, and Section 23 (59,100 words, 2,416 sentences) as the test data.</S><S sid="367" ssid="123">Table 5 reports the word and sentence error rates for five different models: (i) the trigram model that comes with the lattices, trained on approximately 40M words, with a vocabulary of 20,000; (ii) the best-performing model from Chelba (2000), which was interpolated with the lattice trigram at A -= 0.4; (iii) our parsing model, with the same training and vocabulary as the perplexity trials above; (iv) a trigram model with the same training and vocabulary as the parsing model; and (v) no language model at all.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'143'", "'277'", "'367'"]
'20'
'143'
'277'
'367'
['20', '143', '277', '367']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S><S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S><S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S><S sid="277" ssid="33">The first set of results looks at the performance of the parser on the standard corpora for statistical parsing trials: Sections 2-21 (989,860 words, 39,832 sentences) of the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) served as the training data, Section 24 (34,199 words, 1,346 sentences) as the held-out data for parameter estimation, and Section 23 (59,100 words, 2,416 sentences) as the test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'31'", "'32'", "'277'"]
'20'
'31'
'32'
'277'
['20', '31', '32', '277']
parsed_discourse_facet ['method_citation']
<S sid="133" ssid="37">Statistically based heuristic best-first or beam-search strategies (Caraballo and Charniak 1998; Charniak, Goldwater, and Johnson 1998; Goodman 1997) have yielded an enormous improvement in the quality and speed of parsers, even without any guarantee that the parse returned is, in fact, that with the maximum likelihood for the probability model.</S><S sid="134" ssid="38">The parsers with the highest published broad-coverage parsing accuracy, which include Charniak (1997, 2000), Collins (1997, 1999), and Ratnaparkhi (1997), all utilize simple and straightforward statistically based search heuristics, pruning the search-space quite dramatically!\</S><S sid="135" ssid="39">Such methods are nearly always used in conjunction with some form of dynamic programming (henceforth DP).</S><S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'134'", "'135'", "'282'"]
'133'
'134'
'135'
'282'
['133', '134', '135', '282']
parsed_discourse_facet ['method_citation']
<S sid="135" ssid="39">Such methods are nearly always used in conjunction with some form of dynamic programming (henceforth DP).</S><S sid="269" ssid="25">In such a model, it is possible to commit to a set of partial analyses at a particular point that cannot be completed given the rest of the input string (i.e., the parser can &amp;quot;garden path&amp;quot;).</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S><S sid="403" ssid="16">Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.</S>
original cit marker offset is 0
new cit marker offset is 0



["'135'", "'269'", "'402'", "'403'"]
'135'
'269'
'402'
'403'
['135', '269', '402', '403']
parsed_discourse_facet ['method_citation']
<S sid="182" ssid="86">The functions that we have chosen for this paper follow from the intuition (and experience) that what helps parsing is different depending on the constituent that is being expanded.</S><S sid="184" ssid="88">If the POS is leftmost within its constituent, then very often the lexical item is sensitive to the governing category to which it is attaching.</S><S sid="185" ssid="89">For example, if the POS is a preposition, then its probability of expanding to a particular word is very different if it is attaching to a noun phrase than if it is attaching to a verb phrase, and perhaps quite different depending on the head of the constituent to which it is attaching.</S><S sid="231" ssid="135">Since we do not know the POS for the word, we must sum the LAP for all POS For a PCFG G, a stack S = Ao An$ (which we will write AN and a look-ahead terminal item wi, we define the look-ahead probability as follows: We recursively estimate this with two empirically observed conditional probabilities for every nonterminal A,: 13(A, w,a) and P(A, c).</S>
original cit marker offset is 0
new cit marker offset is 0



["'182'", "'184'", "'185'", "'231'"]
'182'
'184'
'185'
'231'
['182', '184', '185', '231']
parsed_discourse_facet ['method_citation']
<S sid="136" ssid="40">That is, search efficiency for these parsers is improved by both statistical search heuristics and DP.</S><S sid="267" ssid="23">In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.</S><S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S><S sid="298" ssid="54">What is perhaps surprising is that the difference is not greater.</S>
original cit marker offset is 0
new cit marker offset is 0



["'136'", "'267'", "'282'", "'298'"]
'136'
'267'
'282'
'298'
['136', '267', '282', '298']
parsed_discourse_facet ['method_citation']
<S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S><S sid="290" ssid="46">Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.</S><S sid="377" ssid="133">The point of this small experiment was to see if our parsing model could provide useful information even in the case that recognition errors occur, as opposed to the (generally) fully grammatical strings upon which the perplexity results were obtained.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'282'", "'290'", "'377'", "'402'"]
'282'
'290'
'377'
'402'
['282', '290', '377', '402']
parsed_discourse_facet ['results_citation']
<S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S><S sid="281" ssid="37">First, and least surprising, is that the accuracy of the parses improved as we conditioned on more and more information.</S><S sid="290" ssid="46">Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.</S><S sid="291" ssid="47">Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'281'", "'290'", "'291'"]
'32'
'281'
'290'
'291'
['32', '281', '290', '291']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="27">The top-down guidance that is provided makes this approach quite efficient in practice.</S><S sid="76" ssid="34">The leftfactorization transform that we use is identical to what is called right binarization in Roark and Johnson (1999).</S><S sid="96" ssid="54">This interpolation is recursively applied to the smaller-order n-grams until the bigram is finally interpolated with the unigram, i.e., Ao = 1.</S><S sid="378" ssid="134">As one reviewer pointed out, given that our model relies so heavily on context, it may have difficulty recovering from even one recognition error, perhaps more difficulty than a more locally oriented trigram.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'76'", "'96'", "'378'"]
'39'
'76'
'96'
'378'
['39', '76', '96', '378']
parsed_discourse_facet ['method_citation']
<S sid="101" ssid="5">As mentioned in Section 2.1, a PCFG defines a probability distribution over strings of words.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S><S sid="403" ssid="16">Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.</S>
original cit marker offset is 0
new cit marker offset is 0



["'101'", "'401'", "'402'", "'403'"]
'101'
'401'
'402'
'403'
['101', '401', '402', '403']
parsed_discourse_facet ['method_citation']
<S sid="235" ssid="139">The basic idea is that we want the beam to be very wide if there are few analyses that have been advanced, but relatively narrow if many analyses have been advanced.</S><S sid="239" ssid="143">After 1,000 candidates, the beam has narrowed to 10-2p.</S><S sid="267" ssid="23">In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.</S><S sid="349" ssid="105">One way to test this is the following: at each point in the sentence, calculate the conditional probability of each word in the vocabulary given the previous words, and sum them.\</S>
original cit marker offset is 0
new cit marker offset is 0



["'235'", "'239'", "'267'", "'349'"]
'235'
'239'
'267'
'349'
['235', '239', '267', '349']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="142" ssid="46">A simple PCFG conditions rule probabilities on the left-hand side of the rule.</S><S sid="363" ssid="119">Splitting of the contractions is critical for parsing, since the two parts oftentimes (as in the previous example) fall in different constituents.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'142'", "'363'", "'401'", "'402'"]
'142'
'363'
'401'
'402'
['142', '363', '401', '402']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">A lexicalized probabilistic topdown parser is then presented, which performs very well, in terms of both the accuracy of returned parses and the efficiency with which they are found, relative to the best broad-coverage statistical parsers.</S><S sid="9" ssid="3">A lexicalized probabilistic topdown parser is then presented, which performs very well, in terms of both the accuracy of returned parses and the efficiency with which they are found, relative to the best broad-coverage statistical parsers.</S><S sid="142" ssid="46">A simple PCFG conditions rule probabilities on the left-hand side of the rule.</S><S sid="143" ssid="47">It has been shown repeatedly&#8212;e.g., Briscoe and Carroll (1993), Charniak (1997), Collins (1997), Inui et al. (1997), Johnson (1998)&#8212;that conditioning the probabilities of structures on the context within which they appear, for example on the lexical head of a constituent (Charniak 1997; Collins 1997), on the label of its parent nonterminal (Johnson 1998), or, ideally, on both and many other things besides, leads to a much better parsing model and results in higher parsing accuracies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'9'", "'142'", "'143'"]
'3'
'9'
'142'
'143'
['3', '9', '142', '143']
parsed_discourse_facet ['aim_citation']
<S sid="99" ssid="3">These can be divided into two rough groups: those that use the grammar as a language model, and those that use a parser to uncover phrasal heads standing in an important relation (c-command) to the current word.</S><S sid="322" ssid="78">Thus, Chelba and Jelinek (1998a, 1998b) also used a parser to help assign word probabilities, via the structured language model outlined in Section 3.2.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'99'", "'322'", "'401'", "'402'"]
'99'
'322'
'401'
'402'
['99', '322', '401', '402']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S><S sid="268" ssid="24">This is an incremental parser with a pruning strategy and no backtracking.</S><S sid="309" ssid="65">Let Ht be the priority queue H, before any processing has begun with word w, in the look-ahead.</S><S sid="310" ssid="66">This is a subset of the possible leftmost partial derivations with respect to the prefix string W. Since RV is produced by expanding only analyses on priority queue H;\, the set of complete trees consistent with the partial derivations on priority queue Ht is a subset of the set of complete trees consistent with the partial derivations on priority queue HT\\, that is, the total probability mass represented by the priority queues is monotonically decreasing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'268'", "'309'", "'310'"]
'21'
'268'
'309'
'310'
['21', '268', '309', '310']
parsed_discourse_facet ['method_citation']



J01-2004
P05-1022
0
method_citation
['method_citation']
parsing: input/ref/Task1/J01-2004_swastika.csv
<S sid="372" ssid="128">The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.</S>
original cit marker offset is 0
new cit marker offset is 0



['372']
372
['372']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S>
original cit marker offset is 0
new cit marker offset is 0



['15']
15
['15']
parsed_discourse_facet ['result_citation']
    <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



['31']
31
['31']
parsed_discourse_facet ['result_citation']
    <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



['31']
31
['31']
parsed_discourse_facet ['result_citation']
    <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



['31']
31
['31']
parsed_discourse_facet ['result_citation']
    <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



['31']
31
['31']
parsed_discourse_facet ['result_citation']
<S sid="215" ssid="119">The first word in the string remaining to be parsed, w1, we will call the look-ahead word.</S>
original cit marker offset is 0
new cit marker offset is 0



['215']
215
['215']
parsed_discourse_facet ['method_citation']
    <S sid="302" ssid="58">In the beam search approach outlined above, we can estimate the string's probability in the same manner, by summing the probabilities of the parses that the algorithm finds.</S>
original cit marker offset is 0
new cit marker offset is 0



['302']
302
['302']
parsed_discourse_facet ['method_citation']
<S sid="372" ssid="128">The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.</S>
original cit marker offset is 0
new cit marker offset is 0



['372']
372
['372']
parsed_discourse_facet ['result_citation']
    <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



['31']
31
['31']
parsed_discourse_facet ['result_citation']
    <S sid="100" ssid="4">The approach that we will subsequently present uses the probabilistic grammar as its language model, but only includes probability mass from those parses that are found, that is, it uses the parser to find a subset of the total set of parses (hopefully most of the high-probability parses) and uses the sum of their probabilities as an estimate of the true probability given the grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



['100']
100
['100']
parsed_discourse_facet ['method_citation']
    <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



['31']
31
['31']
parsed_discourse_facet ['result_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



['21']
21
['21']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/J01-2004.annv3.csv
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S><S sid="16" ssid="4">While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.</S><S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S><S sid="93" ssid="51">The standard language model used in many speech recognition systems is the trigram model, i.e., a Markov model of order 2, which can be characterized by the following equation: To smooth the trigram models that are used in this paper, we interpolate the probability estimates of higher-order Markov models with lower-order Markov models (Jelinek and Mercer 1980).</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'16'", "'31'", "'93'"]
'15'
'16'
'31'
'93'
['15', '16', '31', '93']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S><S sid="16" ssid="4">While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.</S><S sid="141" ssid="45">We will then present empirical results in two domains: one to compare with previous work in the parsing literature, and the other to compare with previous work using parsing for language modeling for speech recognition, in particular with the Chelba and Jelinek results mentioned above.</S><S sid="399" ssid="12">In addition, as mentioned above, we would like to further test our language model in speech recognition tasks, to see if the perplexity improvement that we have seen can lead to significant reductions in word error rate.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'16'", "'141'", "'399'"]
'15'
'16'
'141'
'399'
['15', '16', '141', '399']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S><S sid="143" ssid="47">It has been shown repeatedly&#8212;e.g., Briscoe and Carroll (1993), Charniak (1997), Collins (1997), Inui et al. (1997), Johnson (1998)&#8212;that conditioning the probabilities of structures on the context within which they appear, for example on the lexical head of a constituent (Charniak 1997; Collins 1997), on the label of its parent nonterminal (Johnson 1998), or, ideally, on both and many other things besides, leads to a much better parsing model and results in higher parsing accuracies.</S><S sid="277" ssid="33">The first set of results looks at the performance of the parser on the standard corpora for statistical parsing trials: Sections 2-21 (989,860 words, 39,832 sentences) of the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) served as the training data, Section 24 (34,199 words, 1,346 sentences) as the held-out data for parameter estimation, and Section 23 (59,100 words, 2,416 sentences) as the test data.</S><S sid="367" ssid="123">Table 5 reports the word and sentence error rates for five different models: (i) the trigram model that comes with the lattices, trained on approximately 40M words, with a vocabulary of 20,000; (ii) the best-performing model from Chelba (2000), which was interpolated with the lattice trigram at A -= 0.4; (iii) our parsing model, with the same training and vocabulary as the perplexity trials above; (iv) a trigram model with the same training and vocabulary as the parsing model; and (v) no language model at all.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'143'", "'277'", "'367'"]
'20'
'143'
'277'
'367'
['20', '143', '277', '367']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S><S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S><S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S><S sid="277" ssid="33">The first set of results looks at the performance of the parser on the standard corpora for statistical parsing trials: Sections 2-21 (989,860 words, 39,832 sentences) of the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) served as the training data, Section 24 (34,199 words, 1,346 sentences) as the held-out data for parameter estimation, and Section 23 (59,100 words, 2,416 sentences) as the test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'31'", "'32'", "'277'"]
'20'
'31'
'32'
'277'
['20', '31', '32', '277']
parsed_discourse_facet ['method_citation']
<S sid="133" ssid="37">Statistically based heuristic best-first or beam-search strategies (Caraballo and Charniak 1998; Charniak, Goldwater, and Johnson 1998; Goodman 1997) have yielded an enormous improvement in the quality and speed of parsers, even without any guarantee that the parse returned is, in fact, that with the maximum likelihood for the probability model.</S><S sid="134" ssid="38">The parsers with the highest published broad-coverage parsing accuracy, which include Charniak (1997, 2000), Collins (1997, 1999), and Ratnaparkhi (1997), all utilize simple and straightforward statistically based search heuristics, pruning the search-space quite dramatically!\</S><S sid="135" ssid="39">Such methods are nearly always used in conjunction with some form of dynamic programming (henceforth DP).</S><S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'134'", "'135'", "'282'"]
'133'
'134'
'135'
'282'
['133', '134', '135', '282']
parsed_discourse_facet ['method_citation']
<S sid="135" ssid="39">Such methods are nearly always used in conjunction with some form of dynamic programming (henceforth DP).</S><S sid="269" ssid="25">In such a model, it is possible to commit to a set of partial analyses at a particular point that cannot be completed given the rest of the input string (i.e., the parser can &amp;quot;garden path&amp;quot;).</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S><S sid="403" ssid="16">Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.</S>
original cit marker offset is 0
new cit marker offset is 0



["'135'", "'269'", "'402'", "'403'"]
'135'
'269'
'402'
'403'
['135', '269', '402', '403']
parsed_discourse_facet ['method_citation']
<S sid="182" ssid="86">The functions that we have chosen for this paper follow from the intuition (and experience) that what helps parsing is different depending on the constituent that is being expanded.</S><S sid="184" ssid="88">If the POS is leftmost within its constituent, then very often the lexical item is sensitive to the governing category to which it is attaching.</S><S sid="185" ssid="89">For example, if the POS is a preposition, then its probability of expanding to a particular word is very different if it is attaching to a noun phrase than if it is attaching to a verb phrase, and perhaps quite different depending on the head of the constituent to which it is attaching.</S><S sid="231" ssid="135">Since we do not know the POS for the word, we must sum the LAP for all POS For a PCFG G, a stack S = Ao An$ (which we will write AN and a look-ahead terminal item wi, we define the look-ahead probability as follows: We recursively estimate this with two empirically observed conditional probabilities for every nonterminal A,: 13(A, w,a) and P(A, c).</S>
original cit marker offset is 0
new cit marker offset is 0



["'182'", "'184'", "'185'", "'231'"]
'182'
'184'
'185'
'231'
['182', '184', '185', '231']
parsed_discourse_facet ['method_citation']
<S sid="136" ssid="40">That is, search efficiency for these parsers is improved by both statistical search heuristics and DP.</S><S sid="267" ssid="23">In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.</S><S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S><S sid="298" ssid="54">What is perhaps surprising is that the difference is not greater.</S>
original cit marker offset is 0
new cit marker offset is 0



["'136'", "'267'", "'282'", "'298'"]
'136'
'267'
'282'
'298'
['136', '267', '282', '298']
parsed_discourse_facet ['method_citation']
<S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S><S sid="290" ssid="46">Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.</S><S sid="377" ssid="133">The point of this small experiment was to see if our parsing model could provide useful information even in the case that recognition errors occur, as opposed to the (generally) fully grammatical strings upon which the perplexity results were obtained.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'282'", "'290'", "'377'", "'402'"]
'282'
'290'
'377'
'402'
['282', '290', '377', '402']
parsed_discourse_facet ['results_citation']
<S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S><S sid="281" ssid="37">First, and least surprising, is that the accuracy of the parses improved as we conditioned on more and more information.</S><S sid="290" ssid="46">Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.</S><S sid="291" ssid="47">Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'281'", "'290'", "'291'"]
'32'
'281'
'290'
'291'
['32', '281', '290', '291']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="27">The top-down guidance that is provided makes this approach quite efficient in practice.</S><S sid="76" ssid="34">The leftfactorization transform that we use is identical to what is called right binarization in Roark and Johnson (1999).</S><S sid="96" ssid="54">This interpolation is recursively applied to the smaller-order n-grams until the bigram is finally interpolated with the unigram, i.e., Ao = 1.</S><S sid="378" ssid="134">As one reviewer pointed out, given that our model relies so heavily on context, it may have difficulty recovering from even one recognition error, perhaps more difficulty than a more locally oriented trigram.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'76'", "'96'", "'378'"]
'39'
'76'
'96'
'378'
['39', '76', '96', '378']
parsed_discourse_facet ['method_citation']
<S sid="101" ssid="5">As mentioned in Section 2.1, a PCFG defines a probability distribution over strings of words.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S><S sid="403" ssid="16">Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.</S>
original cit marker offset is 0
new cit marker offset is 0



["'101'", "'401'", "'402'", "'403'"]
'101'
'401'
'402'
'403'
['101', '401', '402', '403']
parsed_discourse_facet ['method_citation']
<S sid="235" ssid="139">The basic idea is that we want the beam to be very wide if there are few analyses that have been advanced, but relatively narrow if many analyses have been advanced.</S><S sid="239" ssid="143">After 1,000 candidates, the beam has narrowed to 10-2p.</S><S sid="267" ssid="23">In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.</S><S sid="349" ssid="105">One way to test this is the following: at each point in the sentence, calculate the conditional probability of each word in the vocabulary given the previous words, and sum them.\</S>
original cit marker offset is 0
new cit marker offset is 0



["'235'", "'239'", "'267'", "'349'"]
'235'
'239'
'267'
'349'
['235', '239', '267', '349']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="142" ssid="46">A simple PCFG conditions rule probabilities on the left-hand side of the rule.</S><S sid="363" ssid="119">Splitting of the contractions is critical for parsing, since the two parts oftentimes (as in the previous example) fall in different constituents.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'142'", "'363'", "'401'", "'402'"]
'142'
'363'
'401'
'402'
['142', '363', '401', '402']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">A lexicalized probabilistic topdown parser is then presented, which performs very well, in terms of both the accuracy of returned parses and the efficiency with which they are found, relative to the best broad-coverage statistical parsers.</S><S sid="9" ssid="3">A lexicalized probabilistic topdown parser is then presented, which performs very well, in terms of both the accuracy of returned parses and the efficiency with which they are found, relative to the best broad-coverage statistical parsers.</S><S sid="142" ssid="46">A simple PCFG conditions rule probabilities on the left-hand side of the rule.</S><S sid="143" ssid="47">It has been shown repeatedly&#8212;e.g., Briscoe and Carroll (1993), Charniak (1997), Collins (1997), Inui et al. (1997), Johnson (1998)&#8212;that conditioning the probabilities of structures on the context within which they appear, for example on the lexical head of a constituent (Charniak 1997; Collins 1997), on the label of its parent nonterminal (Johnson 1998), or, ideally, on both and many other things besides, leads to a much better parsing model and results in higher parsing accuracies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'9'", "'142'", "'143'"]
'3'
'9'
'142'
'143'
['3', '9', '142', '143']
parsed_discourse_facet ['aim_citation']
<S sid="99" ssid="3">These can be divided into two rough groups: those that use the grammar as a language model, and those that use a parser to uncover phrasal heads standing in an important relation (c-command) to the current word.</S><S sid="322" ssid="78">Thus, Chelba and Jelinek (1998a, 1998b) also used a parser to help assign word probabilities, via the structured language model outlined in Section 3.2.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'99'", "'322'", "'401'", "'402'"]
'99'
'322'
'401'
'402'
['99', '322', '401', '402']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S><S sid="268" ssid="24">This is an incremental parser with a pruning strategy and no backtracking.</S><S sid="309" ssid="65">Let Ht be the priority queue H, before any processing has begun with word w, in the look-ahead.</S><S sid="310" ssid="66">This is a subset of the possible leftmost partial derivations with respect to the prefix string W. Since RV is produced by expanding only analyses on priority queue H;\, the set of complete trees consistent with the partial derivations on priority queue Ht is a subset of the set of complete trees consistent with the partial derivations on priority queue HT\\, that is, the total probability mass represented by the priority queues is monotonically decreasing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'268'", "'309'", "'310'"]
'21'
'268'
'309'
'310'
['21', '268', '309', '310']
parsed_discourse_facet ['method_citation']



J01-2004
P08-1013
0
result_citation
['method_citation', 'hypothesis_citation']



J01-2004
D09-1034
0
method_citation
['method_citation']
parsing: input/ref/Task1/J01-2004_sweta.csv
<S sid="372" ssid="128">The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.</S>
original cit marker offset is 0
new cit marker offset is 0



["372'"]
372'
['372']
parsed_discourse_facet ['method_citation']
<S sid="40" ssid="28">The following section will provide some background in probabilistic context-free grammars and language modeling for speech recognition.</S>
    <S sid="41" ssid="29">There will also be a brief review of previous work using syntactic information for language modeling, before we introduce our model in Section 4.</S>
    <S sid="42" ssid="30">Three parse trees: (a) a complete parse tree; (b) a complete parse tree with an explicit stop symbol; and (c) a partial parse tree.</S>
original cit marker offset is 0
new cit marker offset is 0



["40'", "'41'", "'42'"]
40'
'41'
'42'
['40', '41', '42']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="13">A parser that is not left to right, but which has rooted derivations, e.g., a headfirst parser, will be able to calculate generative joint probabilities for entire strings; however, it will not be able to calculate probabilities for each word conditioned on previously generated words, unless each derivation generates the words in the string in exactly the same order.</S>
original cit marker offset is 0
new cit marker offset is 0



["25'"]
25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="364" ssid="120">We follow Chelba (2000) in dealing with this problem: for parsing purposes, we use the Penn Treebank tokenization; for interpolation with the provided trigram model, and for evaluation, the lattice tokenization is used.</S>
original cit marker offset is 0
new cit marker offset is 0



["364'"]
364'
['364']
parsed_discourse_facet ['method_citation']
<S sid="302" ssid="58">In the beam search approach outlined above, we can estimate the string's probability in the same manner, by summing the probabilities of the parses that the algorithm finds.</S>
original cit marker offset is 0
new cit marker offset is 0



["302'"]
302'
['302']
parsed_discourse_facet ['method_citation']
 <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



["31'"]
31'
['31']
parsed_discourse_facet ['method_citation']
<S sid="231" ssid="135">Since we do not know the POS for the word, we must sum the LAP for all POS For a PCFG G, a stack S = Ao An$ (which we will write AN and a look-ahead terminal item wi, we define the look-ahead probability as follows: We recursively estimate this with two empirically observed conditional probabilities for every nonterminal A,: 13(A, w,a) and P(A, c).</S>
original cit marker offset is 0
new cit marker offset is 0



["231'"]
231'
['231']
parsed_discourse_facet ['method_citation']
<S sid="297" ssid="53">The differences between a k-best and a beam-search parser (not to mention the use of dynamic programming) make a running time difference unsurprising.</S>
original cit marker offset is 0
new cit marker offset is 0



["297'"]
297'
['297']
parsed_discourse_facet ['method_citation']
<S sid="133" ssid="37">Statistically based heuristic best-first or beam-search strategies (Caraballo and Charniak 1998; Charniak, Goldwater, and Johnson 1998; Goodman 1997) have yielded an enormous improvement in the quality and speed of parsers, even without any guarantee that the parse returned is, in fact, that with the maximum likelihood for the probability model.</S>
original cit marker offset is 0
new cit marker offset is 0



["133'"]
133'
['133']
parsed_discourse_facet ['method_citation']
<S sid="291" ssid="47">Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["291'"]
291'
['291']
parsed_discourse_facet ['method_citation']
<S sid="355" ssid="111">In order to get a sense of whether these perplexity reduction results can translate to improvement in a speech recognition task, we performed a very small preliminary experiment on n-best lists.</S>
original cit marker offset is 0
new cit marker offset is 0



["355'"]
355'
['355']
parsed_discourse_facet ['method_citation']
<S sid="59" ssid="17">A PCFG is a CFG with a probability assigned to each rule; specifically, each righthand side has a probability given the left-hand side of the rule.</S>
original cit marker offset is 0
new cit marker offset is 0



["59'"]
59'
['59']
parsed_discourse_facet ['method_citation']
<S sid="100" ssid="4">The approach that we will subsequently present uses the probabilistic grammar as its language model, but only includes probability mass from those parses that are found, that is, it uses the parser to find a subset of the total set of parses (hopefully most of the high-probability parses) and uses the sum of their probabilities as an estimate of the true probability given the grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["100'"]
100'
['100']
parsed_discourse_facet ['method_citation']
<S sid="108" ssid="12">Another approach that uses syntactic structure for language modeling has been to use a shift-reduce parser to &amp;quot;surface&amp;quot; c-commanding phrasal headwords or part-of-speech (POS) tags from arbitrarily far back in the prefix string, for use in a trigram-like model.</S>
original cit marker offset is 0
new cit marker offset is 0



["108'"]
108'
['108']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



["31'"]
31'
['31']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



["31'"]
31'
['31']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/J01-2004.annv3.csv
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S><S sid="16" ssid="4">While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.</S><S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S><S sid="93" ssid="51">The standard language model used in many speech recognition systems is the trigram model, i.e., a Markov model of order 2, which can be characterized by the following equation: To smooth the trigram models that are used in this paper, we interpolate the probability estimates of higher-order Markov models with lower-order Markov models (Jelinek and Mercer 1980).</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'16'", "'31'", "'93'"]
'15'
'16'
'31'
'93'
['15', '16', '31', '93']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S><S sid="16" ssid="4">While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.</S><S sid="141" ssid="45">We will then present empirical results in two domains: one to compare with previous work in the parsing literature, and the other to compare with previous work using parsing for language modeling for speech recognition, in particular with the Chelba and Jelinek results mentioned above.</S><S sid="399" ssid="12">In addition, as mentioned above, we would like to further test our language model in speech recognition tasks, to see if the perplexity improvement that we have seen can lead to significant reductions in word error rate.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'16'", "'141'", "'399'"]
'15'
'16'
'141'
'399'
['15', '16', '141', '399']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S><S sid="143" ssid="47">It has been shown repeatedly&#8212;e.g., Briscoe and Carroll (1993), Charniak (1997), Collins (1997), Inui et al. (1997), Johnson (1998)&#8212;that conditioning the probabilities of structures on the context within which they appear, for example on the lexical head of a constituent (Charniak 1997; Collins 1997), on the label of its parent nonterminal (Johnson 1998), or, ideally, on both and many other things besides, leads to a much better parsing model and results in higher parsing accuracies.</S><S sid="277" ssid="33">The first set of results looks at the performance of the parser on the standard corpora for statistical parsing trials: Sections 2-21 (989,860 words, 39,832 sentences) of the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) served as the training data, Section 24 (34,199 words, 1,346 sentences) as the held-out data for parameter estimation, and Section 23 (59,100 words, 2,416 sentences) as the test data.</S><S sid="367" ssid="123">Table 5 reports the word and sentence error rates for five different models: (i) the trigram model that comes with the lattices, trained on approximately 40M words, with a vocabulary of 20,000; (ii) the best-performing model from Chelba (2000), which was interpolated with the lattice trigram at A -= 0.4; (iii) our parsing model, with the same training and vocabulary as the perplexity trials above; (iv) a trigram model with the same training and vocabulary as the parsing model; and (v) no language model at all.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'143'", "'277'", "'367'"]
'20'
'143'
'277'
'367'
['20', '143', '277', '367']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S><S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S><S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S><S sid="277" ssid="33">The first set of results looks at the performance of the parser on the standard corpora for statistical parsing trials: Sections 2-21 (989,860 words, 39,832 sentences) of the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) served as the training data, Section 24 (34,199 words, 1,346 sentences) as the held-out data for parameter estimation, and Section 23 (59,100 words, 2,416 sentences) as the test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'31'", "'32'", "'277'"]
'20'
'31'
'32'
'277'
['20', '31', '32', '277']
parsed_discourse_facet ['method_citation']
<S sid="133" ssid="37">Statistically based heuristic best-first or beam-search strategies (Caraballo and Charniak 1998; Charniak, Goldwater, and Johnson 1998; Goodman 1997) have yielded an enormous improvement in the quality and speed of parsers, even without any guarantee that the parse returned is, in fact, that with the maximum likelihood for the probability model.</S><S sid="134" ssid="38">The parsers with the highest published broad-coverage parsing accuracy, which include Charniak (1997, 2000), Collins (1997, 1999), and Ratnaparkhi (1997), all utilize simple and straightforward statistically based search heuristics, pruning the search-space quite dramatically!\</S><S sid="135" ssid="39">Such methods are nearly always used in conjunction with some form of dynamic programming (henceforth DP).</S><S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'134'", "'135'", "'282'"]
'133'
'134'
'135'
'282'
['133', '134', '135', '282']
parsed_discourse_facet ['method_citation']
<S sid="135" ssid="39">Such methods are nearly always used in conjunction with some form of dynamic programming (henceforth DP).</S><S sid="269" ssid="25">In such a model, it is possible to commit to a set of partial analyses at a particular point that cannot be completed given the rest of the input string (i.e., the parser can &amp;quot;garden path&amp;quot;).</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S><S sid="403" ssid="16">Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.</S>
original cit marker offset is 0
new cit marker offset is 0



["'135'", "'269'", "'402'", "'403'"]
'135'
'269'
'402'
'403'
['135', '269', '402', '403']
parsed_discourse_facet ['method_citation']
<S sid="182" ssid="86">The functions that we have chosen for this paper follow from the intuition (and experience) that what helps parsing is different depending on the constituent that is being expanded.</S><S sid="184" ssid="88">If the POS is leftmost within its constituent, then very often the lexical item is sensitive to the governing category to which it is attaching.</S><S sid="185" ssid="89">For example, if the POS is a preposition, then its probability of expanding to a particular word is very different if it is attaching to a noun phrase than if it is attaching to a verb phrase, and perhaps quite different depending on the head of the constituent to which it is attaching.</S><S sid="231" ssid="135">Since we do not know the POS for the word, we must sum the LAP for all POS For a PCFG G, a stack S = Ao An$ (which we will write AN and a look-ahead terminal item wi, we define the look-ahead probability as follows: We recursively estimate this with two empirically observed conditional probabilities for every nonterminal A,: 13(A, w,a) and P(A, c).</S>
original cit marker offset is 0
new cit marker offset is 0



["'182'", "'184'", "'185'", "'231'"]
'182'
'184'
'185'
'231'
['182', '184', '185', '231']
parsed_discourse_facet ['method_citation']
<S sid="136" ssid="40">That is, search efficiency for these parsers is improved by both statistical search heuristics and DP.</S><S sid="267" ssid="23">In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.</S><S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S><S sid="298" ssid="54">What is perhaps surprising is that the difference is not greater.</S>
original cit marker offset is 0
new cit marker offset is 0



["'136'", "'267'", "'282'", "'298'"]
'136'
'267'
'282'
'298'
['136', '267', '282', '298']
parsed_discourse_facet ['method_citation']
<S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S><S sid="290" ssid="46">Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.</S><S sid="377" ssid="133">The point of this small experiment was to see if our parsing model could provide useful information even in the case that recognition errors occur, as opposed to the (generally) fully grammatical strings upon which the perplexity results were obtained.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'282'", "'290'", "'377'", "'402'"]
'282'
'290'
'377'
'402'
['282', '290', '377', '402']
parsed_discourse_facet ['results_citation']
<S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S><S sid="281" ssid="37">First, and least surprising, is that the accuracy of the parses improved as we conditioned on more and more information.</S><S sid="290" ssid="46">Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.</S><S sid="291" ssid="47">Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'281'", "'290'", "'291'"]
'32'
'281'
'290'
'291'
['32', '281', '290', '291']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="27">The top-down guidance that is provided makes this approach quite efficient in practice.</S><S sid="76" ssid="34">The leftfactorization transform that we use is identical to what is called right binarization in Roark and Johnson (1999).</S><S sid="96" ssid="54">This interpolation is recursively applied to the smaller-order n-grams until the bigram is finally interpolated with the unigram, i.e., Ao = 1.</S><S sid="378" ssid="134">As one reviewer pointed out, given that our model relies so heavily on context, it may have difficulty recovering from even one recognition error, perhaps more difficulty than a more locally oriented trigram.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'76'", "'96'", "'378'"]
'39'
'76'
'96'
'378'
['39', '76', '96', '378']
parsed_discourse_facet ['method_citation']
<S sid="101" ssid="5">As mentioned in Section 2.1, a PCFG defines a probability distribution over strings of words.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S><S sid="403" ssid="16">Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.</S>
original cit marker offset is 0
new cit marker offset is 0



["'101'", "'401'", "'402'", "'403'"]
'101'
'401'
'402'
'403'
['101', '401', '402', '403']
parsed_discourse_facet ['method_citation']
<S sid="235" ssid="139">The basic idea is that we want the beam to be very wide if there are few analyses that have been advanced, but relatively narrow if many analyses have been advanced.</S><S sid="239" ssid="143">After 1,000 candidates, the beam has narrowed to 10-2p.</S><S sid="267" ssid="23">In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.</S><S sid="349" ssid="105">One way to test this is the following: at each point in the sentence, calculate the conditional probability of each word in the vocabulary given the previous words, and sum them.\</S>
original cit marker offset is 0
new cit marker offset is 0



["'235'", "'239'", "'267'", "'349'"]
'235'
'239'
'267'
'349'
['235', '239', '267', '349']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="142" ssid="46">A simple PCFG conditions rule probabilities on the left-hand side of the rule.</S><S sid="363" ssid="119">Splitting of the contractions is critical for parsing, since the two parts oftentimes (as in the previous example) fall in different constituents.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'142'", "'363'", "'401'", "'402'"]
'142'
'363'
'401'
'402'
['142', '363', '401', '402']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">A lexicalized probabilistic topdown parser is then presented, which performs very well, in terms of both the accuracy of returned parses and the efficiency with which they are found, relative to the best broad-coverage statistical parsers.</S><S sid="9" ssid="3">A lexicalized probabilistic topdown parser is then presented, which performs very well, in terms of both the accuracy of returned parses and the efficiency with which they are found, relative to the best broad-coverage statistical parsers.</S><S sid="142" ssid="46">A simple PCFG conditions rule probabilities on the left-hand side of the rule.</S><S sid="143" ssid="47">It has been shown repeatedly&#8212;e.g., Briscoe and Carroll (1993), Charniak (1997), Collins (1997), Inui et al. (1997), Johnson (1998)&#8212;that conditioning the probabilities of structures on the context within which they appear, for example on the lexical head of a constituent (Charniak 1997; Collins 1997), on the label of its parent nonterminal (Johnson 1998), or, ideally, on both and many other things besides, leads to a much better parsing model and results in higher parsing accuracies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'9'", "'142'", "'143'"]
'3'
'9'
'142'
'143'
['3', '9', '142', '143']
parsed_discourse_facet ['aim_citation']
<S sid="99" ssid="3">These can be divided into two rough groups: those that use the grammar as a language model, and those that use a parser to uncover phrasal heads standing in an important relation (c-command) to the current word.</S><S sid="322" ssid="78">Thus, Chelba and Jelinek (1998a, 1998b) also used a parser to help assign word probabilities, via the structured language model outlined in Section 3.2.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'99'", "'322'", "'401'", "'402'"]
'99'
'322'
'401'
'402'
['99', '322', '401', '402']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S><S sid="268" ssid="24">This is an incremental parser with a pruning strategy and no backtracking.</S><S sid="309" ssid="65">Let Ht be the priority queue H, before any processing has begun with word w, in the look-ahead.</S><S sid="310" ssid="66">This is a subset of the possible leftmost partial derivations with respect to the prefix string W. Since RV is produced by expanding only analyses on priority queue H;\, the set of complete trees consistent with the partial derivations on priority queue Ht is a subset of the set of complete trees consistent with the partial derivations on priority queue HT\\, that is, the total probability mass represented by the priority queues is monotonically decreasing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'268'", "'309'", "'310'"]
'21'
'268'
'309'
'310'
['21', '268', '309', '310']
parsed_discourse_facet ['method_citation']



J01-2004
P04-1015
0
method_citation
['method_citation']



J01-2004
P05-1022
0
method_citation
['method_citation']
parsing: input/ref/Task1/P04-1036_aakansha.csv
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'"]
'15'
['15']
parsed_discourse_facet ['method_citation']
<S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'"]
'41'
['41']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="4">We present work on the use of a thesaurus acquired from raw textual corpora and the WordNet similarity package to find predominant noun senses automatically.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'"]
'4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'"]
'15'
['15']
parsed_discourse_facet ['method_citation']
<S sid="180" ssid="3">The automatically acquired predominant senses were evaluated against the hand-tagged resources SemCor and the SENSEVAL-2 English all-words task giving us a WSD precision of 64% on an all-nouns task.</S>
    <S sid="181" ssid="4">This is just 5% lower than results using the first sense in the manually labelled SemCor, and we obtain 67% precision on polysemous nouns that are not in SemCor.</S>
original cit marker offset is 0
new cit marker offset is 0



["'180'", "'181'"]
'180'
'181'
['180', '181']
parsed_discourse_facet ['result_citation']
<S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'"]
'126'
['126']
parsed_discourse_facet ['method_citation']
<S sid="48" ssid="4">To find the first sense of a word ( ) we take each sense in turn and obtain a score reflecting the prevalence which is used for ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'"]
'48'
['48']
parsed_discourse_facet ['method_citation']
<S sid="169" ssid="17">This method obtains precision of 61% and recall 51%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'169'"]
'169'
['169']
parsed_discourse_facet ['result_citation']
<S sid="171" ssid="19">In contrast, we use the neighbours lists and WordNet similarity measures to impose a prevalence ranking on the WordNet senses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'171'"]
'171'
['171']
parsed_discourse_facet ['method_citation']
<S sid="171" ssid="19">In contrast, we use the neighbours lists and WordNet similarity measures to impose a prevalence ranking on the WordNet senses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'171'"]
'171'
['171']
parsed_discourse_facet ['method_citation']
<S sid="115" ssid="13">Our automatically acquired predominant sense performs nearly as well as the first sense provided by SemCor, which is very encouraging given that our method only uses raw text, with no manual labelling.</S>
original cit marker offset is 0
new cit marker offset is 0



["'115'"]
'115'
['115']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'"]
'126'
['126']
parsed_discourse_facet ['method_citation']
<S sid="180" ssid="3">The automatically acquired predominant senses were evaluated against the hand-tagged resources SemCor and the SENSEVAL-2 English all-words task giving us a WSD precision of 64% on an all-nouns task.</S>
    <S sid="181" ssid="4">This is just 5% lower than results using the first sense in the manually labelled SemCor, and we obtain 67% precision on polysemous nouns that are not in SemCor.</S>
original cit marker offset is 0
new cit marker offset is 0



["'180'", "'181'"]
'180'
'181'
['180', '181']
parsed_discourse_facet ['result_citation']
<S sid="180" ssid="3">The automatically acquired predominant senses were evaluated against the hand-tagged resources SemCor and the SENSEVAL-2 English all-words task giving us a WSD precision of 64% on an all-nouns task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'180'"]
'180'
['180']
parsed_discourse_facet ['method_citation']
<S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'"]
'41'
['41']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P04-1036.annv3.csv
<S sid="2" ssid="2">The problem with using the predominant, or first sense heuristic, aside from the fact that it does not take surrounding context into account, is that it assumes some quantity of handtagged data.</S><S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="14" ssid="7">Even systems which show superior performance to this heuristic often make use of the heuristic where evidence from the context is not sufficient (Hoste et al., 2001).</S><S sid="23" ssid="16">The first sense of star in SemCor is celestial body, however, if one were disambiguating popular news celebrity would be preferred.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'8'", "'14'", "'23'"]
'2'
'8'
'14'
'23'
['2', '8', '14', '23']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S><S sid="21" ssid="14">We believe that an automatic means of finding a predominant sense would be useful for systems that use it as a means of backing-off (Wilks and Stevenson, 1998; Hoste et al., 2001) and for systems that use it in lexical acquisition (McCarthy, 1997; Merlo and Leybold, 2001; Korhonen, 2002) because of the limited size of hand-tagged resources.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'15'", "'21'", "'175'"]
'9'
'15'
'21'
'175'
['9', '15', '21', '175']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="32" ssid="25">We describe some related work in section 6 and conclude in section 7. are therefore investigating a method of automatically ranking WordNet senses from raw text.</S><S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="49" ssid="5">Let be the ordered set of the top scoring neighbours of from the thesaurus with associated distributional similarity scores The thesaurus was acquired using the method described by Lin (1998).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'41'", "'49'", "'175'"]
'32'
'41'
'49'
'175'
['32', '41', '49', '175']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="4" ssid="4">We present work on the use of a thesaurus acquired from raw textual corpora and the WordNet similarity package to find predominant noun senses automatically.</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="178" ssid="1">We have devised a method that uses raw corpus data to automatically find a predominant sense for nouns in WordNet.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'46'", "'166'", "'178'"]
'4'
'46'
'166'
'178'
['4', '46', '166', '178']
parsed_discourse_facet ['aim_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'47'", "'166'", "'175'"]
'0'
'47'
'166'
'175'
['0', '47', '166', '175']
parsed_discourse_facet ['results_citation']
<S sid="111" ssid="9">We give the results for this WSD task in table 2.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="167" ssid="15">In this work the lists of neighbours are themselves clustered to bring out the various senses of the word.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'111'", "'165'", "'167'", "'175'"]
'111'
'165'
'167'
'175'
['111', '165', '167', '175']
parsed_discourse_facet ['results_citation']
<S sid="3" ssid="3">Whilst there are a few hand-tagged corpora available for some languages, one would expect the frequency distribution of the senses of words, particularly topical words, to depend on the genre and domain of the text under consideration.</S><S sid="152" ssid="29">We see that both domains have a similarly high percentage of factotum (domain independent) labels, but as we would expect, the other peaks correspond to the economy label for the FINANCE corpus, and the sports label for the SPORTS corpus. inant senses for 38 polysemous words ranked using the SPORTS and FINANCE corpus.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'152'", "'165'", "'175'"]
'3'
'152'
'165'
'175'
['3', '152', '165', '175']
parsed_discourse_facet ['results_citation']
<S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'", "'47'", "'174'", "'176'"]
'41'
'47'
'174'
'176'
['41', '47', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="20">We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).</S><S sid="66" ssid="22">It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.</S><S sid="83" ssid="12">The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.</S><S sid="84" ssid="13">The random baseline for choosing the predominant sense over all these words ( ) is 32%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'66'", "'83'", "'84'"]
'64'
'66'
'83'
'84'
['64', '66', '83', '84']
parsed_discourse_facet ['results_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'174'", "'175'", "'176'"]
'9'
'174'
'175'
'176'
['9', '174', '175', '176']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="27" ssid="20">We use WordNet as our sense inventory for this work.</S><S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="164" ssid="12">They used syntactic evidence to find a prior distribution for verb classes, based on (Levin, 1993), and incorporate this in a WSD system.</S><S sid="189" ssid="12">Additionally, we need to determine whether senses which do not occur in a wide variety of grammatical contexts fare badly using distributional measures of similarity, and what can be done to combat this problem using relation specific thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'104'", "'164'", "'189'"]
'27'
'104'
'164'
'189'
['27', '104', '164', '189']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="133" ssid="10">We acquired thesauruses for these corpora using the procedure described in section 2.1.</S><S sid="158" ssid="6">We have evaluated our method using publically available resources, both for balanced and domain specific text.</S><S sid="168" ssid="16">They evaluate using the lin measure described above in section 2.2 to determine the precision and recall of these discovered classes with respect to WordNet synsets.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'158'", "'168'", "'175'"]
'133'
'158'
'168'
'175'
['133', '158', '168', '175']
parsed_discourse_facet ['results_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="160" ssid="8">Identification of these domain labels for word senses was semiautomatic and required a considerable amount of hand-labelling.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'46'", "'160'", "'176'"]
'0'
'46'
'160'
'176'
['0', '46', '160', '176']
parsed_discourse_facet ['hypothesis_citation']
<S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="154" ssid="2">In contrast, our work is aimed at discovering the predominant senses from raw text because the first sense heuristic is such a useful one, and because handtagged data is not always available.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'", "'154'", "'174'", "'175'"]
'104'
'154'
'174'
'175'
['104', '154', '174', '175']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.</S><S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="81" ssid="10">4 We calculate the accuracy of finding the predominant sense, when there is indeed one sense with a higher frequency than the others for this word in SemCor ( ).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'81'", "'175'"]
'1'
'9'
'81'
'175'
['1', '9', '81', '175']
parsed_discourse_facet ['results_citation']
<S sid="6" ssid="6">This is a very promising result given that our method does not require any hand-tagged text, such as SemCor.</S><S sid="7" ssid="7">Furthermore, we demonstrate that our method discovers appropriate predominant senses for words from two domainspecific corpora.</S><S sid="79" ssid="8">3 The experimental results reported here are obtained using IC counts from the BNC corpus.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'7'", "'79'", "'175'"]
'6'
'7'
'79'
'175'
['6', '7', '79', '175']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S><S sid="25" ssid="18">However, the most accurate WSD systems are those which require manually sense tagged data in the first place, and their accuracy depends on the quantity of training examples (Yarowsky and Florian, 2002) available.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'13'", "'25'", "'175'"]
'8'
'13'
'25'
'175'
['8', '13', '25', '175']
parsed_discourse_facet ['hypothesis_citation']



P04-1036
W04-0837
0
method_citation
['method_citation', 'hypothesis_citation']
parsing: input/ref/Task1/P04-1036_swastika.csv
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



['8']
8
['8']
parsed_discourse_facet ['result_citation']
<S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S>
original cit marker offset is 0
new cit marker offset is 0



['15']
15
['15']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="24">We are of course able to apply the method to other versions of WordNet. synset, is incremented with the frequency counts from the corpus of all words belonging to that synset, directly or via the hyponymy relation.</S>
original cit marker offset is 0
new cit marker offset is 0



['68']
68
['68']
parsed_discourse_facet ['result_citation']
<S sid="83" ssid="12">The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.</S>
original cit marker offset is 0
new cit marker offset is 0



['83']
83
['83']
parsed_discourse_facet ['result_citation']
<S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S>
original cit marker offset is 0
new cit marker offset is 0



['15']
15
['15']
parsed_discourse_facet ['result_citation']
<S sid="101" ssid="30">Thus, if we used the sense ranking as a heuristic for an &#8220;all nouns&#8221; task we would expect to get precision in the region of 60%.</S>
original cit marker offset is 0
new cit marker offset is 0



['101']
101
['101']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



['126']
126
['126']
parsed_discourse_facet ['result_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



['8']
8
['8']
parsed_discourse_facet ['result_citation']
<S sid="83" ssid="12">The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.</S>
original cit marker offset is 0
new cit marker offset is 0



['83']
83
['83']
parsed_discourse_facet ['result_citation']
<S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



['126']
126
['126']
parsed_discourse_facet ['result_citation']
<S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S>
original cit marker offset is 0
new cit marker offset is 0



['46']
46
['46']
parsed_discourse_facet ['result_citation']
<S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



['126']
126
['126']
parsed_discourse_facet ['result_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



['8']
8
['8']
parsed_discourse_facet ['result_citation']
<S sid="105" ssid="3">We use an allwords task because the predominant senses will reflect the sense distributions of all nouns within the documents, rather than a lexical sample task, where the target words are manually determined and the results will depend on the skew of the words in the sample.</S>
original cit marker offset is 0
new cit marker offset is 0



['105']
105
['105']
parsed_discourse_facet ['result_citation']
<S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S>
original cit marker offset is 0
new cit marker offset is 0



['13']
13
['13']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S>
original cit marker offset is 0
new cit marker offset is 0



['13']
13
['13']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



['8']
8
['8']
parsed_discourse_facet ['result_citation']
parsing: input/res/Task1/P04-1036.annv3.csv
<S sid="2" ssid="2">The problem with using the predominant, or first sense heuristic, aside from the fact that it does not take surrounding context into account, is that it assumes some quantity of handtagged data.</S><S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="14" ssid="7">Even systems which show superior performance to this heuristic often make use of the heuristic where evidence from the context is not sufficient (Hoste et al., 2001).</S><S sid="23" ssid="16">The first sense of star in SemCor is celestial body, however, if one were disambiguating popular news celebrity would be preferred.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'8'", "'14'", "'23'"]
'2'
'8'
'14'
'23'
['2', '8', '14', '23']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S><S sid="21" ssid="14">We believe that an automatic means of finding a predominant sense would be useful for systems that use it as a means of backing-off (Wilks and Stevenson, 1998; Hoste et al., 2001) and for systems that use it in lexical acquisition (McCarthy, 1997; Merlo and Leybold, 2001; Korhonen, 2002) because of the limited size of hand-tagged resources.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'15'", "'21'", "'175'"]
'9'
'15'
'21'
'175'
['9', '15', '21', '175']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="32" ssid="25">We describe some related work in section 6 and conclude in section 7. are therefore investigating a method of automatically ranking WordNet senses from raw text.</S><S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="49" ssid="5">Let be the ordered set of the top scoring neighbours of from the thesaurus with associated distributional similarity scores The thesaurus was acquired using the method described by Lin (1998).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'41'", "'49'", "'175'"]
'32'
'41'
'49'
'175'
['32', '41', '49', '175']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="4" ssid="4">We present work on the use of a thesaurus acquired from raw textual corpora and the WordNet similarity package to find predominant noun senses automatically.</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="178" ssid="1">We have devised a method that uses raw corpus data to automatically find a predominant sense for nouns in WordNet.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'46'", "'166'", "'178'"]
'4'
'46'
'166'
'178'
['4', '46', '166', '178']
parsed_discourse_facet ['aim_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'47'", "'166'", "'175'"]
'0'
'47'
'166'
'175'
['0', '47', '166', '175']
parsed_discourse_facet ['results_citation']
<S sid="111" ssid="9">We give the results for this WSD task in table 2.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="167" ssid="15">In this work the lists of neighbours are themselves clustered to bring out the various senses of the word.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'111'", "'165'", "'167'", "'175'"]
'111'
'165'
'167'
'175'
['111', '165', '167', '175']
parsed_discourse_facet ['results_citation']
<S sid="3" ssid="3">Whilst there are a few hand-tagged corpora available for some languages, one would expect the frequency distribution of the senses of words, particularly topical words, to depend on the genre and domain of the text under consideration.</S><S sid="152" ssid="29">We see that both domains have a similarly high percentage of factotum (domain independent) labels, but as we would expect, the other peaks correspond to the economy label for the FINANCE corpus, and the sports label for the SPORTS corpus. inant senses for 38 polysemous words ranked using the SPORTS and FINANCE corpus.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'152'", "'165'", "'175'"]
'3'
'152'
'165'
'175'
['3', '152', '165', '175']
parsed_discourse_facet ['results_citation']
<S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'", "'47'", "'174'", "'176'"]
'41'
'47'
'174'
'176'
['41', '47', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="20">We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).</S><S sid="66" ssid="22">It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.</S><S sid="83" ssid="12">The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.</S><S sid="84" ssid="13">The random baseline for choosing the predominant sense over all these words ( ) is 32%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'66'", "'83'", "'84'"]
'64'
'66'
'83'
'84'
['64', '66', '83', '84']
parsed_discourse_facet ['results_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'174'", "'175'", "'176'"]
'9'
'174'
'175'
'176'
['9', '174', '175', '176']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="27" ssid="20">We use WordNet as our sense inventory for this work.</S><S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="164" ssid="12">They used syntactic evidence to find a prior distribution for verb classes, based on (Levin, 1993), and incorporate this in a WSD system.</S><S sid="189" ssid="12">Additionally, we need to determine whether senses which do not occur in a wide variety of grammatical contexts fare badly using distributional measures of similarity, and what can be done to combat this problem using relation specific thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'104'", "'164'", "'189'"]
'27'
'104'
'164'
'189'
['27', '104', '164', '189']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="133" ssid="10">We acquired thesauruses for these corpora using the procedure described in section 2.1.</S><S sid="158" ssid="6">We have evaluated our method using publically available resources, both for balanced and domain specific text.</S><S sid="168" ssid="16">They evaluate using the lin measure described above in section 2.2 to determine the precision and recall of these discovered classes with respect to WordNet synsets.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'158'", "'168'", "'175'"]
'133'
'158'
'168'
'175'
['133', '158', '168', '175']
parsed_discourse_facet ['results_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="160" ssid="8">Identification of these domain labels for word senses was semiautomatic and required a considerable amount of hand-labelling.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'46'", "'160'", "'176'"]
'0'
'46'
'160'
'176'
['0', '46', '160', '176']
parsed_discourse_facet ['hypothesis_citation']
<S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="154" ssid="2">In contrast, our work is aimed at discovering the predominant senses from raw text because the first sense heuristic is such a useful one, and because handtagged data is not always available.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'", "'154'", "'174'", "'175'"]
'104'
'154'
'174'
'175'
['104', '154', '174', '175']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.</S><S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="81" ssid="10">4 We calculate the accuracy of finding the predominant sense, when there is indeed one sense with a higher frequency than the others for this word in SemCor ( ).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'81'", "'175'"]
'1'
'9'
'81'
'175'
['1', '9', '81', '175']
parsed_discourse_facet ['results_citation']
<S sid="6" ssid="6">This is a very promising result given that our method does not require any hand-tagged text, such as SemCor.</S><S sid="7" ssid="7">Furthermore, we demonstrate that our method discovers appropriate predominant senses for words from two domainspecific corpora.</S><S sid="79" ssid="8">3 The experimental results reported here are obtained using IC counts from the BNC corpus.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'7'", "'79'", "'175'"]
'6'
'7'
'79'
'175'
['6', '7', '79', '175']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S><S sid="25" ssid="18">However, the most accurate WSD systems are those which require manually sense tagged data in the first place, and their accuracy depends on the quantity of training examples (Yarowsky and Florian, 2002) available.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'13'", "'25'", "'175'"]
'8'
'13'
'25'
'175'
['8', '13', '25', '175']
parsed_discourse_facet ['hypothesis_citation']



P04-1036
P10-1155
0
result_citation
['results_citation']



P04-1036
W12-2429
0
result_citation
['hypothesis_citation']
parsing: input/ref/Task1/P04-1036_sweta.csv
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



["8'"]
8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="82" ssid="11">We also calculate the WSD accuracy that would be obtained on SemCor, when using our first sense in all contexts ( ).</S>
original cit marker offset is 0
new cit marker offset is 0



["82'"]
82'
['82']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="20">We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).</S>
original cit marker offset is 0
new cit marker offset is 0



["64'"]
64'
['64']
parsed_discourse_facet ['method_citation']
<S sid="172" ssid="20">We believe automatic ranking techniques such as ours will be useful for systems that rely on WordNet, for example those that use it for lexical acquisition or WSD.</S>
original cit marker offset is 0
new cit marker offset is 0



["172'"]
172'
['172']
parsed_discourse_facet ['method_citation']
<S sid="153" ssid="1">Most research in WSD concentrates on using contextual features, typically neighbouring words, to help determine the correct sense of a target word.</S>
original cit marker offset is 0
new cit marker offset is 0



["153'"]
153'
['153']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.</S>
original cit marker offset is 0
new cit marker offset is 0



["1'"]
1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S>
original cit marker offset is 0
new cit marker offset is 0



["165'"]
165'
['165']
parsed_discourse_facet ['method_citation']
<S sid="171" ssid="19">In contrast, we use the neighbours lists and WordNet similarity measures to impose a prevalence ranking on the WordNet senses.</S>
original cit marker offset is 0
new cit marker offset is 0



["171'"]
171'
['171']
parsed_discourse_facet ['method_citation']
<S sid="89" ssid="18">Since both measures gave comparable results we restricted our remaining experiments to jcn because this gave good results for finding the predominant sense, and is much more efficient than lesk, given the precompilation of the IC files.</S>
original cit marker offset is 0
new cit marker offset is 0



["89'"]
89'
['89']
parsed_discourse_facet ['method_citation']
<S sid="172" ssid="20">We believe automatic ranking techniques such as ours will be useful for systems that rely on WordNet, for example those that use it for lexical acquisition or WSD.</S>
original cit marker offset is 0
new cit marker offset is 0



["172'"]
172'
['172']
parsed_discourse_facet ['method_citation']
<S sid="189" ssid="12">Additionally, we need to determine whether senses which do not occur in a wide variety of grammatical contexts fare badly using distributional measures of similarity, and what can be done to combat this problem using relation specific thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["189'"]
189'
['189']
parsed_discourse_facet ['method_citation']
<S sid="87" ssid="16">Again, the automatic ranking outperforms this by a large margin.</S>
original cit marker offset is 0
new cit marker offset is 0



["87'"]
87'
['87']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.</S>
original cit marker offset is 0
new cit marker offset is 0



["1'"]
1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="89" ssid="18">Since both measures gave comparable results we restricted our remaining experiments to jcn because this gave good results for finding the predominant sense, and is much more efficient than lesk, given the precompilation of the IC files.</S>
original cit marker offset is 0
new cit marker offset is 0



["89'"]
89'
['89']
parsed_discourse_facet ['method_citation']
 <S sid="137" ssid="14">Additionally, we evaluated our method quantitatively using the Subject Field Codes (SFC) resource (Magnini and Cavagli`a, 2000) which annotates WordNet synsets with domain labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["137'"]
137'
['137']
parsed_discourse_facet ['method_citation']
<S sid="63" ssid="19">We experimented using six of these to provide the in equation 1 above and obtained results well over our baseline, but because of space limitations give results for the two which perform the best.</S>
original cit marker offset is 0
new cit marker offset is 0



["63'"]
63'
['63']
parsed_discourse_facet ['method_citation']
<S sid="159" ssid="7">Magnini and Cavagli`a (2000) have identified WordNet word senses with particular domains, and this has proven useful for high precision WSD (Magnini et al., 2001); indeed in section 5 we used these domain labels for evaluation.</S>
original cit marker offset is 0
new cit marker offset is 0



["159'"]
159'
['159']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P04-1036.annv3.csv
<S sid="2" ssid="2">The problem with using the predominant, or first sense heuristic, aside from the fact that it does not take surrounding context into account, is that it assumes some quantity of handtagged data.</S><S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="14" ssid="7">Even systems which show superior performance to this heuristic often make use of the heuristic where evidence from the context is not sufficient (Hoste et al., 2001).</S><S sid="23" ssid="16">The first sense of star in SemCor is celestial body, however, if one were disambiguating popular news celebrity would be preferred.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'8'", "'14'", "'23'"]
'2'
'8'
'14'
'23'
['2', '8', '14', '23']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S><S sid="21" ssid="14">We believe that an automatic means of finding a predominant sense would be useful for systems that use it as a means of backing-off (Wilks and Stevenson, 1998; Hoste et al., 2001) and for systems that use it in lexical acquisition (McCarthy, 1997; Merlo and Leybold, 2001; Korhonen, 2002) because of the limited size of hand-tagged resources.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'15'", "'21'", "'175'"]
'9'
'15'
'21'
'175'
['9', '15', '21', '175']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="32" ssid="25">We describe some related work in section 6 and conclude in section 7. are therefore investigating a method of automatically ranking WordNet senses from raw text.</S><S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="49" ssid="5">Let be the ordered set of the top scoring neighbours of from the thesaurus with associated distributional similarity scores The thesaurus was acquired using the method described by Lin (1998).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'41'", "'49'", "'175'"]
'32'
'41'
'49'
'175'
['32', '41', '49', '175']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="4" ssid="4">We present work on the use of a thesaurus acquired from raw textual corpora and the WordNet similarity package to find predominant noun senses automatically.</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="178" ssid="1">We have devised a method that uses raw corpus data to automatically find a predominant sense for nouns in WordNet.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'46'", "'166'", "'178'"]
'4'
'46'
'166'
'178'
['4', '46', '166', '178']
parsed_discourse_facet ['aim_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'47'", "'166'", "'175'"]
'0'
'47'
'166'
'175'
['0', '47', '166', '175']
parsed_discourse_facet ['results_citation']
<S sid="111" ssid="9">We give the results for this WSD task in table 2.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="167" ssid="15">In this work the lists of neighbours are themselves clustered to bring out the various senses of the word.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'111'", "'165'", "'167'", "'175'"]
'111'
'165'
'167'
'175'
['111', '165', '167', '175']
parsed_discourse_facet ['results_citation']
<S sid="3" ssid="3">Whilst there are a few hand-tagged corpora available for some languages, one would expect the frequency distribution of the senses of words, particularly topical words, to depend on the genre and domain of the text under consideration.</S><S sid="152" ssid="29">We see that both domains have a similarly high percentage of factotum (domain independent) labels, but as we would expect, the other peaks correspond to the economy label for the FINANCE corpus, and the sports label for the SPORTS corpus. inant senses for 38 polysemous words ranked using the SPORTS and FINANCE corpus.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'152'", "'165'", "'175'"]
'3'
'152'
'165'
'175'
['3', '152', '165', '175']
parsed_discourse_facet ['results_citation']
<S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'", "'47'", "'174'", "'176'"]
'41'
'47'
'174'
'176'
['41', '47', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="20">We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).</S><S sid="66" ssid="22">It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.</S><S sid="83" ssid="12">The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.</S><S sid="84" ssid="13">The random baseline for choosing the predominant sense over all these words ( ) is 32%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'66'", "'83'", "'84'"]
'64'
'66'
'83'
'84'
['64', '66', '83', '84']
parsed_discourse_facet ['results_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'174'", "'175'", "'176'"]
'9'
'174'
'175'
'176'
['9', '174', '175', '176']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="27" ssid="20">We use WordNet as our sense inventory for this work.</S><S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="164" ssid="12">They used syntactic evidence to find a prior distribution for verb classes, based on (Levin, 1993), and incorporate this in a WSD system.</S><S sid="189" ssid="12">Additionally, we need to determine whether senses which do not occur in a wide variety of grammatical contexts fare badly using distributional measures of similarity, and what can be done to combat this problem using relation specific thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'104'", "'164'", "'189'"]
'27'
'104'
'164'
'189'
['27', '104', '164', '189']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="133" ssid="10">We acquired thesauruses for these corpora using the procedure described in section 2.1.</S><S sid="158" ssid="6">We have evaluated our method using publically available resources, both for balanced and domain specific text.</S><S sid="168" ssid="16">They evaluate using the lin measure described above in section 2.2 to determine the precision and recall of these discovered classes with respect to WordNet synsets.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'158'", "'168'", "'175'"]
'133'
'158'
'168'
'175'
['133', '158', '168', '175']
parsed_discourse_facet ['results_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="160" ssid="8">Identification of these domain labels for word senses was semiautomatic and required a considerable amount of hand-labelling.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'46'", "'160'", "'176'"]
'0'
'46'
'160'
'176'
['0', '46', '160', '176']
parsed_discourse_facet ['hypothesis_citation']
<S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="154" ssid="2">In contrast, our work is aimed at discovering the predominant senses from raw text because the first sense heuristic is such a useful one, and because handtagged data is not always available.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'", "'154'", "'174'", "'175'"]
'104'
'154'
'174'
'175'
['104', '154', '174', '175']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.</S><S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="81" ssid="10">4 We calculate the accuracy of finding the predominant sense, when there is indeed one sense with a higher frequency than the others for this word in SemCor ( ).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'81'", "'175'"]
'1'
'9'
'81'
'175'
['1', '9', '81', '175']
parsed_discourse_facet ['results_citation']
<S sid="6" ssid="6">This is a very promising result given that our method does not require any hand-tagged text, such as SemCor.</S><S sid="7" ssid="7">Furthermore, we demonstrate that our method discovers appropriate predominant senses for words from two domainspecific corpora.</S><S sid="79" ssid="8">3 The experimental results reported here are obtained using IC counts from the BNC corpus.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'7'", "'79'", "'175'"]
'6'
'7'
'79'
'175'
['6', '7', '79', '175']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S><S sid="25" ssid="18">However, the most accurate WSD systems are those which require manually sense tagged data in the first place, and their accuracy depends on the quantity of training examples (Yarowsky and Florian, 2002) available.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'13'", "'25'", "'175'"]
'8'
'13'
'25'
'175'
['8', '13', '25', '175']
parsed_discourse_facet ['hypothesis_citation']
parsing: input/ref/Task1/P04-1036_vardha.csv
    <S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
    <S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'"]
'15'
['15']
parsed_discourse_facet ['method_citation']
<S sid="45" ssid="1">In order to find the predominant sense of a target word we use a thesaurus acquired from automatically parsed text based on the method of Lin (1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'45'"]
'45'
['45']
parsed_discourse_facet ['method_citation']
<S sid="66" ssid="22">It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'66'"]
'66'
['66']
parsed_discourse_facet ['method_citation']
 <S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'"]
'126'
['126']
parsed_discourse_facet ['method_citation']
<S sid="101" ssid="30">Thus, if we used the sense ranking as a heuristic for an &#8220;all nouns&#8221; task we would expect to get precision in the region of 60%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'101'"]
'101'
['101']
parsed_discourse_facet ['method_citation']
 <S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'"]
'126'
['126']
parsed_discourse_facet ['method_citation']
 <S sid="115" ssid="13">Our automatically acquired predominant sense performs nearly as well as the first sense provided by SemCor, which is very encouraging given that our method only uses raw text, with no manual labelling.</S>
original cit marker offset is 0
new cit marker offset is 0



["'115'"]
'115'
['115']
parsed_discourse_facet ['method_citation']
  <S sid="89" ssid="18">Since both measures gave comparable results we restricted our remaining experiments to jcn because this gave good results for finding the predominant sense, and is much more efficient than lesk, given the precompilation of the IC files.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'"]
'89'
['89']
parsed_discourse_facet ['method_citation']
 <S sid="137" ssid="14">Additionally, we evaluated our method quantitatively using the Subject Field Codes (SFC) resource (Magnini and Cavagli`a, 2000) which annotates WordNet synsets with domain labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'137'"]
'137'
['137']
parsed_discourse_facet ['method_citation']
75 ssid="4">We generated a thesaurus entry for all polysemous nouns which occurred in SemCor with a frequency 2, and in the BNC with a frequency 10 in the grammatical relations listed in section 2.1 above.</S>
original cit marker offset is 0
new cit marker offset is 0



["'75'"]
'75'
['75']
Error in Reference Offset
 <S sid="155" ssid="3">A major benefit of our work, rather than reliance on hand-tagged training data such as SemCor, is that this method permits us to produce predominant senses for the domain and text type required.</S>
original cit marker offset is 0
new cit marker offset is 0



["'155'"]
'155'
['155']
parsed_discourse_facet ['method_citation']
  <S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
 <S sid="155" ssid="3">A major benefit of our work, rather than reliance on hand-tagged training data such as SemCor, is that this method permits us to produce predominant senses for the domain and text type required.</S>
original cit marker offset is 0
new cit marker offset is 0



["'155'"]
'155'
['155']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="24">We are of course able to apply the method to other versions of WordNet. synset, is incremented with the frequency counts from the corpus of all words belonging to that synset, directly or via the hyponymy relation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'"]
'68'
['68']
parsed_discourse_facet ['method_citation']
    <S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'"]
'13'
['13']
parsed_discourse_facet ['method_citation']
  <S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P04-1036.annv3.csv
<S sid="2" ssid="2">The problem with using the predominant, or first sense heuristic, aside from the fact that it does not take surrounding context into account, is that it assumes some quantity of handtagged data.</S><S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="14" ssid="7">Even systems which show superior performance to this heuristic often make use of the heuristic where evidence from the context is not sufficient (Hoste et al., 2001).</S><S sid="23" ssid="16">The first sense of star in SemCor is celestial body, however, if one were disambiguating popular news celebrity would be preferred.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'8'", "'14'", "'23'"]
'2'
'8'
'14'
'23'
['2', '8', '14', '23']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S><S sid="21" ssid="14">We believe that an automatic means of finding a predominant sense would be useful for systems that use it as a means of backing-off (Wilks and Stevenson, 1998; Hoste et al., 2001) and for systems that use it in lexical acquisition (McCarthy, 1997; Merlo and Leybold, 2001; Korhonen, 2002) because of the limited size of hand-tagged resources.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'15'", "'21'", "'175'"]
'9'
'15'
'21'
'175'
['9', '15', '21', '175']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="32" ssid="25">We describe some related work in section 6 and conclude in section 7. are therefore investigating a method of automatically ranking WordNet senses from raw text.</S><S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="49" ssid="5">Let be the ordered set of the top scoring neighbours of from the thesaurus with associated distributional similarity scores The thesaurus was acquired using the method described by Lin (1998).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'41'", "'49'", "'175'"]
'32'
'41'
'49'
'175'
['32', '41', '49', '175']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="4" ssid="4">We present work on the use of a thesaurus acquired from raw textual corpora and the WordNet similarity package to find predominant noun senses automatically.</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="178" ssid="1">We have devised a method that uses raw corpus data to automatically find a predominant sense for nouns in WordNet.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'46'", "'166'", "'178'"]
'4'
'46'
'166'
'178'
['4', '46', '166', '178']
parsed_discourse_facet ['aim_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'47'", "'166'", "'175'"]
'0'
'47'
'166'
'175'
['0', '47', '166', '175']
parsed_discourse_facet ['results_citation']
<S sid="111" ssid="9">We give the results for this WSD task in table 2.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="167" ssid="15">In this work the lists of neighbours are themselves clustered to bring out the various senses of the word.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'111'", "'165'", "'167'", "'175'"]
'111'
'165'
'167'
'175'
['111', '165', '167', '175']
parsed_discourse_facet ['results_citation']
<S sid="3" ssid="3">Whilst there are a few hand-tagged corpora available for some languages, one would expect the frequency distribution of the senses of words, particularly topical words, to depend on the genre and domain of the text under consideration.</S><S sid="152" ssid="29">We see that both domains have a similarly high percentage of factotum (domain independent) labels, but as we would expect, the other peaks correspond to the economy label for the FINANCE corpus, and the sports label for the SPORTS corpus. inant senses for 38 polysemous words ranked using the SPORTS and FINANCE corpus.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'152'", "'165'", "'175'"]
'3'
'152'
'165'
'175'
['3', '152', '165', '175']
parsed_discourse_facet ['results_citation']
<S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'", "'47'", "'174'", "'176'"]
'41'
'47'
'174'
'176'
['41', '47', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="20">We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).</S><S sid="66" ssid="22">It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.</S><S sid="83" ssid="12">The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.</S><S sid="84" ssid="13">The random baseline for choosing the predominant sense over all these words ( ) is 32%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'66'", "'83'", "'84'"]
'64'
'66'
'83'
'84'
['64', '66', '83', '84']
parsed_discourse_facet ['results_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'174'", "'175'", "'176'"]
'9'
'174'
'175'
'176'
['9', '174', '175', '176']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="27" ssid="20">We use WordNet as our sense inventory for this work.</S><S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="164" ssid="12">They used syntactic evidence to find a prior distribution for verb classes, based on (Levin, 1993), and incorporate this in a WSD system.</S><S sid="189" ssid="12">Additionally, we need to determine whether senses which do not occur in a wide variety of grammatical contexts fare badly using distributional measures of similarity, and what can be done to combat this problem using relation specific thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'104'", "'164'", "'189'"]
'27'
'104'
'164'
'189'
['27', '104', '164', '189']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="133" ssid="10">We acquired thesauruses for these corpora using the procedure described in section 2.1.</S><S sid="158" ssid="6">We have evaluated our method using publically available resources, both for balanced and domain specific text.</S><S sid="168" ssid="16">They evaluate using the lin measure described above in section 2.2 to determine the precision and recall of these discovered classes with respect to WordNet synsets.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'158'", "'168'", "'175'"]
'133'
'158'
'168'
'175'
['133', '158', '168', '175']
parsed_discourse_facet ['results_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="160" ssid="8">Identification of these domain labels for word senses was semiautomatic and required a considerable amount of hand-labelling.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'46'", "'160'", "'176'"]
'0'
'46'
'160'
'176'
['0', '46', '160', '176']
parsed_discourse_facet ['hypothesis_citation']
<S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="154" ssid="2">In contrast, our work is aimed at discovering the predominant senses from raw text because the first sense heuristic is such a useful one, and because handtagged data is not always available.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'", "'154'", "'174'", "'175'"]
'104'
'154'
'174'
'175'
['104', '154', '174', '175']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.</S><S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="81" ssid="10">4 We calculate the accuracy of finding the predominant sense, when there is indeed one sense with a higher frequency than the others for this word in SemCor ( ).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'81'", "'175'"]
'1'
'9'
'81'
'175'
['1', '9', '81', '175']
parsed_discourse_facet ['results_citation']
<S sid="6" ssid="6">This is a very promising result given that our method does not require any hand-tagged text, such as SemCor.</S><S sid="7" ssid="7">Furthermore, we demonstrate that our method discovers appropriate predominant senses for words from two domainspecific corpora.</S><S sid="79" ssid="8">3 The experimental results reported here are obtained using IC counts from the BNC corpus.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'7'", "'79'", "'175'"]
'6'
'7'
'79'
'175'
['6', '7', '79', '175']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S><S sid="25" ssid="18">However, the most accurate WSD systems are those which require manually sense tagged data in the first place, and their accuracy depends on the quantity of training examples (Yarowsky and Florian, 2002) available.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'13'", "'25'", "'175'"]
'8'
'13'
'25'
'175'
['8', '13', '25', '175']
parsed_discourse_facet ['hypothesis_citation']



P04-1036
W12-2429
0
method_citation
['hypothesis_citation']
parsing: input/ref/Task1/P05-1013_aakansha.csv
<S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="20">We call this pseudoprojective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al., 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
<S sid="106" ssid="17">However, the accuracy is considerably higher than previously reported results for robust non-projective parsing of Czech, with a best performance of 73% UAS (Holan, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'106'"]
'106'
['106']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="13">As expected, the most informative encoding, Head+Path, gives the highest accuracy with over 99% of all non-projective arcs being recovered correctly in both data sets.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'"]
'86'
['86']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="7">As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'109'"]
'109'
['109']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="7">As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="19">By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'"]
'23'
['23']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="20">We call this pseudoprojective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al., 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
<S sid="80" ssid="7">As shown in Table 3, the proportion of sentences containing some non-projective dependency ranges from about 15% in DDT to almost 25% in PDT.</S>
    <S sid="81"  ssid="8">However, the overall percentage of non-projective arcs is less than 2% in PDT and less than 1% in DDT.</S>
original cit marker offset is 0
new cit marker offset is 0



["'80'", "'81'"]
'80'
'81'
['80', '81']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="20">We call this pseudoprojective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al., 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="20">We call this pseudoprojective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al., 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
<S sid="49" ssid="20">The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.</S>
original cit marker offset is 0
new cit marker offset is 0



["'49'"]
'49'
['49']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'109'"]
'109'
['109']
parsed_discourse_facet ['method_citation']
<S sid="14" ssid="10">While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'14'"]
'14'
['14']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P05-1013.annv3.csv
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="61" ssid="32">Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'61'", "'62'", "'109'"]
'2'
'61'
'62'
'109'
['2', '61', '62', '109']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'62'", "'109'"]
'1'
'9'
'62'
'109'
['1', '9', '62', '109']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="3" ssid="3">Experiments using data from the Prague Dependency Treebank show that the combined system can handle nonprojective constructions with a precision sufficient to yield a significant improvement in overall parsing accuracy.</S><S sid="19" ssid="15">Finally, since non-projective constructions often involve long-distance dependencies, the problem is closely related to the recovery of empty categories and non-local dependencies in constituency-based parsing (Johnson, 2002; Dienes and Dubey, 2003; Jijkoun and de Rijke, 2004; Cahill et al., 2004; Levy and Manning, 2004; Campbell, 2004).</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'19'", "'20'"]
'2'
'3'
'19'
'20'
['2', '3', '19', '20']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'17'", "'21'"]
'1'
'2'
'17'
'21'
['1', '2', '17', '21']
parsed_discourse_facet ['results_citation']
<S sid="0">Pseudo-Projective Dependency Parsing</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'27'", "'109'"]
'0'
'2'
'27'
'109'
['0', '2', '27', '109']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'37'", "'50'", "'104'"]
'22'
'37'
'50'
'104'
['22', '37', '50', '104']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="40" ssid="11">Even this may be nondeterministic, in case the graph contains several non-projective arcs whose lifts interact, but we use the following algorithm to construct a minimal projective transformation D0 = (W, A0) of a (nonprojective) dependency graph D = (W, A): The function SMALLEST-NONP-ARC returns the non-projective arc with the shortest distance from head to dependent (breaking ties from left to right).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'40'"]
'2'
'20'
'21'
'40'
['2', '20', '21', '40']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.</S><S sid="36" ssid="7">As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'36'", "'37'", "'50'"]
'22'
'36'
'37'
'50'
['22', '36', '37', '50']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="107" ssid="18">Compared to related work on the recovery of long-distance dependencies in constituency-based parsing, our approach is similar to that of Dienes and Dubey (2003) in that the processing of non-local dependencies is partly integrated in the parsing process, via an extension of the set of syntactic categories, whereas most other approaches rely on postprocessing only.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'21'", "'62'", "'107'"]
'2'
'21'
'62'
'107'
['2', '21', '62', '107']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="105" ssid="16">Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'17'", "'62'", "'105'"]
'9'
'17'
'62'
'105'
['9', '17', '62', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="7" ssid="3">From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.</S><S sid="12" ssid="8">Prague Dependency Treebank (Haji&#711;c et al., 2001b), Danish Dependency Treebank (Kromann, 2003), and the METU Treebank of Turkish (Oflazer et al., 2003), which generally allow annotations with nonprojective dependency structures.</S><S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'7'", "'12'", "'95'"]
'2'
'7'
'12'
'95'
['2', '7', '12', '95']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="23" ssid="19">By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.</S><S sid="61" ssid="32">Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.</S><S sid="94" ssid="5">The first thing to note is that projectivizing helps in itself, even if no encoding is used, as seen from the fact that the projective baseline outperforms the non-projective training condition by more than half a percentage point on attachment score, although the gain is much smaller with respect to exact match.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'23'", "'61'", "'94'"]
'1'
'23'
'61'
'94'
['1', '23', '61', '94']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">Pseudo-Projective Dependency Parsing</S><S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="8" ssid="4">Thus, most broad-coverage parsers based on dependency grammar have been restricted to projective structures.</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'8'", "'104'"]
'0'
'1'
'8'
'104'
['0', '1', '8', '104']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="13" ssid="9">The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'21'", "'27'", "'62'"]
'13'
'21'
'27'
'62'
['13', '21', '27', '62']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'104'", "'109'"]
'1'
'2'
'104'
'109'
['1', '2', '104', '109']
parsed_discourse_facet ['results_citation']
<S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="49" ssid="20">The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'37'", "'49'", "'50'"]
'21'
'37'
'49'
'50'
['21', '37', '49', '50']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'17'", "'21'"]
'1'
'2'
'17'
'21'
['1', '2', '17', '21']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="13" ssid="9">The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S><S sid="39" ssid="10">However, since we want to preserve as much of the original structure as possible, we are interested in finding a transformation that involves a minimal number of lifts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'13'", "'20'", "'39'"]
'2'
'13'
'20'
'39'
['2', '13', '20', '39']
parsed_discourse_facet ['hypothesis_citation']
<S sid="14" ssid="10">While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.</S><S sid="79" ssid="6">In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.</S><S sid="92" ssid="3">Evaluation metrics used are Attachment Score (AS), i.e. the proportion of tokens that are attached to the correct head, and Exact Match (EM), i.e. the proportion of sentences for which the dependency graph exactly matches the gold standard.</S><S sid="106" ssid="17">However, the accuracy is considerably higher than previously reported results for robust non-projective parsing of Czech, with a best performance of 73% UAS (Holan, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'14'", "'79'", "'92'", "'106'"]
'14'
'79'
'92'
'106'
['14', '79', '92', '106']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="26" ssid="22">In section 2 we introduce the graph transformation techniques used to projectivize and deprojectivize dependency graphs, and in section 3 we describe the data-driven dependency parser that is the core of our system.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="105" ssid="16">Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'26'", "'27'", "'105'"]
'1'
'26'
'27'
'105'
['1', '26', '27', '105']
parsed_discourse_facet ['hypothesis_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



P05-1013
D07-1119
0
method_citation
['method_citation', 'aim_citation']



P05-1013
C08-1081
0
method_citation
['method_citation', 'aim_citation']
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
parsing: input/ref/Task1/P05-1013_swastika.csv
<S sid="49" ssid="20">The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.</S>
original cit marker offset is 0
new cit marker offset is 0



['49']
49
['49']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
parsed_discourse_facet ['method_citation']
<S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



['95']
95
['95']
parsed_discourse_facet ['result_citation']
<S sid="79" ssid="6">In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.</S>
original cit marker offset is 0
new cit marker offset is 0



['79']
79
['79']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
parsed_discourse_facet ['result_citation']
<S sid="38" ssid="9">Projectivizing a dependency graph by lifting nonprojective arcs is a nondeterministic operation in the general case.</S>
original cit marker offset is 0
new cit marker offset is 0



['38']
38
['38']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
parsed_discourse_facet ['result_citation']
<S sid="79" ssid="6">In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.</S>
original cit marker offset is 0
new cit marker offset is 0



['79']
79
['79']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
parsed_discourse_facet ['result_citation']
S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
Error in Reference Offset
S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
Error in Reference Offset
    <S sid="86" ssid="13">As expected, the most informative encoding, Head+Path, gives the highest accuracy with over 99% of all non-projective arcs being recovered correctly in both data sets.</S>
original cit marker offset is 0
new cit marker offset is 0



['86']
86
['86']
parsed_discourse_facet ['method_citation']
<S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



['95']
95
['95']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
parsed_discourse_facet ['result_citation']
 <S sid="51" ssid="22">In the second scheme, Head+Path, we in addition modify the label of every arc along the lifting path from the syntactic to the linear head so that if the original label is p the new label is p&#8595;.</S>
original cit marker offset is 0
new cit marker offset is 0



['51']
51
['51']
parsed_discourse_facet ['method_citation']
<S sid="99" ssid="10">This may seem surprising, given the experiments reported in section 4, but the explanation is probably that the non-projective dependencies that can be recovered at all are of the simple kind that only requires a single lift, where the encoding of path information is often redundant.</S>
original cit marker offset is 0
new cit marker offset is 0



['99']
99
['99']
parsed_discourse_facet ['result_citation']
<S sid="7" ssid="3">From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S>
original cit marker offset is 0
new cit marker offset is 0



['2']
2
['2']
parsed_discourse_facet ['aim_citation']
parsing: input/res/Task1/P05-1013.annv3.csv
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="61" ssid="32">Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'61'", "'62'", "'109'"]
'2'
'61'
'62'
'109'
['2', '61', '62', '109']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'62'", "'109'"]
'1'
'9'
'62'
'109'
['1', '9', '62', '109']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="3" ssid="3">Experiments using data from the Prague Dependency Treebank show that the combined system can handle nonprojective constructions with a precision sufficient to yield a significant improvement in overall parsing accuracy.</S><S sid="19" ssid="15">Finally, since non-projective constructions often involve long-distance dependencies, the problem is closely related to the recovery of empty categories and non-local dependencies in constituency-based parsing (Johnson, 2002; Dienes and Dubey, 2003; Jijkoun and de Rijke, 2004; Cahill et al., 2004; Levy and Manning, 2004; Campbell, 2004).</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'19'", "'20'"]
'2'
'3'
'19'
'20'
['2', '3', '19', '20']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'17'", "'21'"]
'1'
'2'
'17'
'21'
['1', '2', '17', '21']
parsed_discourse_facet ['results_citation']
<S sid="0">Pseudo-Projective Dependency Parsing</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'27'", "'109'"]
'0'
'2'
'27'
'109'
['0', '2', '27', '109']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'37'", "'50'", "'104'"]
'22'
'37'
'50'
'104'
['22', '37', '50', '104']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="40" ssid="11">Even this may be nondeterministic, in case the graph contains several non-projective arcs whose lifts interact, but we use the following algorithm to construct a minimal projective transformation D0 = (W, A0) of a (nonprojective) dependency graph D = (W, A): The function SMALLEST-NONP-ARC returns the non-projective arc with the shortest distance from head to dependent (breaking ties from left to right).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'40'"]
'2'
'20'
'21'
'40'
['2', '20', '21', '40']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.</S><S sid="36" ssid="7">As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'36'", "'37'", "'50'"]
'22'
'36'
'37'
'50'
['22', '36', '37', '50']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="107" ssid="18">Compared to related work on the recovery of long-distance dependencies in constituency-based parsing, our approach is similar to that of Dienes and Dubey (2003) in that the processing of non-local dependencies is partly integrated in the parsing process, via an extension of the set of syntactic categories, whereas most other approaches rely on postprocessing only.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'21'", "'62'", "'107'"]
'2'
'21'
'62'
'107'
['2', '21', '62', '107']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="105" ssid="16">Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'17'", "'62'", "'105'"]
'9'
'17'
'62'
'105'
['9', '17', '62', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="7" ssid="3">From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.</S><S sid="12" ssid="8">Prague Dependency Treebank (Haji&#711;c et al., 2001b), Danish Dependency Treebank (Kromann, 2003), and the METU Treebank of Turkish (Oflazer et al., 2003), which generally allow annotations with nonprojective dependency structures.</S><S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'7'", "'12'", "'95'"]
'2'
'7'
'12'
'95'
['2', '7', '12', '95']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="23" ssid="19">By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.</S><S sid="61" ssid="32">Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.</S><S sid="94" ssid="5">The first thing to note is that projectivizing helps in itself, even if no encoding is used, as seen from the fact that the projective baseline outperforms the non-projective training condition by more than half a percentage point on attachment score, although the gain is much smaller with respect to exact match.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'23'", "'61'", "'94'"]
'1'
'23'
'61'
'94'
['1', '23', '61', '94']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">Pseudo-Projective Dependency Parsing</S><S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="8" ssid="4">Thus, most broad-coverage parsers based on dependency grammar have been restricted to projective structures.</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'8'", "'104'"]
'0'
'1'
'8'
'104'
['0', '1', '8', '104']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="13" ssid="9">The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'21'", "'27'", "'62'"]
'13'
'21'
'27'
'62'
['13', '21', '27', '62']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'104'", "'109'"]
'1'
'2'
'104'
'109'
['1', '2', '104', '109']
parsed_discourse_facet ['results_citation']
<S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="49" ssid="20">The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'37'", "'49'", "'50'"]
'21'
'37'
'49'
'50'
['21', '37', '49', '50']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'17'", "'21'"]
'1'
'2'
'17'
'21'
['1', '2', '17', '21']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="13" ssid="9">The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S><S sid="39" ssid="10">However, since we want to preserve as much of the original structure as possible, we are interested in finding a transformation that involves a minimal number of lifts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'13'", "'20'", "'39'"]
'2'
'13'
'20'
'39'
['2', '13', '20', '39']
parsed_discourse_facet ['hypothesis_citation']
<S sid="14" ssid="10">While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.</S><S sid="79" ssid="6">In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.</S><S sid="92" ssid="3">Evaluation metrics used are Attachment Score (AS), i.e. the proportion of tokens that are attached to the correct head, and Exact Match (EM), i.e. the proportion of sentences for which the dependency graph exactly matches the gold standard.</S><S sid="106" ssid="17">However, the accuracy is considerably higher than previously reported results for robust non-projective parsing of Czech, with a best performance of 73% UAS (Holan, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'14'", "'79'", "'92'", "'106'"]
'14'
'79'
'92'
'106'
['14', '79', '92', '106']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="26" ssid="22">In section 2 we introduce the graph transformation techniques used to projectivize and deprojectivize dependency graphs, and in section 3 we describe the data-driven dependency parser that is the core of our system.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="105" ssid="16">Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'26'", "'27'", "'105'"]
'1'
'26'
'27'
'105'
['1', '26', '27', '105']
parsed_discourse_facet ['hypothesis_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



P05-1013
P08-1006
0
method_citation
['hypothesis_citation']



P05-1013
W10-1403
0
result_citation
['hypothesis_citation']
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
parsing: input/ref/Task1/P05-1013_vardha.csv
 <S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
  <S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
    <S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
  <S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
    <S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'109'"]
'109'
['109']
parsed_discourse_facet ['method_citation']
 <S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



["'95'"]
'95'
['95']
parsed_discourse_facet ['method_citation']
    <S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
    <S sid="36" ssid="7">As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
 <S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'62'"]
'62'
['62']
parsed_discourse_facet ['method_citation']
 <S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
    <S sid="23" ssid="19">By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'"]
'23'
['23']
parsed_discourse_facet ['method_citation']
 <S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
 <S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



["'95'"]
'95'
['95']
parsed_discourse_facet ['method_citation']
    <S sid="96" ssid="7">With respect to exact match, the improvement is even more noticeable, which shows quite clearly that even if non-projective dependencies are rare on the token level, they are nevertheless important for getting the global syntactic structure correct.</S>
original cit marker offset is 0
new cit marker offset is 0



["'96'"]
'96'
['96']
parsed_discourse_facet ['method_citation']
 <S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



["'95'"]
'95'
['95']
parsed_discourse_facet ['method_citation']
  <S sid="40" ssid="11">Even this may be nondeterministic, in case the graph contains several non-projective arcs whose lifts interact, but we use the following algorithm to construct a minimal projective transformation D0 = (W, A0) of a (nonprojective) dependency graph D = (W, A): The function SMALLEST-NONP-ARC returns the non-projective arc with the shortest distance from head to dependent (breaking ties from left to right).</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'"]
'40'
['40']
parsed_discourse_facet ['method_citation']
  <S sid="7" ssid="3">From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'"]
'7'
['7']
parsed_discourse_facet ['method_citation']
    <S sid="14" ssid="10">While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'14'"]
'14'
['14']
parsed_discourse_facet ['method_citation']
 <S sid="49" ssid="20">The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.</S>
original cit marker offset is 0
new cit marker offset is 0



["'49'"]
'49'
['49']
parsed_discourse_facet ['method_citation']
 <S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P05-1013.annv3.csv
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="61" ssid="32">Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'61'", "'62'", "'109'"]
'2'
'61'
'62'
'109'
['2', '61', '62', '109']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'62'", "'109'"]
'1'
'9'
'62'
'109'
['1', '9', '62', '109']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="3" ssid="3">Experiments using data from the Prague Dependency Treebank show that the combined system can handle nonprojective constructions with a precision sufficient to yield a significant improvement in overall parsing accuracy.</S><S sid="19" ssid="15">Finally, since non-projective constructions often involve long-distance dependencies, the problem is closely related to the recovery of empty categories and non-local dependencies in constituency-based parsing (Johnson, 2002; Dienes and Dubey, 2003; Jijkoun and de Rijke, 2004; Cahill et al., 2004; Levy and Manning, 2004; Campbell, 2004).</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'19'", "'20'"]
'2'
'3'
'19'
'20'
['2', '3', '19', '20']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'17'", "'21'"]
'1'
'2'
'17'
'21'
['1', '2', '17', '21']
parsed_discourse_facet ['results_citation']
<S sid="0">Pseudo-Projective Dependency Parsing</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'27'", "'109'"]
'0'
'2'
'27'
'109'
['0', '2', '27', '109']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'37'", "'50'", "'104'"]
'22'
'37'
'50'
'104'
['22', '37', '50', '104']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="40" ssid="11">Even this may be nondeterministic, in case the graph contains several non-projective arcs whose lifts interact, but we use the following algorithm to construct a minimal projective transformation D0 = (W, A0) of a (nonprojective) dependency graph D = (W, A): The function SMALLEST-NONP-ARC returns the non-projective arc with the shortest distance from head to dependent (breaking ties from left to right).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'40'"]
'2'
'20'
'21'
'40'
['2', '20', '21', '40']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.</S><S sid="36" ssid="7">As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'36'", "'37'", "'50'"]
'22'
'36'
'37'
'50'
['22', '36', '37', '50']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="107" ssid="18">Compared to related work on the recovery of long-distance dependencies in constituency-based parsing, our approach is similar to that of Dienes and Dubey (2003) in that the processing of non-local dependencies is partly integrated in the parsing process, via an extension of the set of syntactic categories, whereas most other approaches rely on postprocessing only.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'21'", "'62'", "'107'"]
'2'
'21'
'62'
'107'
['2', '21', '62', '107']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="105" ssid="16">Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'17'", "'62'", "'105'"]
'9'
'17'
'62'
'105'
['9', '17', '62', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="7" ssid="3">From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.</S><S sid="12" ssid="8">Prague Dependency Treebank (Haji&#711;c et al., 2001b), Danish Dependency Treebank (Kromann, 2003), and the METU Treebank of Turkish (Oflazer et al., 2003), which generally allow annotations with nonprojective dependency structures.</S><S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'7'", "'12'", "'95'"]
'2'
'7'
'12'
'95'
['2', '7', '12', '95']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="23" ssid="19">By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.</S><S sid="61" ssid="32">Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.</S><S sid="94" ssid="5">The first thing to note is that projectivizing helps in itself, even if no encoding is used, as seen from the fact that the projective baseline outperforms the non-projective training condition by more than half a percentage point on attachment score, although the gain is much smaller with respect to exact match.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'23'", "'61'", "'94'"]
'1'
'23'
'61'
'94'
['1', '23', '61', '94']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">Pseudo-Projective Dependency Parsing</S><S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="8" ssid="4">Thus, most broad-coverage parsers based on dependency grammar have been restricted to projective structures.</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'8'", "'104'"]
'0'
'1'
'8'
'104'
['0', '1', '8', '104']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="13" ssid="9">The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'21'", "'27'", "'62'"]
'13'
'21'
'27'
'62'
['13', '21', '27', '62']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'104'", "'109'"]
'1'
'2'
'104'
'109'
['1', '2', '104', '109']
parsed_discourse_facet ['results_citation']
<S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="49" ssid="20">The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'37'", "'49'", "'50'"]
'21'
'37'
'49'
'50'
['21', '37', '49', '50']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'17'", "'21'"]
'1'
'2'
'17'
'21'
['1', '2', '17', '21']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="13" ssid="9">The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S><S sid="39" ssid="10">However, since we want to preserve as much of the original structure as possible, we are interested in finding a transformation that involves a minimal number of lifts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'13'", "'20'", "'39'"]
'2'
'13'
'20'
'39'
['2', '13', '20', '39']
parsed_discourse_facet ['hypothesis_citation']
<S sid="14" ssid="10">While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.</S><S sid="79" ssid="6">In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.</S><S sid="92" ssid="3">Evaluation metrics used are Attachment Score (AS), i.e. the proportion of tokens that are attached to the correct head, and Exact Match (EM), i.e. the proportion of sentences for which the dependency graph exactly matches the gold standard.</S><S sid="106" ssid="17">However, the accuracy is considerably higher than previously reported results for robust non-projective parsing of Czech, with a best performance of 73% UAS (Holan, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'14'", "'79'", "'92'", "'106'"]
'14'
'79'
'92'
'106'
['14', '79', '92', '106']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="26" ssid="22">In section 2 we introduce the graph transformation techniques used to projectivize and deprojectivize dependency graphs, and in section 3 we describe the data-driven dependency parser that is the core of our system.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="105" ssid="16">Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'26'", "'27'", "'105'"]
'1'
'26'
'27'
'105'
['1', '26', '27', '105']
parsed_discourse_facet ['hypothesis_citation']



P05-1013
P08-1006
0
method_citation
['hypothesis_citation']



P05-1013
W10-1403
0
method_citation
['hypothesis_citation']



P05-1013
D07-1013
0
method_citation
['hypothesis_citation']



P05-1013
D07-1119
0
method_citation
['method_citation', 'aim_citation']



P05-1013
N07-1050
0
method_citation
['aim_citation']
parsing: input/ref/Task1/P08-1028_aakansha.csv
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'"]
'51'
['51']
parsed_discourse_facet ['method_citation']
<S sid="189" ssid="1">In this paper we presented a general framework for vector-based semantic composition.</S>
    <S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



["'189'", "'190'"]
'189'
'190'
['189', '190']
parsed_discourse_facet ['method_citation']
<S sid="185" ssid="19">The multiplicative model yields a better fit with the experimental data, &#961; = 0.17.</S>
    <S sid="186" ssid="20">The combined model is best overall with &#961; = 0.19.</S>
    <S sid="187" ssid="21">However, the difference between the two models is not statistically significant.</S>
original cit marker offset is 0
new cit marker offset is 0



["'185'", "'186'"]
'185'
'186'
['185', '186']
parsed_discourse_facet ['result_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'"]
'51'
['51']
parsed_discourse_facet ['method_citation']
<S sid="189" ssid="1">In this paper we presented a general framework for vector-based semantic composition.</S>
    <S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



["'189'", "'190'"]
'189'
'190'
['189', '190']
parsed_discourse_facet ['method_citation']
<S sid="48" ssid="21">The idea is to add not only the vectors representing the predicate and its argument but also the neighbors associated with both of them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'"]
'48'
['48']
parsed_discourse_facet ['method_citation']
<S sid="53" ssid="1">We formulate semantic composition as a function of two vectors, u and v. We assume that individual words are represented by vectors acquired from a corpus following any of the parametrisations that have been suggested in the literature.1 We briefly note here that a word&#8217;s vector typically represents its co-occurrence with neighboring words.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'53'", "'57'"]
'53'
'57'
['53', '57']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="16">Although the composition model in (5) is commonly used in the literature, from a linguistic perspective, the model in (6) is more appealing.</S>
    <S sid="69" ssid="17">Simply adding the vectors u and v lumps their contents together rather than allowing the content of one vector to pick out the relevant content of the other.</S>
    <S sid="70" ssid="18">Instead, it could be argued that the contribution of the ith component of u should be scaled according to its relevance to v, and vice versa.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'69'", "'70'"]
'68'
'69'
'70'
['68', '69', '70']
parsed_discourse_facet ['method_citation']
<S sid="189" ssid="1">In this paper we presented a general framework for vector-based semantic composition.</S>
    <S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



["'189'", "'190'"]
'189'
'190'
['189', '190']
parsed_discourse_facet ['method_citation']
<S sid="189" ssid="1">In this paper we presented a general framework for vector-based semantic composition.</S>
    <S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



["'189'", "'190'"]
'189'
'190'
['189', '190']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="20">In this paper we examine models of semantic composition that are empirically grounded and can represent similarity relations.</S>
    <S sid="25" ssid="21">We present a general framework for vector-based composition which allows us to consider different classes of models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'"]
'24'
'25'
['24', '25']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'"]
'64'
['64']
parsed_discourse_facet ['method_citation']
<S sid="176" ssid="10">The multiplicative and combined models yield means closer to the human ratings.</S>
    <S sid="177" ssid="11">The difference between High and Low similarity values estimated by these models are statistically significant (p &lt; 0.01 using the Wilcoxon rank sum test).</S>
original cit marker offset is 0
new cit marker offset is 0



["'176'", "'177'"]
'176'
'177'
['176', '177']
parsed_discourse_facet ['method_citation']
<S sid="191" ssid="3">Despite the popularity of additive models, our experimental results showed the superiority of models utilizing multiplicative combinations, at least for the sentence similarity task attempted here.</S>
original cit marker offset is 0
new cit marker offset is 0



["'191'"]
'191'
['191']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="20">In this paper we examine models of semantic composition that are empirically grounded and can represent similarity relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1028.annv3.csv
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S><S sid="194" ssid="6">Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'57'", "'194'"]
'51'
'52'
'57'
'194'
['51', '52', '57', '194']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">Moreover, the vector similarities within such semantic spaces have been shown to substantially correlate with human similarity judgments (McDonald, 2000) and word association norms (Denhire and Lemaire, 2004).</S><S sid="23" ssid="19">The downside of this approach is that differences in meaning are qualitative rather than quantitative, and degrees of similarity cannot be expressed easily.</S><S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S><S sid="87" ssid="35">Combining the multiplicative model with an additive model, which does not suffer from this problem, could mitigate this problem: pi = &#945;ui +&#946;vi +&#947;uivi (11) where &#945;, &#946;, and &#947; are weighting constants.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'23'", "'42'", "'87'"]
'10'
'23'
'42'
'87'
['10', '23', '42', '87']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">Central in these models is the notion of compositionality &#8212; the meaning of complex expressions is determined by the meanings of their constituent expressions and the rules used to combine them.</S><S sid="44" ssid="17">For example, assuming that individual words are represented by vectors, we can compute the meaning of a sentence by taking their mean (Foltz et al., 1998; Landauer and Dumais, 1997).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="138" ssid="51">Model Parameters Irrespectively of their form, all composition models discussed here are based on a semantic space for representing the meanings of individual words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'44'", "'51'", "'138'"]
'21'
'44'
'51'
'138'
['21', '44', '51', '138']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="26" ssid="22">Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.</S><S sid="27" ssid="23">Our results show that the multiplicative models are superior and correlate significantly with behavioral data.</S><S sid="90" ssid="3">He argues that the subjects of ran in The color ran and The horse ran select different senses of ran.</S><S sid="183" ssid="17">The weighted additive model (p = 0.09) is not significantly different from the baseline either or Kintsch (2001) (p = 0.09).</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'", "'90'", "'183'"]
'26'
'27'
'90'
'183'
['26', '27', '90', '183']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="50" ssid="23">The merits of different approaches are illustrated with a few hand picked examples and parameter values and large scale evaluations are uniformly absent (see Frank et al. (2007) for a criticism of Kintsch&#8217;s (2001) evaluation standards).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="75" ssid="23">An extreme form of this differential in the contribution of constituents is where one of the vectors, say u, contributes nothing at all to the combination: Admittedly the model in (8) is impoverished and rather simplistic, however it can serve as a simple baseline against which to compare more sophisticated models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'51'", "'52'", "'75'"]
'50'
'51'
'52'
'75'
['50', '51', '52', '75']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">In cognitive science vector-based models have been successful in simulating semantic priming (Lund and Burgess, 1996; Landauer and Dumais, 1997) and text comprehension (Landauer and Dumais, 1997; Foltz et al., 1998).</S><S sid="35" ssid="8">The tensor product u &#174; v is a matrix whose components are all the possible products uivj of the components of vectors u and v. A major difficulty with tensor products is their dimensionality which is higher than the dimensionality of the original vectors (precisely, the tensor product has dimensionality m x n).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'35'", "'52'", "'57'"]
'9'
'35'
'52'
'57'
['9', '35', '52', '57']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="1" ssid="1">This paper proposes a framework for representing the meaning of phrases and sentences in vector space.</S><S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S><S sid="43" ssid="16">Vector addition is by far the most common method for representing the meaning of linguistic sequences.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'42'", "'43'", "'57'"]
'1'
'42'
'43'
'57'
['1', '42', '43', '57']
parsed_discourse_facet ['hypothesis_citation']
<S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S><S sid="58" ssid="6">We define a general class of models for this process of composition as: The expression above allows us to derive models for which p is constructed in a distinct space from u and v, as is the case for tensor products.</S><S sid="59" ssid="7">It also allows us to derive models in which composition makes use of background knowledge K and models in which composition has a dependence, via the argument R, on syntax.</S><S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



["'57'", "'58'", "'59'", "'60'"]
'57'
'58'
'59'
'60'
['57', '58', '59', '60']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="74" ssid="22">As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'74'", "'168'"]
'51'
'52'
'74'
'168'
['51', '52', '74', '168']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">In cognitive science vector-based models have been successful in simulating semantic priming (Lund and Burgess, 1996; Landauer and Dumais, 1997) and text comprehension (Landauer and Dumais, 1997; Foltz et al., 1998).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'51'", "'52'", "'60'"]
'9'
'51'
'52'
'60'
['9', '51', '52', '60']
parsed_discourse_facet ['hypothesis_citation']
<S sid="38" ssid="11">The projection is defined in terms of circular convolution a mathematical function that compresses the tensor product of two vectors.</S><S sid="39" ssid="12">The compression is achieved by summing along the transdiagonal elements of the tensor product.</S><S sid="65" ssid="13">So, if we assume that only the ith components of u and v contribute to the ith component of p, that these components are not dependent on i, and that the function is symmetric with regard to the interchange of u and v, we obtain a simpler instantiation of an additive model: Analogously, under the same assumptions, we obtain the following simpler multiplicative model: only the ith components of u and v contribute to the ith component of p. Another class of models can be derived by relaxing this constraint.</S><S sid="194" ssid="6">Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'65'", "'194'"]
'38'
'39'
'65'
'194'
['38', '39', '65', '194']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">Central to our approach is vector composition which we operationalize in terms of additive and multiplicative functions.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S><S sid="174" ssid="8">The simple additive model fails to distinguish between High and Low Similarity items.</S><S sid="191" ssid="3">Despite the popularity of additive models, our experimental results showed the superiority of models utilizing multiplicative combinations, at least for the sentence similarity task attempted here.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'168'", "'174'", "'191'"]
'2'
'168'
'174'
'191'
['2', '168', '174', '191']
parsed_discourse_facet ['hypothesis_citation']
<S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S><S sid="156" ssid="69">This yielded a weighted sum consisting of 95% verb, 0% noun and 5% of their multiplicative combination.</S><S sid="174" ssid="8">The simple additive model fails to distinguish between High and Low Similarity items.</S><S sid="176" ssid="10">The multiplicative and combined models yield means closer to the human ratings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'156'", "'174'", "'176'"]
'64'
'156'
'174'
'176'
['64', '156', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="22">Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.</S><S sid="99" ssid="12">In order to establish an independent measure of sentence similarity, we assembled a set of experimental materials and elicited similarity ratings from human subjects.</S><S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S><S sid="172" ssid="6">Here, we are interested in relative differences, since the two types of ratings correspond to different scales.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'99'", "'163'", "'172'"]
'26'
'99'
'163'
'172'
['26', '99', '163', '172']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="7" ssid="3">A variety of NLP tasks have made good use of vector-based models.</S><S sid="14" ssid="10">This is illustrated in the example below taken from Landauer et al. (1997).</S><S sid="143" ssid="56">We used WordSim353, a benchmark dataset (Finkelstein et al., 2002), consisting of relatedness judgments (on a scale of 0 to 10) for 353 word pairs.</S><S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'14'", "'143'", "'163'"]
'7'
'14'
'143'
'163'
['7', '14', '143', '163']
parsed_discourse_facet ['aim_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S><S sid="164" ssid="77">A more scrupulous evaluation requires directly correlating all the individual participants&#8217; similarity judgments with those of the models.6 We used Spearman&#8217;s p for our correlation analyses.</S><S sid="182" ssid="16">The lowest correlation (p = 0.04) is observed for the simple additive model which is not significantly different from the non-compositional baseline model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'64'", "'164'", "'182'"]
'51'
'64'
'164'
'182'
['51', '64', '164', '182']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="74" ssid="22">As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'74'", "'168'"]
'51'
'52'
'74'
'168'
['51', '52', '74', '168']
parsed_discourse_facet ['method_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



P08-1028
D08-1094
0
method_citation
['method_citation']



P08-1028
D11-1094
0
method_citation
['method_citation']
IGNORE THIS: Key error 5
parsing: input/ref/Task1/P08-1028_swastika.csv
<S sid="21" ssid="17">Central in these models is the notion of compositionality &#8212; the meaning of complex expressions is determined by the meanings of their constituent expressions and the rules used to combine them.</S>
original cit marker offset is 0
new cit marker offset is 0



['21']
21
['21']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="23">Our results show that the multiplicative models are superior and correlate significantly with behavioral data.</S>
original cit marker offset is 0
new cit marker offset is 0



['27']
27
['27']
parsed_discourse_facet ['result_citation']
<S sid="189" ssid="1">In this paper we presented a general framework for vector-based semantic composition.</S>
original cit marker offset is 0
new cit marker offset is 0



['189']
189
['189']
parsed_discourse_facet ['aim_citation']
<S sid="53" ssid="1">We formulate semantic composition as a function of two vectors, u and v. We assume that individual words are represented by vectors acquired from a corpus following any of the parametrisations that have been suggested in the literature.1 We briefly note here that a word&#8217;s vector typically represents its co-occurrence with neighboring words.</S>
original cit marker offset is 0
new cit marker offset is 0



['53']
53
['53']
parsed_discourse_facet ['method_citation']
<S sid="76" ssid="24">The models considered so far assume that components do not &#8216;interfere&#8217; with each other, i.e., that It is also possible to re-introduce the dependence on K into the model of vector composition.</S>
original cit marker offset is 0
new cit marker offset is 0



['76']
76
['76']
parsed_discourse_facet ['method_citation']
<S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



['57']
57
['57']
parsed_discourse_facet ['method_citation']
<S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



['57']
57
['57']
parsed_discourse_facet ['method_citation']
<S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



['190']
190
['190']
parsed_discourse_facet ['result_citation']
<S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



['60']
60
['60']
parsed_discourse_facet ['method_citation']
<S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



['190']
190
['190']
parsed_discourse_facet ['result_citation']
<S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



['190']
190
['190']
parsed_discourse_facet ['result_citation']
<S sid="73" ssid="21">Relaxing the assumption of symmetry in the case of the simple additive model produces a model which weighs the contribution of the two components differently: This allows additive models to become more syntax aware, since semantically important constituents can participate more actively in the composition.</S>
original cit marker offset is 0
new cit marker offset is 0



['73']
73
['73']
parsed_discourse_facet ['result_citation']
<S sid="99" ssid="12">In order to establish an independent measure of sentence similarity, we assembled a set of experimental materials and elicited similarity ratings from human subjects.</S>
original cit marker offset is 0
new cit marker offset is 0



['99']
99
['99']
parsed_discourse_facet ['method_citation']
<S sid="189" ssid="1">In this paper we presented a general framework for vector-based semantic composition.</S>
original cit marker offset is 0
new cit marker offset is 0



['189']
189
['189']
parsed_discourse_facet ['aim_citation']
<S sid="191" ssid="3">Despite the popularity of additive models, our experimental results showed the superiority of models utilizing multiplicative combinations, at least for the sentence similarity task attempted here.</S>
original cit marker offset is 0
new cit marker offset is 0



['191']
191
['191']
parsed_discourse_facet ['result_citation']
<S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



['190']
190
['190']
parsed_discourse_facet ['result_citation']
parsing: input/res/Task1/P08-1028.annv3.csv
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S><S sid="194" ssid="6">Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'57'", "'194'"]
'51'
'52'
'57'
'194'
['51', '52', '57', '194']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">Moreover, the vector similarities within such semantic spaces have been shown to substantially correlate with human similarity judgments (McDonald, 2000) and word association norms (Denhire and Lemaire, 2004).</S><S sid="23" ssid="19">The downside of this approach is that differences in meaning are qualitative rather than quantitative, and degrees of similarity cannot be expressed easily.</S><S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S><S sid="87" ssid="35">Combining the multiplicative model with an additive model, which does not suffer from this problem, could mitigate this problem: pi = &#945;ui +&#946;vi +&#947;uivi (11) where &#945;, &#946;, and &#947; are weighting constants.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'23'", "'42'", "'87'"]
'10'
'23'
'42'
'87'
['10', '23', '42', '87']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">Central in these models is the notion of compositionality &#8212; the meaning of complex expressions is determined by the meanings of their constituent expressions and the rules used to combine them.</S><S sid="44" ssid="17">For example, assuming that individual words are represented by vectors, we can compute the meaning of a sentence by taking their mean (Foltz et al., 1998; Landauer and Dumais, 1997).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="138" ssid="51">Model Parameters Irrespectively of their form, all composition models discussed here are based on a semantic space for representing the meanings of individual words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'44'", "'51'", "'138'"]
'21'
'44'
'51'
'138'
['21', '44', '51', '138']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="26" ssid="22">Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.</S><S sid="27" ssid="23">Our results show that the multiplicative models are superior and correlate significantly with behavioral data.</S><S sid="90" ssid="3">He argues that the subjects of ran in The color ran and The horse ran select different senses of ran.</S><S sid="183" ssid="17">The weighted additive model (p = 0.09) is not significantly different from the baseline either or Kintsch (2001) (p = 0.09).</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'", "'90'", "'183'"]
'26'
'27'
'90'
'183'
['26', '27', '90', '183']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="50" ssid="23">The merits of different approaches are illustrated with a few hand picked examples and parameter values and large scale evaluations are uniformly absent (see Frank et al. (2007) for a criticism of Kintsch&#8217;s (2001) evaluation standards).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="75" ssid="23">An extreme form of this differential in the contribution of constituents is where one of the vectors, say u, contributes nothing at all to the combination: Admittedly the model in (8) is impoverished and rather simplistic, however it can serve as a simple baseline against which to compare more sophisticated models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'51'", "'52'", "'75'"]
'50'
'51'
'52'
'75'
['50', '51', '52', '75']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">In cognitive science vector-based models have been successful in simulating semantic priming (Lund and Burgess, 1996; Landauer and Dumais, 1997) and text comprehension (Landauer and Dumais, 1997; Foltz et al., 1998).</S><S sid="35" ssid="8">The tensor product u &#174; v is a matrix whose components are all the possible products uivj of the components of vectors u and v. A major difficulty with tensor products is their dimensionality which is higher than the dimensionality of the original vectors (precisely, the tensor product has dimensionality m x n).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'35'", "'52'", "'57'"]
'9'
'35'
'52'
'57'
['9', '35', '52', '57']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="1" ssid="1">This paper proposes a framework for representing the meaning of phrases and sentences in vector space.</S><S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S><S sid="43" ssid="16">Vector addition is by far the most common method for representing the meaning of linguistic sequences.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'42'", "'43'", "'57'"]
'1'
'42'
'43'
'57'
['1', '42', '43', '57']
parsed_discourse_facet ['hypothesis_citation']
<S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S><S sid="58" ssid="6">We define a general class of models for this process of composition as: The expression above allows us to derive models for which p is constructed in a distinct space from u and v, as is the case for tensor products.</S><S sid="59" ssid="7">It also allows us to derive models in which composition makes use of background knowledge K and models in which composition has a dependence, via the argument R, on syntax.</S><S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



["'57'", "'58'", "'59'", "'60'"]
'57'
'58'
'59'
'60'
['57', '58', '59', '60']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="74" ssid="22">As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'74'", "'168'"]
'51'
'52'
'74'
'168'
['51', '52', '74', '168']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">In cognitive science vector-based models have been successful in simulating semantic priming (Lund and Burgess, 1996; Landauer and Dumais, 1997) and text comprehension (Landauer and Dumais, 1997; Foltz et al., 1998).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'51'", "'52'", "'60'"]
'9'
'51'
'52'
'60'
['9', '51', '52', '60']
parsed_discourse_facet ['hypothesis_citation']
<S sid="38" ssid="11">The projection is defined in terms of circular convolution a mathematical function that compresses the tensor product of two vectors.</S><S sid="39" ssid="12">The compression is achieved by summing along the transdiagonal elements of the tensor product.</S><S sid="65" ssid="13">So, if we assume that only the ith components of u and v contribute to the ith component of p, that these components are not dependent on i, and that the function is symmetric with regard to the interchange of u and v, we obtain a simpler instantiation of an additive model: Analogously, under the same assumptions, we obtain the following simpler multiplicative model: only the ith components of u and v contribute to the ith component of p. Another class of models can be derived by relaxing this constraint.</S><S sid="194" ssid="6">Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'65'", "'194'"]
'38'
'39'
'65'
'194'
['38', '39', '65', '194']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">Central to our approach is vector composition which we operationalize in terms of additive and multiplicative functions.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S><S sid="174" ssid="8">The simple additive model fails to distinguish between High and Low Similarity items.</S><S sid="191" ssid="3">Despite the popularity of additive models, our experimental results showed the superiority of models utilizing multiplicative combinations, at least for the sentence similarity task attempted here.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'168'", "'174'", "'191'"]
'2'
'168'
'174'
'191'
['2', '168', '174', '191']
parsed_discourse_facet ['hypothesis_citation']
<S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S><S sid="156" ssid="69">This yielded a weighted sum consisting of 95% verb, 0% noun and 5% of their multiplicative combination.</S><S sid="174" ssid="8">The simple additive model fails to distinguish between High and Low Similarity items.</S><S sid="176" ssid="10">The multiplicative and combined models yield means closer to the human ratings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'156'", "'174'", "'176'"]
'64'
'156'
'174'
'176'
['64', '156', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="22">Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.</S><S sid="99" ssid="12">In order to establish an independent measure of sentence similarity, we assembled a set of experimental materials and elicited similarity ratings from human subjects.</S><S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S><S sid="172" ssid="6">Here, we are interested in relative differences, since the two types of ratings correspond to different scales.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'99'", "'163'", "'172'"]
'26'
'99'
'163'
'172'
['26', '99', '163', '172']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="7" ssid="3">A variety of NLP tasks have made good use of vector-based models.</S><S sid="14" ssid="10">This is illustrated in the example below taken from Landauer et al. (1997).</S><S sid="143" ssid="56">We used WordSim353, a benchmark dataset (Finkelstein et al., 2002), consisting of relatedness judgments (on a scale of 0 to 10) for 353 word pairs.</S><S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'14'", "'143'", "'163'"]
'7'
'14'
'143'
'163'
['7', '14', '143', '163']
parsed_discourse_facet ['aim_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S><S sid="164" ssid="77">A more scrupulous evaluation requires directly correlating all the individual participants&#8217; similarity judgments with those of the models.6 We used Spearman&#8217;s p for our correlation analyses.</S><S sid="182" ssid="16">The lowest correlation (p = 0.04) is observed for the simple additive model which is not significantly different from the non-compositional baseline model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'64'", "'164'", "'182'"]
'51'
'64'
'164'
'182'
['51', '64', '164', '182']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="74" ssid="22">As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'74'", "'168'"]
'51'
'52'
'74'
'168'
['51', '52', '74', '168']
parsed_discourse_facet ['method_citation']



P08-1028
W11-0131
0
method_citation
['hypothesis_citation']



P08-1028
W11-0115
0
method_citation
['method_citation', 'aim_citation']
parsing: input/ref/Task1/P08-1028_sweta.csv
<S sid="65" ssid="13">So, if we assume that only the ith components of u and v contribute to the ith component of p, that these components are not dependent on i, and that the function is symmetric with regard to the interchange of u and v, we obtain a simpler instantiation of an additive model: Analogously, under the same assumptions, we obtain the following simpler multiplicative model: only the ith components of u and v contribute to the ith component of p. Another class of models can be derived by relaxing this constraint.</S>
original cit marker offset is 0
new cit marker offset is 0



["65'"]
65'
['65']
parsed_discourse_facet ['method_citation']
 <S sid="75" ssid="23">An extreme form of this differential in the contribution of constituents is where one of the vectors, say u, contributes nothing at all to the combination: Admittedly the model in (8) is impoverished and rather simplistic, however it can serve as a simple baseline against which to compare more sophisticated models.</S>
original cit marker offset is 0
new cit marker offset is 0



["75'"]
75'
['75']
parsed_discourse_facet ['method_citation']
<S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S>
original cit marker offset is 0
new cit marker offset is 0



["42'"]
42'
['42']
parsed_discourse_facet ['method_citation']
 <S sid="21" ssid="17">Central in these models is the notion of compositionality &#8212; the meaning of complex expressions is determined by the meanings of their constituent expressions and the rules used to combine them.</S>
original cit marker offset is 0
new cit marker offset is 0



["21'"]
21'
['21']
parsed_discourse_facet ['method_citation']
    <S sid="195" ssid="7">The resulting vector is sparser but expresses more succinctly the meaning of the predicate-argument structure, and thus allows semantic similarity to be modelled more accurately.</S>
original cit marker offset is 0
new cit marker offset is 0



["195'"]
195'
['195']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="21">We present a general framework for vector-based composition which allows us to consider different classes of models.</S>
original cit marker offset is 0
new cit marker offset is 0



["25'"]
25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="21">We present a general framework for vector-based composition which allows us to consider different classes of models.</S>
original cit marker offset is 0
new cit marker offset is 0



["25'"]
25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["57'"]
57'
['57']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S>
original cit marker offset is 0
new cit marker offset is 0



["51'"]
51'
['51']
parsed_discourse_facet ['method_citation']
<S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



["190'"]
190'
['190']
parsed_discourse_facet ['method_citation']
 <S sid="29" ssid="2">While neural networks can readily represent single distinct objects, in the case of multiple objects there are fundamental difficulties in keeping track of which features are bound to which objects.</S>
original cit marker offset is 0
new cit marker offset is 0



["29'"]
29'
['29']
parsed_discourse_facet ['method_citation']
    <S sid="38" ssid="11">The projection is defined in terms of circular convolution a mathematical function that compresses the tensor product of two vectors.</S>
original cit marker offset is 0
new cit marker offset is 0



["38'"]
38'
['38']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S>
original cit marker offset is 0
new cit marker offset is 0



["51'"]
51'
['51']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S>
original cit marker offset is 0
new cit marker offset is 0



["64'"]
64'
['64']
parsed_discourse_facet ['method_citation']
<S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["163'"]
163'
['163']
parsed_discourse_facet ['method_citation']
<S sid="185" ssid="19">The multiplicative model yields a better fit with the experimental data, &#961; = 0.17.</S>
original cit marker offset is 0
new cit marker offset is 0



["185'"]
185'
['185']
parsed_discourse_facet ['method_citation']
<S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



["190'"]
190'
['190']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1028.annv3.csv
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S><S sid="194" ssid="6">Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'57'", "'194'"]
'51'
'52'
'57'
'194'
['51', '52', '57', '194']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">Moreover, the vector similarities within such semantic spaces have been shown to substantially correlate with human similarity judgments (McDonald, 2000) and word association norms (Denhire and Lemaire, 2004).</S><S sid="23" ssid="19">The downside of this approach is that differences in meaning are qualitative rather than quantitative, and degrees of similarity cannot be expressed easily.</S><S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S><S sid="87" ssid="35">Combining the multiplicative model with an additive model, which does not suffer from this problem, could mitigate this problem: pi = &#945;ui +&#946;vi +&#947;uivi (11) where &#945;, &#946;, and &#947; are weighting constants.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'23'", "'42'", "'87'"]
'10'
'23'
'42'
'87'
['10', '23', '42', '87']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">Central in these models is the notion of compositionality &#8212; the meaning of complex expressions is determined by the meanings of their constituent expressions and the rules used to combine them.</S><S sid="44" ssid="17">For example, assuming that individual words are represented by vectors, we can compute the meaning of a sentence by taking their mean (Foltz et al., 1998; Landauer and Dumais, 1997).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="138" ssid="51">Model Parameters Irrespectively of their form, all composition models discussed here are based on a semantic space for representing the meanings of individual words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'44'", "'51'", "'138'"]
'21'
'44'
'51'
'138'
['21', '44', '51', '138']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="26" ssid="22">Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.</S><S sid="27" ssid="23">Our results show that the multiplicative models are superior and correlate significantly with behavioral data.</S><S sid="90" ssid="3">He argues that the subjects of ran in The color ran and The horse ran select different senses of ran.</S><S sid="183" ssid="17">The weighted additive model (p = 0.09) is not significantly different from the baseline either or Kintsch (2001) (p = 0.09).</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'", "'90'", "'183'"]
'26'
'27'
'90'
'183'
['26', '27', '90', '183']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="50" ssid="23">The merits of different approaches are illustrated with a few hand picked examples and parameter values and large scale evaluations are uniformly absent (see Frank et al. (2007) for a criticism of Kintsch&#8217;s (2001) evaluation standards).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="75" ssid="23">An extreme form of this differential in the contribution of constituents is where one of the vectors, say u, contributes nothing at all to the combination: Admittedly the model in (8) is impoverished and rather simplistic, however it can serve as a simple baseline against which to compare more sophisticated models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'51'", "'52'", "'75'"]
'50'
'51'
'52'
'75'
['50', '51', '52', '75']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">In cognitive science vector-based models have been successful in simulating semantic priming (Lund and Burgess, 1996; Landauer and Dumais, 1997) and text comprehension (Landauer and Dumais, 1997; Foltz et al., 1998).</S><S sid="35" ssid="8">The tensor product u &#174; v is a matrix whose components are all the possible products uivj of the components of vectors u and v. A major difficulty with tensor products is their dimensionality which is higher than the dimensionality of the original vectors (precisely, the tensor product has dimensionality m x n).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'35'", "'52'", "'57'"]
'9'
'35'
'52'
'57'
['9', '35', '52', '57']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="1" ssid="1">This paper proposes a framework for representing the meaning of phrases and sentences in vector space.</S><S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S><S sid="43" ssid="16">Vector addition is by far the most common method for representing the meaning of linguistic sequences.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'42'", "'43'", "'57'"]
'1'
'42'
'43'
'57'
['1', '42', '43', '57']
parsed_discourse_facet ['hypothesis_citation']
<S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S><S sid="58" ssid="6">We define a general class of models for this process of composition as: The expression above allows us to derive models for which p is constructed in a distinct space from u and v, as is the case for tensor products.</S><S sid="59" ssid="7">It also allows us to derive models in which composition makes use of background knowledge K and models in which composition has a dependence, via the argument R, on syntax.</S><S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



["'57'", "'58'", "'59'", "'60'"]
'57'
'58'
'59'
'60'
['57', '58', '59', '60']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="74" ssid="22">As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'74'", "'168'"]
'51'
'52'
'74'
'168'
['51', '52', '74', '168']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">In cognitive science vector-based models have been successful in simulating semantic priming (Lund and Burgess, 1996; Landauer and Dumais, 1997) and text comprehension (Landauer and Dumais, 1997; Foltz et al., 1998).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'51'", "'52'", "'60'"]
'9'
'51'
'52'
'60'
['9', '51', '52', '60']
parsed_discourse_facet ['hypothesis_citation']
<S sid="38" ssid="11">The projection is defined in terms of circular convolution a mathematical function that compresses the tensor product of two vectors.</S><S sid="39" ssid="12">The compression is achieved by summing along the transdiagonal elements of the tensor product.</S><S sid="65" ssid="13">So, if we assume that only the ith components of u and v contribute to the ith component of p, that these components are not dependent on i, and that the function is symmetric with regard to the interchange of u and v, we obtain a simpler instantiation of an additive model: Analogously, under the same assumptions, we obtain the following simpler multiplicative model: only the ith components of u and v contribute to the ith component of p. Another class of models can be derived by relaxing this constraint.</S><S sid="194" ssid="6">Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'65'", "'194'"]
'38'
'39'
'65'
'194'
['38', '39', '65', '194']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">Central to our approach is vector composition which we operationalize in terms of additive and multiplicative functions.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S><S sid="174" ssid="8">The simple additive model fails to distinguish between High and Low Similarity items.</S><S sid="191" ssid="3">Despite the popularity of additive models, our experimental results showed the superiority of models utilizing multiplicative combinations, at least for the sentence similarity task attempted here.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'168'", "'174'", "'191'"]
'2'
'168'
'174'
'191'
['2', '168', '174', '191']
parsed_discourse_facet ['hypothesis_citation']
<S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S><S sid="156" ssid="69">This yielded a weighted sum consisting of 95% verb, 0% noun and 5% of their multiplicative combination.</S><S sid="174" ssid="8">The simple additive model fails to distinguish between High and Low Similarity items.</S><S sid="176" ssid="10">The multiplicative and combined models yield means closer to the human ratings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'156'", "'174'", "'176'"]
'64'
'156'
'174'
'176'
['64', '156', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="22">Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.</S><S sid="99" ssid="12">In order to establish an independent measure of sentence similarity, we assembled a set of experimental materials and elicited similarity ratings from human subjects.</S><S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S><S sid="172" ssid="6">Here, we are interested in relative differences, since the two types of ratings correspond to different scales.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'99'", "'163'", "'172'"]
'26'
'99'
'163'
'172'
['26', '99', '163', '172']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="7" ssid="3">A variety of NLP tasks have made good use of vector-based models.</S><S sid="14" ssid="10">This is illustrated in the example below taken from Landauer et al. (1997).</S><S sid="143" ssid="56">We used WordSim353, a benchmark dataset (Finkelstein et al., 2002), consisting of relatedness judgments (on a scale of 0 to 10) for 353 word pairs.</S><S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'14'", "'143'", "'163'"]
'7'
'14'
'143'
'163'
['7', '14', '143', '163']
parsed_discourse_facet ['aim_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S><S sid="164" ssid="77">A more scrupulous evaluation requires directly correlating all the individual participants&#8217; similarity judgments with those of the models.6 We used Spearman&#8217;s p for our correlation analyses.</S><S sid="182" ssid="16">The lowest correlation (p = 0.04) is observed for the simple additive model which is not significantly different from the non-compositional baseline model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'64'", "'164'", "'182'"]
'51'
'64'
'164'
'182'
['51', '64', '164', '182']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="74" ssid="22">As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'74'", "'168'"]
'51'
'52'
'74'
'168'
['51', '52', '74', '168']
parsed_discourse_facet ['method_citation']



P08-1028
P14-1060
0
method_citation
['hypothesis_citation']



P08-1028
W11-0131
0
method_citation
['hypothesis_citation']



P08-1028
P10-1021
0
method_citation
['method_citation']



P08-1028
W11-0115
0
method_citation
['method_citation', 'aim_citation']
parsing: input/ref/Task1/P08-1043_aakansha.csv
<S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'94'"]
'94'
['94']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'"]
'4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'"]
'4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="69" ssid="1">We represent all morphological analyses of a given utterance using a lattice structure.</S>
    <S sid="70" ssid="2">Each lattice arc corresponds to a segment and its corresponding PoS tag, and a path through the lattice corresponds to a specific morphological segmentation of the utterance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'69'", "'70'"]
'69'
'70'
['69', '70']
parsed_discourse_facet ['method_citation']
<S sid="85" ssid="17">The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.</S>
original cit marker offset is 0
new cit marker offset is 0



["'85'"]
'85'
['85']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'94'"]
'94'
['94']
parsed_discourse_facet ['method_citation']
<S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S>
    <S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training 	similar to (Cohen and Smith, 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'134'"]
'133'
'134'
['133', '134']
parsed_discourse_facet ['method_citation']
<S sid="85" ssid="17">The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.</S>
original cit marker offset is 0
new cit marker offset is 0



["'85'"]
'85'
['85']
parsed_discourse_facet ['method_citation']
<S sid="155" ssid="33">Evaluation We use 8 different measures to evaluate the performance of our system on the joint disambiguation task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'155'"]
'155'
['155']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1043.annv3.csv
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="35" ssid="14">The form fmnh, for example, can be understood as the verb &#8220;lubricated&#8221;, the possessed noun &#8220;her oil&#8221;, the adjective &#8220;fat&#8221; or the verb &#8220;got fat&#8221;.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="98" ssid="30">The Grammar Our parser looks for the most likely tree spanning a single path through the lattice of which the yield is a sequence of lexemes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'35'", "'49'", "'98'"]
'33'
'35'
'49'
'98'
['33', '35', '49', '98']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity.</S><S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S><S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'4'", "'18'", "'49'"]
'3'
'4'
'18'
'49'
['3', '4', '18', '49']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S><S sid="65" ssid="12">A possible probabilistic model for assigning probabilities to complex analyses of a surface form may be and indeed recent sequential disambiguation models for Hebrew (Adler and Elhadad, 2006) and Arabic (Smith et al., 2005) present similar models.</S><S sid="82" ssid="14">In sequential tagging models such as (Adler and Elhadad, 2006; Bar-Haim et al., 2007; Smith et al., 2005) weights are assigned according to a language model The input for the joint task is a sequence W = w1, ... , wn of space-delimited tokens.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'65'", "'82'"]
'20'
'21'
'65'
'82'
['20', '21', '65', '82']
parsed_discourse_facet ['aim_citation']
<S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="52" ssid="10">Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.</S><S sid="175" ssid="13">In our model there are no such hyper-parameters, and the performance is the result of truly joint disambiguation. sults.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'20'", "'52'", "'175'"]
'18'
'20'
'52'
'175'
['18', '20', '52', '175']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S><S sid="47" ssid="5">Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'47'", "'48'", "'49'"]
'4'
'47'
'48'
'49'
['4', '47', '48', '49']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="47" ssid="5">Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'47'", "'48'", "'49'"]
'33'
'47'
'48'
'49'
['33', '47', '48', '49']
parsed_discourse_facet ['aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S><S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S><S sid="106" ssid="38">Handling Unknown tokens When handling unknown tokens in a language such as Hebrew various important aspects have to be borne in mind.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'86'", "'94'", "'106'"]
'33'
'86'
'94'
'106'
['33', '86', '94', '106']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="85" ssid="17">The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.</S><S sid="192" ssid="6">Using a wide-coverage morphological analyzer based on (Itai et al., 2006) should cater for a better coverage, and incorporating lexical probabilities learned from a big (unannotated) corpus (cf.</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'85'", "'192'", "'193'"]
'33'
'85'
'192'
'193'
['33', '85', '192', '193']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="0">A Single Generative Model for Joint Morphological Segmentation and Syntactic Parsing</S><S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S><S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'18'", "'19'", "'20'"]
'0'
'18'
'19'
'20'
['0', '18', '19', '20']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="71" ssid="3">This is by now a fairly standard representation for multiple morphological segmentation of Hebrew utterances (Adler, 2001; Bar-Haim et al., 2005; Smith et al., 2005; Cohen and Smith, 2007; Adler, 2007).</S><S sid="141" ssid="19">This analyzer setting is similar to that of (Cohen and Smith, 2007), and models using it are denoted nohsp, Parser and Grammar We used BitPar (Schmid, 2004), an efficient general purpose parser,10 together with various treebank grammars to parse the input sentences and propose compatible morphological segmentation and syntactic analysis.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'49'", "'71'", "'141'"]
'21'
'49'
'71'
'141'
['21', '49', '71', '141']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="159" ssid="37">Our parsing performance measures (SY N) thus report the PARSEVAL extension proposed in Tsarfaty (2006).</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'49'", "'159'", "'193'"]
'33'
'49'
'159'
'193'
['33', '49', '159', '193']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="151" ssid="29">In our third model GTppp we also add the distinction between general PPs and possessive PPs following Goldberg and Elhadad (2007).</S><S sid="152" ssid="30">In our forth model GTnph we add the definiteness status of constituents following Tsarfaty and Sima&#8217;an (2007).</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'151'", "'152'", "'193'"]
'33'
'151'
'152'
'193'
['33', '151', '152', '193']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="52" ssid="10">Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.</S><S sid="158" ssid="36">Evaluating parsing results in our joint framework, as argued by Tsarfaty (2006), is not trivial under the joint disambiguation task, as the hypothesized yield need not coincide with the correct one.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'48'", "'52'", "'158'"]
'20'
'48'
'52'
'158'
['20', '48', '52', '158']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="51" ssid="9">Tsarfaty (2006) used a morphological analyzer (Segal, 2000), a PoS tagger (Bar-Haim et al., 2005), and a general purpose parser (Schmid, 2000) in an integrated framework in which morphological and syntactic components interact to share information, leading to improved performance on the joint task.</S><S sid="132" ssid="10">(we ignored the 419 trees in their development set.)</S><S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S><S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'132'", "'133'", "'134'"]
'51'
'132'
'133'
'134'
['51', '132', '133', '134']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S><S sid="112" ssid="44">We first make use of our morphological analyzer to find all segmentation possibilities by chopping off all prefix sequence possibilities (including the empty prefix) and construct a lattice off of them.</S><S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S><S sid="140" ssid="18">For these models we limit the options provided for OOV words by not considering the entire token as a valid segmentation in case at least some prefix segmentation exists.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'", "'112'", "'133'", "'140'"]
'86'
'112'
'133'
'140'
['86', '112', '133', '140']
parsed_discourse_facet ['method_citation']
<S sid="123" ssid="1">Previous work on morphological and syntactic disambiguation in Hebrew used different sets of data, different splits, differing annotation schemes, and different evaluation measures.</S><S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S><S sid="154" ssid="32">For all grammars, we use fine-grained PoS tags indicating various morphological features annotated therein.</S><S sid="155" ssid="33">Evaluation We use 8 different measures to evaluate the performance of our system on the joint disambiguation task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'123'", "'134'", "'154'", "'155'"]
'123'
'134'
'154'
'155'
['123', '134', '154', '155']
parsed_discourse_facet ['results_citation']



P08-1043
P11-1141
0
method_citation
['hypothesis_citation']



P08-1043
W10-1404
0
method_citation
['hypothesis_citation']



P08-1043
P12-2002
0
method_citation
['method_citation', 'hypothesis_citation']



P08-1043
D12-1046
0
method_citation
['hypothesis_citation']



P08-1043
E09-1038
0
method_citation
['results_citation']
parsing: input/ref/Task1/P08-1043_swastika.csv
    <S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S>
original cit marker offset is 0
new cit marker offset is 0



['94']
94
['94']
parsed_discourse_facet ['aim_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S>
original cit marker offset is 0
new cit marker offset is 0



['4']
4
['4']
parsed_discourse_facet ['result_citation']
    <S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S>
original cit marker offset is 0
new cit marker offset is 0



['94']
94
['94']
parsed_discourse_facet ['method_citation']
    <S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



['19']
19
['19']
parsed_discourse_facet ['method_citation']
    <S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



['19']
19
['19']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S>
original cit marker offset is 0
new cit marker offset is 0



['4']
4
['4']
parsed_discourse_facet ['result_citation']
<S sid="105" ssid="37">3An English sentence with ambiguous PoS assignment can be trivially represented as a lattice similar to our own, where every pair of consecutive nodes correspond to a word, and every possible PoS assignment for this word is a connecting arc.</S>
original cit marker offset is 0
new cit marker offset is 0



['105']
105
['105']
parsed_discourse_facet ['method_citation']
    <S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



['19']
19
['19']
parsed_discourse_facet ['method_citation']
    <S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



['19']
19
['19']
parsed_discourse_facet ['method_citation']
<S sid="163" ssid="1">The accuracy results for segmentation, tagging and parsing using our different models and our standard data split are summarized in Table 1.</S>
original cit marker offset is 0
new cit marker offset is 0



['163']
163
['163']
parsed_discourse_facet ['result_citation']
    <S sid="100" ssid="32">This means that the rules in our grammar are of two kinds: (a) syntactic rules relating nonterminals to a sequence of non-terminals and/or PoS tags, and (b) lexical rules relating PoS tags to lattice arcs (lexemes).</S>
original cit marker offset is 0
new cit marker offset is 0



['100']
100
['100']
parsed_discourse_facet ['method_citation']
    <S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S>
original cit marker offset is 0
new cit marker offset is 0



['94']
94
['94']
parsed_discourse_facet ['result_citation']
<S sid="188" ssid="2">The overall performance of our joint framework demonstrates that a probability distribution obtained over mere syntactic contexts using a Treebank grammar and a data-driven lexicon outperforms upper bounds proposed by previous joint disambiguation systems and achieves segmentation and parsing results on a par with state-of-the-art standalone applications results.</S>
original cit marker offset is 0
new cit marker offset is 0



['188']
188
['188']
parsed_discourse_facet ['result_citation']
<S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S>
original cit marker offset is 0
new cit marker offset is 0



['86']
86
['86']
parsed_discourse_facet ['result_citation']
<S sid="97" ssid="29">Thus our proposed model is a proper model assigning probability mass to all (7r, L) pairs, where 7r is a parse tree and L is the one and only lattice that a sequence of characters (and spaces) W over our alpha-beth gives rise to.</S>
original cit marker offset is 0
new cit marker offset is 0



['97']
97
['97']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1043.annv3.csv
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="35" ssid="14">The form fmnh, for example, can be understood as the verb &#8220;lubricated&#8221;, the possessed noun &#8220;her oil&#8221;, the adjective &#8220;fat&#8221; or the verb &#8220;got fat&#8221;.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="98" ssid="30">The Grammar Our parser looks for the most likely tree spanning a single path through the lattice of which the yield is a sequence of lexemes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'35'", "'49'", "'98'"]
'33'
'35'
'49'
'98'
['33', '35', '49', '98']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity.</S><S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S><S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'4'", "'18'", "'49'"]
'3'
'4'
'18'
'49'
['3', '4', '18', '49']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S><S sid="65" ssid="12">A possible probabilistic model for assigning probabilities to complex analyses of a surface form may be and indeed recent sequential disambiguation models for Hebrew (Adler and Elhadad, 2006) and Arabic (Smith et al., 2005) present similar models.</S><S sid="82" ssid="14">In sequential tagging models such as (Adler and Elhadad, 2006; Bar-Haim et al., 2007; Smith et al., 2005) weights are assigned according to a language model The input for the joint task is a sequence W = w1, ... , wn of space-delimited tokens.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'65'", "'82'"]
'20'
'21'
'65'
'82'
['20', '21', '65', '82']
parsed_discourse_facet ['aim_citation']
<S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="52" ssid="10">Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.</S><S sid="175" ssid="13">In our model there are no such hyper-parameters, and the performance is the result of truly joint disambiguation. sults.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'20'", "'52'", "'175'"]
'18'
'20'
'52'
'175'
['18', '20', '52', '175']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S><S sid="47" ssid="5">Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'47'", "'48'", "'49'"]
'4'
'47'
'48'
'49'
['4', '47', '48', '49']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="47" ssid="5">Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'47'", "'48'", "'49'"]
'33'
'47'
'48'
'49'
['33', '47', '48', '49']
parsed_discourse_facet ['aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S><S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S><S sid="106" ssid="38">Handling Unknown tokens When handling unknown tokens in a language such as Hebrew various important aspects have to be borne in mind.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'86'", "'94'", "'106'"]
'33'
'86'
'94'
'106'
['33', '86', '94', '106']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="85" ssid="17">The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.</S><S sid="192" ssid="6">Using a wide-coverage morphological analyzer based on (Itai et al., 2006) should cater for a better coverage, and incorporating lexical probabilities learned from a big (unannotated) corpus (cf.</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'85'", "'192'", "'193'"]
'33'
'85'
'192'
'193'
['33', '85', '192', '193']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="0">A Single Generative Model for Joint Morphological Segmentation and Syntactic Parsing</S><S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S><S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'18'", "'19'", "'20'"]
'0'
'18'
'19'
'20'
['0', '18', '19', '20']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="71" ssid="3">This is by now a fairly standard representation for multiple morphological segmentation of Hebrew utterances (Adler, 2001; Bar-Haim et al., 2005; Smith et al., 2005; Cohen and Smith, 2007; Adler, 2007).</S><S sid="141" ssid="19">This analyzer setting is similar to that of (Cohen and Smith, 2007), and models using it are denoted nohsp, Parser and Grammar We used BitPar (Schmid, 2004), an efficient general purpose parser,10 together with various treebank grammars to parse the input sentences and propose compatible morphological segmentation and syntactic analysis.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'49'", "'71'", "'141'"]
'21'
'49'
'71'
'141'
['21', '49', '71', '141']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="159" ssid="37">Our parsing performance measures (SY N) thus report the PARSEVAL extension proposed in Tsarfaty (2006).</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'49'", "'159'", "'193'"]
'33'
'49'
'159'
'193'
['33', '49', '159', '193']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="151" ssid="29">In our third model GTppp we also add the distinction between general PPs and possessive PPs following Goldberg and Elhadad (2007).</S><S sid="152" ssid="30">In our forth model GTnph we add the definiteness status of constituents following Tsarfaty and Sima&#8217;an (2007).</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'151'", "'152'", "'193'"]
'33'
'151'
'152'
'193'
['33', '151', '152', '193']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="52" ssid="10">Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.</S><S sid="158" ssid="36">Evaluating parsing results in our joint framework, as argued by Tsarfaty (2006), is not trivial under the joint disambiguation task, as the hypothesized yield need not coincide with the correct one.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'48'", "'52'", "'158'"]
'20'
'48'
'52'
'158'
['20', '48', '52', '158']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="51" ssid="9">Tsarfaty (2006) used a morphological analyzer (Segal, 2000), a PoS tagger (Bar-Haim et al., 2005), and a general purpose parser (Schmid, 2000) in an integrated framework in which morphological and syntactic components interact to share information, leading to improved performance on the joint task.</S><S sid="132" ssid="10">(we ignored the 419 trees in their development set.)</S><S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S><S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'132'", "'133'", "'134'"]
'51'
'132'
'133'
'134'
['51', '132', '133', '134']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S><S sid="112" ssid="44">We first make use of our morphological analyzer to find all segmentation possibilities by chopping off all prefix sequence possibilities (including the empty prefix) and construct a lattice off of them.</S><S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S><S sid="140" ssid="18">For these models we limit the options provided for OOV words by not considering the entire token as a valid segmentation in case at least some prefix segmentation exists.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'", "'112'", "'133'", "'140'"]
'86'
'112'
'133'
'140'
['86', '112', '133', '140']
parsed_discourse_facet ['method_citation']
<S sid="123" ssid="1">Previous work on morphological and syntactic disambiguation in Hebrew used different sets of data, different splits, differing annotation schemes, and different evaluation measures.</S><S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S><S sid="154" ssid="32">For all grammars, we use fine-grained PoS tags indicating various morphological features annotated therein.</S><S sid="155" ssid="33">Evaluation We use 8 different measures to evaluate the performance of our system on the joint disambiguation task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'123'", "'134'", "'154'", "'155'"]
'123'
'134'
'154'
'155'
['123', '134', '154', '155']
parsed_discourse_facet ['results_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



P08-1043
P11-1141
0
result_citation
['hypothesis_citation']



P08-1043
D12-1046
0
method_citation
['hypothesis_citation']
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
parsing: input/ref/Task1/P08-1043_sweta.csv
<S sid="156" ssid="34">To evaluate the performance on the segmentation task, we report SEG, the standard harmonic means for segmentation Precision and Recall F1 (as defined in Bar-Haim et al. (2005); Tsarfaty (2006)) as well as the segmentation accuracy SEGTok measure indicating the percentage of input tokens assigned the correct exact segmentation (as reported by Cohen and Smith (2007)).</S>
original cit marker offset is 0
new cit marker offset is 0



["156'"]
156'
['156']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S>
original cit marker offset is 0
new cit marker offset is 0



["4'"]
4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="70" ssid="2">Each lattice arc corresponds to a segment and its corresponding PoS tag, and a path through the lattice corresponds to a specific morphological segmentation of the utterance.</S>
original cit marker offset is 0
new cit marker offset is 0



["70'"]
70'
['70']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity.</S>
original cit marker offset is 0
new cit marker offset is 0



["3'"]
3'
['3']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="9">Tsarfaty (2006) used a morphological analyzer (Segal, 2000), a PoS tagger (Bar-Haim et al., 2005), and a general purpose parser (Schmid, 2000) in an integrated framework in which morphological and syntactic components interact to share information, leading to improved performance on the joint task.</S>
original cit marker offset is 0
new cit marker offset is 0



["51'"]
51'
['51']
parsed_discourse_facet ['method_citation']
<S sid="107" ssid="39">Firstly, Hebrew unknown tokens are doubly unknown: each unknown token may correspond to several segmentation possibilities, and each segment in such sequences may be able to admit multiple PoS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["107'"]
107'
['107']
parsed_discourse_facet ['method_citation']
<S sid="14" ssid="10">The input for the segmentation task is however highly ambiguous for Semitic languages, and surface forms (tokens) may admit multiple possible analyses as in (BarHaim et al., 2007; Adler and Elhadad, 2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["14'"]
14'
['14']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S>
original cit marker offset is 0
new cit marker offset is 0



["33'"]
33'
['33']
parsed_discourse_facet ['method_citation']
<S sid="53" ssid="11">Both (Tsarfaty, 2006; Cohen and Smith, 2007) have shown that a single integrated framework outperforms a completely streamlined implementation, yet neither has shown a single generative model which handles both tasks.</S>
original cit marker offset is 0
new cit marker offset is 0



["53'"]
53'
['53']
parsed_discourse_facet ['method_citation']
 <S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S>
original cit marker offset is 0
new cit marker offset is 0



["48'"]
48'
['48']
parsed_discourse_facet ['method_citation']
<S sid="141" ssid="19">This analyzer setting is similar to that of (Cohen and Smith, 2007), and models using it are denoted nohsp, Parser and Grammar We used BitPar (Schmid, 2004), an efficient general purpose parser,10 together with various treebank grammars to parse the input sentences and propose compatible morphological segmentation and syntactic analysis.</S>
original cit marker offset is 0
new cit marker offset is 0



["141'"]
141'
['141']
parsed_discourse_facet ['method_citation']
<S sid="188" ssid="2">The overall performance of our joint framework demonstrates that a probability distribution obtained over mere syntactic contexts using a Treebank grammar and a data-driven lexicon outperforms upper bounds proposed by previous joint disambiguation systems and achieves segmentation and parsing results on a par with state-of-the-art standalone applications results.</S>
original cit marker offset is 0
new cit marker offset is 0



["188'"]
188'
['188']
parsed_discourse_facet ['method_citation']
<S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S>
original cit marker offset is 0
new cit marker offset is 0



["94'"]
94'
['94']
parsed_discourse_facet ['method_citation']
<S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["134'"]
134'
['134']
parsed_discourse_facet ['method_citation']
    <S sid="156" ssid="34">To evaluate the performance on the segmentation task, we report SEG, the standard harmonic means for segmentation Precision and Recall F1 (as defined in Bar-Haim et al. (2005); Tsarfaty (2006)) as well as the segmentation accuracy SEGTok measure indicating the percentage of input tokens assigned the correct exact segmentation (as reported by Cohen and Smith (2007)).</S>
original cit marker offset is 0
new cit marker offset is 0



["156'"]
156'
['156']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="1">Current state-of-the-art broad-coverage parsers assume a direct correspondence between the lexical items ingrained in the proposed syntactic analyses (the yields of syntactic parse-trees) and the spacedelimited tokens (henceforth, &#8216;tokens&#8217;) that constitute the unanalyzed surface forms (utterances).</S>
original cit marker offset is 0
new cit marker offset is 0



["5'"]
5'
['5']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1043.annv3.csv
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="35" ssid="14">The form fmnh, for example, can be understood as the verb &#8220;lubricated&#8221;, the possessed noun &#8220;her oil&#8221;, the adjective &#8220;fat&#8221; or the verb &#8220;got fat&#8221;.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="98" ssid="30">The Grammar Our parser looks for the most likely tree spanning a single path through the lattice of which the yield is a sequence of lexemes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'35'", "'49'", "'98'"]
'33'
'35'
'49'
'98'
['33', '35', '49', '98']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity.</S><S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S><S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'4'", "'18'", "'49'"]
'3'
'4'
'18'
'49'
['3', '4', '18', '49']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S><S sid="65" ssid="12">A possible probabilistic model for assigning probabilities to complex analyses of a surface form may be and indeed recent sequential disambiguation models for Hebrew (Adler and Elhadad, 2006) and Arabic (Smith et al., 2005) present similar models.</S><S sid="82" ssid="14">In sequential tagging models such as (Adler and Elhadad, 2006; Bar-Haim et al., 2007; Smith et al., 2005) weights are assigned according to a language model The input for the joint task is a sequence W = w1, ... , wn of space-delimited tokens.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'65'", "'82'"]
'20'
'21'
'65'
'82'
['20', '21', '65', '82']
parsed_discourse_facet ['aim_citation']
<S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="52" ssid="10">Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.</S><S sid="175" ssid="13">In our model there are no such hyper-parameters, and the performance is the result of truly joint disambiguation. sults.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'20'", "'52'", "'175'"]
'18'
'20'
'52'
'175'
['18', '20', '52', '175']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S><S sid="47" ssid="5">Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'47'", "'48'", "'49'"]
'4'
'47'
'48'
'49'
['4', '47', '48', '49']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="47" ssid="5">Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'47'", "'48'", "'49'"]
'33'
'47'
'48'
'49'
['33', '47', '48', '49']
parsed_discourse_facet ['aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S><S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S><S sid="106" ssid="38">Handling Unknown tokens When handling unknown tokens in a language such as Hebrew various important aspects have to be borne in mind.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'86'", "'94'", "'106'"]
'33'
'86'
'94'
'106'
['33', '86', '94', '106']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="85" ssid="17">The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.</S><S sid="192" ssid="6">Using a wide-coverage morphological analyzer based on (Itai et al., 2006) should cater for a better coverage, and incorporating lexical probabilities learned from a big (unannotated) corpus (cf.</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'85'", "'192'", "'193'"]
'33'
'85'
'192'
'193'
['33', '85', '192', '193']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="0">A Single Generative Model for Joint Morphological Segmentation and Syntactic Parsing</S><S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S><S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'18'", "'19'", "'20'"]
'0'
'18'
'19'
'20'
['0', '18', '19', '20']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="71" ssid="3">This is by now a fairly standard representation for multiple morphological segmentation of Hebrew utterances (Adler, 2001; Bar-Haim et al., 2005; Smith et al., 2005; Cohen and Smith, 2007; Adler, 2007).</S><S sid="141" ssid="19">This analyzer setting is similar to that of (Cohen and Smith, 2007), and models using it are denoted nohsp, Parser and Grammar We used BitPar (Schmid, 2004), an efficient general purpose parser,10 together with various treebank grammars to parse the input sentences and propose compatible morphological segmentation and syntactic analysis.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'49'", "'71'", "'141'"]
'21'
'49'
'71'
'141'
['21', '49', '71', '141']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="159" ssid="37">Our parsing performance measures (SY N) thus report the PARSEVAL extension proposed in Tsarfaty (2006).</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'49'", "'159'", "'193'"]
'33'
'49'
'159'
'193'
['33', '49', '159', '193']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="151" ssid="29">In our third model GTppp we also add the distinction between general PPs and possessive PPs following Goldberg and Elhadad (2007).</S><S sid="152" ssid="30">In our forth model GTnph we add the definiteness status of constituents following Tsarfaty and Sima&#8217;an (2007).</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'151'", "'152'", "'193'"]
'33'
'151'
'152'
'193'
['33', '151', '152', '193']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="52" ssid="10">Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.</S><S sid="158" ssid="36">Evaluating parsing results in our joint framework, as argued by Tsarfaty (2006), is not trivial under the joint disambiguation task, as the hypothesized yield need not coincide with the correct one.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'48'", "'52'", "'158'"]
'20'
'48'
'52'
'158'
['20', '48', '52', '158']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="51" ssid="9">Tsarfaty (2006) used a morphological analyzer (Segal, 2000), a PoS tagger (Bar-Haim et al., 2005), and a general purpose parser (Schmid, 2000) in an integrated framework in which morphological and syntactic components interact to share information, leading to improved performance on the joint task.</S><S sid="132" ssid="10">(we ignored the 419 trees in their development set.)</S><S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S><S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'132'", "'133'", "'134'"]
'51'
'132'
'133'
'134'
['51', '132', '133', '134']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S><S sid="112" ssid="44">We first make use of our morphological analyzer to find all segmentation possibilities by chopping off all prefix sequence possibilities (including the empty prefix) and construct a lattice off of them.</S><S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S><S sid="140" ssid="18">For these models we limit the options provided for OOV words by not considering the entire token as a valid segmentation in case at least some prefix segmentation exists.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'", "'112'", "'133'", "'140'"]
'86'
'112'
'133'
'140'
['86', '112', '133', '140']
parsed_discourse_facet ['method_citation']
<S sid="123" ssid="1">Previous work on morphological and syntactic disambiguation in Hebrew used different sets of data, different splits, differing annotation schemes, and different evaluation measures.</S><S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S><S sid="154" ssid="32">For all grammars, we use fine-grained PoS tags indicating various morphological features annotated therein.</S><S sid="155" ssid="33">Evaluation We use 8 different measures to evaluate the performance of our system on the joint disambiguation task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'123'", "'134'", "'154'", "'155'"]
'123'
'134'
'154'
'155'
['123', '134', '154', '155']
parsed_discourse_facet ['results_citation']



P08-1043
P11-1141
0
method_citation
['hypothesis_citation']



P08-1043
P12-2002
0
method_citation
['method_citation', 'hypothesis_citation']
parsing: input/ref/Task1/P08-1102_aakansha.csv
<S sid="130" ssid="1">We proposed a cascaded linear model for Chinese Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'130'"]
'130'
['130']
parsed_discourse_facet ['method_citation']
<S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S>
original cit marker offset is 0
new cit marker offset is 0



["'42'"]
'42'
['42']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="21">According to Ng and Low (2004), the segmentation task can be transformed to a tagging problem by assigning each character a boundary tag of the following four types: We can extract segmentation result by splitting the labelled result into subsequences of pattern s or bm*e which denote single-character word and multicharacter word respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'"]
'25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="130" ssid="1">We proposed a cascaded linear model for Chinese Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'130'"]
'130'
['130']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'34'"]
'34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'"]
'12'
['12']
parsed_discourse_facet ['method_citation']
<S sid="130" ssid="1">We proposed a cascaded linear model for Chinese Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'130'"]
'130'
['130']
parsed_discourse_facet ['method_citation']
<S sid="130" ssid="1">We proposed a cascaded linear model for Chinese Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'130'"]
'130'
['130']
parsed_discourse_facet ['method_citation']
<S sid="121" ssid="32">Among other features, the 4-gram POS LM plays the most important role, removing this feature causes F-measure decrement of 0.33 points on segmentation and 0.71 points on Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'121'"]
'121'
['121']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="9">C represents a Chinese character while the subscript of C indicates its position in the sentence relative to the current character (it has the subscript 0).</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'"]
'37'
['37']
parsed_discourse_facet ['method_citation']
<S sid="73" ssid="24">For instance, if the word w appears N times in training corpus and is labelled as POS t for n times, the probability Pr(t|w) can be estimated by the formula below: The probability Pr(w|t) could be estimated through the same approach.</S>
original cit marker offset is 0
new cit marker offset is 0



["'73'"]
'73'
['73']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="18">Following Collins, we use a function GEN(x) generating all candidate results of an input x , a representation 4) mapping each training example (x, y) &#8712; X &#215; Y to a feature vector 4)(x, y) &#8712; Rd, and a parameter vector &#945;&#65533; &#8712; Rd corresponding to the feature vector. d means the dimension of the vector space, it equals to the amount of features in the model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'"]
'46'
['46']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'"]
'12'
['12']
parsed_discourse_facet ['method_citation']
<S sid="130" ssid="1">We proposed a cascaded linear model for Chinese Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'130'"]
'130'
['130']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1102.annv3.csv
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="22" ssid="18">2 Segmentation and POS Tagging Given a Chinese character sequence: while the segmentation and POS tagging result can be depicted as: Here, Ci (i = L.n) denotes Chinese character, ti (i = L.m) denotes POS tag, and Cl:r (l &lt; r) denotes character sequence ranges from Cl to Cr.</S><S sid="77" ssid="2">In Chinese Joint S&amp;T, the mission of the decoder is to find the boundary-POS labelled sequence with the highest score.</S><S sid="78" ssid="3">Given a Chinese character sequence C1:n, the decoding procedure can proceed in a left-right fashion with a dynamic programming approach.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'22'", "'77'", "'78'"]
'10'
'22'
'77'
'78'
['10', '22', '77', '78']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="24" ssid="20">It is a better idea to perform segmentation and POS tagging jointly in a uniform framework.</S><S sid="25" ssid="21">According to Ng and Low (2004), the segmentation task can be transformed to a tagging problem by assigning each character a boundary tag of the following four types: We can extract segmentation result by splitting the labelled result into subsequences of pattern s or bm*e which denote single-character word and multicharacter word respectively.</S><S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S><S sid="32" ssid="4">We trained a character-based perceptron for Chinese Joint S&amp;T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'31'", "'32'"]
'24'
'25'
'31'
'32'
['24', '25', '31', '32']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S><S sid="39" ssid="11">We called them non-lexical-target because predications derived from them can predicate without considering the current character C0.</S><S sid="40" ssid="12">Templates in the column below are expanded from the upper ones.</S><S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'40'", "'42'"]
'38'
'39'
'40'
'42'
['38', '39', '40', '42']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S><S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S><S sid="101" ssid="12">On the three corpora, it also outperformed the word-based perceptron model of Zhang and Clark (2007).</S><S sid="119" ssid="30">We also find that the perceptron model functions as the kernel of the outside-layer linear model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'31'", "'38'", "'101'", "'119'"]
'31'
'38'
'101'
'119'
['31', '38', '101', '119']
parsed_discourse_facet ['method_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S><S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="4" ssid="4">On the Penn Chinese Treebank 5.0, we obtain an error reduction of segmentation and joint segmentation and part-of-speech tagging over the perceptron-only baseline.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'4'"]
'0'
'1'
'2'
'4'
['0', '1', '2', '4']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S><S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S><S sid="51" ssid="2">Additional features most widely used are related to word or POS ngrams.</S><S sid="113" ssid="24">Besides this perceptron, other sub-models are trained and used as additional features of the outside-layer linear model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'51'", "'113'"]
'33'
'34'
'51'
'113'
['33', '34', '51', '113']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">Compared to performing segmentation and POS tagging one at a time, Joint S&amp;T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).</S><S sid="12" ssid="8">Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.</S><S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S><S sid="86" ssid="11">Line 4 scans words of all possible lengths l (l = 1.. min(i, K), where i points to the current considering character).</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'42'", "'86'"]
'11'
'12'
'42'
'86'
['11', '12', '42', '86']
parsed_discourse_facet ['hypothesis_citation']
<S sid="88" ssid="13">Line 8 considers each candidate result in N-best list at prior position of the current word.</S><S sid="100" ssid="11">Test results listed in Table 2 shows that this model obtains higher accuracy than the best of SIGHAN Bakeoff 2 in three corpora (AS, CityU and MSR).</S><S sid="107" ssid="18">The evaluation results are shown in Table 3.</S><S sid="129" ssid="40">Experimental results show that, it achieves obvious improvement over the perceptron-only model, about from 0.973 to 0.978 on segmentation, and from 0.925 to 0.934 on Joint S&amp;T, with error reductions of 18.5% and 12% respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'88'", "'100'", "'107'", "'129'"]
'88'
'100'
'107'
'129'
['88', '100', '107', '129']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="22" ssid="18">2 Segmentation and POS Tagging Given a Chinese character sequence: while the segmentation and POS tagging result can be depicted as: Here, Ci (i = L.n) denotes Chinese character, ti (i = L.m) denotes POS tag, and Cl:r (l &lt; r) denotes character sequence ranges from Cl to Cr.</S><S sid="23" ssid="19">We can see that segmentation and POS tagging task is to divide a character sequence into several subsequences and label each of them a POS tag.</S><S sid="105" ssid="16">At the first step, we conducted a group of contrasting experiments on the core perceptron, the first concentrated on the segmentation regardless of the POS information and reported the F-measure on segmentation only, while the second performed Joint S&amp;T using POS information and reported the F-measure both on segmentation and on Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'22'", "'23'", "'105'"]
'10'
'22'
'23'
'105'
['10', '22', '23', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="58" ssid="9">Instead of incorporating all features into the perceptron directly, we first trained the perceptron using character-based features, and several other sub-models using additional ones such as word or POS n-grams, then trained the outside-layer linear model using the outputs of these sub-models, including the perceptron.</S><S sid="71" ssid="22">Using W = w1:m to denote the word sequence, T = t1:m to denote the corresponding POS sequence, P (T |W) to denote the probability that W is labelled as T, and P(W|T) to denote the probability that T generates W, we can define the cooccurrence model as follows: &#955;wt and &#955;tw denote the corresponding weights of the two components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'10'", "'58'", "'71'"]
'0'
'10'
'58'
'71'
['0', '10', '58', '71']
parsed_discourse_facet ['hypothesis_citation']
<S sid="13" ssid="9">However, as such features are generated dynamically during the decoding procedure, two limitation arise: on the one hand, the amount of parameters increases rapidly, which is apt to overfit on training corpus; on the other hand, exact inference by dynamic programming is intractable because the current predication relies on the results of prior predications.</S><S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S><S sid="133" ssid="4">However, can the perceptron incorporate all the knowledge used in the outside-layer linear model?</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'33'", "'35'", "'133'"]
'13'
'33'
'35'
'133'
['13', '33', '35', '133']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="13" ssid="9">However, as such features are generated dynamically during the decoding procedure, two limitation arise: on the one hand, the amount of parameters increases rapidly, which is apt to overfit on training corpus; on the other hand, exact inference by dynamic programming is intractable because the current predication relies on the results of prior predications.</S><S sid="14" ssid="10">As a result, many theoretically useful features such as higherorder word or POS n-grams are difficult to be incorporated in the model efficiently.</S><S sid="41" ssid="13">We add a field C0 to each template in the upper column, so that it can carry out predication according to not only the context but also the current character itself.</S><S sid="91" ssid="2">The first was conducted to test the performance of the perceptron on segmentation on the corpus from SIGHAN Bakeoff 2, including the Academia Sinica Corpus (AS), the Hong Kong City University Corpus (CityU), the Peking University Corpus (PKU) and the Microsoft Research Corpus (MSR).</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'14'", "'41'", "'91'"]
'13'
'14'
'41'
'91'
['13', '14', '41', '91']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="15" ssid="11">To cope with this problem, we propose a cascaded linear model inspired by the log-linear model (Och and Ney, 2004) widely used in statistical machine translation to incorporate different kinds of knowledge sources.</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S><S sid="50" ssid="1">In theory, any useful knowledge can be incorporated into the perceptron directly, besides the characterbased features already adopted.</S><S sid="51" ssid="2">Additional features most widely used are related to word or POS ngrams.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'35'", "'50'", "'51'"]
'15'
'35'
'50'
'51'
['15', '35', '50', '51']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="16" ssid="12">Shown in Figure 1, the cascaded model has a two-layer architecture, with a characterbased perceptron as the core combined with other real-valued features such as language models.</S><S sid="57" ssid="8">It has a two-layer architecture, with a perceptron as the core and another linear model as the outside-layer.</S><S sid="65" ssid="16">As shown in Figure 1, the character-based perceptron is used as the inside-layer linear model and sends its output to the outside-layer.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'16'", "'57'", "'65'"]
'2'
'16'
'57'
'65'
['2', '16', '57', '65']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="11" ssid="7">Compared to performing segmentation and POS tagging one at a time, Joint S&amp;T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).</S><S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'11'", "'34'", "'35'"]
'10'
'11'
'34'
'35'
['10', '11', '34', '35']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S><S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'31'"]
'0'
'1'
'2'
'31'
['0', '1', '2', '31']
parsed_discourse_facet ['hypothesis_citation']
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
parsing: input/ref/Task1/P08-1102_swastika.csv
    <S sid="32" ssid="4">We trained a character-based perceptron for Chinese Joint S&amp;T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['32']
32
['32']
parsed_discourse_facet ['method_citation']
    <S sid="32" ssid="4">We trained a character-based perceptron for Chinese Joint S&amp;T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['32']
32
['32']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S>
original cit marker offset is 0
new cit marker offset is 0



['38']
38
['38']
parsed_discourse_facet ['method_citation']
    <S sid="92" ssid="3">The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['92']
92
['92']
parsed_discourse_facet ['method_citation']
    <S sid="36" ssid="8">All feature templates and their instances are shown in Table 1.</S>
original cit marker offset is 0
new cit marker offset is 0



['36']
36
['36']
parsed_discourse_facet ['method_citation']
    <S sid="32" ssid="4">We trained a character-based perceptron for Chinese Joint S&amp;T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['32']
32
['32']
parsed_discourse_facet ['method_citation']
    <S sid="92" ssid="3">The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['92']
92
['92']
parsed_discourse_facet ['method_citation']
    <S sid="92" ssid="3">The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['92']
92
['92']
parsed_discourse_facet ['method_citation']
<S sid="97" ssid="8">Figure 3 shows their learning curves depicting the F-measure on the development set after 1 to 10 training iterations.</S>
original cit marker offset is 0
new cit marker offset is 0



['97']
97
['97']
parsed_discourse_facet ['result_citation']
<S sid="91" ssid="2">The first was conducted to test the performance of the perceptron on segmentation on the corpus from SIGHAN Bakeoff 2, including the Academia Sinica Corpus (AS), the Hong Kong City University Corpus (CityU), the Peking University Corpus (PKU) and the Microsoft Research Corpus (MSR).</S>
original cit marker offset is 0
new cit marker offset is 0



['91']
91
['91']
parsed_discourse_facet ['aim_citation']
<S sid="16" ssid="12">Shown in Figure 1, the cascaded model has a two-layer architecture, with a characterbased perceptron as the core combined with other real-valued features such as language models.</S>
original cit marker offset is 0
new cit marker offset is 0



['16']
16
['16']
parsed_discourse_facet ['method_citation']
    <S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S>
original cit marker offset is 0
new cit marker offset is 0



['34']
34
['34']
parsed_discourse_facet ['method_citation']
    <S sid="92" ssid="3">The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['92']
92
['92']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1102.annv3.csv
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="22" ssid="18">2 Segmentation and POS Tagging Given a Chinese character sequence: while the segmentation and POS tagging result can be depicted as: Here, Ci (i = L.n) denotes Chinese character, ti (i = L.m) denotes POS tag, and Cl:r (l &lt; r) denotes character sequence ranges from Cl to Cr.</S><S sid="77" ssid="2">In Chinese Joint S&amp;T, the mission of the decoder is to find the boundary-POS labelled sequence with the highest score.</S><S sid="78" ssid="3">Given a Chinese character sequence C1:n, the decoding procedure can proceed in a left-right fashion with a dynamic programming approach.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'22'", "'77'", "'78'"]
'10'
'22'
'77'
'78'
['10', '22', '77', '78']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="24" ssid="20">It is a better idea to perform segmentation and POS tagging jointly in a uniform framework.</S><S sid="25" ssid="21">According to Ng and Low (2004), the segmentation task can be transformed to a tagging problem by assigning each character a boundary tag of the following four types: We can extract segmentation result by splitting the labelled result into subsequences of pattern s or bm*e which denote single-character word and multicharacter word respectively.</S><S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S><S sid="32" ssid="4">We trained a character-based perceptron for Chinese Joint S&amp;T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'31'", "'32'"]
'24'
'25'
'31'
'32'
['24', '25', '31', '32']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S><S sid="39" ssid="11">We called them non-lexical-target because predications derived from them can predicate without considering the current character C0.</S><S sid="40" ssid="12">Templates in the column below are expanded from the upper ones.</S><S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'40'", "'42'"]
'38'
'39'
'40'
'42'
['38', '39', '40', '42']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S><S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S><S sid="101" ssid="12">On the three corpora, it also outperformed the word-based perceptron model of Zhang and Clark (2007).</S><S sid="119" ssid="30">We also find that the perceptron model functions as the kernel of the outside-layer linear model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'31'", "'38'", "'101'", "'119'"]
'31'
'38'
'101'
'119'
['31', '38', '101', '119']
parsed_discourse_facet ['method_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S><S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="4" ssid="4">On the Penn Chinese Treebank 5.0, we obtain an error reduction of segmentation and joint segmentation and part-of-speech tagging over the perceptron-only baseline.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'4'"]
'0'
'1'
'2'
'4'
['0', '1', '2', '4']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S><S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S><S sid="51" ssid="2">Additional features most widely used are related to word or POS ngrams.</S><S sid="113" ssid="24">Besides this perceptron, other sub-models are trained and used as additional features of the outside-layer linear model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'51'", "'113'"]
'33'
'34'
'51'
'113'
['33', '34', '51', '113']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">Compared to performing segmentation and POS tagging one at a time, Joint S&amp;T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).</S><S sid="12" ssid="8">Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.</S><S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S><S sid="86" ssid="11">Line 4 scans words of all possible lengths l (l = 1.. min(i, K), where i points to the current considering character).</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'42'", "'86'"]
'11'
'12'
'42'
'86'
['11', '12', '42', '86']
parsed_discourse_facet ['hypothesis_citation']
<S sid="88" ssid="13">Line 8 considers each candidate result in N-best list at prior position of the current word.</S><S sid="100" ssid="11">Test results listed in Table 2 shows that this model obtains higher accuracy than the best of SIGHAN Bakeoff 2 in three corpora (AS, CityU and MSR).</S><S sid="107" ssid="18">The evaluation results are shown in Table 3.</S><S sid="129" ssid="40">Experimental results show that, it achieves obvious improvement over the perceptron-only model, about from 0.973 to 0.978 on segmentation, and from 0.925 to 0.934 on Joint S&amp;T, with error reductions of 18.5% and 12% respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'88'", "'100'", "'107'", "'129'"]
'88'
'100'
'107'
'129'
['88', '100', '107', '129']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="22" ssid="18">2 Segmentation and POS Tagging Given a Chinese character sequence: while the segmentation and POS tagging result can be depicted as: Here, Ci (i = L.n) denotes Chinese character, ti (i = L.m) denotes POS tag, and Cl:r (l &lt; r) denotes character sequence ranges from Cl to Cr.</S><S sid="23" ssid="19">We can see that segmentation and POS tagging task is to divide a character sequence into several subsequences and label each of them a POS tag.</S><S sid="105" ssid="16">At the first step, we conducted a group of contrasting experiments on the core perceptron, the first concentrated on the segmentation regardless of the POS information and reported the F-measure on segmentation only, while the second performed Joint S&amp;T using POS information and reported the F-measure both on segmentation and on Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'22'", "'23'", "'105'"]
'10'
'22'
'23'
'105'
['10', '22', '23', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="58" ssid="9">Instead of incorporating all features into the perceptron directly, we first trained the perceptron using character-based features, and several other sub-models using additional ones such as word or POS n-grams, then trained the outside-layer linear model using the outputs of these sub-models, including the perceptron.</S><S sid="71" ssid="22">Using W = w1:m to denote the word sequence, T = t1:m to denote the corresponding POS sequence, P (T |W) to denote the probability that W is labelled as T, and P(W|T) to denote the probability that T generates W, we can define the cooccurrence model as follows: &#955;wt and &#955;tw denote the corresponding weights of the two components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'10'", "'58'", "'71'"]
'0'
'10'
'58'
'71'
['0', '10', '58', '71']
parsed_discourse_facet ['hypothesis_citation']
<S sid="13" ssid="9">However, as such features are generated dynamically during the decoding procedure, two limitation arise: on the one hand, the amount of parameters increases rapidly, which is apt to overfit on training corpus; on the other hand, exact inference by dynamic programming is intractable because the current predication relies on the results of prior predications.</S><S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S><S sid="133" ssid="4">However, can the perceptron incorporate all the knowledge used in the outside-layer linear model?</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'33'", "'35'", "'133'"]
'13'
'33'
'35'
'133'
['13', '33', '35', '133']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="13" ssid="9">However, as such features are generated dynamically during the decoding procedure, two limitation arise: on the one hand, the amount of parameters increases rapidly, which is apt to overfit on training corpus; on the other hand, exact inference by dynamic programming is intractable because the current predication relies on the results of prior predications.</S><S sid="14" ssid="10">As a result, many theoretically useful features such as higherorder word or POS n-grams are difficult to be incorporated in the model efficiently.</S><S sid="41" ssid="13">We add a field C0 to each template in the upper column, so that it can carry out predication according to not only the context but also the current character itself.</S><S sid="91" ssid="2">The first was conducted to test the performance of the perceptron on segmentation on the corpus from SIGHAN Bakeoff 2, including the Academia Sinica Corpus (AS), the Hong Kong City University Corpus (CityU), the Peking University Corpus (PKU) and the Microsoft Research Corpus (MSR).</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'14'", "'41'", "'91'"]
'13'
'14'
'41'
'91'
['13', '14', '41', '91']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="15" ssid="11">To cope with this problem, we propose a cascaded linear model inspired by the log-linear model (Och and Ney, 2004) widely used in statistical machine translation to incorporate different kinds of knowledge sources.</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S><S sid="50" ssid="1">In theory, any useful knowledge can be incorporated into the perceptron directly, besides the characterbased features already adopted.</S><S sid="51" ssid="2">Additional features most widely used are related to word or POS ngrams.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'35'", "'50'", "'51'"]
'15'
'35'
'50'
'51'
['15', '35', '50', '51']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="16" ssid="12">Shown in Figure 1, the cascaded model has a two-layer architecture, with a characterbased perceptron as the core combined with other real-valued features such as language models.</S><S sid="57" ssid="8">It has a two-layer architecture, with a perceptron as the core and another linear model as the outside-layer.</S><S sid="65" ssid="16">As shown in Figure 1, the character-based perceptron is used as the inside-layer linear model and sends its output to the outside-layer.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'16'", "'57'", "'65'"]
'2'
'16'
'57'
'65'
['2', '16', '57', '65']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="11" ssid="7">Compared to performing segmentation and POS tagging one at a time, Joint S&amp;T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).</S><S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'11'", "'34'", "'35'"]
'10'
'11'
'34'
'35'
['10', '11', '34', '35']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S><S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'31'"]
'0'
'1'
'2'
'31'
['0', '1', '2', '31']
parsed_discourse_facet ['hypothesis_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



P08-1102
C08-1049
0
method_citation
['method_citation']



P08-1102
C10-1132
0
method_citation
['results_citation', 'method_citation']
IGNORE THIS: Key error 5
parsing: input/ref/Task1/P08-1102_sweta.csv
<S sid="21" ssid="17">Experiments show that our cascaded model can utilize different knowledge sources effectively and obtain accuracy improvements on both segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["21'"]
21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="24">A subsequence of boundary-POS labelling result indicates a word with POS t only if the boundary tag sequence composed of its boundary part conforms to s or bm*e style, and all POS tags in its POS part equal to t. For example, a tag sequence b NN m NN e NN represents a threecharacter word with POS tag NN.</S>
original cit marker offset is 0
new cit marker offset is 0



["28'"]
28'
['28']
parsed_discourse_facet ['method_citation']
<S sid="43" ssid="15">Note that the templates of Ng and Low (2004) have already contained some lexical-target ones.</S>
original cit marker offset is 0
new cit marker offset is 0



["43'"]
43'
['43']
parsed_discourse_facet ['method_citation']
<S sid="92" ssid="3">The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["92'"]
92'
['92']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">To segment and tag a character sequence, there are two strategies to choose: performing POS tagging following segmentation; or joint segmentation and POS tagging (Joint S&amp;T).</S>
original cit marker offset is 0
new cit marker offset is 0



["9'"]
9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S>
    <S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["33'", "'34'"]
33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["12'"]
12'
['12']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="15">In our experiments we trained a 3-gram word language model measuring the fluency of the segmentation result, a 4-gram POS language model functioning as the product of statetransition probabilities in HMM, and a word-POS co-occurrence model describing how much probably a word sequence coexists with a POS sequence.</S>
original cit marker offset is 0
new cit marker offset is 0



["64'"]
64'
['64']
parsed_discourse_facet ['method_citation']
<S sid="79" ssid="4">By maintaining a stack of size N at each position i of the sequence, we can preserve the top N best candidate labelled results of subsequence C1:i during decoding.</S>
original cit marker offset is 0
new cit marker offset is 0



["79'"]
79'
['79']
parsed_discourse_facet ['method_citation']
<S sid="96" ssid="7">In order to test the performance of the lexical-target templates and meanwhile determine the best iterations over the training corpus, we randomly chosen 2, 000 shorter sentences (less than 50 words) as the development set and the rest as the training set (84, 294 sentences), then trained a perceptron model named NON-LEX using only nonlexical-target features and another named LEX using both the two kinds of features.</S>
original cit marker offset is 0
new cit marker offset is 0



["96'"]
96'
['96']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="2">The first was conducted to test the performance of the perceptron on segmentation on the corpus from SIGHAN Bakeoff 2, including the Academia Sinica Corpus (AS), the Hong Kong City University Corpus (CityU), the Peking University Corpus (PKU) and the Microsoft Research Corpus (MSR).</S>
original cit marker offset is 0
new cit marker offset is 0



["91'"]
91'
['91']
parsed_discourse_facet ['method_citation']
 <S sid="16" ssid="12">Shown in Figure 1, the cascaded model has a two-layer architecture, with a characterbased perceptron as the core combined with other real-valued features such as language models.</S>
original cit marker offset is 0
new cit marker offset is 0



["16'"]
16'
['16']
parsed_discourse_facet ['method_citation']
<S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S>
original cit marker offset is 0
new cit marker offset is 0



["35'"]
35'
['35']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S>
original cit marker offset is 0
new cit marker offset is 0



["91'"]
91'
['91']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1102.annv3.csv
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="22" ssid="18">2 Segmentation and POS Tagging Given a Chinese character sequence: while the segmentation and POS tagging result can be depicted as: Here, Ci (i = L.n) denotes Chinese character, ti (i = L.m) denotes POS tag, and Cl:r (l &lt; r) denotes character sequence ranges from Cl to Cr.</S><S sid="77" ssid="2">In Chinese Joint S&amp;T, the mission of the decoder is to find the boundary-POS labelled sequence with the highest score.</S><S sid="78" ssid="3">Given a Chinese character sequence C1:n, the decoding procedure can proceed in a left-right fashion with a dynamic programming approach.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'22'", "'77'", "'78'"]
'10'
'22'
'77'
'78'
['10', '22', '77', '78']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="24" ssid="20">It is a better idea to perform segmentation and POS tagging jointly in a uniform framework.</S><S sid="25" ssid="21">According to Ng and Low (2004), the segmentation task can be transformed to a tagging problem by assigning each character a boundary tag of the following four types: We can extract segmentation result by splitting the labelled result into subsequences of pattern s or bm*e which denote single-character word and multicharacter word respectively.</S><S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S><S sid="32" ssid="4">We trained a character-based perceptron for Chinese Joint S&amp;T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'31'", "'32'"]
'24'
'25'
'31'
'32'
['24', '25', '31', '32']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S><S sid="39" ssid="11">We called them non-lexical-target because predications derived from them can predicate without considering the current character C0.</S><S sid="40" ssid="12">Templates in the column below are expanded from the upper ones.</S><S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'40'", "'42'"]
'38'
'39'
'40'
'42'
['38', '39', '40', '42']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S><S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S><S sid="101" ssid="12">On the three corpora, it also outperformed the word-based perceptron model of Zhang and Clark (2007).</S><S sid="119" ssid="30">We also find that the perceptron model functions as the kernel of the outside-layer linear model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'31'", "'38'", "'101'", "'119'"]
'31'
'38'
'101'
'119'
['31', '38', '101', '119']
parsed_discourse_facet ['method_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S><S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="4" ssid="4">On the Penn Chinese Treebank 5.0, we obtain an error reduction of segmentation and joint segmentation and part-of-speech tagging over the perceptron-only baseline.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'4'"]
'0'
'1'
'2'
'4'
['0', '1', '2', '4']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S><S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S><S sid="51" ssid="2">Additional features most widely used are related to word or POS ngrams.</S><S sid="113" ssid="24">Besides this perceptron, other sub-models are trained and used as additional features of the outside-layer linear model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'51'", "'113'"]
'33'
'34'
'51'
'113'
['33', '34', '51', '113']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">Compared to performing segmentation and POS tagging one at a time, Joint S&amp;T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).</S><S sid="12" ssid="8">Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.</S><S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S><S sid="86" ssid="11">Line 4 scans words of all possible lengths l (l = 1.. min(i, K), where i points to the current considering character).</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'42'", "'86'"]
'11'
'12'
'42'
'86'
['11', '12', '42', '86']
parsed_discourse_facet ['hypothesis_citation']
<S sid="88" ssid="13">Line 8 considers each candidate result in N-best list at prior position of the current word.</S><S sid="100" ssid="11">Test results listed in Table 2 shows that this model obtains higher accuracy than the best of SIGHAN Bakeoff 2 in three corpora (AS, CityU and MSR).</S><S sid="107" ssid="18">The evaluation results are shown in Table 3.</S><S sid="129" ssid="40">Experimental results show that, it achieves obvious improvement over the perceptron-only model, about from 0.973 to 0.978 on segmentation, and from 0.925 to 0.934 on Joint S&amp;T, with error reductions of 18.5% and 12% respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'88'", "'100'", "'107'", "'129'"]
'88'
'100'
'107'
'129'
['88', '100', '107', '129']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="22" ssid="18">2 Segmentation and POS Tagging Given a Chinese character sequence: while the segmentation and POS tagging result can be depicted as: Here, Ci (i = L.n) denotes Chinese character, ti (i = L.m) denotes POS tag, and Cl:r (l &lt; r) denotes character sequence ranges from Cl to Cr.</S><S sid="23" ssid="19">We can see that segmentation and POS tagging task is to divide a character sequence into several subsequences and label each of them a POS tag.</S><S sid="105" ssid="16">At the first step, we conducted a group of contrasting experiments on the core perceptron, the first concentrated on the segmentation regardless of the POS information and reported the F-measure on segmentation only, while the second performed Joint S&amp;T using POS information and reported the F-measure both on segmentation and on Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'22'", "'23'", "'105'"]
'10'
'22'
'23'
'105'
['10', '22', '23', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="58" ssid="9">Instead of incorporating all features into the perceptron directly, we first trained the perceptron using character-based features, and several other sub-models using additional ones such as word or POS n-grams, then trained the outside-layer linear model using the outputs of these sub-models, including the perceptron.</S><S sid="71" ssid="22">Using W = w1:m to denote the word sequence, T = t1:m to denote the corresponding POS sequence, P (T |W) to denote the probability that W is labelled as T, and P(W|T) to denote the probability that T generates W, we can define the cooccurrence model as follows: &#955;wt and &#955;tw denote the corresponding weights of the two components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'10'", "'58'", "'71'"]
'0'
'10'
'58'
'71'
['0', '10', '58', '71']
parsed_discourse_facet ['hypothesis_citation']
<S sid="13" ssid="9">However, as such features are generated dynamically during the decoding procedure, two limitation arise: on the one hand, the amount of parameters increases rapidly, which is apt to overfit on training corpus; on the other hand, exact inference by dynamic programming is intractable because the current predication relies on the results of prior predications.</S><S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S><S sid="133" ssid="4">However, can the perceptron incorporate all the knowledge used in the outside-layer linear model?</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'33'", "'35'", "'133'"]
'13'
'33'
'35'
'133'
['13', '33', '35', '133']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="13" ssid="9">However, as such features are generated dynamically during the decoding procedure, two limitation arise: on the one hand, the amount of parameters increases rapidly, which is apt to overfit on training corpus; on the other hand, exact inference by dynamic programming is intractable because the current predication relies on the results of prior predications.</S><S sid="14" ssid="10">As a result, many theoretically useful features such as higherorder word or POS n-grams are difficult to be incorporated in the model efficiently.</S><S sid="41" ssid="13">We add a field C0 to each template in the upper column, so that it can carry out predication according to not only the context but also the current character itself.</S><S sid="91" ssid="2">The first was conducted to test the performance of the perceptron on segmentation on the corpus from SIGHAN Bakeoff 2, including the Academia Sinica Corpus (AS), the Hong Kong City University Corpus (CityU), the Peking University Corpus (PKU) and the Microsoft Research Corpus (MSR).</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'14'", "'41'", "'91'"]
'13'
'14'
'41'
'91'
['13', '14', '41', '91']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="15" ssid="11">To cope with this problem, we propose a cascaded linear model inspired by the log-linear model (Och and Ney, 2004) widely used in statistical machine translation to incorporate different kinds of knowledge sources.</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S><S sid="50" ssid="1">In theory, any useful knowledge can be incorporated into the perceptron directly, besides the characterbased features already adopted.</S><S sid="51" ssid="2">Additional features most widely used are related to word or POS ngrams.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'35'", "'50'", "'51'"]
'15'
'35'
'50'
'51'
['15', '35', '50', '51']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="16" ssid="12">Shown in Figure 1, the cascaded model has a two-layer architecture, with a characterbased perceptron as the core combined with other real-valued features such as language models.</S><S sid="57" ssid="8">It has a two-layer architecture, with a perceptron as the core and another linear model as the outside-layer.</S><S sid="65" ssid="16">As shown in Figure 1, the character-based perceptron is used as the inside-layer linear model and sends its output to the outside-layer.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'16'", "'57'", "'65'"]
'2'
'16'
'57'
'65'
['2', '16', '57', '65']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="11" ssid="7">Compared to performing segmentation and POS tagging one at a time, Joint S&amp;T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).</S><S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'11'", "'34'", "'35'"]
'10'
'11'
'34'
'35'
['10', '11', '34', '35']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S><S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'31'"]
'0'
'1'
'2'
'31'
['0', '1', '2', '31']
parsed_discourse_facet ['hypothesis_citation']
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
parsing: input/ref/Task1/P11-1060_aakansha.csv
<S sid="11" ssid="7">Figure 1 shows our probabilistic model: with respect to a world w (database of facts), producing an answer y.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'"]
'11'
['11']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'"]
'2'
['2']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="112" ssid="88">Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.</S>
original cit marker offset is 0
new cit marker offset is 0



["'112'"]
'112'
['112']
parsed_discourse_facet ['method_citation']
<S sid="35" ssid="11">Although a DCS tree is a logical form, note that it looks like a syntactic dependency tree with predicates in place of words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'"]
'11'
['11']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="42" ssid="18">The denotation JzKw (z evaluated on w) is the set of consistent values of the root node (see Figure 2 for an example).</S>
original cit marker offset is 0
new cit marker offset is 0



["'42'"]
'42'
['42']
parsed_discourse_facet ['method_citation']
<S sid="106" ssid="82">Learning Given a training dataset D containing (x, y) pairs, we define the regularized marginal log-likelihood objective O(&#952;) = E(x,y)ED log p&#952;(JzKw = y  |x, z &#8712; ZL(x)) &#8722; &#955;k&#952;k22, which sums over all DCS trees z that evaluate to the target answer y.</S>
original cit marker offset is 0
new cit marker offset is 0



["'106'"]
'106'
['106']
parsed_discourse_facet ['method_citation']
<S sid="45" ssid="21">The logical forms in DCS are called DCS trees, where nodes are labeled with predicates, and edges are labeled with relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'45'"]
'45'
['45']
parsed_discourse_facet ['method_citation']
<S sid="88" ssid="64">Generalized Quantification (d.ri = Q) Generalized quantifiers are predicates on two sets, a restrictor A and a nuclear scope B.</S>
original cit marker offset is 0
new cit marker offset is 0



["'88'"]
'88'
['88']
parsed_discourse_facet ['method_citation']
<S sid="171" ssid="56">This yields a more system is based on a new semantic representation, factorized and flexible representation that is easier DCS, which offers a simple and expressive alterto search through and parametrize using features. native to lambda calculus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'171'"]
'171'
['171']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P11-1060.annv3.csv
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'7'", "'9'"]
'1'
'2'
'7'
'9'
['1', '2', '7', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="6" ssid="2">Answering these types of complex questions compositionally involves first mapping the questions into logical forms (semantic parsing).</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'6'", "'9'", "'10'"]
'2'
'6'
'9'
'10'
['2', '6', '9', '10']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="3" ssid="3">In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'8'", "'9'"]
'2'
'3'
'8'
'9'
['2', '3', '8', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="46" ssid="22">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).</S><S sid="48" ssid="24">In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.</S><S sid="49" ssid="25">Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compositional structures, but they cannot capture higherorder phenomena in language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'", "'46'", "'48'", "'49'"]
'25'
'46'
'48'
'49'
['25', '46', '48', '49']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.</S><S sid="34" ssid="10">Figure 2(a) shows an example of a DCS tree.</S><S sid="38" ssid="14">Let us start by considering a DCS tree z with only join relations.</S><S sid="107" ssid="83">Our model is arc-factored, so we can sum over all DCS trees in ZL(x) using dynamic programming.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'34'", "'38'", "'107'"]
'12'
'34'
'38'
'107'
['12', '34', '38', '107']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="164" ssid="49">Past work has also fofor the second.</S><S sid="165" ssid="50">These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'164'", "'165'", "'166'"]
'7'
'164'
'165'
'166'
['7', '164', '165', '166']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="156" ssid="41">There has been a fair amount of past work on no predicates), confusion of Washington state with this topic: Liang et al. (2010) induces combinatory Washington D.C., learning the wrong lexical asso- logic programs in a non-linguistic setting.</S><S sid="165" ssid="50">These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'8'", "'156'", "'165'"]
'7'
'8'
'156'
'165'
['7', '8', '156', '165']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S><S sid="135" ssid="20">SEMRESP requires a lexicon of 1.42 words per non-value predicate, WordNet features, and syntactic parse trees; DCS requires only words for the domain-independent predicates (overall, around 0.5 words per non-value predicate), POS tags, and very simple indicator features.</S><S sid="136" ssid="21">In fact, DCS performs comparably to even the version of SEMRESP trained using logical forms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'10'", "'135'", "'136'"]
'9'
'10'
'135'
'136'
['9', '10', '135', '136']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="3" ssid="3">In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid="5" ssid="1">What is the total population of the ten largest capitals in the US?</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'5'", "'22'"]
'2'
'3'
'5'
'22'
['2', '3', '5', '22']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="132" ssid="17">Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'9'", "'132'"]
'1'
'2'
'9'
'132'
['1', '2', '9', '132']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'22'", "'25'", "'36'"]
'21'
'22'
'25'
'36'
['21', '22', '25', '36']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="47" ssid="23">This algorithm is linear in the number of nodes times the size of the denotations.1 Now the dual importance of trees in DCS is clear: We have seen that trees parallel syntactic dependency structure, which will facilitate parsing.</S><S sid="48" ssid="24">In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.</S><S sid="49" ssid="25">Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compositional structures, but they cannot capture higherorder phenomena in language.</S><S sid="94" ssid="70">We now turn to the task of mapping natural language For the example in Figure 4(b), the de- utterances to DCS trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'47'", "'48'", "'49'", "'94'"]
'47'
'48'
'49'
'94'
['47', '48', '49', '94']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.</S><S sid="33" ssid="9">As another example, w(average) = {(S, &#175;x) : We write a DCS tree z as hp; r1 : c1; ... ; rm : cmi.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S><S sid="167" ssid="52">In DCS, we start with lexical triggers, which are 6 Conclusion more basic than CCG lexical entries.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'33'", "'166'", "'167'"]
'12'
'33'
'166'
'167'
['12', '33', '166', '167']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="43" ssid="19">Computation We can compute the denotation JzKw of a DCS tree z by exploiting dynamic programming on trees (Dechter, 2003).</S><S sid="46" ssid="22">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).</S><S sid="50" ssid="26">For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.</S><S sid="86" ssid="62">Formally, extraction simply moves the i-th column to the front: Xi(d) = di, &#8722;(i, &#248;){&#945;1 = &#248;}.</S>
original cit marker offset is 0
new cit marker offset is 0



["'43'", "'46'", "'50'", "'86'"]
'43'
'46'
'50'
'86'
['43', '46', '50', '86']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'9'"]
'1'
'2'
'8'
'9'
['1', '2', '8', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="133" ssid="18">Table 2 shows that our system using lexical triggers L (henceforth, DCS) outperforms SEMRESP (78.9% over 73.2%).</S><S sid="140" ssid="25">Table 3 shows that even DCS, which does not use prototypes, is comparable to the best previous system (Kwiatkowski et al., 2010), and by adding a few prototypes, DCS+ offers a decisive edge (91.1% over 88.9% on GEO).</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'133'", "'140'", "'166'"]
'7'
'133'
'140'
'166'
['7', '133', '140', '166']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="162" ssid="47">The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.</S><S sid="164" ssid="49">Past work has also fofor the second.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'9'", "'162'", "'164'"]
'7'
'9'
'162'
'164'
['7', '9', '162', '164']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="17" ssid="13">The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'22'", "'25'", "'36'"]
'17'
'22'
'25'
'36'
['17', '22', '25', '36']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="13">The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.</S><S sid="50" ssid="26">For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.</S><S sid="150" ssid="35">For example, area (by virtue which results in programs (DCS trees) which are of being a noun) triggers many predicates: city, much simpler than the logically-equivalent lambda state, area, etc.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'50'", "'150'", "'166'"]
'17'
'50'
'150'
'166'
['17', '50', '150', '166']
parsed_discourse_facet ['method_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
parsing: input/ref/Task1/P11-1060_swastika.csv
<S sid="112" ssid="88">Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.</S>
original cit marker offset is 0
new cit marker offset is 0



['112']
112
['112']
parsed_discourse_facet ['method_citation']
<S sid="112" ssid="88">Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.</S>
original cit marker offset is 0
new cit marker offset is 0



['112']
112
['112']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



['25']
25
['25']
parsed_discourse_facet ['aim_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



['21']
21
['21']
parsed_discourse_facet ['aim_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



['25']
25
['25']
parsed_discourse_facet ['aim_citation']
    <S sid="148" ssid="33">This bootstrapping behavior occurs naturally: The &#8220;easy&#8221; examples are processed first, where easy is defined by the ability of the current model to generate the correct answer using any tree. with scope variation.</S>
original cit marker offset is 0
new cit marker offset is 0



['148']
148
['148']
parsed_discourse_facet ['method_citation']
    <S sid="13" ssid="9">We want to induce latent logical forms z (and parameters 0) given only question-answer pairs (x, y), which is much cheaper to obtain than (x, z) pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



['13']
13
['13']
parsed_discourse_facet ['result_citation']
<S sid="112" ssid="88">Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.</S>
original cit marker offset is 0
new cit marker offset is 0



['112']
112
['112']
parsed_discourse_facet ['result_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



['21']
21
['21']
parsed_discourse_facet ['aim_citation']
<S sid="47" ssid="23">This algorithm is linear in the number of nodes times the size of the denotations.1 Now the dual importance of trees in DCS is clear: We have seen that trees parallel syntactic dependency structure, which will facilitate parsing.</S>
original cit marker offset is 0
new cit marker offset is 0



['47']
47
['47']
parsed_discourse_facet ['method_citation']
<S sid="112" ssid="88">Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.</S>
original cit marker offset is 0
new cit marker offset is 0



['112']
112
['112']
parsed_discourse_facet ['method_citation']
S sid="44" ssid="20">The recurrence is as follows: At each node, we compute the set of tuples v consistent with the predicate at that node (v &#8712; w(p)), and S(x)}, where a set of pairs S is treated as a set-valued function S(x) = {y : (x, y) &#8712; S} with domain S1 = {x : (x, y) &#8712; S}.</S>
original cit marker offset is 0
new cit marker offset is 0



['44']
44
['44']
Error in Reference Offset
<S sid="106" ssid="82">Learning Given a training dataset D containing (x, y) pairs, we define the regularized marginal log-likelihood objective O(&#952;) = E(x,y)ED log p&#952;(JzKw = y  |x, z &#8712; ZL(x)) &#8722; &#955;k&#952;k22, which sums over all DCS trees z that evaluate to the target answer y.</S>
original cit marker offset is 0
new cit marker offset is 0



['106']
106
['106']
parsed_discourse_facet ['aim_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



['21']
21
['21']
parsed_discourse_facet ['aim_citation']
    <S sid="172" ssid="57">Free from the burden It also allows us to easily add new lexical triggers of annotating logical forms, we hope to use our without becoming mired in the semantic formalism. techniques in developing even more accurate and Quantifiers and superlatives significantly compli- broader-coverage language understanding systems. cate scoping in lambda calculus, and often type rais- Acknowledgments We thank Luke Zettlemoyer ing needs to be employed.</S>
original cit marker offset is 0
new cit marker offset is 0



['172']
172
['172']
parsed_discourse_facet ['result_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



['21']
21
['21']
parsed_discourse_facet ['aim_citation']
<S sid="171" ssid="56">This yields a more system is based on a new semantic representation, factorized and flexible representation that is easier DCS, which offers a simple and expressive alterto search through and parametrize using features. native to lambda calculus.</S>
original cit marker offset is 0
new cit marker offset is 0



['171']
171
['171']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P11-1060.annv3.csv
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'7'", "'9'"]
'1'
'2'
'7'
'9'
['1', '2', '7', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="6" ssid="2">Answering these types of complex questions compositionally involves first mapping the questions into logical forms (semantic parsing).</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'6'", "'9'", "'10'"]
'2'
'6'
'9'
'10'
['2', '6', '9', '10']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="3" ssid="3">In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'8'", "'9'"]
'2'
'3'
'8'
'9'
['2', '3', '8', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="46" ssid="22">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).</S><S sid="48" ssid="24">In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.</S><S sid="49" ssid="25">Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compositional structures, but they cannot capture higherorder phenomena in language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'", "'46'", "'48'", "'49'"]
'25'
'46'
'48'
'49'
['25', '46', '48', '49']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.</S><S sid="34" ssid="10">Figure 2(a) shows an example of a DCS tree.</S><S sid="38" ssid="14">Let us start by considering a DCS tree z with only join relations.</S><S sid="107" ssid="83">Our model is arc-factored, so we can sum over all DCS trees in ZL(x) using dynamic programming.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'34'", "'38'", "'107'"]
'12'
'34'
'38'
'107'
['12', '34', '38', '107']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="164" ssid="49">Past work has also fofor the second.</S><S sid="165" ssid="50">These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'164'", "'165'", "'166'"]
'7'
'164'
'165'
'166'
['7', '164', '165', '166']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="156" ssid="41">There has been a fair amount of past work on no predicates), confusion of Washington state with this topic: Liang et al. (2010) induces combinatory Washington D.C., learning the wrong lexical asso- logic programs in a non-linguistic setting.</S><S sid="165" ssid="50">These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'8'", "'156'", "'165'"]
'7'
'8'
'156'
'165'
['7', '8', '156', '165']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S><S sid="135" ssid="20">SEMRESP requires a lexicon of 1.42 words per non-value predicate, WordNet features, and syntactic parse trees; DCS requires only words for the domain-independent predicates (overall, around 0.5 words per non-value predicate), POS tags, and very simple indicator features.</S><S sid="136" ssid="21">In fact, DCS performs comparably to even the version of SEMRESP trained using logical forms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'10'", "'135'", "'136'"]
'9'
'10'
'135'
'136'
['9', '10', '135', '136']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="3" ssid="3">In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid="5" ssid="1">What is the total population of the ten largest capitals in the US?</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'5'", "'22'"]
'2'
'3'
'5'
'22'
['2', '3', '5', '22']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="132" ssid="17">Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'9'", "'132'"]
'1'
'2'
'9'
'132'
['1', '2', '9', '132']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'22'", "'25'", "'36'"]
'21'
'22'
'25'
'36'
['21', '22', '25', '36']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="47" ssid="23">This algorithm is linear in the number of nodes times the size of the denotations.1 Now the dual importance of trees in DCS is clear: We have seen that trees parallel syntactic dependency structure, which will facilitate parsing.</S><S sid="48" ssid="24">In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.</S><S sid="49" ssid="25">Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compositional structures, but they cannot capture higherorder phenomena in language.</S><S sid="94" ssid="70">We now turn to the task of mapping natural language For the example in Figure 4(b), the de- utterances to DCS trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'47'", "'48'", "'49'", "'94'"]
'47'
'48'
'49'
'94'
['47', '48', '49', '94']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.</S><S sid="33" ssid="9">As another example, w(average) = {(S, &#175;x) : We write a DCS tree z as hp; r1 : c1; ... ; rm : cmi.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S><S sid="167" ssid="52">In DCS, we start with lexical triggers, which are 6 Conclusion more basic than CCG lexical entries.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'33'", "'166'", "'167'"]
'12'
'33'
'166'
'167'
['12', '33', '166', '167']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="43" ssid="19">Computation We can compute the denotation JzKw of a DCS tree z by exploiting dynamic programming on trees (Dechter, 2003).</S><S sid="46" ssid="22">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).</S><S sid="50" ssid="26">For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.</S><S sid="86" ssid="62">Formally, extraction simply moves the i-th column to the front: Xi(d) = di, &#8722;(i, &#248;){&#945;1 = &#248;}.</S>
original cit marker offset is 0
new cit marker offset is 0



["'43'", "'46'", "'50'", "'86'"]
'43'
'46'
'50'
'86'
['43', '46', '50', '86']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'9'"]
'1'
'2'
'8'
'9'
['1', '2', '8', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="133" ssid="18">Table 2 shows that our system using lexical triggers L (henceforth, DCS) outperforms SEMRESP (78.9% over 73.2%).</S><S sid="140" ssid="25">Table 3 shows that even DCS, which does not use prototypes, is comparable to the best previous system (Kwiatkowski et al., 2010), and by adding a few prototypes, DCS+ offers a decisive edge (91.1% over 88.9% on GEO).</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'133'", "'140'", "'166'"]
'7'
'133'
'140'
'166'
['7', '133', '140', '166']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="162" ssid="47">The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.</S><S sid="164" ssid="49">Past work has also fofor the second.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'9'", "'162'", "'164'"]
'7'
'9'
'162'
'164'
['7', '9', '162', '164']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="17" ssid="13">The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'22'", "'25'", "'36'"]
'17'
'22'
'25'
'36'
['17', '22', '25', '36']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="13">The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.</S><S sid="50" ssid="26">For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.</S><S sid="150" ssid="35">For example, area (by virtue which results in programs (DCS trees) which are of being a noun) triggers many predicates: city, much simpler than the logically-equivalent lambda state, area, etc.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'50'", "'150'", "'166'"]
'17'
'50'
'150'
'166'
['17', '50', '150', '166']
parsed_discourse_facet ['method_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: Key error 5
parsing: input/ref/Task1/P11-1060_sweta.csv
<S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S>
original cit marker offset is 0
new cit marker offset is 0



["8'"]
8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="132" ssid="17">Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["132'"]
132'
['132']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["25'"]
25'
['25']
parsed_discourse_facet ['method_citation']
 <S sid="45" ssid="21">The logical forms in DCS are called DCS trees, where nodes are labeled with predicates, and edges are labeled with relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["45'"]
45'
['45']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="27">It is impossible to represent the semantics of this phrase with just a CSP, so we introduce a new aggregate relation, notated E. Consider a tree hE:ci, whose root is connected to a child c via E. If the denotation of c is a set of values s, the parent&#8217;s denotation is then a singleton set containing s. Formally: Figure 3(a) shows the DCS tree for our running example.</S>
original cit marker offset is 0
new cit marker offset is 0



["51'"]
51'
['51']
parsed_discourse_facet ['method_citation']
 <S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["166'"]
166'
['166']
parsed_discourse_facet ['method_citation']
 <S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S>
original cit marker offset is 0
new cit marker offset is 0



["8'"]
8'
['8']
parsed_discourse_facet ['method_citation']
 <S sid="11" ssid="7">Figure 1 shows our probabilistic model: with respect to a world w (database of facts), producing an answer y.</S>
original cit marker offset is 0
new cit marker offset is 0



["11'"]
11'
['11']
parsed_discourse_facet ['method_citation']
  <S sid="115" ssid="91">After training, given a new utterance x, our system outputs the most likely y, summing out the latent logical form z: argmaxy p&#952;(T)(y  |x, z &#8712; &#732;ZL,&#952;(T)).</S>
original cit marker offset is 0
new cit marker offset is 0



["115'"]
115'
['115']
parsed_discourse_facet ['method_citation']
<S sid="132" ssid="17">Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["132'"]
132'
['132']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["25'"]
25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="94" ssid="70">We now turn to the task of mapping natural language For the example in Figure 4(b), the de- utterances to DCS trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["94'"]
94'
['94']
parsed_discourse_facet ['method_citation']
<S sid="132" ssid="17">Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["132'"]
132'
['132']
parsed_discourse_facet ['method_citation']
<S sid="157" ssid="42">Eisenciations due to data sparsity, and having an insuffi- stein et al. (2009) induces conjunctive formulae and ciently large K. uses them as features in another learning problem.</S>
original cit marker offset is 0
new cit marker offset is 0



["157'"]
157'
['157']
parsed_discourse_facet ['method_citation']
<S sid="106" ssid="82">Learning Given a training dataset D containing (x, y) pairs, we define the regularized marginal log-likelihood objective O(&#952;) = E(x,y)ED log p&#952;(JzKw = y  |x, z &#8712; ZL(x)) &#8722; &#955;k&#952;k22, which sums over all DCS trees z that evaluate to the target answer y.</S>
original cit marker offset is 0
new cit marker offset is 0



["106'"]
106'
['106']
parsed_discourse_facet ['method_citation']
<S sid="167" ssid="52">In DCS, we start with lexical triggers, which are 6 Conclusion more basic than CCG lexical entries.</S>
original cit marker offset is 0
new cit marker offset is 0



["167'"]
167'
['167']
parsed_discourse_facet ['method_citation']
<S sid="138" ssid="23">Next, we compared our systems (DCS and DCS+) with the state-of-the-art semantic parsers on the full dataset for both GEO and JOBS (see Table 3).</S>
original cit marker offset is 0
new cit marker offset is 0



["138'"]
138'
['138']
parsed_discourse_facet ['method_citation']
<S sid="40" ssid="16">The CSP has two types of constraints: (i) x &#8712; w(p) for each node x labeled with predicate p &#8712; P; and (ii) xj = yj0 (the j-th component of x must equal the j'-th component of y) for each edge (x, y) labeled with j0j &#8712; R. A solution to the CSP is an assignment of nodes to values that satisfies all the constraints.</S>
original cit marker offset is 0
new cit marker offset is 0



["40'"]
40'
['40']
parsed_discourse_facet ['method_citation']
<S sid="171" ssid="56">This yields a more system is based on a new semantic representation, factorized and flexible representation that is easier DCS, which offers a simple and expressive alterto search through and parametrize using features. native to lambda calculus.</S>
original cit marker offset is 0
new cit marker offset is 0



["171'"]
171'
['171']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P11-1060.annv3.csv
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'7'", "'9'"]
'1'
'2'
'7'
'9'
['1', '2', '7', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="6" ssid="2">Answering these types of complex questions compositionally involves first mapping the questions into logical forms (semantic parsing).</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'6'", "'9'", "'10'"]
'2'
'6'
'9'
'10'
['2', '6', '9', '10']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="3" ssid="3">In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'8'", "'9'"]
'2'
'3'
'8'
'9'
['2', '3', '8', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="46" ssid="22">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).</S><S sid="48" ssid="24">In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.</S><S sid="49" ssid="25">Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compositional structures, but they cannot capture higherorder phenomena in language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'", "'46'", "'48'", "'49'"]
'25'
'46'
'48'
'49'
['25', '46', '48', '49']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.</S><S sid="34" ssid="10">Figure 2(a) shows an example of a DCS tree.</S><S sid="38" ssid="14">Let us start by considering a DCS tree z with only join relations.</S><S sid="107" ssid="83">Our model is arc-factored, so we can sum over all DCS trees in ZL(x) using dynamic programming.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'34'", "'38'", "'107'"]
'12'
'34'
'38'
'107'
['12', '34', '38', '107']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="164" ssid="49">Past work has also fofor the second.</S><S sid="165" ssid="50">These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'164'", "'165'", "'166'"]
'7'
'164'
'165'
'166'
['7', '164', '165', '166']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="156" ssid="41">There has been a fair amount of past work on no predicates), confusion of Washington state with this topic: Liang et al. (2010) induces combinatory Washington D.C., learning the wrong lexical asso- logic programs in a non-linguistic setting.</S><S sid="165" ssid="50">These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'8'", "'156'", "'165'"]
'7'
'8'
'156'
'165'
['7', '8', '156', '165']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S><S sid="135" ssid="20">SEMRESP requires a lexicon of 1.42 words per non-value predicate, WordNet features, and syntactic parse trees; DCS requires only words for the domain-independent predicates (overall, around 0.5 words per non-value predicate), POS tags, and very simple indicator features.</S><S sid="136" ssid="21">In fact, DCS performs comparably to even the version of SEMRESP trained using logical forms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'10'", "'135'", "'136'"]
'9'
'10'
'135'
'136'
['9', '10', '135', '136']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="3" ssid="3">In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid="5" ssid="1">What is the total population of the ten largest capitals in the US?</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'5'", "'22'"]
'2'
'3'
'5'
'22'
['2', '3', '5', '22']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="132" ssid="17">Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'9'", "'132'"]
'1'
'2'
'9'
'132'
['1', '2', '9', '132']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'22'", "'25'", "'36'"]
'21'
'22'
'25'
'36'
['21', '22', '25', '36']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="47" ssid="23">This algorithm is linear in the number of nodes times the size of the denotations.1 Now the dual importance of trees in DCS is clear: We have seen that trees parallel syntactic dependency structure, which will facilitate parsing.</S><S sid="48" ssid="24">In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.</S><S sid="49" ssid="25">Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compositional structures, but they cannot capture higherorder phenomena in language.</S><S sid="94" ssid="70">We now turn to the task of mapping natural language For the example in Figure 4(b), the de- utterances to DCS trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'47'", "'48'", "'49'", "'94'"]
'47'
'48'
'49'
'94'
['47', '48', '49', '94']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.</S><S sid="33" ssid="9">As another example, w(average) = {(S, &#175;x) : We write a DCS tree z as hp; r1 : c1; ... ; rm : cmi.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S><S sid="167" ssid="52">In DCS, we start with lexical triggers, which are 6 Conclusion more basic than CCG lexical entries.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'33'", "'166'", "'167'"]
'12'
'33'
'166'
'167'
['12', '33', '166', '167']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="43" ssid="19">Computation We can compute the denotation JzKw of a DCS tree z by exploiting dynamic programming on trees (Dechter, 2003).</S><S sid="46" ssid="22">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).</S><S sid="50" ssid="26">For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.</S><S sid="86" ssid="62">Formally, extraction simply moves the i-th column to the front: Xi(d) = di, &#8722;(i, &#248;){&#945;1 = &#248;}.</S>
original cit marker offset is 0
new cit marker offset is 0



["'43'", "'46'", "'50'", "'86'"]
'43'
'46'
'50'
'86'
['43', '46', '50', '86']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'9'"]
'1'
'2'
'8'
'9'
['1', '2', '8', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="133" ssid="18">Table 2 shows that our system using lexical triggers L (henceforth, DCS) outperforms SEMRESP (78.9% over 73.2%).</S><S sid="140" ssid="25">Table 3 shows that even DCS, which does not use prototypes, is comparable to the best previous system (Kwiatkowski et al., 2010), and by adding a few prototypes, DCS+ offers a decisive edge (91.1% over 88.9% on GEO).</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'133'", "'140'", "'166'"]
'7'
'133'
'140'
'166'
['7', '133', '140', '166']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="162" ssid="47">The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.</S><S sid="164" ssid="49">Past work has also fofor the second.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'9'", "'162'", "'164'"]
'7'
'9'
'162'
'164'
['7', '9', '162', '164']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="17" ssid="13">The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'22'", "'25'", "'36'"]
'17'
'22'
'25'
'36'
['17', '22', '25', '36']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="13">The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.</S><S sid="50" ssid="26">For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.</S><S sid="150" ssid="35">For example, area (by virtue which results in programs (DCS trees) which are of being a noun) triggers many predicates: city, much simpler than the logically-equivalent lambda state, area, etc.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'50'", "'150'", "'166'"]
'17'
'50'
'150'
'166'
['17', '50', '150', '166']
parsed_discourse_facet ['method_citation']



P11-1060
W12-2802
0
method_citation
['method_citation']



P11-1060
P13-2009
0
method_citation
['method_citation']



P11-1060
P12-1045
0
method_citation
['hypothesis_citation']
parsing: input/ref/Task1/P11-1061_aakansha.csv
<S sid="40" ssid="6">We extend Subramanya et al.&#8217;s intuitions to our bilingual setup.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'"]
'40'
['40']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="11">First, we use a novel graph-based framework for projecting syntactic information across language boundaries.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'"]
'15'
['15']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="2">Central to our approach (see Algorithm 1) is a bilingual similarity graph built from a sentence-aligned parallel corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'"]
'25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="29" ssid="6">To establish a soft correspondence between the two languages, we use a second similarity function, which leverages standard unsupervised word alignment statistics (&#167;3.3).3 Since we have no labeled foreign data, our goal is to project syntactic information from the English side to the foreign side.</S>
original cit marker offset is 0
new cit marker offset is 0



["'29'"]
'29'
['29']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'"]
'18'
['18']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'"]
'18'
['18']
parsed_discourse_facet ['method_citation']
<S sid="158" ssid="1">We have shown the efficacy of graph-based label propagation for projecting part-of-speech information across languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'158'"]
'158'
['158']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">These universal POS categories not only facilitate the transfer of POS information from one language to another, but also relieve us from using controversial evaluation metrics,2 by establishing a direct correspondence between the induced hidden states in the foreign language and the observed English labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="158" ssid="1">We have shown the efficacy of graph-based label propagation for projecting part-of-speech information across languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'158'"]
'158'
['158']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">These universal POS categories not only facilitate the transfer of POS information from one language to another, but also relieve us from using controversial evaluation metrics,2 by establishing a direct correspondence between the induced hidden states in the foreign language and the observed English labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'"]
'17'
['17']
parsed_discourse_facet ['method_citation']
<S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S>
original cit marker offset is 0
new cit marker offset is 0



["'111'"]
'111'
['111']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="29" ssid="6">To establish a soft correspondence between the two languages, we use a second similarity function, which leverages standard unsupervised word alignment statistics (&#167;3.3).3 Since we have no labeled foreign data, our goal is to project syntactic information from the English side to the foreign side.</S>
original cit marker offset is 0
new cit marker offset is 0



["'29'"]
'29'
['29']
parsed_discourse_facet ['method_citation']
<S sid="161" ssid="4">Our results outperform strong unsupervised baselines as well as approaches that rely on direct projections, and bridge the gap between purely supervised and unsupervised POS tagging models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'161'"]
'161'
['161']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P11-1061.annv3.csv
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="7" ssid="3">However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.</S><S sid="8" ssid="4">Unsupervised learning approaches appear to be a natural solution to this problem, as they require only unannotated text for training models.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'7'", "'8'", "'18'"]
'1'
'7'
'8'
'18'
['1', '7', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="6" ssid="2">Supervised part-of-speech (POS) taggers, for example, approach the level of inter-annotator agreement (Shen et al., 2007, 97.3% accuracy for English).</S><S sid="7" ssid="3">However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.</S><S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'6'", "'7'", "'9'"]
'1'
'6'
'7'
'9'
['1', '6', '7', '9']
parsed_discourse_facet ['hypothesis_citation', 'results_citation']
<S sid="0">Unsupervised Part-of-Speech Tagging with Bilingual Graph-Based Projections</S><S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'112'", "'113'"]
'0'
'2'
'112'
'113'
['0', '2', '112', '113']
parsed_discourse_facet ['aim_citation']
<S sid="27" ssid="4">Graph construction does not require any labeled data, but makes use of two similarity functions.</S><S sid="47" ssid="13">Our monolingual similarity function (for connecting pairs of foreign trigram types) is the same as the one used by Subramanya et al. (2010).</S><S sid="48" ssid="14">We briefly review it here for completeness.</S><S sid="51" ssid="17">For each trigram type x2 x3 x4 in a sequence x1 x2 x3 x4 x5, we count how many times that trigram type co-occurs with the different instantiations of each concept, and compute the point-wise mutual information (PMI) between the two.5 The similarity between two trigram types is given by summing over the PMI values over feature instantiations that they have in common.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'47'", "'48'", "'51'"]
'27'
'47'
'48'
'51'
['27', '47', '48', '51']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="4">Graph construction does not require any labeled data, but makes use of two similarity functions.</S><S sid="57" ssid="23">Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.</S><S sid="69" ssid="35">Label propagation is used to propagate these tags inwards and results in tag distributions for the middle word of each Italian trigram.</S><S sid="97" ssid="28">This formulation of the constraint feature is equivalent to the use of a tagging dictionary extracted from the graph using a threshold T on the posterior distribution of tags for a given word type (Eq.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'57'", "'69'", "'97'"]
'27'
'57'
'69'
'97'
['27', '57', '69', '97']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S><S sid="96" ssid="27">The function A : F &#8212;* C maps from the language specific fine-grained tagset F to the coarser universal tagset C and is described in detail in &#167;6.2: Note that when tx(y) = 1 the feature value is 0 and has no effect on the model, while its value is &#8722;oc when tx(y) = 0 and constrains the HMM&#8217;s state space.</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'96'", "'111'", "'113'"]
'19'
'96'
'111'
'113'
['19', '96', '111', '113']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S><S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'17'", "'18'", "'113'"]
'3'
'17'
'18'
'113'
['3', '17', '18', '113']
parsed_discourse_facet ['results_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'111'", "'112'", "'113'"]
'18'
'111'
'112'
'113'
['18', '111', '112', '113']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'24'", "'112'", "'113'"]
'1'
'24'
'112'
'113'
['1', '24', '112', '113']
parsed_discourse_facet ['aim_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S><S sid="16" ssid="12">To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).</S><S sid="70" ssid="1">Given the bilingual graph described in the previous section, we can use label propagation to project the English POS labels to the foreign language.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'16'", "'70'", "'113'"]
'3'
'16'
'70'
'113'
['3', '16', '70', '113']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="29" ssid="6">To establish a soft correspondence between the two languages, we use a second similarity function, which leverages standard unsupervised word alignment statistics (&#167;3.3).3 Since we have no labeled foreign data, our goal is to project syntactic information from the English side to the foreign side.</S><S sid="57" ssid="23">Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'24'", "'29'", "'57'"]
'1'
'24'
'29'
'57'
['1', '24', '29', '57']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S><S sid="71" ssid="2">We use label propagation in two stages to generate soft labels on all the vertices in the graph.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'10'", "'71'", "'113'"]
'1'
'10'
'71'
'113'
['1', '10', '71', '113']
parsed_discourse_facet ['results_citation']
<S sid="4" ssid="4">Across eight European languages, our approach results in an average absolute improvement of 10.4% over a state-of-the-art baseline, and 16.7% over vanilla hidden Markov models induced with the Expectation Maximization algorithm.</S><S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S><S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'9'", "'19'", "'112'"]
'4'
'9'
'19'
'112'
['4', '9', '19', '112']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S><S sid="114" ssid="14">The supervised POS tagging accuracies (on this tagset) are shown in the last row of Table 2.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'18'", "'113'", "'114'"]
'17'
'18'
'113'
'114'
['17', '18', '113', '114']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'17'", "'112'", "'113'"]
'1'
'17'
'112'
'113'
['1', '17', '112', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'24'", "'113'"]
'1'
'2'
'24'
'113'
['1', '2', '24', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'18'", "'111'", "'113'"]
'1'
'18'
'111'
'113'
['1', '18', '111', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="93" ssid="24">For English POS tagging, BergKirkpatrick et al. (2010) found that this direct gradient method performed better (&gt;7% absolute accuracy) than using a feature-enhanced modification of the Expectation-Maximization (EM) algorithm (Dempster et al., 1977).8 Moreover, this route of optimization outperformed a vanilla HMM trained with EM by 12%.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S><S sid="117" ssid="17">In other words, the set of hidden states F was chosen to be the fine set of treebank tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'93'", "'112'", "'113'", "'117'"]
'93'
'112'
'113'
'117'
['93', '112', '113', '117']
parsed_discourse_facet ['method_citation']



P11-1061
N12-1052
0
method_citation
['results_citation']



P11-1061
D12-1127
0
method_citation
['results_citation']
parsing: input/ref/Task1/P11-1061_swastika.csv
    <S sid="144" ssid="7">For comparison, the completely unsupervised feature-HMM baseline accuracy on the universal POS tags for English is 79.4%, and goes up to 88.7% with a treebank dictionary.</S>
original cit marker offset is 0
new cit marker offset is 0



['144']
144
['144']
parsed_discourse_facet ['result_citation']
    <S sid="44" ssid="10">Because all English vertices are going to be labeled, we do not need to disambiguate them by embedding them in trigrams.</S
original cit marker offset is 0
new cit marker offset is 0



['44']
44
['44']
parsed_discourse_facet ['method_citation']
    <S sid="16" ssid="12">To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).</S>
original cit marker offset is 0
new cit marker offset is 0



['16']
16
['16']
parsed_discourse_facet ['method_citation']
    <S sid="44" ssid="10">Because all English vertices are going to be labeled, we do not need to disambiguate them by embedding them in trigrams.</S
original cit marker offset is 0
new cit marker offset is 0



['44']
44
['44']
parsed_discourse_facet ['method_citation']
<S sid="110" ssid="10">We hope that this will allow practitioners to apply our approach directly to languages for which no resources are available.</S>
original cit marker offset is 0
new cit marker offset is 0



['110']
110
['110']
parsed_discourse_facet ['aim_citation']
    <S sid="115" ssid="15">The taggers were trained on datasets labeled with the universal tags.</S>
original cit marker offset is 0
new cit marker offset is 0



['115']
115
['115']
parsed_discourse_facet ['method_citation']
    <S sid="115" ssid="15">The taggers were trained on datasets labeled with the universal tags.</S>
original cit marker offset is 0
new cit marker offset is 0



['115']
115
['115']
parsed_discourse_facet ['method_citation']
<S sid="158" ssid="1">We have shown the efficacy of graph-based label propagation for projecting part-of-speech information across languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['158']
158
['158']
parsed_discourse_facet ['result_citation']
<S sid="23" ssid="19">Our final average POS tagging accuracy of 83.4% compares very favorably to the average accuracy of Berg-Kirkpatrick et al.&#8217;s monolingual unsupervised state-of-the-art model (73.0%), and considerably bridges the gap to fully supervised POS tagging performance (96.6%).</S>
original cit marker offset is 0
new cit marker offset is 0



['23']
23
['23']
parsed_discourse_facet ['result_citation']
<S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['24']
24
['24']
parsed_discourse_facet ['aim_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



['10']
10
['10']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



['???']
???
['???']
parsed_discourse_facet ['method_citation']
    <S sid="16" ssid="12">To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).</S>
original cit marker offset is 0
new cit marker offset is 0



['16']
16
['16']
parsed_discourse_facet ['method_citation']
    <S sid="23" ssid="19">Our final average POS tagging accuracy of 83.4% compares very favorably to the average accuracy of Berg-Kirkpatrick et al.&#8217;s monolingual unsupervised state-of-the-art model (73.0%), and considerably bridges the gap to fully supervised POS tagging performance (96.6%).</S>
original cit marker offset is 0
new cit marker offset is 0



['23']
23
['23']
parsed_discourse_facet ['result_citation']
<S sid="158" ssid="1">We have shown the efficacy of graph-based label propagation for projecting part-of-speech information across languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['158']
158
['158']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



['10']
10
['10']
parsed_discourse_facet ['method_citation']
<S sid="56" ssid="22">To define a similarity function between the English and the foreign vertices, we rely on high-confidence word alignments.</S>
original cit marker offset is 0
new cit marker offset is 0



['56']
56
['56']
parsed_discourse_facet ['method_citation']
<S sid="161" ssid="4">Our results outperform strong unsupervised baselines as well as approaches that rely on direct projections, and bridge the gap between purely supervised and unsupervised POS tagging models.</S>
original cit marker offset is 0
new cit marker offset is 0



['161']
161
['161']
parsed_discourse_facet ['result_citation']
parsing: input/res/Task1/P11-1061.annv3.csv
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="7" ssid="3">However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.</S><S sid="8" ssid="4">Unsupervised learning approaches appear to be a natural solution to this problem, as they require only unannotated text for training models.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'7'", "'8'", "'18'"]
'1'
'7'
'8'
'18'
['1', '7', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="6" ssid="2">Supervised part-of-speech (POS) taggers, for example, approach the level of inter-annotator agreement (Shen et al., 2007, 97.3% accuracy for English).</S><S sid="7" ssid="3">However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.</S><S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'6'", "'7'", "'9'"]
'1'
'6'
'7'
'9'
['1', '6', '7', '9']
parsed_discourse_facet ['hypothesis_citation', 'results_citation']
<S sid="0">Unsupervised Part-of-Speech Tagging with Bilingual Graph-Based Projections</S><S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'112'", "'113'"]
'0'
'2'
'112'
'113'
['0', '2', '112', '113']
parsed_discourse_facet ['aim_citation']
<S sid="27" ssid="4">Graph construction does not require any labeled data, but makes use of two similarity functions.</S><S sid="47" ssid="13">Our monolingual similarity function (for connecting pairs of foreign trigram types) is the same as the one used by Subramanya et al. (2010).</S><S sid="48" ssid="14">We briefly review it here for completeness.</S><S sid="51" ssid="17">For each trigram type x2 x3 x4 in a sequence x1 x2 x3 x4 x5, we count how many times that trigram type co-occurs with the different instantiations of each concept, and compute the point-wise mutual information (PMI) between the two.5 The similarity between two trigram types is given by summing over the PMI values over feature instantiations that they have in common.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'47'", "'48'", "'51'"]
'27'
'47'
'48'
'51'
['27', '47', '48', '51']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="4">Graph construction does not require any labeled data, but makes use of two similarity functions.</S><S sid="57" ssid="23">Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.</S><S sid="69" ssid="35">Label propagation is used to propagate these tags inwards and results in tag distributions for the middle word of each Italian trigram.</S><S sid="97" ssid="28">This formulation of the constraint feature is equivalent to the use of a tagging dictionary extracted from the graph using a threshold T on the posterior distribution of tags for a given word type (Eq.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'57'", "'69'", "'97'"]
'27'
'57'
'69'
'97'
['27', '57', '69', '97']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S><S sid="96" ssid="27">The function A : F &#8212;* C maps from the language specific fine-grained tagset F to the coarser universal tagset C and is described in detail in &#167;6.2: Note that when tx(y) = 1 the feature value is 0 and has no effect on the model, while its value is &#8722;oc when tx(y) = 0 and constrains the HMM&#8217;s state space.</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'96'", "'111'", "'113'"]
'19'
'96'
'111'
'113'
['19', '96', '111', '113']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S><S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'17'", "'18'", "'113'"]
'3'
'17'
'18'
'113'
['3', '17', '18', '113']
parsed_discourse_facet ['results_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'111'", "'112'", "'113'"]
'18'
'111'
'112'
'113'
['18', '111', '112', '113']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'24'", "'112'", "'113'"]
'1'
'24'
'112'
'113'
['1', '24', '112', '113']
parsed_discourse_facet ['aim_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S><S sid="16" ssid="12">To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).</S><S sid="70" ssid="1">Given the bilingual graph described in the previous section, we can use label propagation to project the English POS labels to the foreign language.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'16'", "'70'", "'113'"]
'3'
'16'
'70'
'113'
['3', '16', '70', '113']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="29" ssid="6">To establish a soft correspondence between the two languages, we use a second similarity function, which leverages standard unsupervised word alignment statistics (&#167;3.3).3 Since we have no labeled foreign data, our goal is to project syntactic information from the English side to the foreign side.</S><S sid="57" ssid="23">Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'24'", "'29'", "'57'"]
'1'
'24'
'29'
'57'
['1', '24', '29', '57']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S><S sid="71" ssid="2">We use label propagation in two stages to generate soft labels on all the vertices in the graph.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'10'", "'71'", "'113'"]
'1'
'10'
'71'
'113'
['1', '10', '71', '113']
parsed_discourse_facet ['results_citation']
<S sid="4" ssid="4">Across eight European languages, our approach results in an average absolute improvement of 10.4% over a state-of-the-art baseline, and 16.7% over vanilla hidden Markov models induced with the Expectation Maximization algorithm.</S><S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S><S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'9'", "'19'", "'112'"]
'4'
'9'
'19'
'112'
['4', '9', '19', '112']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S><S sid="114" ssid="14">The supervised POS tagging accuracies (on this tagset) are shown in the last row of Table 2.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'18'", "'113'", "'114'"]
'17'
'18'
'113'
'114'
['17', '18', '113', '114']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'17'", "'112'", "'113'"]
'1'
'17'
'112'
'113'
['1', '17', '112', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'24'", "'113'"]
'1'
'2'
'24'
'113'
['1', '2', '24', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'18'", "'111'", "'113'"]
'1'
'18'
'111'
'113'
['1', '18', '111', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="93" ssid="24">For English POS tagging, BergKirkpatrick et al. (2010) found that this direct gradient method performed better (&gt;7% absolute accuracy) than using a feature-enhanced modification of the Expectation-Maximization (EM) algorithm (Dempster et al., 1977).8 Moreover, this route of optimization outperformed a vanilla HMM trained with EM by 12%.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S><S sid="117" ssid="17">In other words, the set of hidden states F was chosen to be the fine set of treebank tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'93'", "'112'", "'113'", "'117'"]
'93'
'112'
'113'
'117'
['93', '112', '113', '117']
parsed_discourse_facet ['method_citation']
parsing: input/ref/Task1/P11-1061_sweta.csv
 <S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S>
original cit marker offset is 0
new cit marker offset is 0



["9'"]
9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="47" ssid="13">Our monolingual similarity function (for connecting pairs of foreign trigram types) is the same as the one used by Subramanya et al. (2010).</S>
original cit marker offset is 0
new cit marker offset is 0



["47'"]
47'
['47']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



["10'"]
10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="70" ssid="1">Given the bilingual graph described in the previous section, we can use label propagation to project the English POS labels to the foreign language.</S>
original cit marker offset is 0
new cit marker offset is 0



["70'"]
70'
['70']
parsed_discourse_facet ['method_citation']
<S sid="52" ssid="18">This is similar to stacking the different feature instantiations into long (sparse) vectors and computing the cosine similarity between them.</S>
original cit marker offset is 0
new cit marker offset is 0



["52'"]
52'
['52']
parsed_discourse_facet ['method_citation']
 <S sid="83" ssid="14">We then extract a set of possible tags tx(y) by eliminating labels whose probability is below a threshold value &#964;: We describe how we choose &#964; in &#167;6.4.</S>
original cit marker offset is 0
new cit marker offset is 0



["83'"]
83'
['83']
parsed_discourse_facet ['method_citation']
<S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["113'"]
113'
['113']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S>
original cit marker offset is 0
new cit marker offset is 0



["3'"]
3'
['3']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["18'"]
18'
['18']
parsed_discourse_facet ['method_citation']
 <S sid="13" ssid="9">(2009) study related but different multilingual grammar and tagger induction tasks, where it is assumed that no labeled data at all is available.</S>
original cit marker offset is 0
new cit marker offset is 0



["13'"]
13'
['13']
parsed_discourse_facet ['method_citation']
 <S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S>
original cit marker offset is 0
new cit marker offset is 0



["3'"]
3'
['3']
parsed_discourse_facet ['method_citation']
<S sid="120" ssid="20">We were intentionally lenient with our baselines: bilingual information by projecting POS tags directly across alignments in the parallel data.</S>
original cit marker offset is 0
new cit marker offset is 0



["120'"]
120'
['120']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["2'"]
2'
['2']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["19'"]
19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="153" ssid="16">Figure 2 shows an excerpt of a sentence from the Italian test set and the tags assigned by four different models, as well as the gold tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["153'"]
153'
['153']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["18'"]
18'
['18']
parsed_discourse_facet ['method_citation']
<S sid="161" ssid="4">Our results outperform strong unsupervised baselines as well as approaches that rely on direct projections, and bridge the gap between purely supervised and unsupervised POS tagging models.</S>
original cit marker offset is 0
new cit marker offset is 0



["161'"]
161'
['161']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="19">Our final average POS tagging accuracy of 83.4% compares very favorably to the average accuracy of Berg-Kirkpatrick et al.&#8217;s monolingual unsupervised state-of-the-art model (73.0%), and considerably bridges the gap to fully supervised POS tagging performance (96.6%).</S>
original cit marker offset is 0
new cit marker offset is 0



["23'"]
23'
['23']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="19">Our final average POS tagging accuracy of 83.4% compares very favorably to the average accuracy of Berg-Kirkpatrick et al.&#8217;s monolingual unsupervised state-of-the-art model (73.0%), and considerably bridges the gap to fully supervised POS tagging performance (96.6%).</S>
original cit marker offset is 0
new cit marker offset is 0



["23'"]
23'
['23']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P11-1061.annv3.csv
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="7" ssid="3">However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.</S><S sid="8" ssid="4">Unsupervised learning approaches appear to be a natural solution to this problem, as they require only unannotated text for training models.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'7'", "'8'", "'18'"]
'1'
'7'
'8'
'18'
['1', '7', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="6" ssid="2">Supervised part-of-speech (POS) taggers, for example, approach the level of inter-annotator agreement (Shen et al., 2007, 97.3% accuracy for English).</S><S sid="7" ssid="3">However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.</S><S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'6'", "'7'", "'9'"]
'1'
'6'
'7'
'9'
['1', '6', '7', '9']
parsed_discourse_facet ['hypothesis_citation', 'results_citation']
<S sid="0">Unsupervised Part-of-Speech Tagging with Bilingual Graph-Based Projections</S><S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'112'", "'113'"]
'0'
'2'
'112'
'113'
['0', '2', '112', '113']
parsed_discourse_facet ['aim_citation']
<S sid="27" ssid="4">Graph construction does not require any labeled data, but makes use of two similarity functions.</S><S sid="47" ssid="13">Our monolingual similarity function (for connecting pairs of foreign trigram types) is the same as the one used by Subramanya et al. (2010).</S><S sid="48" ssid="14">We briefly review it here for completeness.</S><S sid="51" ssid="17">For each trigram type x2 x3 x4 in a sequence x1 x2 x3 x4 x5, we count how many times that trigram type co-occurs with the different instantiations of each concept, and compute the point-wise mutual information (PMI) between the two.5 The similarity between two trigram types is given by summing over the PMI values over feature instantiations that they have in common.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'47'", "'48'", "'51'"]
'27'
'47'
'48'
'51'
['27', '47', '48', '51']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="4">Graph construction does not require any labeled data, but makes use of two similarity functions.</S><S sid="57" ssid="23">Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.</S><S sid="69" ssid="35">Label propagation is used to propagate these tags inwards and results in tag distributions for the middle word of each Italian trigram.</S><S sid="97" ssid="28">This formulation of the constraint feature is equivalent to the use of a tagging dictionary extracted from the graph using a threshold T on the posterior distribution of tags for a given word type (Eq.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'57'", "'69'", "'97'"]
'27'
'57'
'69'
'97'
['27', '57', '69', '97']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S><S sid="96" ssid="27">The function A : F &#8212;* C maps from the language specific fine-grained tagset F to the coarser universal tagset C and is described in detail in &#167;6.2: Note that when tx(y) = 1 the feature value is 0 and has no effect on the model, while its value is &#8722;oc when tx(y) = 0 and constrains the HMM&#8217;s state space.</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'96'", "'111'", "'113'"]
'19'
'96'
'111'
'113'
['19', '96', '111', '113']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S><S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'17'", "'18'", "'113'"]
'3'
'17'
'18'
'113'
['3', '17', '18', '113']
parsed_discourse_facet ['results_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'111'", "'112'", "'113'"]
'18'
'111'
'112'
'113'
['18', '111', '112', '113']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'24'", "'112'", "'113'"]
'1'
'24'
'112'
'113'
['1', '24', '112', '113']
parsed_discourse_facet ['aim_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S><S sid="16" ssid="12">To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).</S><S sid="70" ssid="1">Given the bilingual graph described in the previous section, we can use label propagation to project the English POS labels to the foreign language.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'16'", "'70'", "'113'"]
'3'
'16'
'70'
'113'
['3', '16', '70', '113']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="29" ssid="6">To establish a soft correspondence between the two languages, we use a second similarity function, which leverages standard unsupervised word alignment statistics (&#167;3.3).3 Since we have no labeled foreign data, our goal is to project syntactic information from the English side to the foreign side.</S><S sid="57" ssid="23">Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'24'", "'29'", "'57'"]
'1'
'24'
'29'
'57'
['1', '24', '29', '57']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S><S sid="71" ssid="2">We use label propagation in two stages to generate soft labels on all the vertices in the graph.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'10'", "'71'", "'113'"]
'1'
'10'
'71'
'113'
['1', '10', '71', '113']
parsed_discourse_facet ['results_citation']
<S sid="4" ssid="4">Across eight European languages, our approach results in an average absolute improvement of 10.4% over a state-of-the-art baseline, and 16.7% over vanilla hidden Markov models induced with the Expectation Maximization algorithm.</S><S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S><S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'9'", "'19'", "'112'"]
'4'
'9'
'19'
'112'
['4', '9', '19', '112']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S><S sid="114" ssid="14">The supervised POS tagging accuracies (on this tagset) are shown in the last row of Table 2.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'18'", "'113'", "'114'"]
'17'
'18'
'113'
'114'
['17', '18', '113', '114']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'17'", "'112'", "'113'"]
'1'
'17'
'112'
'113'
['1', '17', '112', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'24'", "'113'"]
'1'
'2'
'24'
'113'
['1', '2', '24', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'18'", "'111'", "'113'"]
'1'
'18'
'111'
'113'
['1', '18', '111', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="93" ssid="24">For English POS tagging, BergKirkpatrick et al. (2010) found that this direct gradient method performed better (&gt;7% absolute accuracy) than using a feature-enhanced modification of the Expectation-Maximization (EM) algorithm (Dempster et al., 1977).8 Moreover, this route of optimization outperformed a vanilla HMM trained with EM by 12%.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S><S sid="117" ssid="17">In other words, the set of hidden states F was chosen to be the fine set of treebank tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'93'", "'112'", "'113'", "'117'"]
'93'
'112'
'113'
'117'
['93', '112', '113', '117']
parsed_discourse_facet ['method_citation']



P11-1061
N12-1052
0
method_citation
['results_citation']



P11-1061
N12-1090
0
method_citation
['method_citation', 'aim_citation']



P11-1061
P13-1155
0
method_citation
['method_citation', 'aim_citation']



P11-1061
P12-3012
0
method_citation
['hypothesis_citation', 'aim_citation']
parsing: input/ref/Task1/P87-1015_swastika.csv
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['118']
118
['118']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['118']
118
['118']
parsed_discourse_facet ['aim_citation']
<S sid="149" ssid="34">We can obtain a letter equivalent CFL defined by a CFG in which the for each rule as above, we have the production A &#8212;* A1 Anup where tk (up) = cp.</S>
original cit marker offset is 0
new cit marker offset is 0



['149']
149
['149']
parsed_discourse_facet ['method_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['118']
118
['118']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['118']
118
['118']
parsed_discourse_facet ['aim_citation']
    <S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['2']
2
['2']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['118']
118
['118']
parsed_discourse_facet ['aim_citation']
<S sid="222" ssid="28">However, in order to capture the properties of various grammatical systems under consideration, our notation is more restrictive that ILFP, which was designed as a general logical notation to characterize the complete class of languages that are recognizable in polynomial time.</S>
original cit marker offset is 0
new cit marker offset is 0



['222']
222
['222']
parsed_discourse_facet ['method_citation']
<S sid="119" ssid="4">In defining LCFRS's, we hope to generalize the definition of CFG's to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S>
original cit marker offset is 0
new cit marker offset is 0



['119']
119
['119']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['???']
???
['???']
parsed_discourse_facet ['aim_citation']
<S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



['207']
207
['207']
parsed_discourse_facet ['result_citation']
<S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



['207']
207
['207']
parsed_discourse_facet ['result_citation']
<S sid="19" ssid="4">It can be easily shown from Thatcher's result that the path set of every local set is a regular set.</S>
original cit marker offset is 0
new cit marker offset is 0



['19']
19
['19']
parsed_discourse_facet ['method_citation']
<S sid="119" ssid="4">In defining LCFRS's, we hope to generalize the definition of CFG's to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S>
original cit marker offset is 0
new cit marker offset is 0



['119']
119
['119']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['118']
118
['118']
parsed_discourse_facet ['aim_citation']
parsing: input/res/Task1/P87-1015.annv3.csv
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="232" ssid="38">In considering this aspect of a formalism, we hope to better understand the relationship between the structural descriptions generated by the grammars of a formalism, and the properties of semilinearity and polynomial recognizability.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'118'", "'232'"]
'2'
'3'
'118'
'232'
['2', '3', '118', '232']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="180" ssid="65">The rewrite rules and the definition of the composition operations may be stored in the finite state control since G uses a finite number of them.</S><S sid="230" ssid="36">LCFRS\s have only been loosely defined in this paper; we have yet to provide a complete set of formal properties associated with members of this class.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'", "'151'", "'180'", "'230'"]
'118'
'151'
'180'
'230'
['118', '151', '180', '230']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We consider the structural descriptions produced by various grammatical formalisms in terms of the complexity of the paths and the relationship between paths in the sets of structural descriptions that each system can generate.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="214" ssid="20">LCFRS\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'3'", "'119'", "'214'"]
'1'
'3'
'119'
'214'
['1', '3', '119', '214']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="92" ssid="77">We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S><S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'92'", "'118'", "'134'", "'207'"]
'92'
'118'
'134'
'207'
['92', '118', '134', '207']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'74'", "'207'"]
'2'
'3'
'74'
'207'
['2', '3', '74', '207']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\s insists that the composition operations are linear and nonerasing.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="229" ssid="35">In addition, the restricted version of CG\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\s containing formalisms whose tree sets have path sets that are themselves LCFRL\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'146'", "'151'", "'229'"]
'119'
'146'
'151'
'229'
['119', '146', '151', '229']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="92" ssid="77">We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="164" ssid="49">Although embedding this version of LCFRS\s in the framework of ILFP developed by Rounds (1985) is straightforward, our motivation was to capture properties shared by a family of grammatical systems and generalize them defining a class of related formalisms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'92'", "'118'", "'164'"]
'2'
'92'
'118'
'164'
['2', '92', '118', '164']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="117" ssid="2">Our goal is to define a class of formal systems, and show that any member of this class will possess certain attractive properties.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'117'", "'118'"]
'2'
'3'
'117'
'118'
['2', '3', '117', '118']
parsed_discourse_facet ['aim_citation']
<S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\s insists that the composition operations are linear and nonerasing.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="229" ssid="35">In addition, the restricted version of CG\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\s containing formalisms whose tree sets have path sets that are themselves LCFRL\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'146'", "'151'", "'229'"]
'119'
'146'
'151'
'229'
['119', '146', '151', '229']
parsed_discourse_facet ['method_citation']
<S sid="42" ssid="27">Suppose -y results from the adjunction of 71, ,-y, at the k distinct tree addresses 141, , nk in some elementary tree 7\, respectively.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="75" ssid="60">A multicomponent Tree Adjoining Grammar (MCTAG) consists of a finite set of finite elementary tree sets.</S><S sid="158" ssid="43">We can represent any derived tree of a TAG by the two substrings that appear in its frontier, and then define how the adjunction operation concatenates the substrings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'42'", "'74'", "'75'", "'158'"]
'42'
'74'
'75'
'158'
['42', '74', '75', '158']
parsed_discourse_facet ['method_citation']
<S sid="89" ssid="74">Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\s, MCTAG\s, and HG\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.</S><S sid="90" ssid="75">Thus, as in CFG\s, at any point in the derivation, the set of structures that can be applied is determined only by a finite set of rules encapsulated by the grammar.</S><S sid="128" ssid="13">As in the case of the derivation trees of CFG\s, nodes are labeled by a member of some finite set of symbols (perhaps only implicit in the grammar as in TAG\s) used to denote derived structures.</S><S sid="141" ssid="26">Thus, the length of any string in L is a linear combination of the length of strings in some fixed finite subset of L, and thus L is said to have the constant growth property.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'", "'90'", "'128'", "'141'"]
'89'
'90'
'128'
'141'
['89', '90', '128', '141']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S><S sid="135" ssid="20">Unlike GCFG\s, however, the composition operations of LCFRS\s are restricted to be linear (do not duplicate unboundedly large structures) and nonerasing (do not erase unbounded structures, a restriction made in most modern transformational grammars).</S><S sid="228" ssid="34">Since these path sets are semilinear, the property of independent paths in their tree sets is sufficient to cause semilinearity of the languages generated by them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'134'", "'135'", "'228'"]
'2'
'134'
'135'
'228'
['2', '134', '135', '228']
parsed_discourse_facet ['aim_citation']
<S sid="73" ssid="58">The equivalence of CC\s with this restriction to TAG\s and HG\s is, however, still an open problem.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="89" ssid="74">Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\s, MCTAG\s, and HG\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.</S><S sid="228" ssid="34">Since these path sets are semilinear, the property of independent paths in their tree sets is sufficient to cause semilinearity of the languages generated by them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'73'", "'74'", "'89'", "'228'"]
'73'
'74'
'89'
'228'
['73', '74', '89', '228']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="71">MCTAG\s are able to generate tee sets having dependent paths.</S><S sid="93" ssid="78">As is described in Section 4, the property of having a derivation tree set that is a local set appears to be useful in showing important properties of the languages generated by the formalisms.</S><S sid="109" ssid="15">A geometrical progression of language families defined by Weir (1987) involves tree sets with increasingly complex path sets.</S><S sid="111" ssid="17">.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'", "'93'", "'109'", "'111'"]
'86'
'93'
'109'
'111'
['86', '93', '109', '111']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="27" ssid="12">Thus, the tree sets generated by HG\s are similar to those of CFG\s, with each node annotated by the operation (concatenation or wrapping) used to combine the headed strings derived by the daughters of Tree Adjoining Grammars, a tree rewriting formalism, was introduced by Joshi, Levy and Takahashi (1975) and Joshi (1983/85).</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="214" ssid="20">LCFRS\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'27'", "'74'", "'214'"]
'2'
'27'
'74'
'214'
['2', '27', '74', '214']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="91" ssid="76">We characterize a class of formalisms that have this property in Section 4.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'91'", "'118'", "'134'"]
'2'
'91'
'118'
'134'
['2', '91', '118', '134']
parsed_discourse_facet ['aim_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



P87-1015
P01-1018
0
aim_citation
['aim_citation']



P87-1015
E09-1055
0
aim_citation
['method_citation']



P87-1015
P07-1021
0
aim_citation
['hypothesis_citation']



P87-1015
P12-1053
0
aim_citation
['aim_citation']
IGNORE THIS: Key error 5
parsing: input/ref/Task1/P87-1015_sweta.csv
<S sid="205" ssid="11">Independence of paths at this level reflects context freeness of rewriting and suggests why they can be recognized efficiently.</S>
original cit marker offset is 0
new cit marker offset is 0



["205'"]
205'
['205']
parsed_discourse_facet ['method_citation']
<S sid="229" ssid="35">In addition, the restricted version of CG's (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS's containing formalisms whose tree sets have path sets that are themselves LCFRL's (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["229'"]
229'
['229']
parsed_discourse_facet ['method_citation']
<S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS's insists that the composition operations are linear and nonerasing.</S>
original cit marker offset is 0
new cit marker offset is 0



["146'"]
146'
['146']
parsed_discourse_facet ['method_citation']
<S sid="201" ssid="7">It is interesting to note, however, that the ability to produce a bounded number of dependent paths (where two dependent paths can share an unbounded amount of information) does not require machinery as powerful as that used in LFG, FUG and IG's.</S>
original cit marker offset is 0
new cit marker offset is 0



["201'"]
201'
['201']
parsed_discourse_facet ['method_citation']
 <S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL's).</S>
original cit marker offset is 0
new cit marker offset is 0



["151'"]
151'
['151']
parsed_discourse_facet ['method_citation']
 <S sid="222" ssid="28">However, in order to capture the properties of various grammatical systems under consideration, our notation is more restrictive that ILFP, which was designed as a general logical notation to characterize the complete class of languages that are recognizable in polynomial time.</S>
original cit marker offset is 0
new cit marker offset is 0



["222'"]
222'
['222']
parsed_discourse_facet ['method_citation']
<S sid="22" ssid="7">Gazdar (1985) argues this is the appropriate analysis of unbounded dependencies in the hypothetical Scandinavian language Norwedish.</S>
    <S sid="23" ssid="8">He also argues that paired English complementizers may also require structural descriptions whose path sets have nested dependencies.</S>
original cit marker offset is 0
new cit marker offset is 0



["22'", "'23'"]
22'
'23'
['22', '23']
parsed_discourse_facet ['method_citation']
 <S sid="156" ssid="41">Giving a recognition algorithm for LCFRL's involves describing the substrings of the input that are spanned by the structures derived by the LCFRS's and how the composition operation combines these substrings.</S>
original cit marker offset is 0
new cit marker offset is 0



["156'"]
156'
['156']
parsed_discourse_facet ['method_citation']
<S sid="221" ssid="27">Members of LCFRS whose operations have this property can be translated into the ILFP notation (Rounds, 1985).</S>
original cit marker offset is 0
new cit marker offset is 0



["221'"]
221'
['221']
parsed_discourse_facet ['method_citation']
<S sid="54" ssid="39">An IG can be viewed as a CFG in which each nonterminal is associated with a stack.</S>
original cit marker offset is 0
new cit marker offset is 0



["54'"]
54'
['54']
parsed_discourse_facet ['method_citation']
<S sid="128" ssid="13">As in the case of the derivation trees of CFG's, nodes are labeled by a member of some finite set of symbols (perhaps only implicit in the grammar as in TAG's) used to denote derived structures.</S>
original cit marker offset is 0
new cit marker offset is 0



["128'"]
128'
['128']
parsed_discourse_facet ['method_citation']
<S sid="217" ssid="23">In considering the recognition of these languages, we were forced to be more specific regarding the relationship between the structures derived by these formalisms and the substrings they span.</S>
original cit marker offset is 0
new cit marker offset is 0



[";217'"]
;217'
[';217']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="1">From Thatcher's (1973) work, it is obvious that the complexity of the set of paths from root to frontier of trees in a local set (the tree set of a CFG) is regular'.</S>
original cit marker offset is 0
new cit marker offset is 0



["16'"]
16'
['16']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="1">From Thatcher's (1973) work, it is obvious that the complexity of the set of paths from root to frontier of trees in a local set (the tree set of a CFG) is regular'.</S>
original cit marker offset is 0
new cit marker offset is 0



["16'"]
16'
['16']
parsed_discourse_facet ['method_citation']
<S sid="214" ssid="20">LCFRS's share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["214'"]
214'
['214']
parsed_discourse_facet ['method_citation']
<S sid="35" ssid="20">TAG's can be used to give the structural descriptions discussed by Gazdar (1985) for the unbounded nested dependencies in Norwedish, for cross serial dependencies in Dutch subordinate clauses, and for the nestings of paired English complementizers.</S>
original cit marker offset is 0
new cit marker offset is 0



["35'"]
35'
['35']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P87-1015.annv3.csv
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="232" ssid="38">In considering this aspect of a formalism, we hope to better understand the relationship between the structural descriptions generated by the grammars of a formalism, and the properties of semilinearity and polynomial recognizability.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'118'", "'232'"]
'2'
'3'
'118'
'232'
['2', '3', '118', '232']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="180" ssid="65">The rewrite rules and the definition of the composition operations may be stored in the finite state control since G uses a finite number of them.</S><S sid="230" ssid="36">LCFRS\s have only been loosely defined in this paper; we have yet to provide a complete set of formal properties associated with members of this class.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'", "'151'", "'180'", "'230'"]
'118'
'151'
'180'
'230'
['118', '151', '180', '230']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We consider the structural descriptions produced by various grammatical formalisms in terms of the complexity of the paths and the relationship between paths in the sets of structural descriptions that each system can generate.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="214" ssid="20">LCFRS\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'3'", "'119'", "'214'"]
'1'
'3'
'119'
'214'
['1', '3', '119', '214']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="92" ssid="77">We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S><S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'92'", "'118'", "'134'", "'207'"]
'92'
'118'
'134'
'207'
['92', '118', '134', '207']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'74'", "'207'"]
'2'
'3'
'74'
'207'
['2', '3', '74', '207']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\s insists that the composition operations are linear and nonerasing.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="229" ssid="35">In addition, the restricted version of CG\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\s containing formalisms whose tree sets have path sets that are themselves LCFRL\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'146'", "'151'", "'229'"]
'119'
'146'
'151'
'229'
['119', '146', '151', '229']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="92" ssid="77">We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="164" ssid="49">Although embedding this version of LCFRS\s in the framework of ILFP developed by Rounds (1985) is straightforward, our motivation was to capture properties shared by a family of grammatical systems and generalize them defining a class of related formalisms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'92'", "'118'", "'164'"]
'2'
'92'
'118'
'164'
['2', '92', '118', '164']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="117" ssid="2">Our goal is to define a class of formal systems, and show that any member of this class will possess certain attractive properties.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'117'", "'118'"]
'2'
'3'
'117'
'118'
['2', '3', '117', '118']
parsed_discourse_facet ['aim_citation']
<S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\s insists that the composition operations are linear and nonerasing.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="229" ssid="35">In addition, the restricted version of CG\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\s containing formalisms whose tree sets have path sets that are themselves LCFRL\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'146'", "'151'", "'229'"]
'119'
'146'
'151'
'229'
['119', '146', '151', '229']
parsed_discourse_facet ['method_citation']
<S sid="42" ssid="27">Suppose -y results from the adjunction of 71, ,-y, at the k distinct tree addresses 141, , nk in some elementary tree 7\, respectively.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="75" ssid="60">A multicomponent Tree Adjoining Grammar (MCTAG) consists of a finite set of finite elementary tree sets.</S><S sid="158" ssid="43">We can represent any derived tree of a TAG by the two substrings that appear in its frontier, and then define how the adjunction operation concatenates the substrings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'42'", "'74'", "'75'", "'158'"]
'42'
'74'
'75'
'158'
['42', '74', '75', '158']
parsed_discourse_facet ['method_citation']
<S sid="89" ssid="74">Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\s, MCTAG\s, and HG\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.</S><S sid="90" ssid="75">Thus, as in CFG\s, at any point in the derivation, the set of structures that can be applied is determined only by a finite set of rules encapsulated by the grammar.</S><S sid="128" ssid="13">As in the case of the derivation trees of CFG\s, nodes are labeled by a member of some finite set of symbols (perhaps only implicit in the grammar as in TAG\s) used to denote derived structures.</S><S sid="141" ssid="26">Thus, the length of any string in L is a linear combination of the length of strings in some fixed finite subset of L, and thus L is said to have the constant growth property.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'", "'90'", "'128'", "'141'"]
'89'
'90'
'128'
'141'
['89', '90', '128', '141']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S><S sid="135" ssid="20">Unlike GCFG\s, however, the composition operations of LCFRS\s are restricted to be linear (do not duplicate unboundedly large structures) and nonerasing (do not erase unbounded structures, a restriction made in most modern transformational grammars).</S><S sid="228" ssid="34">Since these path sets are semilinear, the property of independent paths in their tree sets is sufficient to cause semilinearity of the languages generated by them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'134'", "'135'", "'228'"]
'2'
'134'
'135'
'228'
['2', '134', '135', '228']
parsed_discourse_facet ['aim_citation']
<S sid="73" ssid="58">The equivalence of CC\s with this restriction to TAG\s and HG\s is, however, still an open problem.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="89" ssid="74">Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\s, MCTAG\s, and HG\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.</S><S sid="228" ssid="34">Since these path sets are semilinear, the property of independent paths in their tree sets is sufficient to cause semilinearity of the languages generated by them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'73'", "'74'", "'89'", "'228'"]
'73'
'74'
'89'
'228'
['73', '74', '89', '228']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="71">MCTAG\s are able to generate tee sets having dependent paths.</S><S sid="93" ssid="78">As is described in Section 4, the property of having a derivation tree set that is a local set appears to be useful in showing important properties of the languages generated by the formalisms.</S><S sid="109" ssid="15">A geometrical progression of language families defined by Weir (1987) involves tree sets with increasingly complex path sets.</S><S sid="111" ssid="17">.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'", "'93'", "'109'", "'111'"]
'86'
'93'
'109'
'111'
['86', '93', '109', '111']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="27" ssid="12">Thus, the tree sets generated by HG\s are similar to those of CFG\s, with each node annotated by the operation (concatenation or wrapping) used to combine the headed strings derived by the daughters of Tree Adjoining Grammars, a tree rewriting formalism, was introduced by Joshi, Levy and Takahashi (1975) and Joshi (1983/85).</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="214" ssid="20">LCFRS\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'27'", "'74'", "'214'"]
'2'
'27'
'74'
'214'
['2', '27', '74', '214']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="91" ssid="76">We characterize a class of formalisms that have this property in Section 4.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'91'", "'118'", "'134'"]
'2'
'91'
'118'
'134'
['2', '91', '118', '134']
parsed_discourse_facet ['aim_citation']



P87-1015
W10-1407
0
method_citation
['method_citation']



P87-1015
N10-1035
0
method_citation
['hypothesis_citation', 'aim_citation']
parsing: input/ref/Task1/P87-1015_vardha.csv
<S sid="165" ssid="50">This class of formalisms have the properties that their derivation trees are local sets, and manipulate objects, using a finite number of composition operations that use a finite number of symbols.</S>
original cit marker offset is 0
new cit marker offset is 0



["'165'"]
'165'
['165']
parsed_discourse_facet ['method_citation']
 <S sid="119" ssid="4">In defining LCFRS's, we hope to generalize the definition of CFG's to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'"]
'119'
['119']
parsed_discourse_facet ['method_citation']
    <S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'"]
'3'
['3']
parsed_discourse_facet ['method_citation']
    <S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'"]
'118'
['118']
parsed_discourse_facet ['method_citation']
    <S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'"]
'118'
['118']
parsed_discourse_facet ['method_citation']
    <S sid="133" ssid="18">To show that the derivation trees of any grammar in LCFRS is a local set, we can rewrite the annotated derivation trees such that every node is labelled by a pair to include the composition operations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'"]
'133'
['133']
parsed_discourse_facet ['method_citation']
 <S sid="138" ssid="23">We can show that languages generated by LCFRS's are semilinear as long as the composition operation does not remove any terminal symbols from its arguments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'"]
'138'
['138']
parsed_discourse_facet ['method_citation']
    <S sid="156" ssid="41">Giving a recognition algorithm for LCFRL's involves describing the substrings of the input that are spanned by the structures derived by the LCFRS's and how the composition operation combines these substrings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'156'"]
'156'
['156']
parsed_discourse_facet ['method_citation']
 <S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'"]
'118'
['118']
parsed_discourse_facet ['method_citation']
 <S sid="119" ssid="4">In defining LCFRS's, we hope to generalize the definition of CFG's to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'"]
'119'
['119']
parsed_discourse_facet ['method_citation']
  <S sid="133" ssid="18">To show that the derivation trees of any grammar in LCFRS is a local set, we can rewrite the annotated derivation trees such that every node is labelled by a pair to include the composition operations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'"]
'133'
['133']
parsed_discourse_facet ['method_citation']
 <S sid="164" ssid="49">Although embedding this version of LCFRS's in the framework of ILFP developed by Rounds (1985) is straightforward, our motivation was to capture properties shared by a family of grammatical systems and generalize them defining a class of related formalisms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'164'"]
'164'
['164']
parsed_discourse_facet ['method_citation']
 <S sid="204" ssid="10">The similarities become apparent when they are studied at the level of derivation structures: derivation nee sets of CFG's, HG's, TAG's, and MCTAG's are all local sets.</S>
original cit marker offset is 0
new cit marker offset is 0



["'204'"]
'204'
['204']
parsed_discourse_facet ['method_citation']
    <S sid="9" ssid="7">We examine both the complexity of the paths of trees in the tree sets, and the kinds of dependencies that the formalisms can impose between paths.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
    <S sid="28" ssid="13">A TAG consists of a finite set of elementary trees that are either initial trees or auxiliary trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'"]
'28'
['28']
parsed_discourse_facet ['method_citation']
 <S sid="138" ssid="23">We can show that languages generated by LCFRS's are semilinear as long as the composition operation does not remove any terminal symbols from its arguments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'"]
'138'
['138']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P87-1015.annv3.csv
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="232" ssid="38">In considering this aspect of a formalism, we hope to better understand the relationship between the structural descriptions generated by the grammars of a formalism, and the properties of semilinearity and polynomial recognizability.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'118'", "'232'"]
'2'
'3'
'118'
'232'
['2', '3', '118', '232']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="180" ssid="65">The rewrite rules and the definition of the composition operations may be stored in the finite state control since G uses a finite number of them.</S><S sid="230" ssid="36">LCFRS\s have only been loosely defined in this paper; we have yet to provide a complete set of formal properties associated with members of this class.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'", "'151'", "'180'", "'230'"]
'118'
'151'
'180'
'230'
['118', '151', '180', '230']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We consider the structural descriptions produced by various grammatical formalisms in terms of the complexity of the paths and the relationship between paths in the sets of structural descriptions that each system can generate.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="214" ssid="20">LCFRS\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'3'", "'119'", "'214'"]
'1'
'3'
'119'
'214'
['1', '3', '119', '214']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="92" ssid="77">We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S><S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'92'", "'118'", "'134'", "'207'"]
'92'
'118'
'134'
'207'
['92', '118', '134', '207']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'74'", "'207'"]
'2'
'3'
'74'
'207'
['2', '3', '74', '207']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\s insists that the composition operations are linear and nonerasing.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="229" ssid="35">In addition, the restricted version of CG\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\s containing formalisms whose tree sets have path sets that are themselves LCFRL\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'146'", "'151'", "'229'"]
'119'
'146'
'151'
'229'
['119', '146', '151', '229']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="92" ssid="77">We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="164" ssid="49">Although embedding this version of LCFRS\s in the framework of ILFP developed by Rounds (1985) is straightforward, our motivation was to capture properties shared by a family of grammatical systems and generalize them defining a class of related formalisms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'92'", "'118'", "'164'"]
'2'
'92'
'118'
'164'
['2', '92', '118', '164']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="117" ssid="2">Our goal is to define a class of formal systems, and show that any member of this class will possess certain attractive properties.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'117'", "'118'"]
'2'
'3'
'117'
'118'
['2', '3', '117', '118']
parsed_discourse_facet ['aim_citation']
<S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\s insists that the composition operations are linear and nonerasing.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="229" ssid="35">In addition, the restricted version of CG\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\s containing formalisms whose tree sets have path sets that are themselves LCFRL\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'146'", "'151'", "'229'"]
'119'
'146'
'151'
'229'
['119', '146', '151', '229']
parsed_discourse_facet ['method_citation']
<S sid="42" ssid="27">Suppose -y results from the adjunction of 71, ,-y, at the k distinct tree addresses 141, , nk in some elementary tree 7\, respectively.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="75" ssid="60">A multicomponent Tree Adjoining Grammar (MCTAG) consists of a finite set of finite elementary tree sets.</S><S sid="158" ssid="43">We can represent any derived tree of a TAG by the two substrings that appear in its frontier, and then define how the adjunction operation concatenates the substrings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'42'", "'74'", "'75'", "'158'"]
'42'
'74'
'75'
'158'
['42', '74', '75', '158']
parsed_discourse_facet ['method_citation']
<S sid="89" ssid="74">Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\s, MCTAG\s, and HG\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.</S><S sid="90" ssid="75">Thus, as in CFG\s, at any point in the derivation, the set of structures that can be applied is determined only by a finite set of rules encapsulated by the grammar.</S><S sid="128" ssid="13">As in the case of the derivation trees of CFG\s, nodes are labeled by a member of some finite set of symbols (perhaps only implicit in the grammar as in TAG\s) used to denote derived structures.</S><S sid="141" ssid="26">Thus, the length of any string in L is a linear combination of the length of strings in some fixed finite subset of L, and thus L is said to have the constant growth property.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'", "'90'", "'128'", "'141'"]
'89'
'90'
'128'
'141'
['89', '90', '128', '141']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S><S sid="135" ssid="20">Unlike GCFG\s, however, the composition operations of LCFRS\s are restricted to be linear (do not duplicate unboundedly large structures) and nonerasing (do not erase unbounded structures, a restriction made in most modern transformational grammars).</S><S sid="228" ssid="34">Since these path sets are semilinear, the property of independent paths in their tree sets is sufficient to cause semilinearity of the languages generated by them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'134'", "'135'", "'228'"]
'2'
'134'
'135'
'228'
['2', '134', '135', '228']
parsed_discourse_facet ['aim_citation']
<S sid="73" ssid="58">The equivalence of CC\s with this restriction to TAG\s and HG\s is, however, still an open problem.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="89" ssid="74">Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\s, MCTAG\s, and HG\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.</S><S sid="228" ssid="34">Since these path sets are semilinear, the property of independent paths in their tree sets is sufficient to cause semilinearity of the languages generated by them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'73'", "'74'", "'89'", "'228'"]
'73'
'74'
'89'
'228'
['73', '74', '89', '228']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="71">MCTAG\s are able to generate tee sets having dependent paths.</S><S sid="93" ssid="78">As is described in Section 4, the property of having a derivation tree set that is a local set appears to be useful in showing important properties of the languages generated by the formalisms.</S><S sid="109" ssid="15">A geometrical progression of language families defined by Weir (1987) involves tree sets with increasingly complex path sets.</S><S sid="111" ssid="17">.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'", "'93'", "'109'", "'111'"]
'86'
'93'
'109'
'111'
['86', '93', '109', '111']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="27" ssid="12">Thus, the tree sets generated by HG\s are similar to those of CFG\s, with each node annotated by the operation (concatenation or wrapping) used to combine the headed strings derived by the daughters of Tree Adjoining Grammars, a tree rewriting formalism, was introduced by Joshi, Levy and Takahashi (1975) and Joshi (1983/85).</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="214" ssid="20">LCFRS\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'27'", "'74'", "'214'"]
'2'
'27'
'74'
'214'
['2', '27', '74', '214']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="91" ssid="76">We characterize a class of formalisms that have this property in Section 4.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'91'", "'118'", "'134'"]
'2'
'91'
'118'
'134'
['2', '91', '118', '134']
parsed_discourse_facet ['aim_citation']



P87-1015
W07-2214
0
method_citation
['method_citation', 'aim_citation']



P87-1015
P09-2003
0
method_citation
['method_citation']
parsing: input/ref/Task1/W06-2932_swastika.csv
<S sid="86" ssid="8">Unlabeled accuracy for all verbs increases from 71% to 73% and for all conjunctions from 71% to 74%.</S>
original cit marker offset is 
new cit marker offset is 0



['86']
86
['86']
parsed_discourse_facet ['result_citation']
<S sid="79" ssid="1">Although overall unlabeled accuracy is 86%, most verbs and some conjunctions attach to their head words with much lower accuracy: 69% for main verbs, 75% for the verb ser, and 65% for coordinating conjunctions.</S>
original cit marker offset is 0
new cit marker offset is 0



['79']
79
['79']
parsed_discourse_facet ['result_citation']
<S sid="79" ssid="1">Although overall unlabeled accuracy is 86%, most verbs and some conjunctions attach to their head words with much lower accuracy: 69% for main verbs, 75% for the verb ser, and 65% for coordinating conjunctions.</S>
original cit marker offset is 0
new cit marker offset is 0



['79']
79
['79']
parsed_discourse_facet ['result_citation']
<S sid="79" ssid="1">Although overall unlabeled accuracy is 86%, most verbs and some conjunctions attach to their head words with much lower accuracy: 69% for main verbs, 75% for the verb ser, and 65% for coordinating conjunctions.</S>
original cit marker offset is 0
new cit marker offset is 0



['79']
79
['79']
parsed_discourse_facet ['result_citation']
<S sid="22" ssid="4">An exact projective and an approximate non-projective parsing algorithm are presented, since it is shown that nonprojective dependency parsing becomes NP-hard when features are extended beyond a single edge.</S>
original cit marker offset is 0
new cit marker offset is 0



['22']
22
['22']
parsed_discourse_facet ['method_citation']
<S sid="54" ssid="2">Based on performance from a held-out section of the training data, we used non-projective parsing algorithms for Czech, Danish, Dutch, German, Japanese, Portuguese and Slovene, and projective parsing algorithms for Arabic, Bulgarian, Chinese, Spanish, Swedish and Turkish.</S>
original cit marker offset is 0
new cit marker offset is 0



['54']
54
['54']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S>
original cit marker offset is 0
new cit marker offset is 0



['12']
12
['12']
parsed_discourse_facet ['method_citation']
    <S sid="22" ssid="4">An exact projective and an approximate non-projective parsing algorithm are presented, since it is shown that nonprojective dependency parsing becomes NP-hard when features are extended beyond a single edge.</S>
original cit marker offset is 0
new cit marker offset is 0



['22']
22
['22']
parsed_discourse_facet ['method_citation']
<S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



['41']
41
['41']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="6">Its power lies in the ability to define a rich set of features over parsing decisions, as well as surface level features relative to these decisions.</S>
original cit marker offset is 0
new cit marker offset is 0



['24']
24
['24']
parsed_discourse_facet ['method_citation']
<S sid="79" ssid="1">Although overall unlabeled accuracy is 86%, most verbs and some conjunctions attach to their head words with much lower accuracy: 69% for main verbs, 75% for the verb ser, and 65% for coordinating conjunctions.</S>
original cit marker offset is 0
new cit marker offset is 0



['79']
79
['79']
parsed_discourse_facet ['result_citation']
<S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S>
original cit marker offset is 0
new cit marker offset is 0



['12']
12
['12']
parsed_discourse_facet ['method_citation']
<S sid="43" ssid="12">For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.</S>
original cit marker offset is 0
new cit marker offset is 0



['43']
43
['43']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W06-2932.annv3.csv
<S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'20'", "'21'", "'104'"]
'19'
'20'
'21'
'104'
['19', '20', '21', '104']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'45'", "'58'", "'104'"]
'11'
'45'
'58'
'104'
['11', '45', '58', '104']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="10" ssid="6">Dependency graphs also encode much of the deep syntactic information needed for further processing.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="59" ssid="7">Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.</S><S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'58'", "'59'", "'61'"]
'10'
'58'
'59'
'61'
['10', '58', '59', '61']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="13" ssid="9">We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="31" ssid="13">Not all data sets in our experiments include morphological features, so we use them only when available.</S><S sid="64" ssid="2">N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'19'", "'31'", "'64'"]
'13'
'19'
'31'
'64'
['13', '19', '31', '64']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="43" ssid="12">For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.</S><S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'19'", "'43'", "'44'"]
'11'
'19'
'43'
'44'
['11', '19', '43', '44']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'21'", "'58'", "'104'"]
'13'
'21'
'58'
'104'
['13', '21', '58', '104']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S><S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'44'", "'58'"]
'11'
'12'
'44'
'58'
['11', '12', '44', '58']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="18" ssid="14">We Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X), pages 216&#8211;220, New York City, June 2006. c&#65533;2006 Association for Computational Linguistics assume that all dependency graphs are trees but may be non-projective, both of which are true in the data sets we use.</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'11'", "'18'", "'19'"]
'2'
'11'
'18'
'19'
['2', '11', '18', '19']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="3" ssid="3">The second stage takes the output from the first and labels all the edges in the dependency graph with appropriate syntactic categories using a globally trained sequence classifier over components of the graph.</S><S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'41'", "'104'"]
'2'
'3'
'41'
'104'
['2', '3', '41', '104']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="24" ssid="6">Its power lies in the ability to define a rich set of features over parsing decisions, as well as surface level features relative to these decisions.</S><S sid="31" ssid="13">Not all data sets in our experiments include morphological features, so we use them only when available.</S><S sid="46" ssid="15">Of course, we have to define a set of suitable features.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'24'", "'31'", "'46'"]
'2'
'24'
'31'
'46'
['2', '24', '31', '46']
parsed_discourse_facet ['results_citation']
<S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S><S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S><S sid="59" ssid="7">Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.</S><S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'45'", "'59'", "'61'"]
'44'
'45'
'59'
'61'
['44', '45', '59', '61']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'41'"]
'2'
'20'
'21'
'41'
['2', '20', '21', '41']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'104'"]
'2'
'20'
'21'
'104'
['2', '20', '21', '104']
parsed_discourse_facet ['hypothesis_citation']



W06-2932
I08-1012
0
method_citation
['method_citation', 'hypothesis_citation']



W06-2932
D07-1122
0
method_citation
['hypothesis_citation']



W06-2932
D07-1015
0
method_citation
['results_citation']
parsing: input/ref/Task1/W06-2932_sweta.csv
 <S sid="5" ssid="1">Often in language processing we require a deep syntactic representation of a sentence in order to assist further processing.</S>
original cit marker offset is 0
new cit marker offset is 0



["5'"]
5'
['5']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="5">However, in a two stage system we can incorporate features over the entire output of the unlabeled parser since that structure is fixed as input.</S>
original cit marker offset is 0
new cit marker offset is 0



["36'"]
36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["61'"]
61'
['61']
parsed_discourse_facet ['method_citation']
<S sid="76" ssid="14">For instance, sequential labeling improves the labeling of 2This difference was much larger for experiments in which gold standard unlabeled dependencies are used. objects from 81.7%/75.6% to 84.2%/81.3% (labeled precision/recall) and the labeling of subjects from 86.8%/88.2% to 90.5%/90.4% for Swedish.</S>
original cit marker offset is 0
new cit marker offset is 0



["76'"]
76'
['76']
parsed_discourse_facet ['method_citation']
 <S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["45'"]
45'
['45']
parsed_discourse_facet ['method_citation']
<S sid="106" ssid="3">First, we plan on examining the performance difference between two-staged dependency parsing (as presented here) and joint parsing plus labeling.</S>
original cit marker offset is 0
new cit marker offset is 0



["106'"]
106'
['106']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S>
original cit marker offset is 0
new cit marker offset is 0



["12'"]
12'
['12']
parsed_discourse_facet ['method_citation']
<S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["104'"]
104'
['104']
parsed_discourse_facet ['method_citation']
<S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["58'"]
58'
['58']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="2">N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.</S>
original cit marker offset is 0
new cit marker offset is 0



["64'"]
64'
['64']
parsed_discourse_facet ['method_citation']
<S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



["41'"]
41'
['41']
parsed_discourse_facet ['method_citation']
 <S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["21'"]
21'
['21']
parsed_discourse_facet ['method_citation']
 <S sid="64" ssid="2">N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.</S>
original cit marker offset is 0
new cit marker offset is 0



["64'"]
64'
['64']
parsed_discourse_facet ['method_citation']
 <S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["104'"]
104'
['104']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="2">Ideally one would like to make all parsing and labeling decisions jointly so that the shared knowledge of both decisions will help resolve any ambiguities.</S>
original cit marker offset is 0
new cit marker offset is 0



["33'"]
33'
['33']
parsed_discourse_facet ['method_citation']
<S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



["41'"]
41'
['41']
parsed_discourse_facet ['method_citation']
 <S sid="43" ssid="12">For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.</S>
original cit marker offset is 0
new cit marker offset is 0



["43'"]
43'
['43']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W06-2932.annv3.csv
<S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'20'", "'21'", "'104'"]
'19'
'20'
'21'
'104'
['19', '20', '21', '104']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'45'", "'58'", "'104'"]
'11'
'45'
'58'
'104'
['11', '45', '58', '104']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="10" ssid="6">Dependency graphs also encode much of the deep syntactic information needed for further processing.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="59" ssid="7">Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.</S><S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'58'", "'59'", "'61'"]
'10'
'58'
'59'
'61'
['10', '58', '59', '61']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="13" ssid="9">We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="31" ssid="13">Not all data sets in our experiments include morphological features, so we use them only when available.</S><S sid="64" ssid="2">N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'19'", "'31'", "'64'"]
'13'
'19'
'31'
'64'
['13', '19', '31', '64']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="43" ssid="12">For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.</S><S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'19'", "'43'", "'44'"]
'11'
'19'
'43'
'44'
['11', '19', '43', '44']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'21'", "'58'", "'104'"]
'13'
'21'
'58'
'104'
['13', '21', '58', '104']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S><S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'44'", "'58'"]
'11'
'12'
'44'
'58'
['11', '12', '44', '58']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="18" ssid="14">We Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X), pages 216&#8211;220, New York City, June 2006. c&#65533;2006 Association for Computational Linguistics assume that all dependency graphs are trees but may be non-projective, both of which are true in the data sets we use.</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'11'", "'18'", "'19'"]
'2'
'11'
'18'
'19'
['2', '11', '18', '19']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="3" ssid="3">The second stage takes the output from the first and labels all the edges in the dependency graph with appropriate syntactic categories using a globally trained sequence classifier over components of the graph.</S><S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'41'", "'104'"]
'2'
'3'
'41'
'104'
['2', '3', '41', '104']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="24" ssid="6">Its power lies in the ability to define a rich set of features over parsing decisions, as well as surface level features relative to these decisions.</S><S sid="31" ssid="13">Not all data sets in our experiments include morphological features, so we use them only when available.</S><S sid="46" ssid="15">Of course, we have to define a set of suitable features.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'24'", "'31'", "'46'"]
'2'
'24'
'31'
'46'
['2', '24', '31', '46']
parsed_discourse_facet ['results_citation']
<S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S><S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S><S sid="59" ssid="7">Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.</S><S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'45'", "'59'", "'61'"]
'44'
'45'
'59'
'61'
['44', '45', '59', '61']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'41'"]
'2'
'20'
'21'
'41'
['2', '20', '21', '41']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'104'"]
'2'
'20'
'21'
'104'
['2', '20', '21', '104']
parsed_discourse_facet ['hypothesis_citation']
IGNORE THIS: key error 1
IGNORE THIS: key error 1



W06-2932
W06-2920
0
method_citation
['hypothesis_citation', 'method_citation']



W06-2932
I08-1012
0
method_citation
['method_citation', 'hypothesis_citation']



W06-2932
D07-1122
0
method_citation
['hypothesis_citation']
parsing: input/ref/Task1/W06-2932_vardha.csv
    <S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="5">However, in a two stage system we can incorporate features over the entire output of the unlabeled parser since that structure is fixed as input.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
    <S sid="57" ssid="5">Performance is measured through unlabeled accuracy, which is the percentage of words that modify the correct head in the dependency graph, and labeled accuracy, which is the percentage of words that modify the correct head and label the dependency edge correctly in the graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'57'"]
'57'
['57']
parsed_discourse_facet ['method_citation']
    <S sid="76" ssid="14">For instance, sequential labeling improves the labeling of 2This difference was much larger for experiments in which gold standard unlabeled dependencies are used. objects from 81.7%/75.6% to 84.2%/81.3% (labeled precision/recall) and the labeling of subjects from 86.8%/88.2% to 90.5%/90.4% for Swedish.</S>
original cit marker offset is 0
new cit marker offset is 0



["'76'"]
'76'
['76']
parsed_discourse_facet ['method_citation']
 <S sid="54" ssid="2">Based on performance from a held-out section of the training data, we used non-projective parsing algorithms for Czech, Danish, Dutch, German, Japanese, Portuguese and Slovene, and projective parsing algorithms for Arabic, Bulgarian, Chinese, Spanish, Swedish and Turkish.</S>
original cit marker offset is 0
new cit marker offset is 0



["'54'"]
'54'
['54']
parsed_discourse_facet ['method_citation']
    <S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
    <S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'"]
'12'
['12']
parsed_discourse_facet ['method_citation']
    <S sid="57" ssid="5">Performance is measured through unlabeled accuracy, which is the percentage of words that modify the correct head in the dependency graph, and labeled accuracy, which is the percentage of words that modify the correct head and label the dependency edge correctly in the graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'57'"]
'57'
['57']
parsed_discourse_facet ['method_citation']
    <S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'58'"]
'58'
['58']
parsed_discourse_facet ['method_citation']
    <S sid="22" ssid="4">An exact projective and an approximate non-projective parsing algorithm are presented, since it is shown that nonprojective dependency parsing becomes NP-hard when features are extended beyond a single edge.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'"]
'22'
['22']
parsed_discourse_facet ['method_citation']
    <S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'"]
'41'
['41']
parsed_discourse_facet ['method_citation']
    <S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
    <S sid="64" ssid="2">N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'"]
'64'
['64']
parsed_discourse_facet ['method_citation']
    <S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
    <S sid="57" ssid="5">Performance is measured through unlabeled accuracy, which is the percentage of words that modify the correct head in the dependency graph, and labeled accuracy, which is the percentage of words that modify the correct head and label the edge correctly in the graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'57'"]
'57'
['57']
parsed_discourse_facet ['method_citation']
    <S sid="43" ssid="12">For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.</S>
original cit marker offset is 0
new cit marker offset is 0



["'43'"]
'43'
['43']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W06-2932.annv3.csv
<S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'20'", "'21'", "'104'"]
'19'
'20'
'21'
'104'
['19', '20', '21', '104']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'45'", "'58'", "'104'"]
'11'
'45'
'58'
'104'
['11', '45', '58', '104']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="10" ssid="6">Dependency graphs also encode much of the deep syntactic information needed for further processing.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="59" ssid="7">Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.</S><S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'58'", "'59'", "'61'"]
'10'
'58'
'59'
'61'
['10', '58', '59', '61']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="13" ssid="9">We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="31" ssid="13">Not all data sets in our experiments include morphological features, so we use them only when available.</S><S sid="64" ssid="2">N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'19'", "'31'", "'64'"]
'13'
'19'
'31'
'64'
['13', '19', '31', '64']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="43" ssid="12">For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.</S><S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'19'", "'43'", "'44'"]
'11'
'19'
'43'
'44'
['11', '19', '43', '44']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'21'", "'58'", "'104'"]
'13'
'21'
'58'
'104'
['13', '21', '58', '104']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S><S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'44'", "'58'"]
'11'
'12'
'44'
'58'
['11', '12', '44', '58']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="18" ssid="14">We Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X), pages 216&#8211;220, New York City, June 2006. c&#65533;2006 Association for Computational Linguistics assume that all dependency graphs are trees but may be non-projective, both of which are true in the data sets we use.</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'11'", "'18'", "'19'"]
'2'
'11'
'18'
'19'
['2', '11', '18', '19']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="3" ssid="3">The second stage takes the output from the first and labels all the edges in the dependency graph with appropriate syntactic categories using a globally trained sequence classifier over components of the graph.</S><S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'41'", "'104'"]
'2'
'3'
'41'
'104'
['2', '3', '41', '104']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="24" ssid="6">Its power lies in the ability to define a rich set of features over parsing decisions, as well as surface level features relative to these decisions.</S><S sid="31" ssid="13">Not all data sets in our experiments include morphological features, so we use them only when available.</S><S sid="46" ssid="15">Of course, we have to define a set of suitable features.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'24'", "'31'", "'46'"]
'2'
'24'
'31'
'46'
['2', '24', '31', '46']
parsed_discourse_facet ['results_citation']
<S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S><S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S><S sid="59" ssid="7">Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.</S><S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'45'", "'59'", "'61'"]
'44'
'45'
'59'
'61'
['44', '45', '59', '61']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'41'"]
'2'
'20'
'21'
'41'
['2', '20', '21', '41']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'104'"]
'2'
'20'
'21'
'104'
['2', '20', '21', '104']
parsed_discourse_facet ['hypothesis_citation']
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



W06-2932
W12-3407
0
method_citation
['method_citation', 'hypothesis_citation']



W06-2932
I08-1012
0
method_citation
['method_citation', 'hypothesis_citation']



W06-2932
D07-1122
0
method_citation
['hypothesis_citation']
IGNORE THIS: Key error 5
parsing: input/ref/Task1/W06-3114_aakansha.csv
<S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'170'"]
'170'
['170']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="1">The evaluation framework for the shared task is similar to the one used in last year&#8217;s shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="2">The BLEU metric, as all currently proposed automatic metrics, is occasionally suspected to be biased towards statistical systems, especially the phrase-based systems currently in use.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="2">The BLEU metric, as all currently proposed automatic metrics, is occasionally suspected to be biased towards statistical systems, especially the phrase-based systems currently in use.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['method_citation']
<S sid="102" ssid="18">Confidence Interval: To estimate confidence intervals for the average mean scores for the systems, we use standard significance testing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'102'"]
'102'
['102']
parsed_discourse_facet ['method_citation']
<S sid="84" ssid="23">The human judges were presented with the following definition of adequacy and fluency, but no additional instructions:</S>
original cit marker offset is 0
new cit marker offset is 0



["'84'"]
'84'
['84']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="4">To lower the barrier of entrance to the competition, we provided a complete baseline MT system, along with data resources.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'"]
'11'
['11']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'"]
'126'
['126']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="8">Out-of-domain test data is from the Project Syndicate web site, a compendium of political commentary.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'"]
'15'
['15']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="1">The evaluation framework for the shared task is similar to the one used in last year&#8217;s shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="90" ssid="6">Another way to view the judgements is that they are less quality judgements of machine translation systems per se, but rankings of machine translation systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'"]
'90'
['90']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="3">&#8226; We evaluated translation from English, in addition to into English.</S>
    <S sid="6" ssid="4">English was again paired with German, French, and Spanish.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'6'"]
'5'
'6'
['5', '6']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W06-3114.annv3.csv
<S sid="48" ssid="14">Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="56" ssid="22">The bootstrap method has been critized by Riezler and Maxwell (2005) and Collins et al. (2005), as being too optimistic in deciding for statistical significant difference between systems.</S><S sid="57" ssid="23">We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'56'", "'57'"]
'48'
'49'
'56'
'57'
['48', '49', '56', '57']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="5">We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.</S><S sid="26" ssid="19">Most of these groups follow a phrase-based statistical approach to machine translation.</S><S sid="30" ssid="23">The other half was replaced by other participants, so we ended up with roughly the same number.</S><S sid="65" ssid="4">The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'26'", "'30'", "'65'"]
'7'
'26'
'30'
'65'
['7', '26', '30', '65']
parsed_discourse_facet ['hypothesis_citation']
<S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S><S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="15" ssid="8">Out-of-domain test data is from the Project Syndicate web site, a compendium of political commentary.</S><S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'13'", "'15'", "'18'"]
'9'
'13'
'15'
'18'
['9', '13', '15', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S><S sid="90" ssid="6">Another way to view the judgements is that they are less quality judgements of machine translation systems per se, but rankings of machine translation systems.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'62'", "'90'", "'140'"]
'38'
'62'
'90'
'140'
['38', '62', '90', '140']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .</S><S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S><S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="165" ssid="58">However, ince we extracted the test corpus automatically from web sources, the reference translation was not always accurate &#8212; due to sentence alignment errors, or because translators did not adhere to a strict sentence-by-sentence translation (say, using pronouns when referring to entities mentioned in the previous sentence).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'17'", "'165'"]
'1'
'9'
'17'
'165'
['1', '9', '17', '165']
parsed_discourse_facet ['results_citation']
<S sid="37" ssid="3">It rewards matches of n-gram sequences, but measures only at most indirectly overall grammatical coherence.</S><S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'64'", "'140'"]
'37'
'39'
'64'
'140'
['37', '39', '64', '140']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="3">It rewards matches of n-gram sequences, but measures only at most indirectly overall grammatical coherence.</S><S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="139" ssid="32">Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'139'", "'140'"]
'37'
'39'
'139'
'140'
['37', '39', '139', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="47" ssid="13">Because of this, we retokenized and lowercased submitted output with our own tokenizer, which was also used to prepare the training and test data.</S><S sid="83" ssid="22">The number of judgements is additionally fragmented by our breakup of sentences into in-domain and out-of-domain.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'47'", "'83'", "'140'"]
'39'
'47'
'83'
'140'
['39', '47', '83', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S><S sid="167" ssid="60">One annotator suggested that this was the case for as much as 10% of our test sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'49'", "'140'", "'167'"]
'39'
'49'
'140'
'167'
['39', '49', '140', '167']
parsed_discourse_facet ['method_citation']
<S sid="48" ssid="14">Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="57" ssid="23">We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.</S><S sid="58" ssid="24">We divide up each test set into blocks of 20 sentences (100 blocks for the in-domain test set, 53 blocks for the out-of-domain test set), check for each block, if one system has a higher BLEU score than the other, and then use the sign test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'57'", "'58'"]
'48'
'49'
'57'
'58'
['48', '49', '57', '58']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S><S sid="122" ssid="15">While the Bootstrap method is slightly more sensitive, it is very much in line with the sign test on text blocks.</S><S sid="123" ssid="16">For the manual scoring, we can distinguish only half of the systems, both in terms of fluency and adequacy.</S><S sid="124" ssid="17">More judgements would have enabled us to make better distinctions, but it is not clear what the upper limit is.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'122'", "'123'", "'124'"]
'68'
'122'
'123'
'124'
['68', '122', '123', '124']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="14" ssid="7">There is twice as much language modelling data, since training data for the machine translation system is filtered against sentences of length larger than 40 words.</S><S sid="27" ssid="20">Microsoft&#8217;s approach uses dependency trees, others use hierarchical phrase models.</S><S sid="35" ssid="1">For the automatic evaluation, we used BLEU, since it is the most established metric in the field.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'14'", "'27'", "'35'"]
'13'
'14'
'27'
'35'
['13', '14', '27', '35']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S><S sid="139" ssid="32">Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'62'", "'139'", "'140'"]
'38'
'62'
'139'
'140'
['38', '62', '139', '140']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="58" ssid="24">We divide up each test set into blocks of 20 sentences (100 blocks for the in-domain test set, 53 blocks for the out-of-domain test set), check for each block, if one system has a higher BLEU score than the other, and then use the sign test.</S><S sid="106" ssid="22">Automatic scores are computed on a larger tested than manual scores (3064 sentences vs. 300&#8211;400 sentences). collected manual judgements, we do not necessarily have the same sentence judged for both systems (judges evaluate 5 systems out of the 8&#8211;10 participating systems).</S><S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'58'", "'106'", "'126'"]
'17'
'58'
'106'
'126'
['17', '58', '106', '126']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="9">The test data was again drawn from a segment of the Europarl corpus from the fourth quarter of 2000, which is excluded from the training data.</S><S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S><S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'17'", "'18'", "'126'"]
'16'
'17'
'18'
'126'
['16', '17', '18', '126']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'38'", "'64'", "'170'"]
'13'
'38'
'64'
'170'
['13', '38', '64', '170']
parsed_discourse_facet ['method_citation']
<S sid="63" ssid="2">Many human evaluation metrics have been proposed.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S><S sid="155" ssid="48">For instance, in the recent IWSLT evaluation, first fluency annotations were solicited (while withholding the source sentence), and then adequacy annotations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'63'", "'64'", "'68'", "'155'"]
'63'
'64'
'68'
'155'
['63', '64', '68', '155']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .</S><S sid="7" ssid="5">We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="65" ssid="4">The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'7'", "'64'", "'65'"]
'1'
'7'
'64'
'65'
['1', '7', '64', '65']
parsed_discourse_facet ['aim_citation']



W06-3114
C08-1074
0
method_citation
['hypothesis_citation']



W06-3114
P07-1083
0
method_citation
['results_citation']



W06-3114
W07-0738
0
method_citation
['method_citation']



W06-3114
W11-1002
0
method_citation
['method_citation']
parsing: input/ref/Task1/W06-3114_swastika.csv
<S sid="47" ssid="13">Because of this, we retokenized and lowercased submitted output with our own tokenizer, which was also used to prepare the training and test data.</S>
original cit marker offset is 0
new cit marker offset is 0



['47']
47
['47']
parsed_discourse_facet ['method_citation']
    <S sid="8" ssid="1">The evaluation framework for the shared task is similar to the one used in last year&#8217;s shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



['8']
8
['8']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



['18']
18
['18']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



['18']
18
['18']
parsed_discourse_facet ['method_citation']
<S sid="144" ssid="37">Our suspicion is that BLEU is very sensitive to jargon, to selecting exactly the right words, and not synonyms that human judges may appreciate as equally good.</S>
original cit marker offset is 0
new cit marker offset is 0



['144']
144
['144']
parsed_discourse_facet ['result_citation']
<S sid="145" ssid="38">This is can not be the only explanation, since the discrepancy still holds, for instance, for out-of-domain French-English, where Systran receives among the best adequacy and fluency scores, but a worse BLEU score than all but one statistical system.</S>
original cit marker offset is 0
new cit marker offset is 0



['145']
145
['145']
parsed_discourse_facet ['result_citation']
    <S sid="103" ssid="19">Given a set of n sentences, we can compute the sample mean x&#65533; and sample variance s2 of the individual sentence judgements xi: The extend of the confidence interval [x&#8722;d, x+df can be computed by d = 1.96 &#183;&#65533;n (6) Pairwise Comparison: As for the automatic evaluation metric, we want to be able to rank different systems against each other, for which we need assessments of statistical significance on the differences between a pair of systems.</S>
original cit marker offset is 0
new cit marker offset is 0



['103']
103
['103']
parsed_discourse_facet ['method_citation']
<S sid="50" ssid="16">Following this method, we repeatedly &#8212; say, 1000 times &#8212; sample sets of sentences from the output of each system, measure their BLEU score, and use these 1000 BLEU scores as basis for estimating a confidence interval.</S>
original cit marker offset is 0
new cit marker offset is 0



['50']
50
['50']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S>
original cit marker offset is 0
new cit marker offset is 0



['68']
68
['68']
parsed_discourse_facet ['method_citation']
<S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



['170']
170
['170']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



['18']
18
['18']
parsed_discourse_facet ['method_citation']
<S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



['170']
170
['170']
parsed_discourse_facet ['method_citation']
<S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



['170']
170
['170']
parsed_discourse_facet ['method_citation']
<S sid="92" ssid="8">The way judgements are collected, human judges tend to use the scores to rank systems against each other.</S>
original cit marker offset is 0
new cit marker offset is 0



['92']
92
['92']
parsed_discourse_facet ['result_citation']
<S sid="145" ssid="38">This is can not be the only explanation, since the discrepancy still holds, for instance, for out-of-domain French-English, where Systran receives among the best adequacy and fluency scores, but a worse BLEU score than all but one statistical system.</S>
original cit marker offset is 0
new cit marker offset is 0



['145']
145
['145']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W06-3114.annv3.csv
<S sid="48" ssid="14">Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="56" ssid="22">The bootstrap method has been critized by Riezler and Maxwell (2005) and Collins et al. (2005), as being too optimistic in deciding for statistical significant difference between systems.</S><S sid="57" ssid="23">We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'56'", "'57'"]
'48'
'49'
'56'
'57'
['48', '49', '56', '57']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="5">We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.</S><S sid="26" ssid="19">Most of these groups follow a phrase-based statistical approach to machine translation.</S><S sid="30" ssid="23">The other half was replaced by other participants, so we ended up with roughly the same number.</S><S sid="65" ssid="4">The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'26'", "'30'", "'65'"]
'7'
'26'
'30'
'65'
['7', '26', '30', '65']
parsed_discourse_facet ['hypothesis_citation']
<S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S><S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="15" ssid="8">Out-of-domain test data is from the Project Syndicate web site, a compendium of political commentary.</S><S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'13'", "'15'", "'18'"]
'9'
'13'
'15'
'18'
['9', '13', '15', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S><S sid="90" ssid="6">Another way to view the judgements is that they are less quality judgements of machine translation systems per se, but rankings of machine translation systems.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'62'", "'90'", "'140'"]
'38'
'62'
'90'
'140'
['38', '62', '90', '140']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .</S><S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S><S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="165" ssid="58">However, ince we extracted the test corpus automatically from web sources, the reference translation was not always accurate &#8212; due to sentence alignment errors, or because translators did not adhere to a strict sentence-by-sentence translation (say, using pronouns when referring to entities mentioned in the previous sentence).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'17'", "'165'"]
'1'
'9'
'17'
'165'
['1', '9', '17', '165']
parsed_discourse_facet ['results_citation']
<S sid="37" ssid="3">It rewards matches of n-gram sequences, but measures only at most indirectly overall grammatical coherence.</S><S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'64'", "'140'"]
'37'
'39'
'64'
'140'
['37', '39', '64', '140']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="3">It rewards matches of n-gram sequences, but measures only at most indirectly overall grammatical coherence.</S><S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="139" ssid="32">Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'139'", "'140'"]
'37'
'39'
'139'
'140'
['37', '39', '139', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="47" ssid="13">Because of this, we retokenized and lowercased submitted output with our own tokenizer, which was also used to prepare the training and test data.</S><S sid="83" ssid="22">The number of judgements is additionally fragmented by our breakup of sentences into in-domain and out-of-domain.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'47'", "'83'", "'140'"]
'39'
'47'
'83'
'140'
['39', '47', '83', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S><S sid="167" ssid="60">One annotator suggested that this was the case for as much as 10% of our test sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'49'", "'140'", "'167'"]
'39'
'49'
'140'
'167'
['39', '49', '140', '167']
parsed_discourse_facet ['method_citation']
<S sid="48" ssid="14">Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="57" ssid="23">We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.</S><S sid="58" ssid="24">We divide up each test set into blocks of 20 sentences (100 blocks for the in-domain test set, 53 blocks for the out-of-domain test set), check for each block, if one system has a higher BLEU score than the other, and then use the sign test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'57'", "'58'"]
'48'
'49'
'57'
'58'
['48', '49', '57', '58']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S><S sid="122" ssid="15">While the Bootstrap method is slightly more sensitive, it is very much in line with the sign test on text blocks.</S><S sid="123" ssid="16">For the manual scoring, we can distinguish only half of the systems, both in terms of fluency and adequacy.</S><S sid="124" ssid="17">More judgements would have enabled us to make better distinctions, but it is not clear what the upper limit is.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'122'", "'123'", "'124'"]
'68'
'122'
'123'
'124'
['68', '122', '123', '124']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="14" ssid="7">There is twice as much language modelling data, since training data for the machine translation system is filtered against sentences of length larger than 40 words.</S><S sid="27" ssid="20">Microsoft&#8217;s approach uses dependency trees, others use hierarchical phrase models.</S><S sid="35" ssid="1">For the automatic evaluation, we used BLEU, since it is the most established metric in the field.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'14'", "'27'", "'35'"]
'13'
'14'
'27'
'35'
['13', '14', '27', '35']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S><S sid="139" ssid="32">Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'62'", "'139'", "'140'"]
'38'
'62'
'139'
'140'
['38', '62', '139', '140']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="58" ssid="24">We divide up each test set into blocks of 20 sentences (100 blocks for the in-domain test set, 53 blocks for the out-of-domain test set), check for each block, if one system has a higher BLEU score than the other, and then use the sign test.</S><S sid="106" ssid="22">Automatic scores are computed on a larger tested than manual scores (3064 sentences vs. 300&#8211;400 sentences). collected manual judgements, we do not necessarily have the same sentence judged for both systems (judges evaluate 5 systems out of the 8&#8211;10 participating systems).</S><S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'58'", "'106'", "'126'"]
'17'
'58'
'106'
'126'
['17', '58', '106', '126']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="9">The test data was again drawn from a segment of the Europarl corpus from the fourth quarter of 2000, which is excluded from the training data.</S><S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S><S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'17'", "'18'", "'126'"]
'16'
'17'
'18'
'126'
['16', '17', '18', '126']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'38'", "'64'", "'170'"]
'13'
'38'
'64'
'170'
['13', '38', '64', '170']
parsed_discourse_facet ['method_citation']
<S sid="63" ssid="2">Many human evaluation metrics have been proposed.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S><S sid="155" ssid="48">For instance, in the recent IWSLT evaluation, first fluency annotations were solicited (while withholding the source sentence), and then adequacy annotations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'63'", "'64'", "'68'", "'155'"]
'63'
'64'
'68'
'155'
['63', '64', '68', '155']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .</S><S sid="7" ssid="5">We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="65" ssid="4">The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'7'", "'64'", "'65'"]
'1'
'7'
'64'
'65'
['1', '7', '64', '65']
parsed_discourse_facet ['aim_citation']
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



W06-3114
C08-1074
0
method_citation
['hypothesis_citation']



W06-3114
D07-1030
0
method_citation
['method_citation']



W06-3114
P07-1108
0
method_citation
['method_citation']
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5
parsing: input/ref/Task1/W06-3114_sweta.csv
 <S sid="108" ssid="1">The results of the manual and automatic evaluation of the participating system translations is detailed in the figures at the end of this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["108'"]
108'
['108']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="27">For more on the participating systems, please refer to the respective system description in the proceedings of the workshop.</S>
original cit marker offset is 0
new cit marker offset is 0



["34'"]
34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["18'"]
18'
['18']
parsed_discourse_facet ['method_citation']
 <S sid="151" ssid="44">The statistical systems seem to still lag behind the commercial rule-based competition when translating into morphological rich languages, as demonstrated by the results for English-German and English-French.</S>
original cit marker offset is 0
new cit marker offset is 0



["151'"]
151'
['151']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="9">The test data was again drawn from a segment of the Europarl corpus from the fourth quarter of 2000, which is excluded from the training data.</S>
original cit marker offset is 0
new cit marker offset is 0



["16'"]
16'
['16']
parsed_discourse_facet ['method_citation']
 <S sid="172" ssid="3">Due to many similarly performing systems, we are not able to draw strong conclusions on the question of correlation of manual and automatic evaluation metrics.</S>
original cit marker offset is 0
new cit marker offset is 0



["172'"]
172'
['172']
parsed_discourse_facet ['method_citation']
 <S sid="36" ssid="2">The BLEU metric, as all currently proposed automatic metrics, is occasionally suspected to be biased towards statistical systems, especially the phrase-based systems currently in use.</S>
original cit marker offset is 0
new cit marker offset is 0



["36'"]
36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="103" ssid="19">Given a set of n sentences, we can compute the sample mean x&#65533; and sample variance s2 of the individual sentence judgements xi: The extend of the confidence interval [x&#8722;d, x+df can be computed by d = 1.96 &#183;&#65533;n (6) Pairwise Comparison: As for the automatic evaluation metric, we want to be able to rank different systems against each other, for which we need assessments of statistical significance on the differences between a pair of systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["103'"]
103'
['103']
parsed_discourse_facet ['method_citation']
<S sid="167" ssid="60">One annotator suggested that this was the case for as much as 10% of our test sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["167'"]
167'
['167']
parsed_discourse_facet ['method_citation']
<S sid="102" ssid="18">Confidence Interval: To estimate confidence intervals for the average mean scores for the systems, we use standard significance testing.</S>
original cit marker offset is 0
new cit marker offset is 0



["102'"]
102'
['102']
parsed_discourse_facet ['method_citation']
<S sid="123" ssid="16">For the manual scoring, we can distinguish only half of the systems, both in terms of fluency and adequacy.</S>
original cit marker offset is 0
new cit marker offset is 0



["123'"]
123'
['123']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="27">For more on the participating systems, please refer to the respective system description in the proceedings of the workshop.</S>
original cit marker offset is 0
new cit marker offset is 0



["34'"]
34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S>
original cit marker offset is 0
new cit marker offset is 0



["62'"]
62'
['62']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["126'"]
126'
['126']
parsed_discourse_facet ['method_citation']
<S sid="173" ssid="4">The bias of automatic methods in favor of statistical systems seems to be less pronounced on out-of-domain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["173'"]
173'
['173']
parsed_discourse_facet ['method_citation']
 <S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["170'"]
170'
['170']
parsed_discourse_facet ['method_citation']
<S sid="84" ssid="23">The human judges were presented with the following definition of adequacy and fluency, but no additional instructions:</S>
original cit marker offset is 0
new cit marker offset is 0



["84'"]
84'
['84']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="1">The evaluation framework for the shared task is similar to the one used in last year&#8217;s shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["8'"]
8'
['8']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W06-3114.annv3.csv
<S sid="48" ssid="14">Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="56" ssid="22">The bootstrap method has been critized by Riezler and Maxwell (2005) and Collins et al. (2005), as being too optimistic in deciding for statistical significant difference between systems.</S><S sid="57" ssid="23">We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'56'", "'57'"]
'48'
'49'
'56'
'57'
['48', '49', '56', '57']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="5">We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.</S><S sid="26" ssid="19">Most of these groups follow a phrase-based statistical approach to machine translation.</S><S sid="30" ssid="23">The other half was replaced by other participants, so we ended up with roughly the same number.</S><S sid="65" ssid="4">The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'26'", "'30'", "'65'"]
'7'
'26'
'30'
'65'
['7', '26', '30', '65']
parsed_discourse_facet ['hypothesis_citation']
<S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S><S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="15" ssid="8">Out-of-domain test data is from the Project Syndicate web site, a compendium of political commentary.</S><S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'13'", "'15'", "'18'"]
'9'
'13'
'15'
'18'
['9', '13', '15', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S><S sid="90" ssid="6">Another way to view the judgements is that they are less quality judgements of machine translation systems per se, but rankings of machine translation systems.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'62'", "'90'", "'140'"]
'38'
'62'
'90'
'140'
['38', '62', '90', '140']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .</S><S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S><S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="165" ssid="58">However, ince we extracted the test corpus automatically from web sources, the reference translation was not always accurate &#8212; due to sentence alignment errors, or because translators did not adhere to a strict sentence-by-sentence translation (say, using pronouns when referring to entities mentioned in the previous sentence).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'17'", "'165'"]
'1'
'9'
'17'
'165'
['1', '9', '17', '165']
parsed_discourse_facet ['results_citation']
<S sid="37" ssid="3">It rewards matches of n-gram sequences, but measures only at most indirectly overall grammatical coherence.</S><S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'64'", "'140'"]
'37'
'39'
'64'
'140'
['37', '39', '64', '140']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="3">It rewards matches of n-gram sequences, but measures only at most indirectly overall grammatical coherence.</S><S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="139" ssid="32">Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'139'", "'140'"]
'37'
'39'
'139'
'140'
['37', '39', '139', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="47" ssid="13">Because of this, we retokenized and lowercased submitted output with our own tokenizer, which was also used to prepare the training and test data.</S><S sid="83" ssid="22">The number of judgements is additionally fragmented by our breakup of sentences into in-domain and out-of-domain.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'47'", "'83'", "'140'"]
'39'
'47'
'83'
'140'
['39', '47', '83', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S><S sid="167" ssid="60">One annotator suggested that this was the case for as much as 10% of our test sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'49'", "'140'", "'167'"]
'39'
'49'
'140'
'167'
['39', '49', '140', '167']
parsed_discourse_facet ['method_citation']
<S sid="48" ssid="14">Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="57" ssid="23">We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.</S><S sid="58" ssid="24">We divide up each test set into blocks of 20 sentences (100 blocks for the in-domain test set, 53 blocks for the out-of-domain test set), check for each block, if one system has a higher BLEU score than the other, and then use the sign test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'57'", "'58'"]
'48'
'49'
'57'
'58'
['48', '49', '57', '58']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S><S sid="122" ssid="15">While the Bootstrap method is slightly more sensitive, it is very much in line with the sign test on text blocks.</S><S sid="123" ssid="16">For the manual scoring, we can distinguish only half of the systems, both in terms of fluency and adequacy.</S><S sid="124" ssid="17">More judgements would have enabled us to make better distinctions, but it is not clear what the upper limit is.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'122'", "'123'", "'124'"]
'68'
'122'
'123'
'124'
['68', '122', '123', '124']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="14" ssid="7">There is twice as much language modelling data, since training data for the machine translation system is filtered against sentences of length larger than 40 words.</S><S sid="27" ssid="20">Microsoft&#8217;s approach uses dependency trees, others use hierarchical phrase models.</S><S sid="35" ssid="1">For the automatic evaluation, we used BLEU, since it is the most established metric in the field.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'14'", "'27'", "'35'"]
'13'
'14'
'27'
'35'
['13', '14', '27', '35']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S><S sid="139" ssid="32">Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'62'", "'139'", "'140'"]
'38'
'62'
'139'
'140'
['38', '62', '139', '140']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="58" ssid="24">We divide up each test set into blocks of 20 sentences (100 blocks for the in-domain test set, 53 blocks for the out-of-domain test set), check for each block, if one system has a higher BLEU score than the other, and then use the sign test.</S><S sid="106" ssid="22">Automatic scores are computed on a larger tested than manual scores (3064 sentences vs. 300&#8211;400 sentences). collected manual judgements, we do not necessarily have the same sentence judged for both systems (judges evaluate 5 systems out of the 8&#8211;10 participating systems).</S><S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'58'", "'106'", "'126'"]
'17'
'58'
'106'
'126'
['17', '58', '106', '126']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="9">The test data was again drawn from a segment of the Europarl corpus from the fourth quarter of 2000, which is excluded from the training data.</S><S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S><S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'17'", "'18'", "'126'"]
'16'
'17'
'18'
'126'
['16', '17', '18', '126']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'38'", "'64'", "'170'"]
'13'
'38'
'64'
'170'
['13', '38', '64', '170']
parsed_discourse_facet ['method_citation']
<S sid="63" ssid="2">Many human evaluation metrics have been proposed.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S><S sid="155" ssid="48">For instance, in the recent IWSLT evaluation, first fluency annotations were solicited (while withholding the source sentence), and then adequacy annotations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'63'", "'64'", "'68'", "'155'"]
'63'
'64'
'68'
'155'
['63', '64', '68', '155']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .</S><S sid="7" ssid="5">We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="65" ssid="4">The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'7'", "'64'", "'65'"]
'1'
'7'
'64'
'65'
['1', '7', '64', '65']
parsed_discourse_facet ['aim_citation']



W06-3114
C08-1074
0
method_citation
['hypothesis_citation']



W06-3114
W07-0738
0
method_citation
['method_citation']



W06-3114
D07-1030
0
method_citation
['method_citation']



W06-3114
W11-1002
0
method_citation
['method_citation']



W06-3114
P07-1108
0
method_citation
['method_citation']
parsing: input/ref/Task1/W11-2123_aakansha.csv
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'"]
'7'
['7']
parsed_discourse_facet ['method_citation']
<S sid="45" ssid="23">The PROBING data structure is a rather straightforward application of these hash tables to store Ngram language models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'45'"]
'45'
['45']
parsed_discourse_facet ['method_citation']
<S sid="136" ssid="8">We offer a state function s(wn1) = wn&#65533; where substring wn&#65533; is guaranteed to extend (to the right) in the same way that wn1 does for purposes of language modeling.</S>
original cit marker offset is 0
new cit marker offset is 0



["'136'"]
'136'
['136']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'"]
'7'
['7']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="3">Queries take the form p(wn|wn&#8722;1 1 ) where wn1 is an n-gram.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="205" ssid="24">We evaluate the time and memory consumption of each data structure by computing perplexity on 4 billion tokens from the English Gigaword corpus (Parker et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'205'"]
'205'
['205']
parsed_discourse_facet ['method_citation']
<S sid="274" ssid="1">We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.</S>
original cit marker offset is 0
new cit marker offset is 0



["'274'"]
'274'
['274']
parsed_discourse_facet ['method_citation']
<S sid="204" ssid="23">For RandLM, we used the settings in the documentation: 8 bits per value and false positive probability 1 256.</S>
original cit marker offset is 0
new cit marker offset is 0



["'204'"]
'204'
['204']
parsed_discourse_facet ['method_citation']
<S sid="274" ssid="1">We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.</S>
original cit marker offset is 0
new cit marker offset is 0



["'274'"]
'274'
['274']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="229" ssid="48">Then we ran binary search to determine the least amount of memory with which it would run.</S>
original cit marker offset is 0
new cit marker offset is 0



["'229'"]
'229'
['229']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="93" ssid="71">The cost of storing these averages, in bits, is Because there are comparatively few unigrams, we elected to store them byte-aligned and unquantized, making every query faster.</S>
original cit marker offset is 0
new cit marker offset is 0



["'93'"]
'93'
['93']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'199'"]
'199'
['199']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W11-2123.annv3.csv
<S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'21'", "'98'", "'199'"]
'12'
'21'
'98'
'199'
['12', '21', '98', '199']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="102" ssid="6">The PROBING model was designed to improve upon SRILM by using linear probing hash tables (though not arranged in a trie), allocating memory all at once (eliminating the need for full pointers), and being easy to compile.</S><S sid="223" ssid="42">The binary language model from Section 5.2 and text phrase table were forced into disk cache before each run.</S><S sid="244" ssid="63">Time for Moses itself to load, including loading the language model and phrase table, is included.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'102'", "'223'", "'244'"]
'0'
'102'
'223'
'244'
['0', '102', '223', '244']
parsed_discourse_facet ['results_citation']
<S sid="135" ssid="7">Therefore, we want state to encode the minimum amount of information necessary to properly compute language model scores, so that the decoder will be faster and make fewer search errors.</S><S sid="136" ssid="8">We offer a state function s(wn1) = wn&#65533; where substring wn&#65533; is guaranteed to extend (to the right) in the same way that wn1 does for purposes of language modeling.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'135'", "'136'", "'152'", "'199'"]
'135'
'136'
'152'
'199'
['135', '136', '152', '199']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S><S sid="268" ssid="10">For example, syntactic decoders (Koehn et al., 2007; Dyer et al., 2010; Li et al., 2009) perform dynamic programming parametrized by both backward- and forward-looking state.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'21'", "'129'", "'268'"]
'1'
'21'
'129'
'268'
['1', '21', '129', '268']
parsed_discourse_facet ['results_citation']
<S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'21'", "'51'", "'199'"]
'12'
'21'
'51'
'199'
['12', '21', '51', '199']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="25" ssid="3">An important subproblem of language model storage is therefore sparse mapping: storing values for sparse keys using little memory then retrieving values given keys using little time.</S><S sid="130" ssid="2">Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'25'", "'130'", "'199'"]
'0'
'25'
'130'
'199'
['0', '25', '130', '199']
parsed_discourse_facet ['results_citation']
<S sid="68" ssid="46">The trie data structure is commonly used for language modeling.</S><S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S><S sid="130" ssid="2">Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.</S><S sid="274" ssid="1">We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'129'", "'130'", "'274'"]
'68'
'129'
'130'
'274'
['68', '129', '130', '274']
parsed_discourse_facet ['method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="2" ssid="2">The structure uses linear probing hash tables and is designed for speed.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'21'", "'199'"]
'0'
'2'
'21'
'199'
['0', '2', '21', '199']
parsed_discourse_facet ['hypothesis_citation']
<S sid="44" ssid="22">Further, the special hash 0 suffices to flag empty buckets.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="264" ssid="6">For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'51'", "'98'", "'264'"]
'44'
'51'
'98'
'264'
['44', '51', '98', '264']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="16" ssid="11">BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.</S><S sid="35" ssid="13">Non-empty buckets contain an entry belonging to them or to a preceding bucket where a conflict occurred.</S><S sid="92" ssid="70">To quantize, we use the binning method (Federico and Bertoldi, 2006) that sorts values, divides into equally sized bins, and averages within each bin.</S><S sid="204" ssid="23">For RandLM, we used the settings in the documentation: 8 bits per value and false positive probability 1 256.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'35'", "'92'", "'204'"]
'16'
'35'
'92'
'204'
['16', '35', '92', '204']
parsed_discourse_facet ['hypothesis_citation']
<S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="263" ssid="5">Quantization can be improved by jointly encoding probability and backoff.</S><S sid="264" ssid="6">For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'98'", "'263'", "'264'"]
'51'
'98'
'263'
'264'
['51', '98', '263', '264']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="254" ssid="73">We used this data to build an unpruned ARPA file with IRSTLM&#8217;s improved-kneser-ney option and the default three pieces.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'51'", "'254'"]
'0'
'1'
'51'
'254'
['0', '1', '51', '254']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="6" ssid="1">Language models are widely applied in natural language processing, and applications such as machine translation make very frequent queries.</S><S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'6'", "'7'", "'103'"]
'1'
'6'
'7'
'103'
['1', '6', '7', '103']
parsed_discourse_facet ['hypothesis_citation']
<S sid="5" ssid="5">This paper describes the several performance techniques used and presents benchmarks against alternative implementations.</S><S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'12'", "'21'", "'199'"]
'5'
'12'
'21'
'199'
['5', '12', '21', '199']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S><S sid="14" ssid="9">MITLM 0.4 (Hsu and Glass, 2008) is mostly designed for accurate model estimation, but can also compute perplexity.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'7'", "'14'"]
'0'
'1'
'7'
'14'
['0', '1', '7', '14']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">The structure uses linear probing hash tables and is designed for speed.</S><S sid="11" ssid="6">Many packages perform language model queries.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'11'", "'152'", "'199'"]
'2'
'11'
'152'
'199'
['2', '11', '152', '199']
parsed_discourse_facet ['results_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="131" ssid="3">Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N &#8722; 1 preceding words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'103'", "'131'"]
'0'
'1'
'103'
'131'
['0', '1', '103', '131']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="11">BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.</S><S sid="141" ssid="13">Syntactic decoders, such as cdec (Dyer et al., 2010), build state from null context then store it in the hypergraph node for later extension.</S><S sid="164" ssid="36">This makes memory usage comparable to our PROBING model.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'141'", "'164'", "'199'"]
'16'
'141'
'164'
'199'
['16', '141', '164', '199']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="137" ssid="9">The state function is integrated into the query process so that, in lieu of the query p(wnjwn&#8722;1 1 ), the application issues query p(wnjs(wn&#8722;1 1 )) which also returns s(wn1 ).</S><S sid="198" ssid="17">Memory usage is the same as with binary search and lower than with set.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'103'", "'137'", "'198'", "'199'"]
'103'
'137'
'198'
'199'
['103', '137', '198', '199']
parsed_discourse_facet ['method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'103'", "'152'"]
'0'
'1'
'103'
'152'
['0', '1', '103', '152']
parsed_discourse_facet ['results_citation']



W11-2123
W12-3145
0
method_citation
['method_citation']



W11-2123
W12-3131
0
method_citation
['results_citation']



W11-2123
W12-3160
0
method_citation
['results_citation']



W11-2123
W12-3706
0
method_citation
['hypothesis_citation']



W11-2123
E12-1083
0
method_citation
['method_citation', 'aim_citation']



W11-2123
D12-1108
0
method_citation
['hypothesis_citation']
parsing: input/ref/Task1/W11-2123_swastika.csv
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="52" ssid="30">Our implementation permits jumping to any n-gram of any length with a single lookup; this appears to be unique among language model implementations.</S>
original cit marker offset is 0
new cit marker offset is 0



['52']
52
['52']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
<S sid="177" ssid="49">However, TRIE partitions storage by n-gram length, so walking the trie reads N disjoint pages.</S>
original cit marker offset is 0
new cit marker offset is 0



['177']
177
['177']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="200" ssid="19">The model was built with open vocabulary, modified Kneser-Ney smoothing, and default pruning settings that remove singletons of order 3 and higher.</S>
original cit marker offset is 0
new cit marker offset is 0



['200']
200
['200']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
<S sid="200" ssid="19">The model was built with open vocabulary, modified Kneser-Ney smoothing, and default pruning settings that remove singletons of order 3 and higher.</S>
original cit marker offset is 0
new cit marker offset is 0



['200']
200
['200']
parsed_discourse_facet ['method_citation']
<S sid="200" ssid="19">The model was built with open vocabulary, modified Kneser-Ney smoothing, and default pruning settings that remove singletons of order 3 and higher.</S>
original cit marker offset is 0
new cit marker offset is 0



['200']
200
['200']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
<S sid="278" ssid="5">We attain these results using several optimizations: hashing, custom lookup tables, bit-level packing, and state for left-to-right query patterns.</S>
original cit marker offset is 0
new cit marker offset is 0



['278']
278
['278']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
parsing: input/res/Task1/W11-2123.annv3.csv
<S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'21'", "'98'", "'199'"]
'12'
'21'
'98'
'199'
['12', '21', '98', '199']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="102" ssid="6">The PROBING model was designed to improve upon SRILM by using linear probing hash tables (though not arranged in a trie), allocating memory all at once (eliminating the need for full pointers), and being easy to compile.</S><S sid="223" ssid="42">The binary language model from Section 5.2 and text phrase table were forced into disk cache before each run.</S><S sid="244" ssid="63">Time for Moses itself to load, including loading the language model and phrase table, is included.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'102'", "'223'", "'244'"]
'0'
'102'
'223'
'244'
['0', '102', '223', '244']
parsed_discourse_facet ['results_citation']
<S sid="135" ssid="7">Therefore, we want state to encode the minimum amount of information necessary to properly compute language model scores, so that the decoder will be faster and make fewer search errors.</S><S sid="136" ssid="8">We offer a state function s(wn1) = wn&#65533; where substring wn&#65533; is guaranteed to extend (to the right) in the same way that wn1 does for purposes of language modeling.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'135'", "'136'", "'152'", "'199'"]
'135'
'136'
'152'
'199'
['135', '136', '152', '199']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S><S sid="268" ssid="10">For example, syntactic decoders (Koehn et al., 2007; Dyer et al., 2010; Li et al., 2009) perform dynamic programming parametrized by both backward- and forward-looking state.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'21'", "'129'", "'268'"]
'1'
'21'
'129'
'268'
['1', '21', '129', '268']
parsed_discourse_facet ['results_citation']
<S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'21'", "'51'", "'199'"]
'12'
'21'
'51'
'199'
['12', '21', '51', '199']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="25" ssid="3">An important subproblem of language model storage is therefore sparse mapping: storing values for sparse keys using little memory then retrieving values given keys using little time.</S><S sid="130" ssid="2">Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'25'", "'130'", "'199'"]
'0'
'25'
'130'
'199'
['0', '25', '130', '199']
parsed_discourse_facet ['results_citation']
<S sid="68" ssid="46">The trie data structure is commonly used for language modeling.</S><S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S><S sid="130" ssid="2">Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.</S><S sid="274" ssid="1">We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'129'", "'130'", "'274'"]
'68'
'129'
'130'
'274'
['68', '129', '130', '274']
parsed_discourse_facet ['method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="2" ssid="2">The structure uses linear probing hash tables and is designed for speed.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'21'", "'199'"]
'0'
'2'
'21'
'199'
['0', '2', '21', '199']
parsed_discourse_facet ['hypothesis_citation']
<S sid="44" ssid="22">Further, the special hash 0 suffices to flag empty buckets.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="264" ssid="6">For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'51'", "'98'", "'264'"]
'44'
'51'
'98'
'264'
['44', '51', '98', '264']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="16" ssid="11">BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.</S><S sid="35" ssid="13">Non-empty buckets contain an entry belonging to them or to a preceding bucket where a conflict occurred.</S><S sid="92" ssid="70">To quantize, we use the binning method (Federico and Bertoldi, 2006) that sorts values, divides into equally sized bins, and averages within each bin.</S><S sid="204" ssid="23">For RandLM, we used the settings in the documentation: 8 bits per value and false positive probability 1 256.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'35'", "'92'", "'204'"]
'16'
'35'
'92'
'204'
['16', '35', '92', '204']
parsed_discourse_facet ['hypothesis_citation']
<S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="263" ssid="5">Quantization can be improved by jointly encoding probability and backoff.</S><S sid="264" ssid="6">For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'98'", "'263'", "'264'"]
'51'
'98'
'263'
'264'
['51', '98', '263', '264']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="254" ssid="73">We used this data to build an unpruned ARPA file with IRSTLM&#8217;s improved-kneser-ney option and the default three pieces.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'51'", "'254'"]
'0'
'1'
'51'
'254'
['0', '1', '51', '254']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="6" ssid="1">Language models are widely applied in natural language processing, and applications such as machine translation make very frequent queries.</S><S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'6'", "'7'", "'103'"]
'1'
'6'
'7'
'103'
['1', '6', '7', '103']
parsed_discourse_facet ['hypothesis_citation']
<S sid="5" ssid="5">This paper describes the several performance techniques used and presents benchmarks against alternative implementations.</S><S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'12'", "'21'", "'199'"]
'5'
'12'
'21'
'199'
['5', '12', '21', '199']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S><S sid="14" ssid="9">MITLM 0.4 (Hsu and Glass, 2008) is mostly designed for accurate model estimation, but can also compute perplexity.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'7'", "'14'"]
'0'
'1'
'7'
'14'
['0', '1', '7', '14']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">The structure uses linear probing hash tables and is designed for speed.</S><S sid="11" ssid="6">Many packages perform language model queries.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'11'", "'152'", "'199'"]
'2'
'11'
'152'
'199'
['2', '11', '152', '199']
parsed_discourse_facet ['results_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="131" ssid="3">Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N &#8722; 1 preceding words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'103'", "'131'"]
'0'
'1'
'103'
'131'
['0', '1', '103', '131']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="11">BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.</S><S sid="141" ssid="13">Syntactic decoders, such as cdec (Dyer et al., 2010), build state from null context then store it in the hypergraph node for later extension.</S><S sid="164" ssid="36">This makes memory usage comparable to our PROBING model.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'141'", "'164'", "'199'"]
'16'
'141'
'164'
'199'
['16', '141', '164', '199']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="137" ssid="9">The state function is integrated into the query process so that, in lieu of the query p(wnjwn&#8722;1 1 ), the application issues query p(wnjs(wn&#8722;1 1 )) which also returns s(wn1 ).</S><S sid="198" ssid="17">Memory usage is the same as with binary search and lower than with set.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'103'", "'137'", "'198'", "'199'"]
'103'
'137'
'198'
'199'
['103', '137', '198', '199']
parsed_discourse_facet ['method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'103'", "'152'"]
'0'
'1'
'103'
'152'
['0', '1', '103', '152']
parsed_discourse_facet ['results_citation']



W11-2123
W12-3131
0
aim_citation
['results_citation']



W11-2123
W12-3160
0
aim_citation
['results_citation']
parsing: input/ref/Task1/W11-2123_vardha.csv
    <S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'"]
'12'
['12']
parsed_discourse_facet ['method_citation']
 <S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'"]
'7'
['7']
parsed_discourse_facet ['method_citation']
 <S sid="131" ssid="3">Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N &#8722; 1 preceding words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'131'"]
'131'
['131']
parsed_discourse_facet ['method_citation']
 <S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
 <S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="108" ssid="12">Compared with SRILM, IRSTLM adds several features: lower memory consumption, a binary file format with memory mapping, caching to increase speed, and quantization.</S>
original cit marker offset is 0
new cit marker offset is 0



["'108'"]
'108'
['108']
parsed_discourse_facet ['method_citation']
    <S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S>
original cit marker offset is 0
new cit marker offset is 0



["'129'"]
'129'
['129']
parsed_discourse_facet ['method_citation']
    <S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'199'"]
'199'
['199']
parsed_discourse_facet ['method_citation']
    <S sid="52" ssid="30">Our implementation permits jumping to any n-gram of any length with a single lookup; this appears to be unique among language model implementations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'"]
'52'
['52']
parsed_discourse_facet ['method_citation']
    <S sid="263" ssid="5">Quantization can be improved by jointly encoding probability and backoff.</S>
original cit marker offset is 0
new cit marker offset is 0



["'263'"]
'263'
['263']
parsed_discourse_facet ['method_citation']
    <S sid="52" ssid="30">Our implementation permits jumping to any n-gram of any length with a single lookup; this appears to be unique among language model implementations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'"]
'52'
['52']
parsed_discourse_facet ['method_citation']
    <S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="145" ssid="17">If the context wnf will never extend to the right (i.e. wnf v is not present in the model for all words v) then no subsequent query will match the full context.</S>
original cit marker offset is 0
new cit marker offset is 0



["'145'"]
'145'
['145']
parsed_discourse_facet ['method_citation']
 <S sid="182" ssid="1">This section measures performance on shared tasks in order of increasing complexity: sparse lookups, evaluating perplexity of a large file, and translation with Moses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'182'"]
'182'
['182']
parsed_discourse_facet ['method_citation']
    <S sid="274" ssid="1">We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.</S>
original cit marker offset is 0
new cit marker offset is 0



["'274'"]
'274'
['274']
parsed_discourse_facet ['method_citation']
    <S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'"]
'12'
['12']
parsed_discourse_facet ['method_citation']
    <S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'"]
'7'
['7']
parsed_discourse_facet ['method_citation']
    <S sid="140" ssid="12">We have modified Moses (Koehn et al., 2007) to keep our state with hypotheses; to conserve memory, phrases do not keep state.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['method_citation']
 <S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'199'"]
'199'
['199']
parsed_discourse_facet ['method_citation']
 <S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'199'"]
'199'
['199']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W11-2123.annv3.csv
<S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'21'", "'98'", "'199'"]
'12'
'21'
'98'
'199'
['12', '21', '98', '199']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="102" ssid="6">The PROBING model was designed to improve upon SRILM by using linear probing hash tables (though not arranged in a trie), allocating memory all at once (eliminating the need for full pointers), and being easy to compile.</S><S sid="223" ssid="42">The binary language model from Section 5.2 and text phrase table were forced into disk cache before each run.</S><S sid="244" ssid="63">Time for Moses itself to load, including loading the language model and phrase table, is included.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'102'", "'223'", "'244'"]
'0'
'102'
'223'
'244'
['0', '102', '223', '244']
parsed_discourse_facet ['results_citation']
<S sid="135" ssid="7">Therefore, we want state to encode the minimum amount of information necessary to properly compute language model scores, so that the decoder will be faster and make fewer search errors.</S><S sid="136" ssid="8">We offer a state function s(wn1) = wn&#65533; where substring wn&#65533; is guaranteed to extend (to the right) in the same way that wn1 does for purposes of language modeling.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'135'", "'136'", "'152'", "'199'"]
'135'
'136'
'152'
'199'
['135', '136', '152', '199']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S><S sid="268" ssid="10">For example, syntactic decoders (Koehn et al., 2007; Dyer et al., 2010; Li et al., 2009) perform dynamic programming parametrized by both backward- and forward-looking state.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'21'", "'129'", "'268'"]
'1'
'21'
'129'
'268'
['1', '21', '129', '268']
parsed_discourse_facet ['results_citation']
<S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'21'", "'51'", "'199'"]
'12'
'21'
'51'
'199'
['12', '21', '51', '199']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="25" ssid="3">An important subproblem of language model storage is therefore sparse mapping: storing values for sparse keys using little memory then retrieving values given keys using little time.</S><S sid="130" ssid="2">Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'25'", "'130'", "'199'"]
'0'
'25'
'130'
'199'
['0', '25', '130', '199']
parsed_discourse_facet ['results_citation']
<S sid="68" ssid="46">The trie data structure is commonly used for language modeling.</S><S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S><S sid="130" ssid="2">Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.</S><S sid="274" ssid="1">We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'129'", "'130'", "'274'"]
'68'
'129'
'130'
'274'
['68', '129', '130', '274']
parsed_discourse_facet ['method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="2" ssid="2">The structure uses linear probing hash tables and is designed for speed.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'21'", "'199'"]
'0'
'2'
'21'
'199'
['0', '2', '21', '199']
parsed_discourse_facet ['hypothesis_citation']
<S sid="44" ssid="22">Further, the special hash 0 suffices to flag empty buckets.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="264" ssid="6">For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'51'", "'98'", "'264'"]
'44'
'51'
'98'
'264'
['44', '51', '98', '264']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="16" ssid="11">BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.</S><S sid="35" ssid="13">Non-empty buckets contain an entry belonging to them or to a preceding bucket where a conflict occurred.</S><S sid="92" ssid="70">To quantize, we use the binning method (Federico and Bertoldi, 2006) that sorts values, divides into equally sized bins, and averages within each bin.</S><S sid="204" ssid="23">For RandLM, we used the settings in the documentation: 8 bits per value and false positive probability 1 256.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'35'", "'92'", "'204'"]
'16'
'35'
'92'
'204'
['16', '35', '92', '204']
parsed_discourse_facet ['hypothesis_citation']
<S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="263" ssid="5">Quantization can be improved by jointly encoding probability and backoff.</S><S sid="264" ssid="6">For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'98'", "'263'", "'264'"]
'51'
'98'
'263'
'264'
['51', '98', '263', '264']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="254" ssid="73">We used this data to build an unpruned ARPA file with IRSTLM&#8217;s improved-kneser-ney option and the default three pieces.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'51'", "'254'"]
'0'
'1'
'51'
'254'
['0', '1', '51', '254']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="6" ssid="1">Language models are widely applied in natural language processing, and applications such as machine translation make very frequent queries.</S><S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'6'", "'7'", "'103'"]
'1'
'6'
'7'
'103'
['1', '6', '7', '103']
parsed_discourse_facet ['hypothesis_citation']
<S sid="5" ssid="5">This paper describes the several performance techniques used and presents benchmarks against alternative implementations.</S><S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'12'", "'21'", "'199'"]
'5'
'12'
'21'
'199'
['5', '12', '21', '199']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S><S sid="14" ssid="9">MITLM 0.4 (Hsu and Glass, 2008) is mostly designed for accurate model estimation, but can also compute perplexity.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'7'", "'14'"]
'0'
'1'
'7'
'14'
['0', '1', '7', '14']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">The structure uses linear probing hash tables and is designed for speed.</S><S sid="11" ssid="6">Many packages perform language model queries.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'11'", "'152'", "'199'"]
'2'
'11'
'152'
'199'
['2', '11', '152', '199']
parsed_discourse_facet ['results_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="131" ssid="3">Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N &#8722; 1 preceding words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'103'", "'131'"]
'0'
'1'
'103'
'131'
['0', '1', '103', '131']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="11">BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.</S><S sid="141" ssid="13">Syntactic decoders, such as cdec (Dyer et al., 2010), build state from null context then store it in the hypergraph node for later extension.</S><S sid="164" ssid="36">This makes memory usage comparable to our PROBING model.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'141'", "'164'", "'199'"]
'16'
'141'
'164'
'199'
['16', '141', '164', '199']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="137" ssid="9">The state function is integrated into the query process so that, in lieu of the query p(wnjwn&#8722;1 1 ), the application issues query p(wnjs(wn&#8722;1 1 )) which also returns s(wn1 ).</S><S sid="198" ssid="17">Memory usage is the same as with binary search and lower than with set.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'103'", "'137'", "'198'", "'199'"]
'103'
'137'
'198'
'199'
['103', '137', '198', '199']
parsed_discourse_facet ['method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'103'", "'152'"]
'0'
'1'
'103'
'152'
['0', '1', '103', '152']
parsed_discourse_facet ['results_citation']



W11-2123
W11-2138
0
method_citation
['hypothesis_citation', 'method_citation']



W11-2123
W12-3131
0
method_citation
['results_citation']



W11-2123
W12-3154
0
method_citation
['hypothesis_citation', 'method_citation']



W11-2123
W11-2139
0
method_citation
['method_citation']



W11-2123
P13-2003
0
method_citation
['hypothesis_citation']



W11-2123
W12-3160
0
method_citation
['results_citation']



W11-2123
P13-2073
0
method_citation
['method_citation']
parsing: input/ref/Task1/W99-0613_aakansha.csv
<S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="30">Roughly speaking, the new algorithm presented in this paper performs a similar search, but instead minimizes a bound on the number of (unlabeled) examples on which two classifiers disagree.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="137" ssid="4">The new algorithm, which we call CoBoost, uses labeled and unlabeled data and builds two classifiers in parallel.</S>
original cit marker offset is 0
new cit marker offset is 0



["'137'"]
'137'
['137']
parsed_discourse_facet ['method_citation']
<S sid="79" ssid="12">2 We now introduce a new algorithm for learning from unlabeled examples, which we will call DLCoTrain (DL stands for decision list, the term Cotrain is taken from (Blum and Mitchell 98)).</S>
original cit marker offset is 0
new cit marker offset is 0



["'79'"]
'79'
['79']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="4">The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="12">But we will show that the use of unlabeled data can drastically reduce the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'"]
'18'
['18']
parsed_discourse_facet ['method_citation']
<S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S>
    <S sid="237" ssid="4">The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'236'", "'237'"]
'236'
'237'
['236', '237']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S>
    <S sid="10" ssid="4">The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'10'"]
'9'
'10'
['9', '10']
parsed_discourse_facet ['method_citation']
<S sid="137" ssid="4">The new algorithm, which we call CoBoost, uses labeled and unlabeled data and builds two classifiers in parallel.</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S>
original cit marker offset is 0
new cit marker offset is 0



["'137'", "'39'"]
'137'
'39'
['137', '39']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="20">We present two algorithms.</S>
    <S sid="27" ssid="21">The first method builds on results from (Yarowsky 95) and (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'"]
'26'
'27'
['26', '27']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="12">But we will show that the use of unlabeled data can drastically reduce the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'"]
'18'
['18']
parsed_discourse_facet ['method_citation']
<S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'85'"]
'85'
['85']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S>
    <S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'9'"]
'8'
'9'
['8', '9']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W99-0613.annv3.csv
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="28" ssid="22">(Yarowsky 95) describes an algorithm for word-sense disambiguation that exploits redundancy in contextual features, and gives impressive performance.</S><S sid="30" ssid="24">(Blum and Mitchell 98) offer a promising formulation of redundancy, also prove some results about how the use of unlabeled examples can help classification, and suggest an objective function when training with unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'7'", "'28'", "'30'"]
'5'
'7'
'28'
'30'
['5', '7', '28', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="27">The second algorithm builds on a boosting algorithm called AdaBoost (Freund and Schapire 97; Schapire and Singer 98).</S><S sid="34" ssid="28">The AdaBoost algorithm was developed for supervised learning.</S><S sid="173" ssid="40">(3)), with one term for each classifier.</S><S sid="175" ssid="42">Put another way, the minimum of Equ.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'173'", "'175'"]
'33'
'34'
'173'
'175'
['33', '34', '173', '175']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S><S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'138'", "'139'", "'203'"]
'91'
'138'
'139'
'203'
['91', '138', '139', '203']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="14" ssid="8">A contextual rule considers words surrounding the string in the sentence in which it appears (e.g., a rule that any proper name modified by an appositive whose head is president is a person).</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="254" ssid="5">Future work should also extend the approach to build a complete named entity extractor - a method that pulls proper names from text and then classifies them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'14'", "'47'", "'254'"]
'2'
'14'
'47'
'254'
['2', '14', '47', '254']
parsed_discourse_facet ['hypothesis_citation']
<S sid="10" ssid="4">The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.</S><S sid="77" ssid="10">In this paper k = 3 (the three labels are person, organization, location), and we set a = 0.1.</S><S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S><S sid="237" ssid="4">The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'77'", "'236'", "'237'"]
'10'
'77'
'236'
'237'
['10', '77', '236', '237']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="18" ssid="12">But we will show that the use of unlabeled data can drastically reduce the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'18'"]
'1'
'2'
'8'
'18'
['1', '2', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="202" ssid="69">The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'47'", "'202'"]
'1'
'9'
'47'
'202'
['1', '9', '47', '202']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="10">Supervised methods have been applied quite successfully to the full MUC named-entity task (Bikel et al. 97).</S><S sid="29" ssid="23">Unfortunately, Yarowsky\s method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.</S><S sid="56" ssid="10">In the appositive case, the contextual predictor was the head of the modifying appositive (president in the Maury Cooper example); in the second case, the contextual predictor was the preposition together with the noun it modifies (plant_in in the Georgia example).</S><S sid="232" ssid="11">For example, the independence assumptions mean that the model fails to capture the dependence between specific and more general features (for example the fact that the feature full.-string=New_York is always seen with the features contains (New) and The baseline method tags all entities as the most frequent class type (organization). contains (York) and is never seen with a feature such as contains (Group) ).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'29'", "'56'", "'232'"]
'16'
'29'
'56'
'232'
['16', '29', '56', '232']
parsed_discourse_facet ['hypothesis_citation']
<S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="219" ssid="86">Finally, we would like to note that it is possible to devise similar algorithms based with other objective functions than the one given in Equ.</S><S sid="251" ssid="2">In addition to a heuristic based on decision list learning, we also presented a boosting-like framework that builds on ideas from (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'", "'139'", "'219'", "'251'"]
'138'
'139'
'219'
'251'
['138', '139', '219', '251']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="6" ssid="6">The second algorithm extends ideas from boosting algorithms, designed for supervised learning tasks, to the framework suggested by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="31" ssid="25">Our first algorithm is similar to Yarowsky\s, but with some important modifications motivated by (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'6'", "'7'", "'31'"]
'5'
'6'
'7'
'31'
['5', '6', '7', '31']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="141" ssid="8">For a description of the application of AdaBoost to various NLP problems see the paper by Abney, Schapire, and Singer in this volume.</S><S sid="153" ssid="20">Schapire and Singer show that the training error is bounded above by Thus, in order to greedily minimize an upper bound on training error, on each iteration we should search for the weak hypothesis ht and the weight at that minimize Z.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'141'", "'153'", "'203'"]
'7'
'141'
'153'
'203'
['7', '141', '153', '203']
parsed_discourse_facet ['hypothesis_citation']
<S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="82" ssid="15">In the named entity domain these rules were Each of these rules was given a strength of 0.9999.</S><S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'60'", "'82'", "'85'", "'140'"]
'60'
'82'
'85'
'140'
['60', '82', '85', '140']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'8'", "'60'", "'140'"]
'5'
'8'
'60'
'140'
['5', '8', '60', '140']
parsed_discourse_facet ['results_citation']



W99-0613
C02-1154
0
method_citation
['hypothesis_citation']



W99-0613
W06-2204
0
method_citation
['hypothesis_citation']



W99-0613
W06-2207
0
method_citation
['method_citation']



W99-0613
P12-1065
0
method_citation
['results_citation']
parsing: input/ref/Task1/W99-0613_swastika.csv
<S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S>
original cit marker offset is 0
new cit marker offset is 0



['9']
9
['9']
parsed_discourse_facet ['aim_citation']
<S sid="159" ssid="26">To prevent this we &amp;quot;smooth&amp;quot; the confidence by adding a small value, e, to both W+ and W_, giving at = Plugging the value of at from Equ.</S>
original cit marker offset is 0
new cit marker offset is 0



['159']
159
['159']
parsed_discourse_facet ['method_citation']
<S sid="137" ssid="4">The new algorithm, which we call CoBoost, uses labeled and unlabeled data and builds two classifiers in parallel.</S>
original cit marker offset is 0
new cit marker offset is 0



['137']
137
['137']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S>
original cit marker offset is 0
new cit marker offset is 0



['91']
91
['91']
parsed_discourse_facet ['method_citation']
<S sid="213" ssid="80">Thus at each iteration the algorithm is forced to pick features for the location, person and organization in turn for the classifier being trained.</S>
original cit marker offset is 0
new cit marker offset is 0



['213']
213
['213']
parsed_discourse_facet ['method_citation']
 <S sid="250" ssid="1">Unlabeled examples in the named-entity classification problem can reduce the need for supervision to a handful of seed rules.</S>
original cit marker offset is 0
new cit marker offset is 0



['250']
250
['250']
parsed_discourse_facet ['result_citation']
<S sid="213" ssid="80">Thus at each iteration the algorithm is forced to pick features for the location, person and organization in turn for the classifier being trained.</S>
original cit marker offset is 0
new cit marker offset is 0



['213']
213
['213']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S>
original cit marker offset is 0
new cit marker offset is 0



['9']
9
['9']
parsed_discourse_facet ['aim_citation']
    <S sid="36" ssid="30">Roughly speaking, the new algorithm presented in this paper performs a similar search, but instead minimizes a bound on the number of (unlabeled) examples on which two classifiers disagree.</S>
original cit marker offset is 0
new cit marker offset is 0



['36']
36
['36']
parsed_discourse_facet ['result_citation']
<S sid="29" ssid="23">Unfortunately, Yarowsky's method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.</S>
original cit marker offset is 0
new cit marker offset is 0



['29']
29
['29']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
    <S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



['85']
85
['85']
parsed_discourse_facet ['method_citation']
    <S sid="95" ssid="28">(Specifically, the limit n starts at 5 and increases by 5 at each iteration.)</S>
original cit marker offset is 0
new cit marker offset is 0



['95']
95
['95']
parsed_discourse_facet ['method_citation']
<S sid="213" ssid="80">Thus at each iteration the algorithm is forced to pick features for the location, person and organization in turn for the classifier being trained.</S>
original cit marker offset is 0
new cit marker offset is 0



['213']
213
['213']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W99-0613.annv3.csv
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="28" ssid="22">(Yarowsky 95) describes an algorithm for word-sense disambiguation that exploits redundancy in contextual features, and gives impressive performance.</S><S sid="30" ssid="24">(Blum and Mitchell 98) offer a promising formulation of redundancy, also prove some results about how the use of unlabeled examples can help classification, and suggest an objective function when training with unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'7'", "'28'", "'30'"]
'5'
'7'
'28'
'30'
['5', '7', '28', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="27">The second algorithm builds on a boosting algorithm called AdaBoost (Freund and Schapire 97; Schapire and Singer 98).</S><S sid="34" ssid="28">The AdaBoost algorithm was developed for supervised learning.</S><S sid="173" ssid="40">(3)), with one term for each classifier.</S><S sid="175" ssid="42">Put another way, the minimum of Equ.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'173'", "'175'"]
'33'
'34'
'173'
'175'
['33', '34', '173', '175']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S><S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'138'", "'139'", "'203'"]
'91'
'138'
'139'
'203'
['91', '138', '139', '203']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="14" ssid="8">A contextual rule considers words surrounding the string in the sentence in which it appears (e.g., a rule that any proper name modified by an appositive whose head is president is a person).</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="254" ssid="5">Future work should also extend the approach to build a complete named entity extractor - a method that pulls proper names from text and then classifies them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'14'", "'47'", "'254'"]
'2'
'14'
'47'
'254'
['2', '14', '47', '254']
parsed_discourse_facet ['hypothesis_citation']
<S sid="10" ssid="4">The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.</S><S sid="77" ssid="10">In this paper k = 3 (the three labels are person, organization, location), and we set a = 0.1.</S><S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S><S sid="237" ssid="4">The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'77'", "'236'", "'237'"]
'10'
'77'
'236'
'237'
['10', '77', '236', '237']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="18" ssid="12">But we will show that the use of unlabeled data can drastically reduce the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'18'"]
'1'
'2'
'8'
'18'
['1', '2', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="202" ssid="69">The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'47'", "'202'"]
'1'
'9'
'47'
'202'
['1', '9', '47', '202']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="10">Supervised methods have been applied quite successfully to the full MUC named-entity task (Bikel et al. 97).</S><S sid="29" ssid="23">Unfortunately, Yarowsky\s method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.</S><S sid="56" ssid="10">In the appositive case, the contextual predictor was the head of the modifying appositive (president in the Maury Cooper example); in the second case, the contextual predictor was the preposition together with the noun it modifies (plant_in in the Georgia example).</S><S sid="232" ssid="11">For example, the independence assumptions mean that the model fails to capture the dependence between specific and more general features (for example the fact that the feature full.-string=New_York is always seen with the features contains (New) and The baseline method tags all entities as the most frequent class type (organization). contains (York) and is never seen with a feature such as contains (Group) ).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'29'", "'56'", "'232'"]
'16'
'29'
'56'
'232'
['16', '29', '56', '232']
parsed_discourse_facet ['hypothesis_citation']
<S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="219" ssid="86">Finally, we would like to note that it is possible to devise similar algorithms based with other objective functions than the one given in Equ.</S><S sid="251" ssid="2">In addition to a heuristic based on decision list learning, we also presented a boosting-like framework that builds on ideas from (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'", "'139'", "'219'", "'251'"]
'138'
'139'
'219'
'251'
['138', '139', '219', '251']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="6" ssid="6">The second algorithm extends ideas from boosting algorithms, designed for supervised learning tasks, to the framework suggested by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="31" ssid="25">Our first algorithm is similar to Yarowsky\s, but with some important modifications motivated by (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'6'", "'7'", "'31'"]
'5'
'6'
'7'
'31'
['5', '6', '7', '31']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="141" ssid="8">For a description of the application of AdaBoost to various NLP problems see the paper by Abney, Schapire, and Singer in this volume.</S><S sid="153" ssid="20">Schapire and Singer show that the training error is bounded above by Thus, in order to greedily minimize an upper bound on training error, on each iteration we should search for the weak hypothesis ht and the weight at that minimize Z.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'141'", "'153'", "'203'"]
'7'
'141'
'153'
'203'
['7', '141', '153', '203']
parsed_discourse_facet ['hypothesis_citation']
<S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="82" ssid="15">In the named entity domain these rules were Each of these rules was given a strength of 0.9999.</S><S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'60'", "'82'", "'85'", "'140'"]
'60'
'82'
'85'
'140'
['60', '82', '85', '140']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'8'", "'60'", "'140'"]
'5'
'8'
'60'
'140'
['5', '8', '60', '140']
parsed_discourse_facet ['results_citation']
IGNORE THIS: key error 1
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



W99-0613
W06-2207
0
method_citation
['method_citation']
IGNORE THIS: Key error 5
parsing: input/ref/Task1/W99-0613_sweta.csv
<S sid="121" ssid="54">They also describe an application of cotraining to classifying web pages (the to feature sets are the words on the page, and other pages pointing to the page).</S>
original cit marker offset is 0
new cit marker offset is 0



["121'"]
121'
['121']
parsed_discourse_facet ['method_citation']
<S sid="252" ssid="3">The method uses a &amp;quot;soft&amp;quot; measure of the agreement between two classifiers as an objective function; we described an algorithm which directly optimizes this function.</S>
original cit marker offset is 0
new cit marker offset is 0



["252'"]
252'
['252']
parsed_discourse_facet ['method_citation']
 <S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S>
original cit marker offset is 0
new cit marker offset is 0



["91'"]
91'
['91']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S>
original cit marker offset is 0
new cit marker offset is 0



["91'"]
91'
['91']
parsed_discourse_facet ['method_citation']
 <S sid="213" ssid="80">Thus at each iteration the algorithm is forced to pick features for the location, person and organization in turn for the classifier being trained.</S>
original cit marker offset is 0
new cit marker offset is 0



["213'"]
213'
['213']
parsed_discourse_facet ['method_citation']
 <S sid="250" ssid="1">Unlabeled examples in the named-entity classification problem can reduce the need for supervision to a handful of seed rules.</S>
original cit marker offset is 0
new cit marker offset is 0



["250'"]
250'
['250']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="33">(Brin 98) ,describes a system for extracting (author, book-title) pairs from the World Wide Web using an approach that bootstraps from an initial seed set of examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["39'"]
39'
['39']
parsed_discourse_facet ['method_citation']
<S sid="202" ssid="69">The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.</S>
original cit marker offset is 0
new cit marker offset is 0



["202'"]
202'
['202']
parsed_discourse_facet ['method_citation']
<S sid="61" ssid="15">The following features were used: full-string=x The full string (e.g., for Maury Cooper, full- s tring=Maury_Cooper). contains(x) If the spelling contains more than one word, this feature applies for any words that the string contains (e.g., Maury Cooper contributes two such features, contains (Maury) and contains (Cooper) . allcapl This feature appears if the spelling is a single word which is all capitals (e.g., IBM would contribute this feature). allcap2 This feature appears if the spelling is a single word which is all capitals or full periods, and contains at least one period.</S>
original cit marker offset is 0
new cit marker offset is 0



["61'"]
61'
['61']
parsed_discourse_facet ['method_citation']
<S sid="176" ssid="43">(7) is at 0 when: 1) Vi : sign(gi (xi)) = sign(g2 (xi)); 2) Ig3(xi)l oo; and 3) sign(gi (xi)) = yi for i = 1, , m. In fact, Zco provides a bound on the sum of the classification error of the labeled examples and the number of disagreements between the two classifiers on the unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["176'"]
176'
['176']
parsed_discourse_facet ['method_citation']
 <S sid="108" ssid="41">In the cotraining case, (Blum and Mitchell 98) argue that the task should be to induce functions Ii and f2 such that So Ii and 12 must (1) correctly classify the labeled examples, and (2) must agree with each other on the unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["108'"]
108'
['108']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="21">The first method builds on results from (Yarowsky 95) and (Blum and Mitchell 98).</S>
    <S sid="28" ssid="22">(Yarowsky 95) describes an algorithm for word-sense disambiguation that exploits redundancy in contextual features, and gives impressive performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["27'", "'28'"]
27'
'28'
['27', '28']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["7'"]
7'
['7']
parsed_discourse_facet ['method_citation']
 <S sid="172" ssid="39">To see this, note thai the first two terms in the above equation correspond to the function that AdaBoost attempts to minimize in the standard supervised setting (Equ.</S>
original cit marker offset is 0
new cit marker offset is 0



["172'"]
172'
['172']
parsed_discourse_facet ['method_citation']
<S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["85'"]
85'
['85']
parsed_discourse_facet ['method_citation']
 <S sid="214" ssid="81">This modification brings the method closer to the DL-CoTrain algorithm described earlier, and is motivated by the intuition that all three labels should be kept healthily populated in the unlabeled examples, preventing one label from dominating &#8212; this deserves more theoretical investigation.</S>
original cit marker offset is 0
new cit marker offset is 0



["214'"]
214'
['214']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W99-0613.annv3.csv
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="28" ssid="22">(Yarowsky 95) describes an algorithm for word-sense disambiguation that exploits redundancy in contextual features, and gives impressive performance.</S><S sid="30" ssid="24">(Blum and Mitchell 98) offer a promising formulation of redundancy, also prove some results about how the use of unlabeled examples can help classification, and suggest an objective function when training with unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'7'", "'28'", "'30'"]
'5'
'7'
'28'
'30'
['5', '7', '28', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="27">The second algorithm builds on a boosting algorithm called AdaBoost (Freund and Schapire 97; Schapire and Singer 98).</S><S sid="34" ssid="28">The AdaBoost algorithm was developed for supervised learning.</S><S sid="173" ssid="40">(3)), with one term for each classifier.</S><S sid="175" ssid="42">Put another way, the minimum of Equ.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'173'", "'175'"]
'33'
'34'
'173'
'175'
['33', '34', '173', '175']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S><S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'138'", "'139'", "'203'"]
'91'
'138'
'139'
'203'
['91', '138', '139', '203']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="14" ssid="8">A contextual rule considers words surrounding the string in the sentence in which it appears (e.g., a rule that any proper name modified by an appositive whose head is president is a person).</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="254" ssid="5">Future work should also extend the approach to build a complete named entity extractor - a method that pulls proper names from text and then classifies them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'14'", "'47'", "'254'"]
'2'
'14'
'47'
'254'
['2', '14', '47', '254']
parsed_discourse_facet ['hypothesis_citation']
<S sid="10" ssid="4">The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.</S><S sid="77" ssid="10">In this paper k = 3 (the three labels are person, organization, location), and we set a = 0.1.</S><S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S><S sid="237" ssid="4">The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'77'", "'236'", "'237'"]
'10'
'77'
'236'
'237'
['10', '77', '236', '237']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="18" ssid="12">But we will show that the use of unlabeled data can drastically reduce the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'18'"]
'1'
'2'
'8'
'18'
['1', '2', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="202" ssid="69">The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'47'", "'202'"]
'1'
'9'
'47'
'202'
['1', '9', '47', '202']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="10">Supervised methods have been applied quite successfully to the full MUC named-entity task (Bikel et al. 97).</S><S sid="29" ssid="23">Unfortunately, Yarowsky\s method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.</S><S sid="56" ssid="10">In the appositive case, the contextual predictor was the head of the modifying appositive (president in the Maury Cooper example); in the second case, the contextual predictor was the preposition together with the noun it modifies (plant_in in the Georgia example).</S><S sid="232" ssid="11">For example, the independence assumptions mean that the model fails to capture the dependence between specific and more general features (for example the fact that the feature full.-string=New_York is always seen with the features contains (New) and The baseline method tags all entities as the most frequent class type (organization). contains (York) and is never seen with a feature such as contains (Group) ).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'29'", "'56'", "'232'"]
'16'
'29'
'56'
'232'
['16', '29', '56', '232']
parsed_discourse_facet ['hypothesis_citation']
<S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="219" ssid="86">Finally, we would like to note that it is possible to devise similar algorithms based with other objective functions than the one given in Equ.</S><S sid="251" ssid="2">In addition to a heuristic based on decision list learning, we also presented a boosting-like framework that builds on ideas from (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'", "'139'", "'219'", "'251'"]
'138'
'139'
'219'
'251'
['138', '139', '219', '251']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="6" ssid="6">The second algorithm extends ideas from boosting algorithms, designed for supervised learning tasks, to the framework suggested by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="31" ssid="25">Our first algorithm is similar to Yarowsky\s, but with some important modifications motivated by (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'6'", "'7'", "'31'"]
'5'
'6'
'7'
'31'
['5', '6', '7', '31']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="141" ssid="8">For a description of the application of AdaBoost to various NLP problems see the paper by Abney, Schapire, and Singer in this volume.</S><S sid="153" ssid="20">Schapire and Singer show that the training error is bounded above by Thus, in order to greedily minimize an upper bound on training error, on each iteration we should search for the weak hypothesis ht and the weight at that minimize Z.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'141'", "'153'", "'203'"]
'7'
'141'
'153'
'203'
['7', '141', '153', '203']
parsed_discourse_facet ['hypothesis_citation']
<S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="82" ssid="15">In the named entity domain these rules were Each of these rules was given a strength of 0.9999.</S><S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'60'", "'82'", "'85'", "'140'"]
'60'
'82'
'85'
'140'
['60', '82', '85', '140']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'8'", "'60'", "'140'"]
'5'
'8'
'60'
'140'
['5', '8', '60', '140']
parsed_discourse_facet ['results_citation']
IGNORE THIS: key error 1
IGNORE THIS: key error 1



W99-0613
W03-1509
0
method_citation
['method_citation']



W99-0613
W03-1022
0
method_citation
['hypothesis_citation']



W99-0613
W06-2207
0
method_citation
['method_citation']
parsing: input/ref/Task1/W99-0613_vardha.csv
    <S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
    <S sid="35" ssid="29">AdaBoost finds a weighted combination of simple (weak) classifiers, where the weights are chosen to minimize a function that bounds the classification error on a set of training examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'35'"]
'35'
['35']
parsed_discourse_facet ['method_citation']
    <S sid="134" ssid="1">This section describes an algorithm based on boosting algorithms, which were previously developed for supervised machine learning problems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'134'"]
'134'
['134']
parsed_discourse_facet ['method_citation']
    <S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S>
original cit marker offset is 0
new cit marker offset is 0



["'236'"]
'236'
['236']
parsed_discourse_facet ['method_citation']
    <S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
    <S sid="42" ssid="36">(Riloff and Shepherd 97) describe a bootstrapping approach for acquiring nouns in particular categories (such as &amp;quot;vehicle&amp;quot; or &amp;quot;weapon&amp;quot; categories).</S>
original cit marker offset is 0
new cit marker offset is 0



["'42'"]
'42'
['42']
parsed_discourse_facet ['method_citation']
    <S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S>
original cit marker offset is 0
new cit marker offset is 0



["'236'"]
'236'
['236']
parsed_discourse_facet ['method_citation']
    <S sid="222" ssid="1">The Expectation Maximization (EM) algorithm (Dempster, Laird and Rubin 77) is a common approach for unsupervised training; in this section we describe its application to the named entity problem.</S>
original cit marker offset is 0
new cit marker offset is 0



["'222'"]
'222'
['222']
parsed_discourse_facet ['method_citation']
    <S sid="30" ssid="24">(Blum and Mitchell 98) offer a promising formulation of redundancy, also prove some results about how the use of can help classification, and suggest an objective function when training with unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'"]
'30'
['30']
parsed_discourse_facet ['method_citation']
 <S sid="26" ssid="20">We present two algorithms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'"]
'26'
['26']
parsed_discourse_facet ['method_citation']
    <S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'"]
'7'
['7']
parsed_discourse_facet ['method_citation']
    <S sid="32" ssid="26">The algorithm can be viewed as heuristically optimizing an objective function suggested by (Blum and Mitchell 98); empirically it is shown to be quite successful in optimizing this criterion.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'"]
'32'
['32']
parsed_discourse_facet ['method_citation']
    <S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S>
original cit marker offset is 0
new cit marker offset is 0



["'47'"]
'47'
['47']
parsed_discourse_facet ['method_citation']
    <S sid="127" ssid="60">The DL-CoTrain algorithm can be motivated as being a greedy method of satisfying the above 2 constraints.</S>
original cit marker offset is 0
new cit marker offset is 0



["'127'"]
'127'
['127']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W99-0613.annv3.csv
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="28" ssid="22">(Yarowsky 95) describes an algorithm for word-sense disambiguation that exploits redundancy in contextual features, and gives impressive performance.</S><S sid="30" ssid="24">(Blum and Mitchell 98) offer a promising formulation of redundancy, also prove some results about how the use of unlabeled examples can help classification, and suggest an objective function when training with unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'7'", "'28'", "'30'"]
'5'
'7'
'28'
'30'
['5', '7', '28', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="27">The second algorithm builds on a boosting algorithm called AdaBoost (Freund and Schapire 97; Schapire and Singer 98).</S><S sid="34" ssid="28">The AdaBoost algorithm was developed for supervised learning.</S><S sid="173" ssid="40">(3)), with one term for each classifier.</S><S sid="175" ssid="42">Put another way, the minimum of Equ.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'173'", "'175'"]
'33'
'34'
'173'
'175'
['33', '34', '173', '175']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S><S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'138'", "'139'", "'203'"]
'91'
'138'
'139'
'203'
['91', '138', '139', '203']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="14" ssid="8">A contextual rule considers words surrounding the string in the sentence in which it appears (e.g., a rule that any proper name modified by an appositive whose head is president is a person).</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="254" ssid="5">Future work should also extend the approach to build a complete named entity extractor - a method that pulls proper names from text and then classifies them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'14'", "'47'", "'254'"]
'2'
'14'
'47'
'254'
['2', '14', '47', '254']
parsed_discourse_facet ['hypothesis_citation']
<S sid="10" ssid="4">The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.</S><S sid="77" ssid="10">In this paper k = 3 (the three labels are person, organization, location), and we set a = 0.1.</S><S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S><S sid="237" ssid="4">The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'77'", "'236'", "'237'"]
'10'
'77'
'236'
'237'
['10', '77', '236', '237']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="18" ssid="12">But we will show that the use of unlabeled data can drastically reduce the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'18'"]
'1'
'2'
'8'
'18'
['1', '2', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="202" ssid="69">The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'47'", "'202'"]
'1'
'9'
'47'
'202'
['1', '9', '47', '202']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="10">Supervised methods have been applied quite successfully to the full MUC named-entity task (Bikel et al. 97).</S><S sid="29" ssid="23">Unfortunately, Yarowsky\s method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.</S><S sid="56" ssid="10">In the appositive case, the contextual predictor was the head of the modifying appositive (president in the Maury Cooper example); in the second case, the contextual predictor was the preposition together with the noun it modifies (plant_in in the Georgia example).</S><S sid="232" ssid="11">For example, the independence assumptions mean that the model fails to capture the dependence between specific and more general features (for example the fact that the feature full.-string=New_York is always seen with the features contains (New) and The baseline method tags all entities as the most frequent class type (organization). contains (York) and is never seen with a feature such as contains (Group) ).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'29'", "'56'", "'232'"]
'16'
'29'
'56'
'232'
['16', '29', '56', '232']
parsed_discourse_facet ['hypothesis_citation']
<S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="219" ssid="86">Finally, we would like to note that it is possible to devise similar algorithms based with other objective functions than the one given in Equ.</S><S sid="251" ssid="2">In addition to a heuristic based on decision list learning, we also presented a boosting-like framework that builds on ideas from (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'", "'139'", "'219'", "'251'"]
'138'
'139'
'219'
'251'
['138', '139', '219', '251']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="6" ssid="6">The second algorithm extends ideas from boosting algorithms, designed for supervised learning tasks, to the framework suggested by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="31" ssid="25">Our first algorithm is similar to Yarowsky\s, but with some important modifications motivated by (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'6'", "'7'", "'31'"]
'5'
'6'
'7'
'31'
['5', '6', '7', '31']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="141" ssid="8">For a description of the application of AdaBoost to various NLP problems see the paper by Abney, Schapire, and Singer in this volume.</S><S sid="153" ssid="20">Schapire and Singer show that the training error is bounded above by Thus, in order to greedily minimize an upper bound on training error, on each iteration we should search for the weak hypothesis ht and the weight at that minimize Z.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'141'", "'153'", "'203'"]
'7'
'141'
'153'
'203'
['7', '141', '153', '203']
parsed_discourse_facet ['hypothesis_citation']
<S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="82" ssid="15">In the named entity domain these rules were Each of these rules was given a strength of 0.9999.</S><S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'60'", "'82'", "'85'", "'140'"]
'60'
'82'
'85'
'140'
['60', '82', '85', '140']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'8'", "'60'", "'140'"]
'5'
'8'
'60'
'140'
['5', '8', '60', '140']
parsed_discourse_facet ['results_citation']
IGNORE THIS: key error 1
IGNORE THIS: key error 1
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



W99-0613
C02-1154
0
method_citation
['hypothesis_citation']



W99-0613
W06-2204
0
method_citation
['hypothesis_citation']
IGNORE THIS: Key error 5
parsing: input/ref/Task1/W99-0623_swastika.csv
<S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



['85']
85
['85']
parsed_discourse_facet ['aim_citation']
<S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



['120']
120
['120']
parsed_discourse_facet ['result_citation']
<S sid="25" ssid="11">In our particular case the majority requires the agreement of only two parsers because we have only three.</S>
original cit marker offset is 0
new cit marker offset is 0



['25']
25
['25']
parsed_discourse_facet ['method_citation']
<S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



['120']
120
['120']
parsed_discourse_facet ['result_citation']
<S sid="38" ssid="24">Under certain conditions the constituent voting and na&#239;ve Bayes constituent combination techniques are guaranteed to produce sets of constituents with no crossing brackets.</S>
original cit marker offset is 0
new cit marker offset is 0



['38']
38
['38']
parsed_discourse_facet ['result_citation']
<S sid="91" ssid="20">Features and context were initially introduced into the models, but they refused to offer any gains in performance.</S>
original cit marker offset is 0
new cit marker offset is 0



['91']
91
['91']
parsed_discourse_facet ['method_citation']
<S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



['120']
120
['120']
parsed_discourse_facet ['result_citation']
<S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



['120']
120
['120']
parsed_discourse_facet ['result_citation']
<S sid="139" ssid="1">We have presented two general approaches to studying parser combination: parser switching and parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



['139']
139
['139']
parsed_discourse_facet ['result_citation']
<S sid="25" ssid="11">In our particular case the majority requires the agreement of only two parsers because we have only three.</S>
original cit marker offset is 0
new cit marker offset is 0



['25']
25
['25']
parsed_discourse_facet ['method_citation']
<S sid="103" ssid="32">The counts represent portions of the approximately 44000 constituents hypothesized by the parsers in the development set.</S>
original cit marker offset is 0
new cit marker offset is 0



['103']
103
['103']
parsed_discourse_facet ['method_citation']
<S sid="139" ssid="1">We have presented two general approaches to studying parser combination: parser switching and parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



['139']
139
['139']
parsed_discourse_facet ['result_citation']
<S sid="70" ssid="56">In this case we are interested in finding' the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



['70']
70
['70']
parsed_discourse_facet ['aim_citation']
<S sid="140" ssid="2">For each experiment we gave an nonparametric and a parametric technique for combining parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



['140']
140
['140']
parsed_discourse_facet ['method_citation']
<S sid="70" ssid="56">In this case we are interested in finding' the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



['70']
70
['70']
parsed_discourse_facet ['aim_citation']
<S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



['85']
85
['85']
parsed_discourse_facet ['result_citation']
<S sid="70" ssid="56">In this case we are interested in finding' the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



['70']
70
['70']
parsed_discourse_facet ['aim_citation']
parsing: input/res/Task1/W99-0623.annv3.csv
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S><S sid="86" ssid="15">Finally we show the combining techniques degrade very little when a poor parser is added to the set.</S><S sid="146" ssid="1">We would like to thank Eugene Charniak, Michael Collins, and Adwait Ratnaparkhi for enabling all of this research by providing us with their parsers and helpful comments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'85'", "'86'", "'146'"]
'1'
'85'
'86'
'146'
['1', '85', '86', '146']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="41" ssid="27">IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.</S><S sid="105" ssid="34">Similarly Figures 1 and 2 show how the isolated constituent precision varies by sentence length and the size of the span of the hypothesized constituent.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'41'", "'105'", "'120'"]
'39'
'41'
'105'
'120'
['39', '41', '105', '120']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="12">This technique has the advantage of requiring no training, but it has the disadvantage of treating all parsers equally even though they may have differing accuracies or may specialize in modeling different phenomena.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="93" ssid="22">Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.</S><S sid="94" ssid="23">This is the only important case, because otherwise the simple majority combining technique would pick the correct constituent.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'", "'93'", "'94'"]
'26'
'27'
'93'
'94'
['26', '27', '93', '94']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="40" ssid="26">Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'27'", "'39'", "'40'"]
'23'
'27'
'39'
'40'
['23', '27', '39', '40']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="32" ssid="18">In Equations 1 through 3 we develop the model for constructing our parse using na&#239;ve Bayes classification.</S><S sid="118" ssid="47">The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.</S><S sid="140" ssid="2">For each experiment we gave an nonparametric and a parametric technique for combining parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'32'", "'118'", "'140'"]
'27'
'32'
'118'
'140'
['27', '32', '118', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="92" ssid="21">While we cannot prove there are no such useful features on which one should condition trust, we can give some insight into why the features we explored offered no gain.</S><S sid="93" ssid="22">Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'92'", "'93'", "'120'"]
'39'
'92'
'93'
'120'
['39', '92', '93', '120']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S><S sid="40" ssid="26">Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.</S><S sid="41" ssid="27">IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'40'", "'41'", "'120'"]
'13'
'40'
'41'
'120'
['13', '40', '41', '120']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="9" ssid="5">Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).</S><S sid="12" ssid="8">The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).</S><S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="135" ssid="64">The average individual parser accuracy was reduced by more than 5% when we added this new parser, but the precision of the constituent voting technique was the only result that decreased significantly.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'12'", "'23'", "'135'"]
'9'
'12'
'23'
'135'
['9', '12', '23', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="21" ssid="7">One hybridization strategy is to let the parsers vote on constituents\ membership in the hypothesized set.</S><S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S><S sid="95" ssid="24">One side of the decision making process is when we choose to believe a constituent should be in the parse, even though only one parser suggests it.</S><S sid="96" ssid="25">We call such a constituent an isolated constituent.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'51'", "'95'", "'96'"]
'21'
'51'
'95'
'96'
['21', '51', '95', '96']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S><S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'13'", "'85'", "'120'"]
'1'
'13'
'85'
'120'
['1', '13', '85', '120']
parsed_discourse_facet ['hypothesis_citation']
<S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S><S sid="88" ssid="17">For example, one parser could be more accurate at predicting noun phrases than the other parsers.</S><S sid="89" ssid="18">None of the models we have presented utilize features associated with a particular constituent (i.e. the label, span, parent label, etc.) to influence parser preference.</S><S sid="108" ssid="37">From this we see that a finer-grained model for parser combination, at least for the features we have examined, will not give us any additional power.</S>
original cit marker offset is 0
new cit marker offset is 0



["'87'", "'88'", "'89'", "'108'"]
'87'
'88'
'89'
'108'
['87', '88', '89', '108']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="21" ssid="7">One hybridization strategy is to let the parsers vote on constituents\ membership in the hypothesized set.</S><S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S><S sid="55" ssid="41">We have developed a general approach for combining parsers when preserving the entire structure of a parse tree is important.</S><S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'51'", "'55'", "'87'"]
'21'
'51'
'55'
'87'
['21', '51', '55', '87']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S><S sid="78" ssid="7">The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'77'", "'78'", "'98'"]
'1'
'77'
'78'
'98'
['1', '77', '78', '98']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="6">Since our goal is to perform well under these measures we will similarly treat constituents as the minimal substructures for combination.</S><S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="145" ssid="7">We plan to explore more powerful techniques for exploiting the diversity of parsing methods.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'23'", "'27'", "'145'"]
'20'
'23'
'27'
'145'
['20', '23', '27', '145']
parsed_discourse_facet ['method_citation']
<S sid="70" ssid="56">In this case we are interested in finding\ the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S><S sid="99" ssid="28">Consider for a set of constituents the isolated constituent precision parser metric, the portion of isolated constituents that are correctly hypothesized.</S><S sid="118" ssid="47">The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["'70'", "'98'", "'99'", "'118'"]
'70'
'98'
'99'
'118'
['70', '98', '99', '118']
parsed_discourse_facet ['method_citation']
<S sid="6" ssid="2">The machine learning community has been in a similar situation and has studied the combination of multiple classifiers (Wolpert, 1992; Heath et al., 1996).</S><S sid="9" ssid="5">Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).</S><S sid="12" ssid="8">The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).</S><S sid="54" ssid="40">If the parse contains productions from outside our grammar the machine has no direct method for handling them (e.g. the resulting database query may be syntactically malformed).</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'9'", "'12'", "'54'"]
'6'
'9'
'12'
'54'
['6', '9', '12', '54']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S><S sid="78" ssid="7">The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'77'", "'78'", "'98'"]
'1'
'77'
'78'
'98'
['1', '77', '78', '98']
parsed_discourse_facet ['method_citation', 'aim_citation']



W99-0623
A00-2005
0
result_citation
['method_citation']



W99-0623
W05-1518
0
result_citation
['results_citation', 'method_citation']



W99-0623
N09-2064
0
aim_citation
['method_citation']
parsing: input/ref/Task1/W99-0623_sweta.csv
 <S sid="144" ssid="6">Combining multiple highly-accurate independent parsers yields promising results.</S>
original cit marker offset is 0
new cit marker offset is 0



["144'"]
144'
['144']
parsed_discourse_facet ['method_citation']
 <S sid="125" ssid="54">The constituent voting and na&#239;ve Bayes techniques are equivalent because the parameters learned in the training set did not sufficiently discriminate between the three parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["125'"]
125'
['125']
parsed_discourse_facet ['method_citation']
<S sid="125" ssid="54">The constituent voting and na&#239;ve Bayes techniques are equivalent because the parameters learned in the training set did not sufficiently discriminate between the three parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["125'"]
125'
['125']
parsed_discourse_facet ['method_citation']
    <S sid="48" ssid="34">&#8226; Similarly, when the na&#239;ve Bayes classifier is configured such that the constituents require estimated probabilities strictly larger than 0.5 to be accepted, there is not enough probability mass remaining on crossing brackets for them to be included in the hypothesis.</S>
original cit marker offset is 0
new cit marker offset is 0



["48'"]
48'
['48']
parsed_discourse_facet ['method_citation']
 <S sid="139" ssid="1">We have presented two general approaches to studying parser combination: parser switching and parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["139'"]
139'
['139']
parsed_discourse_facet ['method_citation']
<S sid="134" ssid="63">As seen by the drop in average individual parser performance baseline, the introduced parser does not perform very well.</S>
original cit marker offset is 0
new cit marker offset is 0



["134'"]
134'
['134']
parsed_discourse_facet ['method_citation']
 <S sid="38" ssid="24">Under certain conditions the constituent voting and na&#239;ve Bayes constituent combination techniques are guaranteed to produce sets of constituents with no crossing brackets.</S>
original cit marker offset is 0
new cit marker offset is 0



["38'"]
38'
['38']
parsed_discourse_facet ['method_citation']
    <S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["120'"]
120'
['120']
parsed_discourse_facet ['method_citation']
<S sid="139" ssid="1">We have presented two general approaches to studying parser combination: parser switching and parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["139'"]
139'
['139']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S>
original cit marker offset is 0
new cit marker offset is 0



["13'"]
13'
['13']
parsed_discourse_facet ['method_citation']
<S sid="108" ssid="37">From this we see that a finer-grained model for parser combination, at least for the features we have examined, will not give us any additional power.</S>
original cit marker offset is 0
new cit marker offset is 0



["108'"]
108'
['108']
parsed_discourse_facet ['method_citation']
<S sid="139" ssid="1">We have presented two general approaches to studying parser combination: parser switching and parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["139'"]
139'
['139']
parsed_discourse_facet ['method_citation']
<S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["98'"]
98'
['98']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S>
original cit marker offset is 0
new cit marker offset is 0



["27'"]
27'
['27']
parsed_discourse_facet ['method_citation']
<S sid="80" ssid="9">For our experiments we also report the mean of precision and recall, which we denote by (P + R)I2 and F-measure.</S>
    <S sid="81" ssid="10">F-measure is the harmonic mean of precision and recall, 2PR/(P + R).</S>
    <S sid="82" ssid="11">It is closer to the smaller value of precision and recall when there is a large skew in their values.</S>
original cit marker offset is 0
new cit marker offset is 0



["80'", "'81'", "'82'"]
80'
'81'
'82'
['80', '81', '82']
parsed_discourse_facet ['method_citation']
<S sid="49" ssid="35">In general, the lemma of the previous section does not ensure that all the productions in the combined parse are found in the grammars of the member parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["49'"]
49'
['49']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">Similar advances have been made in machine translation (Frederking and Nirenburg, 1994), speech recognition (Fiscus, 1997) and named entity recognition (Borthwick et al., 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["11'"]
11'
['11']
parsed_discourse_facet ['method_citation']
<S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["98'"]
98'
['98']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W99-0623.annv3.csv
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S><S sid="86" ssid="15">Finally we show the combining techniques degrade very little when a poor parser is added to the set.</S><S sid="146" ssid="1">We would like to thank Eugene Charniak, Michael Collins, and Adwait Ratnaparkhi for enabling all of this research by providing us with their parsers and helpful comments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'85'", "'86'", "'146'"]
'1'
'85'
'86'
'146'
['1', '85', '86', '146']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="41" ssid="27">IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.</S><S sid="105" ssid="34">Similarly Figures 1 and 2 show how the isolated constituent precision varies by sentence length and the size of the span of the hypothesized constituent.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'41'", "'105'", "'120'"]
'39'
'41'
'105'
'120'
['39', '41', '105', '120']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="12">This technique has the advantage of requiring no training, but it has the disadvantage of treating all parsers equally even though they may have differing accuracies or may specialize in modeling different phenomena.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="93" ssid="22">Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.</S><S sid="94" ssid="23">This is the only important case, because otherwise the simple majority combining technique would pick the correct constituent.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'", "'93'", "'94'"]
'26'
'27'
'93'
'94'
['26', '27', '93', '94']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="40" ssid="26">Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'27'", "'39'", "'40'"]
'23'
'27'
'39'
'40'
['23', '27', '39', '40']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="32" ssid="18">In Equations 1 through 3 we develop the model for constructing our parse using na&#239;ve Bayes classification.</S><S sid="118" ssid="47">The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.</S><S sid="140" ssid="2">For each experiment we gave an nonparametric and a parametric technique for combining parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'32'", "'118'", "'140'"]
'27'
'32'
'118'
'140'
['27', '32', '118', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="92" ssid="21">While we cannot prove there are no such useful features on which one should condition trust, we can give some insight into why the features we explored offered no gain.</S><S sid="93" ssid="22">Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'92'", "'93'", "'120'"]
'39'
'92'
'93'
'120'
['39', '92', '93', '120']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S><S sid="40" ssid="26">Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.</S><S sid="41" ssid="27">IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'40'", "'41'", "'120'"]
'13'
'40'
'41'
'120'
['13', '40', '41', '120']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="9" ssid="5">Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).</S><S sid="12" ssid="8">The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).</S><S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="135" ssid="64">The average individual parser accuracy was reduced by more than 5% when we added this new parser, but the precision of the constituent voting technique was the only result that decreased significantly.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'12'", "'23'", "'135'"]
'9'
'12'
'23'
'135'
['9', '12', '23', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="21" ssid="7">One hybridization strategy is to let the parsers vote on constituents\ membership in the hypothesized set.</S><S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S><S sid="95" ssid="24">One side of the decision making process is when we choose to believe a constituent should be in the parse, even though only one parser suggests it.</S><S sid="96" ssid="25">We call such a constituent an isolated constituent.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'51'", "'95'", "'96'"]
'21'
'51'
'95'
'96'
['21', '51', '95', '96']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S><S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'13'", "'85'", "'120'"]
'1'
'13'
'85'
'120'
['1', '13', '85', '120']
parsed_discourse_facet ['hypothesis_citation']
<S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S><S sid="88" ssid="17">For example, one parser could be more accurate at predicting noun phrases than the other parsers.</S><S sid="89" ssid="18">None of the models we have presented utilize features associated with a particular constituent (i.e. the label, span, parent label, etc.) to influence parser preference.</S><S sid="108" ssid="37">From this we see that a finer-grained model for parser combination, at least for the features we have examined, will not give us any additional power.</S>
original cit marker offset is 0
new cit marker offset is 0



["'87'", "'88'", "'89'", "'108'"]
'87'
'88'
'89'
'108'
['87', '88', '89', '108']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="21" ssid="7">One hybridization strategy is to let the parsers vote on constituents\ membership in the hypothesized set.</S><S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S><S sid="55" ssid="41">We have developed a general approach for combining parsers when preserving the entire structure of a parse tree is important.</S><S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'51'", "'55'", "'87'"]
'21'
'51'
'55'
'87'
['21', '51', '55', '87']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S><S sid="78" ssid="7">The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'77'", "'78'", "'98'"]
'1'
'77'
'78'
'98'
['1', '77', '78', '98']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="6">Since our goal is to perform well under these measures we will similarly treat constituents as the minimal substructures for combination.</S><S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="145" ssid="7">We plan to explore more powerful techniques for exploiting the diversity of parsing methods.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'23'", "'27'", "'145'"]
'20'
'23'
'27'
'145'
['20', '23', '27', '145']
parsed_discourse_facet ['method_citation']
<S sid="70" ssid="56">In this case we are interested in finding\ the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S><S sid="99" ssid="28">Consider for a set of constituents the isolated constituent precision parser metric, the portion of isolated constituents that are correctly hypothesized.</S><S sid="118" ssid="47">The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["'70'", "'98'", "'99'", "'118'"]
'70'
'98'
'99'
'118'
['70', '98', '99', '118']
parsed_discourse_facet ['method_citation']
<S sid="6" ssid="2">The machine learning community has been in a similar situation and has studied the combination of multiple classifiers (Wolpert, 1992; Heath et al., 1996).</S><S sid="9" ssid="5">Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).</S><S sid="12" ssid="8">The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).</S><S sid="54" ssid="40">If the parse contains productions from outside our grammar the machine has no direct method for handling them (e.g. the resulting database query may be syntactically malformed).</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'9'", "'12'", "'54'"]
'6'
'9'
'12'
'54'
['6', '9', '12', '54']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S><S sid="78" ssid="7">The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'77'", "'78'", "'98'"]
'1'
'77'
'78'
'98'
['1', '77', '78', '98']
parsed_discourse_facet ['method_citation', 'aim_citation']
IGNORE THIS: key error 1



W99-0623
D09-1161
0
method_citation
['results_citation', 'method_citation']



W99-0623
C10-1151
0
method_citation
['method_citation', 'aim_citation']
parsing: input/ref/Task1/W99-0623_vardha.csv
    <S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'85'"]
'85'
['85']
parsed_discourse_facet ['method_citation']
<S sid="117" ssid="46">Another way to interpret this is that less than 5% of the correct constituents are missing from the hypotheses generated by the union of the three parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'117'"]
'117'
['117']
parsed_discourse_facet ['method_citation']
<S sid="72" ssid="1">The three parsers were trained and tuned by their creators on various sections of the WSJ portion of the Penn Treebank, leaving only sections 22 and 23 completely untouched during the development of any of the parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'72'"]
'72'
['72']
parsed_discourse_facet ['method_citation']
    <S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'120'"]
'120'
['120']
parsed_discourse_facet ['method_citation']
  <S sid="139" ssid="1">We have presented two general approaches to studying parser combination: parser switching and parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["'139'"]
'139'
['139']
parsed_discourse_facet ['method_citation']
 <S sid="84" ssid="13">The first shows how constituent features and context do not help in deciding which parser to trust.</S>
original cit marker offset is 0
new cit marker offset is 0



["'84'"]
'84'
['84']
parsed_discourse_facet ['method_citation']
    <S sid="76" ssid="5">The standard measures for evaluating Penn Treebank parsing performance are precision and recall of the predicted constituents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'76'"]
'76'
['76']
parsed_discourse_facet ['method_citation']
 <S sid="38" ssid="24">Under certain conditions the constituent voting and na&#239;ve Bayes constituent combination techniques are guaranteed to produce sets of constituents with no crossing brackets.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'"]
'38'
['38']
parsed_discourse_facet ['method_citation']
  <S sid="25" ssid="11">In our particular case the majority requires the agreement of only two parsers because we have only three.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'"]
'25'
['25']
parsed_discourse_facet ['method_citation']
 <S sid="72" ssid="1">The three parsers were trained and tuned by their creators on various sections of the WSJ portion of the Penn Treebank, leaving only sections 22 and 23 completely untouched during the development of any of the parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'72'"]
'72'
['72']
parsed_discourse_facet ['method_citation']
    <S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'87'"]
'87'
['87']
parsed_discourse_facet ['method_citation']
    <S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'"]
'51'
['51']
parsed_discourse_facet ['method_citation']
    <S sid="79" ssid="8">Precision is the portion of hypothesized constituents that are correct and recall is the portion of the Treebank constituents that are hypothesized.</S>
original cit marker offset is 0
new cit marker offset is 0



["'79'"]
'79'
['79']
parsed_discourse_facet ['method_citation']
  <S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'"]
'27'
['27']
parsed_discourse_facet ['method_citation']
 <S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S>
original cit marker offset is 0
new cit marker offset is 0



["'77'"]
'77'
['77']
parsed_discourse_facet ['method_citation']
  <S sid="11" ssid="7">Similar advances have been made in machine translation (Frederking and Nirenburg, 1994), speech recognition (Fiscus, 1997) and named entity recognition (Borthwick et al., 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'"]
'11'
['11']
parsed_discourse_facet ['method_citation']
  <S sid="116" ssid="45">The maximum precision row is the upper bound on accuracy if we could pick exactly the correct constituents from among the constituents suggested by the three parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'116'"]
'116'
['116']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W99-0623.annv3.csv
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S><S sid="86" ssid="15">Finally we show the combining techniques degrade very little when a poor parser is added to the set.</S><S sid="146" ssid="1">We would like to thank Eugene Charniak, Michael Collins, and Adwait Ratnaparkhi for enabling all of this research by providing us with their parsers and helpful comments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'85'", "'86'", "'146'"]
'1'
'85'
'86'
'146'
['1', '85', '86', '146']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="41" ssid="27">IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.</S><S sid="105" ssid="34">Similarly Figures 1 and 2 show how the isolated constituent precision varies by sentence length and the size of the span of the hypothesized constituent.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'41'", "'105'", "'120'"]
'39'
'41'
'105'
'120'
['39', '41', '105', '120']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="12">This technique has the advantage of requiring no training, but it has the disadvantage of treating all parsers equally even though they may have differing accuracies or may specialize in modeling different phenomena.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="93" ssid="22">Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.</S><S sid="94" ssid="23">This is the only important case, because otherwise the simple majority combining technique would pick the correct constituent.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'", "'93'", "'94'"]
'26'
'27'
'93'
'94'
['26', '27', '93', '94']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="40" ssid="26">Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'27'", "'39'", "'40'"]
'23'
'27'
'39'
'40'
['23', '27', '39', '40']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="32" ssid="18">In Equations 1 through 3 we develop the model for constructing our parse using na&#239;ve Bayes classification.</S><S sid="118" ssid="47">The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.</S><S sid="140" ssid="2">For each experiment we gave an nonparametric and a parametric technique for combining parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'32'", "'118'", "'140'"]
'27'
'32'
'118'
'140'
['27', '32', '118', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="92" ssid="21">While we cannot prove there are no such useful features on which one should condition trust, we can give some insight into why the features we explored offered no gain.</S><S sid="93" ssid="22">Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'92'", "'93'", "'120'"]
'39'
'92'
'93'
'120'
['39', '92', '93', '120']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S><S sid="40" ssid="26">Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.</S><S sid="41" ssid="27">IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'40'", "'41'", "'120'"]
'13'
'40'
'41'
'120'
['13', '40', '41', '120']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="9" ssid="5">Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).</S><S sid="12" ssid="8">The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).</S><S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="135" ssid="64">The average individual parser accuracy was reduced by more than 5% when we added this new parser, but the precision of the constituent voting technique was the only result that decreased significantly.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'12'", "'23'", "'135'"]
'9'
'12'
'23'
'135'
['9', '12', '23', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="21" ssid="7">One hybridization strategy is to let the parsers vote on constituents\ membership in the hypothesized set.</S><S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S><S sid="95" ssid="24">One side of the decision making process is when we choose to believe a constituent should be in the parse, even though only one parser suggests it.</S><S sid="96" ssid="25">We call such a constituent an isolated constituent.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'51'", "'95'", "'96'"]
'21'
'51'
'95'
'96'
['21', '51', '95', '96']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S><S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'13'", "'85'", "'120'"]
'1'
'13'
'85'
'120'
['1', '13', '85', '120']
parsed_discourse_facet ['hypothesis_citation']
<S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S><S sid="88" ssid="17">For example, one parser could be more accurate at predicting noun phrases than the other parsers.</S><S sid="89" ssid="18">None of the models we have presented utilize features associated with a particular constituent (i.e. the label, span, parent label, etc.) to influence parser preference.</S><S sid="108" ssid="37">From this we see that a finer-grained model for parser combination, at least for the features we have examined, will not give us any additional power.</S>
original cit marker offset is 0
new cit marker offset is 0



["'87'", "'88'", "'89'", "'108'"]
'87'
'88'
'89'
'108'
['87', '88', '89', '108']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="21" ssid="7">One hybridization strategy is to let the parsers vote on constituents\ membership in the hypothesized set.</S><S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S><S sid="55" ssid="41">We have developed a general approach for combining parsers when preserving the entire structure of a parse tree is important.</S><S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'51'", "'55'", "'87'"]
'21'
'51'
'55'
'87'
['21', '51', '55', '87']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S><S sid="78" ssid="7">The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'77'", "'78'", "'98'"]
'1'
'77'
'78'
'98'
['1', '77', '78', '98']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="6">Since our goal is to perform well under these measures we will similarly treat constituents as the minimal substructures for combination.</S><S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="145" ssid="7">We plan to explore more powerful techniques for exploiting the diversity of parsing methods.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'23'", "'27'", "'145'"]
'20'
'23'
'27'
'145'
['20', '23', '27', '145']
parsed_discourse_facet ['method_citation']
<S sid="70" ssid="56">In this case we are interested in finding\ the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S><S sid="99" ssid="28">Consider for a set of constituents the isolated constituent precision parser metric, the portion of isolated constituents that are correctly hypothesized.</S><S sid="118" ssid="47">The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["'70'", "'98'", "'99'", "'118'"]
'70'
'98'
'99'
'118'
['70', '98', '99', '118']
parsed_discourse_facet ['method_citation']
<S sid="6" ssid="2">The machine learning community has been in a similar situation and has studied the combination of multiple classifiers (Wolpert, 1992; Heath et al., 1996).</S><S sid="9" ssid="5">Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).</S><S sid="12" ssid="8">The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).</S><S sid="54" ssid="40">If the parse contains productions from outside our grammar the machine has no direct method for handling them (e.g. the resulting database query may be syntactically malformed).</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'9'", "'12'", "'54'"]
'6'
'9'
'12'
'54'
['6', '9', '12', '54']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S><S sid="78" ssid="7">The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'77'", "'78'", "'98'"]
'1'
'77'
'78'
'98'
['1', '77', '78', '98']
parsed_discourse_facet ['method_citation', 'aim_citation']
IGNORE THIS: key error 1
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2
IGNORE THIS: key error 2



W99-0623
D09-1161
0
method_citation
['results_citation', 'method_citation']



W99-0623
N06-2033
0
method_citation
['method_citation']
IGNORE THIS: Key error 5
IGNORE THIS: Key error 5





input/ref/Task1/A00-2018_akanksha.csv
input/res/Task1/A00-2018.annv3.csv
parsing: input/ref/Task1/A00-2018_akanksha.csv
<S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S>
    <S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'", "'91'"]
'90'
'91'
['90', '91']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees [16] that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established [5,9,10,15,17] &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'"]
'5'
['5']
parsed_discourse_facet ['method_citation']
<S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'"]
'90'
['90']
parsed_discourse_facet ['method_citation']
<S sid="48" ssid="17">Maximum-entropy models have two benefits for a parser builder.</S>
    <S sid="49" ssid="18">First, as already implicit in our discussion, factoring the probability computation into a sequence of values corresponding to various &amp;quot;features&amp;quot; suggests that the probability model should be easily changeable &#8212; just change the set of features used.</S>
    <S sid="51" ssid="20">Second, and this is a point we have not yet mentioned, the features used in these models need have no particular independence of one another.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'51'"]
'48'
'49'
'51'
['48', '49', '51']
parsed_discourse_facet ['method_citation']
<S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S>
    <S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
    <S sid="92" ssid="3">For runs with the generative model based upon Markov grammar statistics, the first pass uses the same statistics, but conditioned only on standard PCFG information.</S>
    <S sid="93" ssid="4">This allows the second pass to see expansions not present in the training corpus.</S>
    <S sid="94" ssid="5">We use the gathered statistics for all observed words, even those with very low counts, though obviously our deleted interpolation smoothing gives less emphasis to observed probabilities for rare words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'", "'91'", "'92'", "'93'", "'94'"]
'90'
'91'
'92'
'93'
'94'
['90', '91', '92', '93', '94']
parsed_discourse_facet ['method_citation']
NA
original cit marker offset is 0
new cit marker offset is 0



['0']
0
['0']
Error in Reference Offset
<S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'"]
'90'
['90']
parsed_discourse_facet ['method_citation']
<S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S>
    <S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
    <S sid="92" ssid="3">For runs with the generative model based upon Markov grammar statistics, the first pass uses the same statistics, but conditioned only on standard PCFG information.</S>
    <S sid="93" ssid="4">This allows the second pass to see expansions not present in the training corpus.</S>
    <S sid="94" ssid="5">We use the gathered statistics for all observed words, even those with very low counts, though obviously our deleted interpolation smoothing gives less emphasis to observed probabilities for rare words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'", "'91'", "'92'", "'93'", "'94'"]
'90'
'91'
'92'
'93'
'94'
['90', '91', '92', '93', '94']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="7">To compute a probability in a log-linear model one first defines a set of &amp;quot;features&amp;quot;, functions from the space of configurations over which one is trying to compute probabilities to integers that denote the number of times some pattern occurs in the input.</S>
    <S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S>
    <S sid="40" ssid="9">In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'40'"]
'38'
'39'
'40'
['38', '39', '40']
parsed_discourse_facet ['method_citation']
<S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'174'"]
'174'
['174']
parsed_discourse_facet ['result_citation']
<S sid="85" ssid="54">As partition-function calculation is typically the major on-line computational problem for maximum-entropy models, this simplifies the model significantly.</S>
original cit marker offset is 0
new cit marker offset is 0



["'85'"]
'85'
['85']
parsed_discourse_facet ['method_citation']
<S sid="63" ssid="32">As we discuss in more detail in Section 5, several different features in the context surrounding c are useful to include in H: the label, head pre-terminal and head of the parent of c (denoted as lp, tp, hp), the label of c's left sibling (lb for &amp;quot;before&amp;quot;), and the label of the grandparent of c (la).</S><S sid="143" ssid="34">The first is simply that if we first guess the pre-terminal, when we go to guess the head the first thing we can condition upon is the pre-terminal, i.e., we compute p(h I t).</S><S sid="146" ssid="37">The second major reason why first guessing the pre-terminal makes so much difference is that it can be used when backing off the lexical head in computing the probability of the rule expansion.</S>
original cit marker offset is 0
new cit marker offset is 0



["'63'", "'143'", "'146'"]
'63'
'143'
'146'
['63', '143', '146']
parsed_discourse_facet ['method_citation']
???<S sid="78" ssid="47">With some prior knowledge, non-zero values can greatly speed up this process because fewer iterations are required for convergence.</S>                                        <S sid="79" ssid="48">We comment on this because in our example we can substantially speed up the process by choosing values picked so that, when the maximum-entropy equation is expressed in the form of Equation 4, the gi have as their initial values the values of the corresponding terms in Equation 7.</S>
original cit marker offset is 0
new cit marker offset is 0



["'78'", "'79'"]
'78'
'79'
['78', '79']
parsed_discourse_facet ['method_citation']
<S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'"]
'90'
['90']
parsed_discourse_facet ['method_citation']
<S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'174'"]
'174'
['174']
parsed_discourse_facet ['result_citation']
parsing: input/res/Task1/A00-2018.annv3.csv
<S sid="116" ssid="7">This is as opposed to the &amp;quot;Markovgrammar&amp;quot; approach used in the current parser.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S><S sid="118" ssid="9">First, it uses a clustering scheme on words to give the system a &amp;quot;soft&amp;quot; clustering of heads and sub-heads.</S><S sid="119" ssid="10">(It is &amp;quot;soft&amp;quot; clustering in that a word can belong to more than one cluster with different weights - the weights express the probability of producing the word given that one is going to produce a word from that cluster.)</S>
original cit marker offset is 0
new cit marker offset is 0



["'116'", "'117'", "'118'", "'119'"]
'116'
'117'
'118'
'119'
['116', '117', '118', '119']
parsed_discourse_facet ['implication_citation', 'results_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S><S sid="129" ssid="20">It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.</S><S sid="178" ssid="5">The results of 13 achieved by combining the aforementioned three-best parsers also suggest that the limit on tree-bank trained parsers is much higher than previously thought.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'117'", "'129'", "'178'"]
'91'
'117'
'129'
'178'
['91', '117', '129', '178']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'91'", "'175'"]
'1'
'5'
'91'
'175'
['1', '5', '91', '175']
parsed_discourse_facet ['hypothesis_citation']
<S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S><S sid="40" ssid="9">In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.</S><S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S><S sid="129" ssid="20">It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'40'", "'120'", "'129'"]
'39'
'40'
'120'
'129'
['39', '40', '120', '129']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S><S sid="176" ssid="3">That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'120'", "'176'"]
'1'
'5'
'120'
'176'
['1', '5', '120', '176']
parsed_discourse_facet ['hypothesis_citation', 'results_citation']
<S sid="0">A Maximum-Entropy-Inspired Parser *</S><S sid="122" ssid="13">In this section we evaluate the effects of the various changes we have made by running various versions of our current program.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S><S sid="176" ssid="3">That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'122'", "'175'", "'176'"]
'0'
'122'
'175'
'176'
['0', '122', '175', '176']
parsed_discourse_facet ['aim_citation']
<S sid="6" ssid="2">This represents a 13% decrease in error rate over the best single-parser results on this corpus 9.</S><S sid="10" ssid="6">That is, the parser implements the function arg maxrp(7r s) = arg maxirp(7r, s) = arg maxrp(w).</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'10'", "'91'", "'174'"]
'6'
'10'
'91'
'174'
['6', '10', '91', '174']
parsed_discourse_facet ['hypothesis_citation']
<S sid="89" ssid="58">(Actually, we use a minor variant described in 4.)</S><S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'", "'90'", "'91'", "'117'"]
'89'
'90'
'91'
'117'
['89', '90', '91', '117']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="101" ssid="12">In keeping with the standard methodology 5, 9,10,15,17, we used the Penn Wall Street Journal tree-bank 16 with sections 2-21 for training, section 23 for testing, and section 24 for development (debugging and tuning).</S><S sid="102" ssid="13">Performance on the test corpus is measured using the standard measures from 5,9,10,17.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'101'", "'102'"]
'1'
'5'
'101'
'102'
['1', '5', '101', '102']
parsed_discourse_facet ['results_citation', 'implication_citation']
<S sid="102" ssid="13">Performance on the test corpus is measured using the standard measures from 5,9,10,17.</S><S sid="107" ssid="18">The results for the new parser as well as for the previous top-three individual parsers on this corpus are given in Figure 1.</S><S sid="108" ssid="19">As is typical, all of the standard measures tell pretty much the same story, with the new parser outperforming the other three parsers.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'102'", "'107'", "'108'", "'174'"]
'102'
'107'
'108'
'174'
['102', '107', '108', '174']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="18" ssid="7">The method that gives the best results, however, uses a Markov grammar &#8212; a method for assigning probabilities to any possible expansion using statistics gathered from the training corpus 6,10,15.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'18'", "'117'"]
'1'
'5'
'18'
'117'
['1', '5', '18', '117']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">A Maximum-Entropy-Inspired Parser *</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="12" ssid="1">The model assigns a probability to a parse by a top-down process of considering each constituent c in Ir and for each c first guessing the pre-terminal of c, t(c) (t for &amp;quot;tag&amp;quot;), then the lexical head of c, h(c), and then the expansion of c into further constituents e(c).</S><S sid="141" ssid="32">(For example, part-ofspeech tagging using the most probable preterminal for each word is 90% accurate 8.)</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'5'", "'12'", "'141'"]
'0'
'5'
'12'
'141'
['0', '5', '12', '141']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="97" ssid="8">The other four equations can be found in a longer version of this paper available on the author\s website (www.cs.brown.eduhiec).</S><S sid="143" ssid="34">The first is simply that if we first guess the pre-terminal, when we go to guess the head the first thing we can condition upon is the pre-terminal, i.e., we compute p(h I t).</S><S sid="173" ssid="64">However, a second-order grammar does slightly better and a third-order grammar does significantly better than the tree-bank parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'97'", "'143'", "'173'"]
'91'
'97'
'143'
'173'
['91', '97', '143', '173']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'91'", "'174'", "'175'"]
'1'
'91'
'174'
'175'
['1', '91', '174', '175']
parsed_discourse_facet ['hypothesis_citation']
<S sid="27" ssid="16">In the simplest of such models, a zeroorder Markov grammar, each label on the righthand side is generated conditioned only on / &#8212; that is, according to the distributions p(Li j1), p(M I 1), and p(Ri I 1).</S><S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S><S sid="49" ssid="18">First, as already implicit in our discussion, factoring the probability computation into a sequence of values corresponding to various &amp;quot;features&amp;quot; suggests that the probability model should be easily changeable &#8212; just change the set of features used.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'39'", "'49'", "'91'"]
'27'
'39'
'49'
'91'
['27', '39', '49', '91']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="1">The major problem confronting the author of a generative parser is what information to use to condition the probabilities required in the model, and how to smooth the empirically obtained probabilities to take the sting out of the sparse data problems that are inevitable with even the most modest conditioning.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S><S sid="180" ssid="7">From our perspective, perhaps the two most important numbers to come out of this research are the overall error reduction of 13% over the results in 9 and the intermediateresult improvement of nearly 2% on labeled precision/recall due to the simple idea of guessing the head\s pre-terminal before guessing the head.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'174'", "'175'", "'180'"]
'32'
'174'
'175'
'180'
['32', '174', '175', '180']
parsed_discourse_facet ['method_citation']
dict_values(['We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.'])
dict_values(['This is as opposed to the &quot;Markovgrammar&quot; approach used in the current parser.', 'Also, the earlier parser uses two techniques not employed in the current parser.', 'First, it uses a clustering scheme on words to give the system a &quot;soft&quot; clustering of heads and sub-heads.', '(It is &quot;soft&quot; clustering in that a word can belong to more than one cluster with different weights - the weights express the probability of producing the word given that one is going to produce a word from that cluster.)'])
['system', 'ROUGE-S*', 'Average_R:', '0.00732', '(95%-conf.int.', '0.00732', '-', '0.00732)']
['system', 'ROUGE-S*', 'Average_P:', '0.01070', '(95%-conf.int.', '0.01070', '-', '0.01070)']
['system', 'ROUGE-S*', 'Average_F:', '0.00869', '(95%-conf.int.', '0.00869', '-', '0.00869)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:561', 'F:6']
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees [16] that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established [5,9,10,15,17] &quot;standard&quot; sections of the Wall Street Journal tree-bank.'])
dict_values(['As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'Also, the earlier parser uses two techniques not employed in the current parser.', 'It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.', 'The results of 13 achieved by combining the aforementioned three-best parsers also suggest that the limit on tree-bank trained parsers is much higher than previously thought.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01885', '(95%-conf.int.', '0.01885', '-', '0.01885)']
['system', 'ROUGE-S*', 'Average_P:', '0.04017', '(95%-conf.int.', '0.04017', '-', '0.04017)']
['system', 'ROUGE-S*', 'Average_F:', '0.02566', '(95%-conf.int.', '0.02566', '-', '0.02566)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:946', 'F:38']
dict_values(['We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.'])
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal treebank.', 'We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal tree-bank.', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00076', '(95%-conf.int.', '0.00076', '-', '0.00076)']
['system', 'ROUGE-S*', 'Average_P:', '0.07576', '(95%-conf.int.', '0.07576', '-', '0.07576)']
['system', 'ROUGE-S*', 'Average_F:', '0.00151', '(95%-conf.int.', '0.00151', '-', '0.00151)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:6555', 'P:66', 'F:5']
dict_values(['Maximum-entropy models have two benefits for a parser builder.', 'First, as already implicit in our discussion, factoring the probability computation into a sequence of values corresponding to various &quot;features&quot; suggests that the probability model should be easily changeable &#8212; just change the set of features used.', 'Second, and this is a point we have not yet mentioned, the features used in these models need have no particular independence of one another.'])
dict_values(['In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.', 'In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.', 'Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &quot;correct&quot;, and statistics were collected on the resulting parses.', 'It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00984', '(95%-conf.int.', '0.00984', '-', '0.00984)']
['system', 'ROUGE-S*', 'Average_P:', '0.03871', '(95%-conf.int.', '0.03871', '-', '0.03871)']
['system', 'ROUGE-S*', 'Average_F:', '0.01569', '(95%-conf.int.', '0.01569', '-', '0.01569)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:465', 'F:18']
dict_values(['We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'For runs with the generative model based upon Markov grammar statistics, the first pass uses the same statistics, but conditioned only on standard PCFG information.', 'This allows the second pass to see expansions not present in the training corpus.', 'We use the gathered statistics for all observed words, even those with very low counts, though obviously our deleted interpolation smoothing gives less emphasis to observed probabilities for rare words.'])
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal treebank.', 'We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal tree-bank.', 'Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &quot;correct&quot;, and statistics were collected on the resulting parses.', 'That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00938', '(95%-conf.int.', '0.00938', '-', '0.00938)']
['system', 'ROUGE-S*', 'Average_P:', '0.03030', '(95%-conf.int.', '0.03030', '-', '0.03030)']
['system', 'ROUGE-S*', 'Average_F:', '0.01433', '(95%-conf.int.', '0.01433', '-', '0.01433)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:7140', 'P:2211', 'F:67']
no Reference Text in gold A00-2018
dict_values(['We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.'])
dict_values(['This represents a 13% decrease in error rate over the best single-parser results on this corpus 9.', 'That is, the parser implements the function arg maxrp(7r s) = arg maxirp(7r, s) = arg maxrp(w).', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00196', '(95%-conf.int.', '0.00196', '-', '0.00196)']
['system', 'ROUGE-S*', 'Average_P:', '0.07576', '(95%-conf.int.', '0.07576', '-', '0.07576)']
['system', 'ROUGE-S*', 'Average_F:', '0.00381', '(95%-conf.int.', '0.00381', '-', '0.00381)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2556', 'P:66', 'F:5']
dict_values(['To compute a probability in a log-linear model one first defines a set of &quot;features&quot;, functions from the space of configurations over which one is trying to compute probabilities to integers that denote the number of times some pattern occurs in the input.', 'In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.', 'In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.'])
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal treebank.', 'We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal tree-bank.', 'In keeping with the standard methodology 5, 9,10,15,17, we used the Penn Wall Street Journal tree-bank 16 with sections 2-21 for training, section 23 for testing, and section 24 for development (debugging and tuning).', 'Performance on the test corpus is measured using the standard measures from 5,9,10,17.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00088', '(95%-conf.int.', '0.00088', '-', '0.00088)']
['system', 'ROUGE-S*', 'Average_P:', '0.00634', '(95%-conf.int.', '0.00634', '-', '0.00634)']
['system', 'ROUGE-S*', 'Average_F:', '0.00155', '(95%-conf.int.', '0.00155', '-', '0.00155)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:6786', 'P:946', 'F:6']
dict_values(['As partition-function calculation is typically the major on-line computational problem for maximum-entropy models, this simplifies the model significantly.'])
dict_values(['A Maximum-Entropy-Inspired Parser *', 'We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal tree-bank.', 'The model assigns a probability to a parse by a top-down process of considering each constituent c in Ir and for each c first guessing the pre-terminal of c, t(c) (t for &quot;tag&quot;), then the lexical head of c, h(c), and then the expansion of c into further constituents e(c).', '(For example, part-ofspeech tagging using the most probable preterminal for each word is 90% accurate 8.)'])
['system', 'ROUGE-S*', 'Average_R:', '0.00105', '(95%-conf.int.', '0.00105', '-', '0.00105)']
['system', 'ROUGE-S*', 'Average_P:', '0.03297', '(95%-conf.int.', '0.03297', '-', '0.03297)']
['system', 'ROUGE-S*', 'Average_F:', '0.00204', '(95%-conf.int.', '0.00204', '-', '0.00204)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2850', 'P:91', 'F:3']
dict_values(['With some prior knowledge, non-zero values can greatly speed up this process because fewer iterations are required for convergence.', 'We comment on this because in our example we can substantially speed up the process by choosing values picked so that, when the maximum-entropy equation is expressed in the form of Equation 4, the gi have as their initial values the values of the corresponding terms in Equation 7.'])
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal treebank.', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.', 'This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4950', 'P:465', 'F:0']
dict_values(['We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.'])
dict_values(['In the simplest of such models, a zeroorder Markov grammar, each label on the righthand side is generated conditioned only on / &#8212; that is, according to the distributions p(Li j1), p(M I 1), and p(Ri I 1).', 'In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.', 'First, as already implicit in our discussion, factoring the probability computation into a sequence of values corresponding to various &quot;features&quot; suggests that the probability model should be easily changeable &#8212; just change the set of features used.', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00083', '(95%-conf.int.', '0.00083', '-', '0.00083)']
['system', 'ROUGE-S*', 'Average_P:', '0.03030', '(95%-conf.int.', '0.03030', '-', '0.03030)']
['system', 'ROUGE-S*', 'Average_F:', '0.00161', '(95%-conf.int.', '0.00161', '-', '0.00161)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:66', 'F:2']
dict_values(['We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.'])
dict_values(['The major problem confronting the author of a generative parser is what information to use to condition the probabilities required in the model, and how to smooth the empirically obtained probabilities to take the sting out of the sparse data problems that are inevitable with even the most modest conditioning.', 'We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.', 'This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.', 'From our perspective, perhaps the two most important numbers to come out of this research are the overall error reduction of 13% over the results in 9 and the intermediateresult improvement of nearly 2% on labeled precision/recall due to the simple idea of guessing the head\\s pre-terminal before guessing the head.'])
['system', 'ROUGE-S*', 'Average_R:', '0.10606', '(95%-conf.int.', '0.10606', '-', '0.10606)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.19178', '(95%-conf.int.', '0.19178', '-', '0.19178)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3828', 'P:406', 'F:406']
0.1219099988917273 0.014266363506669424 0.024242727052338844





input/ref/Task1/A00-2018_sweta.csv
input/res/Task1/A00-2018.annv3.csv
parsing: input/ref/Task1/A00-2018_sweta.csv
 <S sid="17" ssid="6">In Section 5 we present some results in which the possible expansions of a constituent are fixed in advanced by extracting a tree-bank grammar [3] from the training corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["17'"]
17'
['17']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees [16] that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established [5,9,10,15,17] &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S>
original cit marker offset is 0
new cit marker offset is 0



["5'"]
5'
['5']
parsed_discourse_facet ['method_citation']
 <S sid="17" ssid="6">In Section 5 we present some results in which the possible expansions of a constituent are fixed in advanced by extracting a tree-bank grammar [3] from the training corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["17'"]
17'
['17']
parsed_discourse_facet ['method_citation']
<S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S>
original cit marker offset is 0
new cit marker offset is 0



["120'"]
120'
['120']
parsed_discourse_facet ['method_citation']
<S sid="119" ssid="10">(It is &amp;quot;soft&amp;quot; clustering in that a word can belong to more than one cluster with different weights - the weights express the probability of producing the word given that one is going to produce a word from that cluster.)</S>
original cit marker offset is 0
new cit marker offset is 0



["119'"]
119'
['119']
parsed_discourse_facet ['method_citation']
<S sid="95" ssid="6">We guess the preterminals of words that are not observed in the training data using statistics on capitalization, hyphenation, word endings (the last two letters), and the probability that a given pre-terminal is realized using a previously unobserved word.</S>
original cit marker offset is 0
new cit marker offset is 0



["95'"]
95'
['95']
parsed_discourse_facet ['method_citation']
 <S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins [9].</S>
original cit marker offset is 0
new cit marker offset is 0



["175'"]
175'
['175']
parsed_discourse_facet ['method_citation']
<S sid="92" ssid="3">For runs with the generative model based upon Markov grammar statistics, the first pass uses the same statistics, but conditioned only on standard PCFG information.</S>
original cit marker offset is 0
new cit marker offset is 0



["92'"]
92'
['92']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established [5,9,10,15,17] &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S>
original cit marker offset is 0
new cit marker offset is 0



["1'"]
1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="17">This is indicated in Figure 2, where the model labeled &amp;quot;Best&amp;quot; has precision of 89.8% and recall of 89.6% for an average of 89.7%, 0.4% lower than the results on the official test corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["126'"]
126'
['126']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="1">The model assigns a probability to a parse by a top-down process of considering each constituent c in Ir and for each c first guessing the pre-terminal of c, t(c) (t for &amp;quot;tag&amp;quot;), then the lexical head of c, h(c), and then the expansion of c into further constituents e(c).</S>
original cit marker offset is 0
new cit marker offset is 0



["12'"]
12'
['12']
parsed_discourse_facet ['method_citation']
<S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["174'"]
174'
['174']
parsed_discourse_facet ['method_citation']
<S sid="63" ssid="32">As we discuss in more detail in Section 5, several different features in the context surrounding c are useful to include in H: the label, head pre-terminal and head of the parent of c (denoted as lp, tp, hp), the label of c's left sibling (lb for &amp;quot;before&amp;quot;), and the label of the grandparent of c (la).</S>
original cit marker offset is 0
new cit marker offset is 0



["63'"]
63'
['63']
parsed_discourse_facet ['method_citation']
<S sid="78" ssid="47">With some prior knowledge, non-zero values can greatly speed up this process because fewer iterations are required for convergence.</S>
original cit marker offset is 0
new cit marker offset is 0



["78'"]
78'
['78']
parsed_discourse_facet ['method_citation']
 <S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["91'"]
91'
['91']
parsed_discourse_facet ['method_citation']
<S sid="180" ssid="7">From our perspective, perhaps the two most important numbers to come out of this research are the overall error reduction of 13% over the results in [9] and the intermediateresult improvement of nearly 2% on labeled precision/recall due to the simple idea of guessing the head's pre-terminal before guessing the head.</S>
original cit marker offset is 0
new cit marker offset is 0



["180'"]
180'
['180']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A00-2018.annv3.csv
<S sid="116" ssid="7">This is as opposed to the &amp;quot;Markovgrammar&amp;quot; approach used in the current parser.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S><S sid="118" ssid="9">First, it uses a clustering scheme on words to give the system a &amp;quot;soft&amp;quot; clustering of heads and sub-heads.</S><S sid="119" ssid="10">(It is &amp;quot;soft&amp;quot; clustering in that a word can belong to more than one cluster with different weights - the weights express the probability of producing the word given that one is going to produce a word from that cluster.)</S>
original cit marker offset is 0
new cit marker offset is 0



["'116'", "'117'", "'118'", "'119'"]
'116'
'117'
'118'
'119'
['116', '117', '118', '119']
parsed_discourse_facet ['implication_citation', 'results_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S><S sid="129" ssid="20">It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.</S><S sid="178" ssid="5">The results of 13 achieved by combining the aforementioned three-best parsers also suggest that the limit on tree-bank trained parsers is much higher than previously thought.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'117'", "'129'", "'178'"]
'91'
'117'
'129'
'178'
['91', '117', '129', '178']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'91'", "'175'"]
'1'
'5'
'91'
'175'
['1', '5', '91', '175']
parsed_discourse_facet ['hypothesis_citation']
<S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S><S sid="40" ssid="9">In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.</S><S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S><S sid="129" ssid="20">It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'40'", "'120'", "'129'"]
'39'
'40'
'120'
'129'
['39', '40', '120', '129']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S><S sid="176" ssid="3">That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'120'", "'176'"]
'1'
'5'
'120'
'176'
['1', '5', '120', '176']
parsed_discourse_facet ['hypothesis_citation', 'results_citation']
<S sid="0">A Maximum-Entropy-Inspired Parser *</S><S sid="122" ssid="13">In this section we evaluate the effects of the various changes we have made by running various versions of our current program.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S><S sid="176" ssid="3">That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'122'", "'175'", "'176'"]
'0'
'122'
'175'
'176'
['0', '122', '175', '176']
parsed_discourse_facet ['aim_citation']
<S sid="6" ssid="2">This represents a 13% decrease in error rate over the best single-parser results on this corpus 9.</S><S sid="10" ssid="6">That is, the parser implements the function arg maxrp(7r s) = arg maxirp(7r, s) = arg maxrp(w).</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'10'", "'91'", "'174'"]
'6'
'10'
'91'
'174'
['6', '10', '91', '174']
parsed_discourse_facet ['hypothesis_citation']
<S sid="89" ssid="58">(Actually, we use a minor variant described in 4.)</S><S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'", "'90'", "'91'", "'117'"]
'89'
'90'
'91'
'117'
['89', '90', '91', '117']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="101" ssid="12">In keeping with the standard methodology 5, 9,10,15,17, we used the Penn Wall Street Journal tree-bank 16 with sections 2-21 for training, section 23 for testing, and section 24 for development (debugging and tuning).</S><S sid="102" ssid="13">Performance on the test corpus is measured using the standard measures from 5,9,10,17.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'101'", "'102'"]
'1'
'5'
'101'
'102'
['1', '5', '101', '102']
parsed_discourse_facet ['results_citation', 'implication_citation']
<S sid="102" ssid="13">Performance on the test corpus is measured using the standard measures from 5,9,10,17.</S><S sid="107" ssid="18">The results for the new parser as well as for the previous top-three individual parsers on this corpus are given in Figure 1.</S><S sid="108" ssid="19">As is typical, all of the standard measures tell pretty much the same story, with the new parser outperforming the other three parsers.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'102'", "'107'", "'108'", "'174'"]
'102'
'107'
'108'
'174'
['102', '107', '108', '174']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="18" ssid="7">The method that gives the best results, however, uses a Markov grammar &#8212; a method for assigning probabilities to any possible expansion using statistics gathered from the training corpus 6,10,15.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'18'", "'117'"]
'1'
'5'
'18'
'117'
['1', '5', '18', '117']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">A Maximum-Entropy-Inspired Parser *</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="12" ssid="1">The model assigns a probability to a parse by a top-down process of considering each constituent c in Ir and for each c first guessing the pre-terminal of c, t(c) (t for &amp;quot;tag&amp;quot;), then the lexical head of c, h(c), and then the expansion of c into further constituents e(c).</S><S sid="141" ssid="32">(For example, part-ofspeech tagging using the most probable preterminal for each word is 90% accurate 8.)</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'5'", "'12'", "'141'"]
'0'
'5'
'12'
'141'
['0', '5', '12', '141']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="97" ssid="8">The other four equations can be found in a longer version of this paper available on the author\s website (www.cs.brown.eduhiec).</S><S sid="143" ssid="34">The first is simply that if we first guess the pre-terminal, when we go to guess the head the first thing we can condition upon is the pre-terminal, i.e., we compute p(h I t).</S><S sid="173" ssid="64">However, a second-order grammar does slightly better and a third-order grammar does significantly better than the tree-bank parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'97'", "'143'", "'173'"]
'91'
'97'
'143'
'173'
['91', '97', '143', '173']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'91'", "'174'", "'175'"]
'1'
'91'
'174'
'175'
['1', '91', '174', '175']
parsed_discourse_facet ['hypothesis_citation']
<S sid="27" ssid="16">In the simplest of such models, a zeroorder Markov grammar, each label on the righthand side is generated conditioned only on / &#8212; that is, according to the distributions p(Li j1), p(M I 1), and p(Ri I 1).</S><S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S><S sid="49" ssid="18">First, as already implicit in our discussion, factoring the probability computation into a sequence of values corresponding to various &amp;quot;features&amp;quot; suggests that the probability model should be easily changeable &#8212; just change the set of features used.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'39'", "'49'", "'91'"]
'27'
'39'
'49'
'91'
['27', '39', '49', '91']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="1">The major problem confronting the author of a generative parser is what information to use to condition the probabilities required in the model, and how to smooth the empirically obtained probabilities to take the sting out of the sparse data problems that are inevitable with even the most modest conditioning.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S><S sid="180" ssid="7">From our perspective, perhaps the two most important numbers to come out of this research are the overall error reduction of 13% over the results in 9 and the intermediateresult improvement of nearly 2% on labeled precision/recall due to the simple idea of guessing the head\s pre-terminal before guessing the head.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'174'", "'175'", "'180'"]
'32'
'174'
'175'
'180'
['32', '174', '175', '180']
parsed_discourse_facet ['method_citation']
dict_values(['In Section 5 we present some results in which the possible expansions of a constituent are fixed in advanced by extracting a tree-bank grammar [3] from the training corpus.'])
dict_values(['This is as opposed to the &quot;Markovgrammar&quot; approach used in the current parser.', 'Also, the earlier parser uses two techniques not employed in the current parser.', 'First, it uses a clustering scheme on words to give the system a &quot;soft&quot; clustering of heads and sub-heads.', '(It is &quot;soft&quot; clustering in that a word can belong to more than one cluster with different weights - the weights express the probability of producing the word given that one is going to produce a word from that cluster.)'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:105', 'F:0']
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees [16] that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established [5,9,10,15,17] &quot;standard&quot; sections of the Wall Street Journal tree-bank.'])
dict_values(['As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'Also, the earlier parser uses two techniques not employed in the current parser.', 'It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.', 'The results of 13 achieved by combining the aforementioned three-best parsers also suggest that the limit on tree-bank trained parsers is much higher than previously thought.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01885', '(95%-conf.int.', '0.01885', '-', '0.01885)']
['system', 'ROUGE-S*', 'Average_P:', '0.04017', '(95%-conf.int.', '0.04017', '-', '0.04017)']
['system', 'ROUGE-S*', 'Average_F:', '0.02566', '(95%-conf.int.', '0.02566', '-', '0.02566)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:946', 'F:38']
dict_values(['In Section 5 we present some results in which the possible expansions of a constituent are fixed in advanced by extracting a tree-bank grammar [3] from the training corpus.'])
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal treebank.', 'We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal tree-bank.', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00275', '(95%-conf.int.', '0.00275', '-', '0.00275)']
['system', 'ROUGE-S*', 'Average_P:', '0.17143', '(95%-conf.int.', '0.17143', '-', '0.17143)']
['system', 'ROUGE-S*', 'Average_F:', '0.00541', '(95%-conf.int.', '0.00541', '-', '0.00541)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:6555', 'P:105', 'F:18']
dict_values(['Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &quot;correct&quot;, and statistics were collected on the resulting parses.'])
dict_values(['In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.', 'In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.', 'Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &quot;correct&quot;, and statistics were collected on the resulting parses.', 'It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.'])
['system', 'ROUGE-S*', 'Average_R:', '0.09344', '(95%-conf.int.', '0.09344', '-', '0.09344)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.17091', '(95%-conf.int.', '0.17091', '-', '0.17091)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:171', 'F:171']
dict_values(['(It is &quot;soft&quot; clustering in that a word can belong to more than one cluster with different weights - the weights express the probability of producing the word given that one is going to produce a word from that cluster.)'])
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal treebank.', 'We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal tree-bank.', 'Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &quot;correct&quot;, and statistics were collected on the resulting parses.', 'That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00070', '(95%-conf.int.', '0.00070', '-', '0.00070)']
['system', 'ROUGE-S*', 'Average_P:', '0.04167', '(95%-conf.int.', '0.04167', '-', '0.04167)']
['system', 'ROUGE-S*', 'Average_F:', '0.00138', '(95%-conf.int.', '0.00138', '-', '0.00138)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:7140', 'P:120', 'F:5']
dict_values(['We guess the preterminals of words that are not observed in the training data using statistics on capitalization, hyphenation, word endings (the last two letters), and the probability that a given pre-terminal is realized using a previously unobserved word.'])
dict_values(['A Maximum-Entropy-Inspired Parser *', 'In this section we evaluate the effects of the various changes we have made by running various versions of our current program.', 'This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.', 'That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:190', 'F:0']
dict_values(['This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins [9].'])
dict_values(['This represents a 13% decrease in error rate over the best single-parser results on this corpus 9.', 'That is, the parser implements the function arg maxrp(7r s) = arg maxirp(7r, s) = arg maxrp(w).', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00743', '(95%-conf.int.', '0.00743', '-', '0.00743)']
['system', 'ROUGE-S*', 'Average_P:', '0.24359', '(95%-conf.int.', '0.24359', '-', '0.24359)']
['system', 'ROUGE-S*', 'Average_F:', '0.01443', '(95%-conf.int.', '0.01443', '-', '0.01443)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2556', 'P:78', 'F:19']
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established [5,9,10,15,17] &quot;standard&quot; sections of the Wall Street Journal treebank.'])
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal treebank.', 'We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal tree-bank.', 'In keeping with the standard methodology 5, 9,10,15,17, we used the Penn Wall Street Journal tree-bank 16 with sections 2-21 for training, section 23 for testing, and section 24 for development (debugging and tuning).', 'Performance on the test corpus is measured using the standard measures from 5,9,10,17.'])
['system', 'ROUGE-S*', 'Average_R:', '0.09284', '(95%-conf.int.', '0.09284', '-', '0.09284)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.16990', '(95%-conf.int.', '0.16990', '-', '0.16990)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:6786', 'P:630', 'F:630']
dict_values(['We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.'])
dict_values(['A Maximum-Entropy-Inspired Parser *', 'We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal tree-bank.', 'The model assigns a probability to a parse by a top-down process of considering each constituent c in Ir and for each c first guessing the pre-terminal of c, t(c) (t for &quot;tag&quot;), then the lexical head of c, h(c), and then the expansion of c into further constituents e(c).', '(For example, part-ofspeech tagging using the most probable preterminal for each word is 90% accurate 8.)'])
['system', 'ROUGE-S*', 'Average_R:', '0.05965', '(95%-conf.int.', '0.05965', '-', '0.05965)']
['system', 'ROUGE-S*', 'Average_P:', '0.41872', '(95%-conf.int.', '0.41872', '-', '0.41872)']
['system', 'ROUGE-S*', 'Average_F:', '0.10442', '(95%-conf.int.', '0.10442', '-', '0.10442)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2850', 'P:406', 'F:170']
dict_values(['With some prior knowledge, non-zero values can greatly speed up this process because fewer iterations are required for convergence.'])
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal treebank.', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.', 'This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4950', 'P:45', 'F:0']
dict_values(['As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.'])
dict_values(['In the simplest of such models, a zeroorder Markov grammar, each label on the righthand side is generated conditioned only on / &#8212; that is, according to the distributions p(Li j1), p(M I 1), and p(Ri I 1).', 'In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.', 'First, as already implicit in our discussion, factoring the probability computation into a sequence of values corresponding to various &quot;features&quot; suggests that the probability model should be easily changeable &#8212; just change the set of features used.', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.'])
['system', 'ROUGE-S*', 'Average_R:', '0.09565', '(95%-conf.int.', '0.09565', '-', '0.09565)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.17460', '(95%-conf.int.', '0.17460', '-', '0.17460)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:231', 'F:231']
dict_values(["From our perspective, perhaps the two most important numbers to come out of this research are the overall error reduction of 13% over the results in [9] and the intermediateresult improvement of nearly 2% on labeled precision/recall due to the simple idea of guessing the head's pre-terminal before guessing the head."])
dict_values(['The major problem confronting the author of a generative parser is what information to use to condition the probabilities required in the model, and how to smooth the empirically obtained probabilities to take the sting out of the sparse data problems that are inevitable with even the most modest conditioning.', 'We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.', 'This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.', 'From our perspective, perhaps the two most important numbers to come out of this research are the overall error reduction of 13% over the results in 9 and the intermediateresult improvement of nearly 2% on labeled precision/recall due to the simple idea of guessing the head\\s pre-terminal before guessing the head.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07210', '(95%-conf.int.', '0.07210', '-', '0.07210)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.13450', '(95%-conf.int.', '0.13450', '-', '0.13450)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3828', 'P:276', 'F:276']
0.40963166325306954 0.03695083302540973 0.06676749944360418





input/ref/Task1/A00-2018_vardha.csv
input/res/Task1/A00-2018.annv3.csv
parsing: input/ref/Task1/A00-2018_vardha.csv
<S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees [16] that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established [5,9,10,15,17] &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'"]
'5'
['5']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees [16] that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established [5,9,10,15,17] &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'"]
'5'
['5']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'"]
'91'
['91']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'"]
'39'
['39']
parsed_discourse_facet ['method_citation']
<S sid="162" ssid="53">Given we are already at the 88% level of accuracy, we judge a 0.6% improvement to be very much worth while.</S>
original cit marker offset is 0
new cit marker offset is 0



["'162'"]
'162'
['162']
parsed_discourse_facet ['method_citation']
 <S sid="87" ssid="56">In a pure maximum-entropy model this is done by feature selection, as in Ratnaparkhi's maximum-entropy parser [17].</S>
original cit marker offset is 0
new cit marker offset is 0



["'87'"]
'87'
['87']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'"]
'91'
['91']
parsed_discourse_facet ['method_citation']
 <S sid="176" ssid="3">That the previous three best parsers on this test [5,9,17] all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'176'"]
'176'
['176']
parsed_discourse_facet ['method_citation']
<S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'174'"]
'174'
['174']
parsed_discourse_facet ['method_citation']
 <S sid="101" ssid="12">In keeping with the standard methodology [5, 9,10,15,17], we used the Penn Wall Street Journal tree-bank [16] with sections 2-21 for training, section 23 for testing, and section 24 for development (debugging and tuning).</S>
original cit marker offset is 0
new cit marker offset is 0



["'101'"]
'101'
['101']
parsed_discourse_facet ['method_citation']
<S sid="155" ssid="46">For example, in the Penn Treebank a vp with both main and auxiliary verbs has the structure shown in Figure 3.</S>
original cit marker offset is 0
new cit marker offset is 0



["'155'"]
'155'
['155']
parsed_discourse_facet ['method_citation']
  <S sid="17" ssid="6">In Section 5 we present some results in which the possible expansions of a constituent are fixed in advanced by extracting a tree-bank grammar [3] from the training corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'"]
'17'
['17']
parsed_discourse_facet ['method_citation']
<S sid="162" ssid="53">Given we are already at the 88% level of accuracy, we judge a 0.6% improvement to be very much worth while.</S>
original cit marker offset is 0
new cit marker offset is 0



["'162'"]
'162'
['162']
parsed_discourse_facet ['method_citation']
 <S sid="40" ssid="9">In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'"]
'40'
['40']
parsed_discourse_facet ['method_citation']
 <S sid="79" ssid="48">We comment on this because in our example we can substantially speed up the process by choosing values picked so that, when the maximum-entropy equation is expressed in the form of Equation 4, the gi have as their initial values the values of the corresponding terms in Equation 7.</S>
original cit marker offset is 0
new cit marker offset is 0



["'79'"]
'79'
['79']
parsed_discourse_facet ['method_citation']
    <S sid="40" ssid="9">In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'"]
'40'
['40']
parsed_discourse_facet ['method_citation']
    <S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins [9].</S>
original cit marker offset is 0
new cit marker offset is 0



["'175'"]
'175'
['175']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A00-2018.annv3.csv
<S sid="116" ssid="7">This is as opposed to the &amp;quot;Markovgrammar&amp;quot; approach used in the current parser.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S><S sid="118" ssid="9">First, it uses a clustering scheme on words to give the system a &amp;quot;soft&amp;quot; clustering of heads and sub-heads.</S><S sid="119" ssid="10">(It is &amp;quot;soft&amp;quot; clustering in that a word can belong to more than one cluster with different weights - the weights express the probability of producing the word given that one is going to produce a word from that cluster.)</S>
original cit marker offset is 0
new cit marker offset is 0



["'116'", "'117'", "'118'", "'119'"]
'116'
'117'
'118'
'119'
['116', '117', '118', '119']
parsed_discourse_facet ['implication_citation', 'results_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S><S sid="129" ssid="20">It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.</S><S sid="178" ssid="5">The results of 13 achieved by combining the aforementioned three-best parsers also suggest that the limit on tree-bank trained parsers is much higher than previously thought.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'117'", "'129'", "'178'"]
'91'
'117'
'129'
'178'
['91', '117', '129', '178']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'91'", "'175'"]
'1'
'5'
'91'
'175'
['1', '5', '91', '175']
parsed_discourse_facet ['hypothesis_citation']
<S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S><S sid="40" ssid="9">In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.</S><S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S><S sid="129" ssid="20">It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'40'", "'120'", "'129'"]
'39'
'40'
'120'
'129'
['39', '40', '120', '129']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="120" ssid="11">Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &amp;quot;correct&amp;quot;, and statistics were collected on the resulting parses.</S><S sid="176" ssid="3">That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'120'", "'176'"]
'1'
'5'
'120'
'176'
['1', '5', '120', '176']
parsed_discourse_facet ['hypothesis_citation', 'results_citation']
<S sid="0">A Maximum-Entropy-Inspired Parser *</S><S sid="122" ssid="13">In this section we evaluate the effects of the various changes we have made by running various versions of our current program.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S><S sid="176" ssid="3">That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'122'", "'175'", "'176'"]
'0'
'122'
'175'
'176'
['0', '122', '175', '176']
parsed_discourse_facet ['aim_citation']
<S sid="6" ssid="2">This represents a 13% decrease in error rate over the best single-parser results on this corpus 9.</S><S sid="10" ssid="6">That is, the parser implements the function arg maxrp(7r s) = arg maxirp(7r, s) = arg maxrp(w).</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'10'", "'91'", "'174'"]
'6'
'10'
'91'
'174'
['6', '10', '91', '174']
parsed_discourse_facet ['hypothesis_citation']
<S sid="89" ssid="58">(Actually, we use a minor variant described in 4.)</S><S sid="90" ssid="1">We created a parser based upon the maximumentropy-inspired model of the last section, smoothed using standard deleted interpolation.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'", "'90'", "'91'", "'117'"]
'89'
'90'
'91'
'117'
['89', '90', '91', '117']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="101" ssid="12">In keeping with the standard methodology 5, 9,10,15,17, we used the Penn Wall Street Journal tree-bank 16 with sections 2-21 for training, section 23 for testing, and section 24 for development (debugging and tuning).</S><S sid="102" ssid="13">Performance on the test corpus is measured using the standard measures from 5,9,10,17.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'101'", "'102'"]
'1'
'5'
'101'
'102'
['1', '5', '101', '102']
parsed_discourse_facet ['results_citation', 'implication_citation']
<S sid="102" ssid="13">Performance on the test corpus is measured using the standard measures from 5,9,10,17.</S><S sid="107" ssid="18">The results for the new parser as well as for the previous top-three individual parsers on this corpus are given in Figure 1.</S><S sid="108" ssid="19">As is typical, all of the standard measures tell pretty much the same story, with the new parser outperforming the other three parsers.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'102'", "'107'", "'108'", "'174'"]
'102'
'107'
'108'
'174'
['102', '107', '108', '174']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="18" ssid="7">The method that gives the best results, however, uses a Markov grammar &#8212; a method for assigning probabilities to any possible expansion using statistics gathered from the training corpus 6,10,15.</S><S sid="117" ssid="8">Also, the earlier parser uses two techniques not employed in the current parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'5'", "'18'", "'117'"]
'1'
'5'
'18'
'117'
['1', '5', '18', '117']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">A Maximum-Entropy-Inspired Parser *</S><S sid="5" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal tree-bank.</S><S sid="12" ssid="1">The model assigns a probability to a parse by a top-down process of considering each constituent c in Ir and for each c first guessing the pre-terminal of c, t(c) (t for &amp;quot;tag&amp;quot;), then the lexical head of c, h(c), and then the expansion of c into further constituents e(c).</S><S sid="141" ssid="32">(For example, part-ofspeech tagging using the most probable preterminal for each word is 90% accurate 8.)</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'5'", "'12'", "'141'"]
'0'
'5'
'12'
'141'
['0', '5', '12', '141']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="97" ssid="8">The other four equations can be found in a longer version of this paper available on the author\s website (www.cs.brown.eduhiec).</S><S sid="143" ssid="34">The first is simply that if we first guess the pre-terminal, when we go to guess the head the first thing we can condition upon is the pre-terminal, i.e., we compute p(h I t).</S><S sid="173" ssid="64">However, a second-order grammar does slightly better and a third-order grammar does significantly better than the tree-bank parser.</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'97'", "'143'", "'173'"]
'91'
'97'
'143'
'173'
['91', '97', '143', '173']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &amp;quot;standard&amp;quot; sections of the Wall Street Journal treebank.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'91'", "'174'", "'175'"]
'1'
'91'
'174'
'175'
['1', '91', '174', '175']
parsed_discourse_facet ['hypothesis_citation']
<S sid="27" ssid="16">In the simplest of such models, a zeroorder Markov grammar, each label on the righthand side is generated conditioned only on / &#8212; that is, according to the distributions p(Li j1), p(M I 1), and p(Ri I 1).</S><S sid="39" ssid="8">In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.</S><S sid="49" ssid="18">First, as already implicit in our discussion, factoring the probability computation into a sequence of values corresponding to various &amp;quot;features&amp;quot; suggests that the probability model should be easily changeable &#8212; just change the set of features used.</S><S sid="91" ssid="2">As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'39'", "'49'", "'91'"]
'27'
'39'
'49'
'91'
['27', '39', '49', '91']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="1">The major problem confronting the author of a generative parser is what information to use to condition the probabilities required in the model, and how to smooth the empirically obtained probabilities to take the sting out of the sparse data problems that are inevitable with even the most modest conditioning.</S><S sid="174" ssid="1">We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.</S><S sid="175" ssid="2">This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.</S><S sid="180" ssid="7">From our perspective, perhaps the two most important numbers to come out of this research are the overall error reduction of 13% over the results in 9 and the intermediateresult improvement of nearly 2% on labeled precision/recall due to the simple idea of guessing the head\s pre-terminal before guessing the head.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'174'", "'175'", "'180'"]
'32'
'174'
'175'
'180'
['32', '174', '175', '180']
parsed_discourse_facet ['method_citation']
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees [16] that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established [5,9,10,15,17] &quot;standard&quot; sections of the Wall Street Journal tree-bank.'])
dict_values(['This is as opposed to the &quot;Markovgrammar&quot; approach used in the current parser.', 'Also, the earlier parser uses two techniques not employed in the current parser.', 'First, it uses a clustering scheme on words to give the system a &quot;soft&quot; clustering of heads and sub-heads.', '(It is &quot;soft&quot; clustering in that a word can belong to more than one cluster with different weights - the weights express the probability of producing the word given that one is going to produce a word from that cluster.)'])
['system', 'ROUGE-S*', 'Average_R:', '0.00366', '(95%-conf.int.', '0.00366', '-', '0.00366)']
['system', 'ROUGE-S*', 'Average_P:', '0.00317', '(95%-conf.int.', '0.00317', '-', '0.00317)']
['system', 'ROUGE-S*', 'Average_F:', '0.00340', '(95%-conf.int.', '0.00340', '-', '0.00340)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:946', 'F:3']
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees [16] that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established [5,9,10,15,17] &quot;standard&quot; sections of the Wall Street Journal tree-bank.'])
dict_values(['As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'Also, the earlier parser uses two techniques not employed in the current parser.', 'It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.', 'The results of 13 achieved by combining the aforementioned three-best parsers also suggest that the limit on tree-bank trained parsers is much higher than previously thought.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01885', '(95%-conf.int.', '0.01885', '-', '0.01885)']
['system', 'ROUGE-S*', 'Average_P:', '0.04017', '(95%-conf.int.', '0.04017', '-', '0.04017)']
['system', 'ROUGE-S*', 'Average_F:', '0.02566', '(95%-conf.int.', '0.02566', '-', '0.02566)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:946', 'F:38']
dict_values(['As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser [2,7], we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.'])
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal treebank.', 'We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal tree-bank.', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03524', '(95%-conf.int.', '0.03524', '-', '0.03524)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.06808', '(95%-conf.int.', '0.06808', '-', '0.06808)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:6555', 'P:231', 'F:231']
dict_values(['In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.'])
dict_values(['In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.', 'In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.', 'Second, Char97 uses unsupervised learning in that the original system was run on about thirty million words of unparsed text, the output was taken as &quot;correct&quot;, and statistics were collected on the resulting parses.', 'It makes no use of special maximum-entropyinspired features (though their presence made it much easier to perform these experiments), it does not guess the pre-terminal before guessing the lexical head, and it uses a tree-bank grammar rather than a Markov grammar.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03005', '(95%-conf.int.', '0.03005', '-', '0.03005)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.05836', '(95%-conf.int.', '0.05836', '-', '0.05836)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:55', 'F:55']
dict_values(['Given we are already at the 88% level of accuracy, we judge a 0.6% improvement to be very much worth while.'])
dict_values(['A Maximum-Entropy-Inspired Parser *', 'In this section we evaluate the effects of the various changes we have made by running various versions of our current program.', 'This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.', 'That the previous three best parsers on this test 5,9,17 all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:28', 'F:0']
dict_values(["In a pure maximum-entropy model this is done by feature selection, as in Ratnaparkhi's maximum-entropy parser [17]."])
dict_values(['This represents a 13% decrease in error rate over the best single-parser results on this corpus 9.', 'That is, the parser implements the function arg maxrp(7r s) = arg maxirp(7r, s) = arg maxrp(w).', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00039', '(95%-conf.int.', '0.00039', '-', '0.00039)']
['system', 'ROUGE-S*', 'Average_P:', '0.01818', '(95%-conf.int.', '0.01818', '-', '0.01818)']
['system', 'ROUGE-S*', 'Average_F:', '0.00077', '(95%-conf.int.', '0.00077', '-', '0.00077)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2556', 'P:55', 'F:1']
dict_values(['That the previous three best parsers on this test [5,9,17] all perform within a percentage point of each other, despite quite different basic mechanisms, led some researchers to wonder if there might be some maximum level of parsing performance that could be obtained using the treebank for training, and to conjecture that perhaps we were at it.'])
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal treebank.', 'We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal tree-bank.', 'In keeping with the standard methodology 5, 9,10,15,17, we used the Penn Wall Street Journal tree-bank 16 with sections 2-21 for training, section 23 for testing, and section 24 for development (debugging and tuning).', 'Performance on the test corpus is measured using the standard measures from 5,9,10,17.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00575', '(95%-conf.int.', '0.00575', '-', '0.00575)']
['system', 'ROUGE-S*', 'Average_P:', '0.18571', '(95%-conf.int.', '0.18571', '-', '0.18571)']
['system', 'ROUGE-S*', 'Average_F:', '0.01115', '(95%-conf.int.', '0.01115', '-', '0.01115)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:6786', 'P:210', 'F:39']
dict_values(['Given we are already at the 88% level of accuracy, we judge a 0.6% improvement to be very much worth while.'])
dict_values(['A Maximum-Entropy-Inspired Parser *', 'We present a new parser for parsing down to Penn tree-bank style parse trees 16 that achieves 90.1% average precision/recall for sentences of length &lt; 40, and 89.5% for sentences of length &lt; 100, when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal tree-bank.', 'The model assigns a probability to a parse by a top-down process of considering each constituent c in Ir and for each c first guessing the pre-terminal of c, t(c) (t for &quot;tag&quot;), then the lexical head of c, h(c), and then the expansion of c into further constituents e(c).', '(For example, part-ofspeech tagging using the most probable preterminal for each word is 90% accurate 8.)'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2850', 'P:28', 'F:0']
dict_values(['We comment on this because in our example we can substantially speed up the process by choosing values picked so that, when the maximum-entropy equation is expressed in the form of Equation 4, the gi have as their initial values the values of the corresponding terms in Equation 7.'])
dict_values(['We present a new parser for parsing down to Penn tree-bank style parse trees that achieves 90.1% average precision/recall for sentences of 40 and less, and for of length 100 and less when trained and tested on the previously established 5,9,10,15,17 &quot;standard&quot; sections of the Wall Street Journal treebank.', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.', 'We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.', 'This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4950', 'P:210', 'F:0']
dict_values(['In the parser we further assume that features are chosen from certain feature schemata and that every feature is a boolean conjunction of sub-features.'])
dict_values(['In the simplest of such models, a zeroorder Markov grammar, each label on the righthand side is generated conditioned only on / &#8212; that is, according to the distributions p(Li j1), p(M I 1), and p(Ri I 1).', 'In our work we assume that any feature can occur at most once, so features are boolean-valued: 0 if the pattern does not occur, 1 if it does.', 'First, as already implicit in our discussion, factoring the probability computation into a sequence of values corresponding to various &quot;features&quot; suggests that the probability model should be easily changeable &#8212; just change the set of features used.', 'As the generative model is top-down and we use a standard bottom-up best-first probabilistic chart parser 2,7, we use the chart parser as a first pass to generate candidate possible parses to be evaluated in the second pass by our probabilistic model.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00580', '(95%-conf.int.', '0.00580', '-', '0.00580)']
['system', 'ROUGE-S*', 'Average_P:', '0.31111', '(95%-conf.int.', '0.31111', '-', '0.31111)']
['system', 'ROUGE-S*', 'Average_F:', '0.01138', '(95%-conf.int.', '0.01138', '-', '0.01138)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:45', 'F:14']
dict_values(['This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins [9].'])
dict_values(['The major problem confronting the author of a generative parser is what information to use to condition the probabilities required in the model, and how to smooth the empirically obtained probabilities to take the sting out of the sparse data problems that are inevitable with even the most modest conditioning.', 'We have presented a lexicalized Markov grammar parsing model that achieves (using the now standard training/testing/development sections of the Penn treebank) an average precision/recall of 91.1% on sentences of length &lt; 40 and 89.5% on sentences of length &lt; 100.', 'This corresponds to an error reduction of 13% over the best previously published single parser results on this test set, those of Collins 9.', 'From our perspective, perhaps the two most important numbers to come out of this research are the overall error reduction of 13% over the results in 9 and the intermediateresult improvement of nearly 2% on labeled precision/recall due to the simple idea of guessing the head\\s pre-terminal before guessing the head.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02038', '(95%-conf.int.', '0.02038', '-', '0.02038)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.03994', '(95%-conf.int.', '0.03994', '-', '0.03994)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3828', 'P:78', 'F:78']
0.3234854516046777 0.010919999900727274 0.019885454364677688





input/ref/Task1/A00-2030_aakansha.csv
input/res/Task1/A00-2030.annv3.csv
parsing: input/ref/Task1/A00-2030_aakansha.csv
<S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'"]
'4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="49" ssid="9">By necessity, we adopted the strategy of hand marking only the semantics.</S>
    <S sid="50" ssid="10">Figure 4 shows an example of the semantic annotation, which was the only type of manual annotation we performed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'49'", "'50'"]
'49'
'50'
['49', '50']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="6">For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'"]
'16'
['16']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="6">An integrated model can limit the propagation of errors by making all decisions jointly.</S>
    <S sid="24" ssid="7">For this reason, we focused on designing an integrated model in which tagging, namefinding, parsing, and semantic interpretation decisions all have the opportunity to mutually influence each other.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'24'"]
'23'
'24'
['23', '24']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="6">An integrated model can limit the propagation of errors by making all decisions jointly.</S>
    <S sid="24" ssid="7">For this reason, we focused on designing an integrated model in which tagging, namefinding, parsing, and semantic interpretation decisions all have the opportunity to mutually influence each other.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'24'"]
'23'
'24'
['23', '24']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="6">An integrated model can limit the propagation of errors by making all decisions jointly.</S>
    <S sid="24" ssid="7">For this reason, we focused on designing an integrated model in which tagging, namefinding, parsing, and semantic interpretation decisions all have the opportunity to mutually influence each other.</S><S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'24'", "'33'", "'34'"]
'23'
'24'
'33'
'34'
['23', '24', '33', '34']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
    <S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["'60'", "'61'"]
'60'
'61'
['60', '61']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'"]
'33'
['33']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
    <S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'"]
'33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S>
    <S sid="12" ssid="2">The Template Element (TE) task identifies organizations, persons, locations, and some artifacts (rocket and airplane-related artifacts).</S><S sid="16" ssid="6">For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'16'"]
'11'
'12'
'16'
['11', '12', '16']
parsed_discourse_facet ['method_citation']
<S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'105'"]
'105'
['105']
parsed_discourse_facet ['result_citation']
<S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
    <S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["'60'", "'61'"]
'60'
'61'
['60', '61']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="6">For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'"]
'16'
['16']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A00-2030.annv3.csv
<S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="40" ssid="8">Further details are discussed in the section Tree Augmentation.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="65" ssid="6">We illustrate the generation process by walking through a few of the steps of the parse shown in Figure 3.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'40'", "'52'", "'65'"]
'11'
'40'
'52'
'65'
['11', '40', '52', '65']
parsed_discourse_facet ['aim_citation']
<S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S><S sid="23" ssid="6">An integrated model can limit the propagation of errors by making all decisions jointly.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="62" ssid="3">For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'23'", "'61'", "'62'"]
'18'
'23'
'61'
'62'
['18', '23', '61', '62']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="107" ssid="4">The semantic training corpus was produced by students according to a simple set of guidelines.</S><S sid="108" ssid="5">This simple semantic annotation was the only source of task knowledge used to configure the model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'11'", "'107'", "'108'"]
'10'
'11'
'107'
'108'
['10', '11', '107', '108']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="30" ssid="13">Although each model differed in its detailed probability structure, we believed that the essential elements of all three models could be generalized in a single probability model.</S><S sid="31" ssid="14">If the single generalized model could then be extended to semantic analysis, all necessary sentence level processing would be contained in that model.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="94" ssid="13">Given a new sentence, the outcome of this search process is a tree structure that encodes both the syntactic and semantic structure of the sentence.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'31'", "'52'", "'94'"]
'30'
'31'
'52'
'94'
['30', '31', '52', '94']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="41" ssid="1">To train our integrated model, we required a large corpus of augmented parse trees.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'41'", "'60'"]
'33'
'34'
'41'
'60'
['33', '34', '41', '60']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="6">For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.</S><S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'18'", "'58'", "'60'"]
'16'
'18'
'58'
'60'
['16', '18', '58', '60']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'34'", "'58'", "'61'"]
'1'
'34'
'58'
'61'
['1', '34', '58', '61']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'52'", "'58'"]
'33'
'34'
'52'
'58'
['33', '34', '52', '58']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="62" ssid="3">For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'61'", "'62'", "'101'"]
'32'
'61'
'62'
'101'
['32', '61', '62', '101']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'58'", "'61'", "'101'"]
'32'
'58'
'61'
'101'
['32', '58', '61', '101']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'33'", "'52'", "'58'"]
'2'
'33'
'52'
'58'
['2', '33', '52', '58']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'51'", "'52'"]
'1'
'2'
'51'
'52'
['1', '2', '51', '52']
parsed_discourse_facet ['hypothesis_citation']
<S sid="28" ssid="11">Finally, our newly constructed parser, like that of (Collins 1997), was based on a generative statistical model.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S><S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'", "'52'", "'60'", "'105'"]
'28'
'52'
'60'
'105'
['28', '52', '60', '105']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="50" ssid="10">Figure 4 shows an example of the semantic annotation, which was the only type of manual annotation we performed.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'50'", "'51'", "'52'"]
'10'
'50'
'51'
'52'
['10', '50', '51', '52']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'6'", "'58'", "'105'"]
'2'
'6'
'58'
'105'
['2', '6', '58', '105']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'34'", "'51'", "'58'"]
'10'
'34'
'51'
'58'
['10', '34', '51', '58']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'58'", "'61'", "'101'"]
'2'
'58'
'61'
'101'
['2', '58', '61', '101']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'11'", "'104'"]
'1'
'2'
'11'
'104'
['1', '2', '11', '104']
parsed_discourse_facet ['aim_citation']
<S sid="0">A Novel Use of Statistical Parsing to Extract Information from Text</S><S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'60'"]
'0'
'1'
'2'
'60'
['0', '1', '2', '60']
parsed_discourse_facet ['hypothesis_citation']
Length 0 input/ref/Task1/A00-2030_aakansha.csv
0.0 0.0 0.0





input/ref/Task1/A00-2030_sweta.csv
input/res/Task1/A00-2030.annv3.csv
parsing: input/ref/Task1/A00-2030_sweta.csv
<S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S>
original cit marker offset is 0
new cit marker offset is 0



["18'"]
18'
['18']
parsed_discourse_facet ['method_citation']
<S sid="100" ssid="5">Given multiple constituents that cover identical spans in the chart, only those constituents with probabilities within a While our focus throughout the project was on TE and TR, we became curious about how well the model did at part-of-speech tagging, syntactic parsing, and at name finding.</S>
original cit marker offset is 0
new cit marker offset is 0



["100'"]
100'
['100']
parsed_discourse_facet ['method_citation']
<S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["52'"]
52'
['52']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["34'"]
34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S>
original cit marker offset is 0
new cit marker offset is 0



["1'"]
1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["61'"]
61'
['61']
parsed_discourse_facet ['method_citation']
<S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["104'"]
104'
['104']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S>
original cit marker offset is 0
new cit marker offset is 0



["32'"]
32'
['32']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["2'"]
2'
['2']
parsed_discourse_facet ['method_citation']
 <S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["61'"]
61'
['61']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["33'"]
33'
['33']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["34'"]
34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="1">Since 1995, a few statistical parsing algorithms (Magerman, 1995; Collins, 1996 and 1997; Charniak, 1997; Rathnaparki, 1997) demonstrated a breakthrough in parsing accuracy, as measured against the University of Pennsylvania TREEBANK as a gold standard.</S>
original cit marker offset is 0
new cit marker offset is 0



["3'"]
3'
['3']
parsed_discourse_facet ['method_citation']
<S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["52'"]
52'
['52']
parsed_discourse_facet ['method_citation']
<S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["104'"]
104'
['104']
parsed_discourse_facet ['method_citation']
<S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["104'"]
104'
['104']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.<
original cit marker offset is 0
new cit marker offset is 0



["2'"]
2'
['2']
parsed_discourse_facet ['method_citation']
<S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction
original cit marker offset is 0
new cit marker offset is 0



["104'"]
104'
['104']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["2'"]
2'
['2']
parsed_discourse_facet ['method_citation']
<S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["61'"]
61'
['61']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A00-2030.annv3.csv
<S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="40" ssid="8">Further details are discussed in the section Tree Augmentation.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="65" ssid="6">We illustrate the generation process by walking through a few of the steps of the parse shown in Figure 3.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'40'", "'52'", "'65'"]
'11'
'40'
'52'
'65'
['11', '40', '52', '65']
parsed_discourse_facet ['aim_citation']
<S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S><S sid="23" ssid="6">An integrated model can limit the propagation of errors by making all decisions jointly.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="62" ssid="3">For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'23'", "'61'", "'62'"]
'18'
'23'
'61'
'62'
['18', '23', '61', '62']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="107" ssid="4">The semantic training corpus was produced by students according to a simple set of guidelines.</S><S sid="108" ssid="5">This simple semantic annotation was the only source of task knowledge used to configure the model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'11'", "'107'", "'108'"]
'10'
'11'
'107'
'108'
['10', '11', '107', '108']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="30" ssid="13">Although each model differed in its detailed probability structure, we believed that the essential elements of all three models could be generalized in a single probability model.</S><S sid="31" ssid="14">If the single generalized model could then be extended to semantic analysis, all necessary sentence level processing would be contained in that model.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="94" ssid="13">Given a new sentence, the outcome of this search process is a tree structure that encodes both the syntactic and semantic structure of the sentence.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'31'", "'52'", "'94'"]
'30'
'31'
'52'
'94'
['30', '31', '52', '94']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="41" ssid="1">To train our integrated model, we required a large corpus of augmented parse trees.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'41'", "'60'"]
'33'
'34'
'41'
'60'
['33', '34', '41', '60']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="6">For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.</S><S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'18'", "'58'", "'60'"]
'16'
'18'
'58'
'60'
['16', '18', '58', '60']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'34'", "'58'", "'61'"]
'1'
'34'
'58'
'61'
['1', '34', '58', '61']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'52'", "'58'"]
'33'
'34'
'52'
'58'
['33', '34', '52', '58']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="62" ssid="3">For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'61'", "'62'", "'101'"]
'32'
'61'
'62'
'101'
['32', '61', '62', '101']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'58'", "'61'", "'101'"]
'32'
'58'
'61'
'101'
['32', '58', '61', '101']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'33'", "'52'", "'58'"]
'2'
'33'
'52'
'58'
['2', '33', '52', '58']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'51'", "'52'"]
'1'
'2'
'51'
'52'
['1', '2', '51', '52']
parsed_discourse_facet ['hypothesis_citation']
<S sid="28" ssid="11">Finally, our newly constructed parser, like that of (Collins 1997), was based on a generative statistical model.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S><S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'", "'52'", "'60'", "'105'"]
'28'
'52'
'60'
'105'
['28', '52', '60', '105']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="50" ssid="10">Figure 4 shows an example of the semantic annotation, which was the only type of manual annotation we performed.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'50'", "'51'", "'52'"]
'10'
'50'
'51'
'52'
['10', '50', '51', '52']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'6'", "'58'", "'105'"]
'2'
'6'
'58'
'105'
['2', '6', '58', '105']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'34'", "'51'", "'58'"]
'10'
'34'
'51'
'58'
['10', '34', '51', '58']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'58'", "'61'", "'101'"]
'2'
'58'
'61'
'101'
['2', '58', '61', '101']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'11'", "'104'"]
'1'
'2'
'11'
'104'
['1', '2', '11', '104']
parsed_discourse_facet ['aim_citation']
<S sid="0">A Novel Use of Statistical Parsing to Extract Information from Text</S><S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'60'"]
'0'
'1'
'2'
'60'
['0', '1', '2', '60']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.'])
dict_values(['Our integrated model represents syntax and semantics jointly using augmented parse trees.', 'In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.', 'To train our integrated model, we required a large corpus of augmented parse trees.', 'In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00450', '(95%-conf.int.', '0.00450', '-', '0.00450)']
['system', 'ROUGE-S*', 'Average_P:', '0.03846', '(95%-conf.int.', '0.03846', '-', '0.03846)']
['system', 'ROUGE-S*', 'Average_F:', '0.00806', '(95%-conf.int.', '0.00806', '-', '0.00806)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:666', 'P:78', 'F:3']
dict_values(['The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.'])
dict_values(['For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.', 'Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.', 'Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.', 'In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00125', '(95%-conf.int.', '0.00125', '-', '0.00125)']
['system', 'ROUGE-S*', 'Average_P:', '0.01307', '(95%-conf.int.', '0.01307', '-', '0.01307)']
['system', 'ROUGE-S*', 'Average_F:', '0.00229', '(95%-conf.int.', '0.00229', '-', '0.00229)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:153', 'F:2']
dict_values(['We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.'])
dict_values(['Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.', 'In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.', 'Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.', 'The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00067', '(95%-conf.int.', '0.00067', '-', '0.00067)']
['system', 'ROUGE-S*', 'Average_P:', '0.01282', '(95%-conf.int.', '0.01282', '-', '0.01282)']
['system', 'ROUGE-S*', 'Average_F:', '0.00128', '(95%-conf.int.', '0.00128', '-', '0.00128)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:78', 'F:1']
dict_values(['In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.'])
dict_values(['Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.', 'The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.', 'For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.', 'We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:190', 'F:0']
dict_values(['The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.'])
dict_values(['Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.', 'Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.', 'The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.', 'We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05368', '(95%-conf.int.', '0.05368', '-', '0.05368)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10190', '(95%-conf.int.', '0.10190', '-', '0.10190)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2850', 'P:153', 'F:153']
dict_values(['In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.'])
dict_values(['Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.', 'In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.', 'To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.', 'In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00518', '(95%-conf.int.', '0.00518', '-', '0.00518)']
['system', 'ROUGE-S*', 'Average_P:', '0.31111', '(95%-conf.int.', '0.31111', '-', '0.31111)']
['system', 'ROUGE-S*', 'Average_F:', '0.01020', '(95%-conf.int.', '0.01020', '-', '0.01020)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2701', 'P:45', 'F:14']
dict_values(['Since 1995, a few statistical parsing algorithms (Magerman, 1995; Collins, 1996 and 1997; Charniak, 1997; Rathnaparki, 1997) demonstrated a breakthrough in parsing accuracy, as measured against the University of Pennsylvania TREEBANK as a gold standard.'])
dict_values(['Finally, our newly constructed parser, like that of (Collins 1997), was based on a generative statistical model.', 'In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.', 'In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).', 'A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02220', '(95%-conf.int.', '0.02220', '-', '0.02220)']
['system', 'ROUGE-S*', 'Average_P:', '0.08300', '(95%-conf.int.', '0.08300', '-', '0.08300)']
['system', 'ROUGE-S*', 'Average_F:', '0.03503', '(95%-conf.int.', '0.03503', '-', '0.03503)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:946', 'P:253', 'F:21']
dict_values(['In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.'])
dict_values(['Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.', 'Figure 4 shows an example of the semantic annotation, which was the only type of manual annotation we performed.', 'To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.', 'In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05427', '(95%-conf.int.', '0.05427', '-', '0.05427)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10296', '(95%-conf.int.', '0.10296', '-', '0.10296)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2211', 'P:120', 'F:120']
dict_values(['We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.'])
dict_values(['In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.', 'In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.', 'Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.', 'A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02256', '(95%-conf.int.', '0.02256', '-', '0.02256)']
['system', 'ROUGE-S*', 'Average_P:', '0.46154', '(95%-conf.int.', '0.46154', '-', '0.46154)']
['system', 'ROUGE-S*', 'Average_F:', '0.04301', '(95%-conf.int.', '0.04301', '-', '0.04301)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:78', 'F:36']
dict_values(['We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.'])
dict_values(['Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.', 'In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.', 'To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.', 'Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:78', 'F:0']
dict_values(['In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.'])
dict_values(['In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.', 'Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.', 'The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.', 'We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07230', '(95%-conf.int.', '0.07230', '-', '0.07230)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.13485', '(95%-conf.int.', '0.13485', '-', '0.13485)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2628', 'P:190', 'F:190']
dict_values(['We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction'])
dict_values(['Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.', 'In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.', 'We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).', 'We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.'])
['system', 'ROUGE-S*', 'Average_R:', '0.04407', '(95%-conf.int.', '0.04407', '-', '0.04407)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.08442', '(95%-conf.int.', '0.08442', '-', '0.08442)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:78', 'F:78']
dict_values(['In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.'])
dict_values(['A Novel Use of Statistical Parsing to Extract Information from Text', 'Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.', 'In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.', 'In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).'])
['system', 'ROUGE-S*', 'Average_R:', '0.17576', '(95%-conf.int.', '0.17576', '-', '0.17576)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.29898', '(95%-conf.int.', '0.29898', '-', '0.29898)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1081', 'P:190', 'F:190']
0.45538461188165685 0.03511076896068639 0.06330615335918344





input/ref/Task1/A00-2030_vardha.csv
input/res/Task1/A00-2030.annv3.csv
parsing: input/ref/Task1/A00-2030_vardha.csv
 <S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'"]
'11'
['11']
parsed_discourse_facet ['method_citation']
<S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'"]
'52'
['52']
parsed_discourse_facet ['method_citation']
<S sid="50" ssid="10">Figure 4 shows an example of the semantic annotation, which was the only type of manual annotation we performed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'"]
'50'
['50']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'34'"]
'34'
['34']
parsed_discourse_facet ['method_citation']
 <S sid="106" ssid="3">We were able to use the Penn TREEBANK to estimate the syntactic parameters; no additional syntactic training was required.</S>
original cit marker offset is 0
new cit marker offset is 0



["'106'"]
'106'
['106']
parsed_discourse_facet ['method_citation']
 <S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'"]
'6'
['6']
parsed_discourse_facet ['method_citation']
 <S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'"]
'6'
['6']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'34'"]
'34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="2">The Template Element (TE) task identifies organizations, persons, locations, and some artifacts (rocket and airplane-related artifacts).</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'"]
'12'
['12']
parsed_discourse_facet ['method_citation']
 <S sid="3" ssid="1">Since 1995, a few statistical parsing algorithms (Magerman, 1995; Collins, 1996 and 1997; Charniak, 1997; Rathnaparki, 1997) demonstrated a breakthrough in parsing accuracy, as measured against the University of Pennsylvania TREEBANK as a gold standard.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'"]
'3'
['3']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'34'"]
'34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'"]
'32'
['32']
parsed_discourse_facet ['method_citation']
 <S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="94" ssid="13">Given a new sentence, the outcome of this search process is a tree structure that encodes both the syntactic and semantic structure of the sentence.</S>
original cit marker offset is 0
new cit marker offset is 0



["'94'"]
'94'
['94']
parsed_discourse_facet ['method_citation']
    <S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'"]
'6'
['6']
parsed_discourse_facet ['method_citation']
 <S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
 <S sid="26" ssid="9">We were already using a generative statistical model for part-of-speech tagging (Weischedel et al. 1993), and more recently, had begun using a generative statistical model for name finding (Bikel et al.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'"]
'26'
['26']
parsed_discourse_facet ['method_citation']
    <S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'"]
'6'
['6']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="2">Currently, the prevailing architecture for dividing sentential processing is a four-stage pipeline consisting of: Since we were interested in exploiting recent advances in parsing, replacing the syntactic analysis stage of the standard pipeline with a modern statistical parser was an obvious possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A00-2030.annv3.csv
<S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="40" ssid="8">Further details are discussed in the section Tree Augmentation.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="65" ssid="6">We illustrate the generation process by walking through a few of the steps of the parse shown in Figure 3.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'40'", "'52'", "'65'"]
'11'
'40'
'52'
'65'
['11', '40', '52', '65']
parsed_discourse_facet ['aim_citation']
<S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S><S sid="23" ssid="6">An integrated model can limit the propagation of errors by making all decisions jointly.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="62" ssid="3">For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'23'", "'61'", "'62'"]
'18'
'23'
'61'
'62'
['18', '23', '61', '62']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="107" ssid="4">The semantic training corpus was produced by students according to a simple set of guidelines.</S><S sid="108" ssid="5">This simple semantic annotation was the only source of task knowledge used to configure the model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'11'", "'107'", "'108'"]
'10'
'11'
'107'
'108'
['10', '11', '107', '108']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="30" ssid="13">Although each model differed in its detailed probability structure, we believed that the essential elements of all three models could be generalized in a single probability model.</S><S sid="31" ssid="14">If the single generalized model could then be extended to semantic analysis, all necessary sentence level processing would be contained in that model.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="94" ssid="13">Given a new sentence, the outcome of this search process is a tree structure that encodes both the syntactic and semantic structure of the sentence.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'31'", "'52'", "'94'"]
'30'
'31'
'52'
'94'
['30', '31', '52', '94']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="41" ssid="1">To train our integrated model, we required a large corpus of augmented parse trees.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'41'", "'60'"]
'33'
'34'
'41'
'60'
['33', '34', '41', '60']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="6">For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.</S><S sid="18" ssid="1">Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'18'", "'58'", "'60'"]
'16'
'18'
'58'
'60'
['16', '18', '58', '60']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'34'", "'58'", "'61'"]
'1'
'34'
'58'
'61'
['1', '34', '58', '61']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'52'", "'58'"]
'33'
'34'
'52'
'58'
['33', '34', '52', '58']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="62" ssid="3">For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'61'", "'62'", "'101'"]
'32'
'61'
'62'
'101'
['32', '61', '62', '101']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="15">Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'58'", "'61'", "'101'"]
'32'
'58'
'61'
'101'
['32', '58', '61', '101']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="33" ssid="1">Our integrated model represents syntax and semantics jointly using augmented parse trees.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'33'", "'52'", "'58'"]
'2'
'33'
'52'
'58'
['2', '33', '52', '58']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'51'", "'52'"]
'1'
'2'
'51'
'52'
['1', '2', '51', '52']
parsed_discourse_facet ['hypothesis_citation']
<S sid="28" ssid="11">Finally, our newly constructed parser, like that of (Collins 1997), was based on a generative statistical model.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S><S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'", "'52'", "'60'", "'105'"]
'28'
'52'
'60'
'105'
['28', '52', '60', '105']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="50" ssid="10">Figure 4 shows an example of the semantic annotation, which was the only type of manual annotation we performed.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="52" ssid="1">In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'50'", "'51'", "'52'"]
'10'
'50'
'51'
'52'
['10', '50', '51', '52']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="6" ssid="4">In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="105" ssid="2">A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'6'", "'58'", "'105'"]
'2'
'6'
'58'
'105'
['2', '6', '58', '105']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="8">Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.</S><S sid="34" ssid="2">In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.</S><S sid="51" ssid="11">To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'34'", "'51'", "'58'"]
'10'
'34'
'51'
'58'
['10', '34', '51', '58']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="58" ssid="4">Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.</S><S sid="61" ssid="2">The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.</S><S sid="101" ssid="6">We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'58'", "'61'", "'101'"]
'2'
'58'
'61'
'101'
['2', '58', '61', '101']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="11" ssid="1">We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).</S><S sid="104" ssid="1">We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'11'", "'104'"]
'1'
'2'
'11'
'104'
['1', '2', '11', '104']
parsed_discourse_facet ['aim_citation']
<S sid="0">A Novel Use of Statistical Parsing to Extract Information from Text</S><S sid="1" ssid="1">Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.</S><S sid="2" ssid="2">In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.</S><S sid="60" ssid="1">In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'60'"]
'0'
'1'
'2'
'60'
['0', '1', '2', '60']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['We were able to use the Penn TREEBANK to estimate the syntactic parameters; no additional syntactic training was required.'])
dict_values(['Our integrated model represents syntax and semantics jointly using augmented parse trees.', 'In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.', 'To train our integrated model, we required a large corpus of augmented parse trees.', 'In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00450', '(95%-conf.int.', '0.00450', '-', '0.00450)']
['system', 'ROUGE-S*', 'Average_P:', '0.08333', '(95%-conf.int.', '0.08333', '-', '0.08333)']
['system', 'ROUGE-S*', 'Average_F:', '0.00855', '(95%-conf.int.', '0.00855', '-', '0.00855)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:666', 'P:36', 'F:3']
dict_values(['In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.'])
dict_values(['For the following example, the The Template Relations (TR) task involves identifying instances of three relations in the text: TR builds on TE in that TR reports binary relations between elements of TE.', 'Almost all approaches to information extraction &#8212; even at the sentence level &#8212; are based on the divide-and-conquer strategy of reducing a complex problem to a set of simpler ones.', 'Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.', 'In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00188', '(95%-conf.int.', '0.00188', '-', '0.00188)']
['system', 'ROUGE-S*', 'Average_P:', '0.03297', '(95%-conf.int.', '0.03297', '-', '0.03297)']
['system', 'ROUGE-S*', 'Average_F:', '0.00356', '(95%-conf.int.', '0.00356', '-', '0.00356)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:91', 'F:3']
dict_values(['In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.'])
dict_values(['Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.', 'In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.', 'Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.', 'The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:91', 'F:0']
dict_values(['The Template Element (TE) task identifies organizations, persons, locations, and some artifacts (rocket and airplane-related artifacts).'])
dict_values(['Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.', 'The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.', 'For each constituent, the head is generated first, followed by the modifiers, which are generated from the head outward.', 'We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:78', 'F:0']
dict_values(['Since 1995, a few statistical parsing algorithms (Magerman, 1995; Collins, 1996 and 1997; Charniak, 1997; Rathnaparki, 1997) demonstrated a breakthrough in parsing accuracy, as measured against the University of Pennsylvania TREEBANK as a gold standard.'])
dict_values(['Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.', 'Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.', 'The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.', 'We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00456', '(95%-conf.int.', '0.00456', '-', '0.00456)']
['system', 'ROUGE-S*', 'Average_P:', '0.05138', '(95%-conf.int.', '0.05138', '-', '0.05138)']
['system', 'ROUGE-S*', 'Average_F:', '0.00838', '(95%-conf.int.', '0.00838', '-', '0.00838)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2850', 'P:253', 'F:13']
dict_values(['Because generative statistical models had already proven successful for each of the first three stages, we were optimistic that some of their properties &#8212; especially their ability to learn from large amounts of data, and their robustness when presented with unexpected inputs &#8212; would also benefit semantic analysis.'])
dict_values(['Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.', 'In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.', 'To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.', 'In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00074', '(95%-conf.int.', '0.00074', '-', '0.00074)']
['system', 'ROUGE-S*', 'Average_P:', '0.00791', '(95%-conf.int.', '0.00791', '-', '0.00791)']
['system', 'ROUGE-S*', 'Average_F:', '0.00135', '(95%-conf.int.', '0.00135', '-', '0.00135)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2701', 'P:253', 'F:2']
dict_values(['Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.'])
dict_values(['Finally, our newly constructed parser, like that of (Collins 1997), was based on a generative statistical model.', 'In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.', 'In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).', 'A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00740', '(95%-conf.int.', '0.00740', '-', '0.00740)']
['system', 'ROUGE-S*', 'Average_P:', '0.05147', '(95%-conf.int.', '0.05147', '-', '0.05147)']
['system', 'ROUGE-S*', 'Average_F:', '0.01294', '(95%-conf.int.', '0.01294', '-', '0.01294)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:946', 'P:136', 'F:7']
dict_values(['Given a new sentence, the outcome of this search process is a tree structure that encodes both the syntactic and semantic structure of the sentence.'])
dict_values(['Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.', 'Figure 4 shows an example of the semantic annotation, which was the only type of manual annotation we performed.', 'To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.', 'In this section, we describe the algorithm that was used to automatically produce augmented trees, starting with a) human-generated semantic annotations and b) machinegenerated syntactic parse trees.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00136', '(95%-conf.int.', '0.00136', '-', '0.00136)']
['system', 'ROUGE-S*', 'Average_P:', '0.05455', '(95%-conf.int.', '0.05455', '-', '0.05455)']
['system', 'ROUGE-S*', 'Average_F:', '0.00265', '(95%-conf.int.', '0.00265', '-', '0.00265)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2211', 'P:55', 'F:3']
dict_values(['In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.'])
dict_values(['In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.', 'In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.', 'Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.', 'A single model proved capable of performing all necessary sentential processing, both syntactic and semantic.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05702', '(95%-conf.int.', '0.05702', '-', '0.05702)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10788', '(95%-conf.int.', '0.10788', '-', '0.10788)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:91', 'F:91']
dict_values(['We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.'])
dict_values(['Instead, our parsing algorithm, trained on the UPenn TREEBANK, was run on the New York Times source to create unsupervised syntactic training which was constrained to be consistent with semantic annotation.', 'In these trees, the standard TREEBANK structures are augmented to convey semantic information, that is, entities and relations.', 'To produce a corpus of augmented parse trees, we used the following multi-step training procedure which exploited the Penn TREEBANK Applying this procedure yielded a new version of the semantically annotated corpus, now annotated with complete augmented trees like that in Figure 3.', 'Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:78', 'F:0']
dict_values(['We were already using a generative statistical model for part-of-speech tagging (Weischedel et al. 1993), and more recently, had begun using a generative statistical model for name finding (Bikel et al.'])
dict_values(['In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.', 'Whenever a relation involves an entity that is not a direct descendant of that relation in the parse tree, semantic pointer labels are attached to all of the intermediate nodes.', 'The detailed probability structure differs, however, in that it was designed to jointly perform part-of-speech tagging, name finding, syntactic parsing, and relation finding in a single process.', 'We evaluated part-of-speech tagging and parsing accuracy on the Wall Street Journal using a now standard procedure (see Collins 97), and evaluated name finding accuracy on the MUC7 named entity test.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00457', '(95%-conf.int.', '0.00457', '-', '0.00457)']
['system', 'ROUGE-S*', 'Average_P:', '0.07843', '(95%-conf.int.', '0.07843', '-', '0.07843)']
['system', 'ROUGE-S*', 'Average_F:', '0.00863', '(95%-conf.int.', '0.00863', '-', '0.00863)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2628', 'P:153', 'F:12']
dict_values(['In this paper, we report adapting a lexicalized, probabilistic context-free parser with head rules (LPCFG-HR) to information extraction.'])
dict_values(['Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.', 'In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.', 'We evaluated the new approach to information extraction on two of the tasks of the Seventh Message Understanding Conference (MUC-7) and reported in (Marsh, 1998).', 'We have demonstrated, at least for one problem, that a lexicalized, probabilistic context-free parser with head rules (LPCFGHR) can be used effectively for information extraction.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03729', '(95%-conf.int.', '0.03729', '-', '0.03729)']
['system', 'ROUGE-S*', 'Average_P:', '0.72527', '(95%-conf.int.', '0.72527', '-', '0.72527)']
['system', 'ROUGE-S*', 'Average_F:', '0.07093', '(95%-conf.int.', '0.07093', '-', '0.07093)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:91', 'F:66']
dict_values(['Currently, the prevailing architecture for dividing sentential processing is a four-stage pipeline consisting of: Since we were interested in exploiting recent advances in parsing, replacing the syntactic analysis stage of the standard pipeline with a modern statistical parser was an obvious possibility.'])
dict_values(['A Novel Use of Statistical Parsing to Extract Information from Text', 'Since 1995, a few statistical parsing algorithms have demonstrated a breakthrough in parsing accuracy, as measured against the UPenn TREEBANK as a gold standard.', 'In this paper we report adapting a lexic al ized, probabilistic context-free parser to information extraction and evaluate this new technique on MUC-7 template elements and template relations.', 'In our statistical model, trees are generated according to a process similar to that described in (Collins 1996, 1997).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00555', '(95%-conf.int.', '0.00555', '-', '0.00555)']
['system', 'ROUGE-S*', 'Average_P:', '0.02174', '(95%-conf.int.', '0.02174', '-', '0.02174)']
['system', 'ROUGE-S*', 'Average_F:', '0.00884', '(95%-conf.int.', '0.00884', '-', '0.00884)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1081', 'P:276', 'F:6']
0.16208076798399407 0.009605384541497043 0.01797769216940237





input/ref/Task1/A97-1014_swastika.csv
input/res/Task1/A97-1014.annv3.csv
parsing: input/ref/Task1/A97-1014_swastika.csv
<S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



['168']
168
['168']
parsed_discourse_facet ['aim_citation']
<S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



['168']
168
['168']
parsed_discourse_facet ['aim_citation']
<S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S>
original cit marker offset is 0
new cit marker offset is 0



['151']
151
['151']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S>
original cit marker offset is 0
new cit marker offset is 0



['15']
15
['15']
parsed_discourse_facet ['result_citation']
<S sid="47" ssid="37">Argument structure can be represented in terms of unordered trees (with crossing branches).</S>
original cit marker offset is 0
new cit marker offset is 0



['47']
47
['47']
parsed_discourse_facet ['method_citation']
<S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



['167']
167
['167']
parsed_discourse_facet ['method_citation']
<S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



['168']
168
['168']
parsed_discourse_facet ['aim_citation']
<S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks') for stochastic grammar induction.</S>
original cit marker offset is 0
new cit marker offset is 0



['4']
4
['4']
parsed_discourse_facet ['aim_citation']
<S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



['160']
160
['160']
parsed_discourse_facet ['method_citation']
<S sid="127" ssid="8">As the need for certain functionalities becomes obvious with growing annotation experience, we have decided to implement the tool in two stages.</S>
original cit marker offset is 0
new cit marker offset is 0



['127']
127
['127']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="29">Consider the German sentence (1) daran wird ihn Anna erkennen, &amp;di er weint at-it will him Anna recognise that he cries 'Anna will recognise him at his cry' A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



['39']
39
['39']
parsed_discourse_facet ['method_citation']
<S sid="72" ssid="17">In order to avoid inconsistencies, the corpus is annotated in two stages: basic annotation and nfirtellte714.</S>
original cit marker offset is 0
new cit marker offset is 0



['72']
72
['72']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks') for stochastic grammar induction.</S>
original cit marker offset is 0
new cit marker offset is 0



['4']
4
['4']
parsed_discourse_facet ['aim_citation']
<S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks') for stochastic grammar induction.</S>
original cit marker offset is 0
new cit marker offset is 0



['4']
4
['4']
parsed_discourse_facet ['aim_citation']
parsing: input/res/Task1/A97-1014.annv3.csv
<S sid="13" ssid="3">The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S><S sid="169" ssid="11">Since the combinatorics of syntactic constructions creates a. demand for very large corpora., efficiency of annotation is an important. criterion for the success of the developed methodology and tools.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'137'", "'168'", "'169'"]
'13'
'137'
'168'
'169'
['13', '137', '168', '169']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="2">Realworld texts annotated with different strata of linguistic information can be used for grammar induction.</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'137'", "'140'", "'165'"]
'12'
'137'
'140'
'165'
['12', '137', '140', '165']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="28">Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S><S sid="141" ssid="22">The corpus is stored in a SQL database.</S><S sid="143" ssid="24">Sentences annotated in previous steps are used as training material for further processing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'140'", "'141'", "'143'"]
'38'
'140'
'141'
'143'
['38', '140', '141', '143']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="48" ssid="38">In order to reduce their ambiguity potential, rather simple, \flat\ trees should be employed, while more information can be expressed by a rich system of function labels.</S><S sid="51" ssid="41">This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.</S><S sid="53" ssid="43">A tree meeting these requirements is given below: Adv V NP NP V CPL NP V damn wird ihn Anna erkennen, dais er \vein!</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'48'", "'51'", "'53'"]
'15'
'48'
'51'
'53'
['15', '48', '51', '53']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="15">The underlying argument SirlteilITC is not represented directly, but can be recovered from the tree and trace-filler annotations.</S><S sid="39" ssid="29">Consider the German sentence (1) daran wird ihn Anna erkennen, &amp;di er weint at-it will him Anna recognise that he cries \Anna will recognise him at his cry\ A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes.</S><S sid="47" ssid="37">Argument structure can be represented in terms of unordered trees (with crossing branches).</S><S sid="51" ssid="41">This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'", "'39'", "'47'", "'51'"]
'25'
'39'
'47'
'51'
['25', '39', '47', '51']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="28">Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.</S><S sid="50" ssid="40">Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.</S><S sid="52" ssid="42">(Hudson, 1984).</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'50'", "'52'", "'167'"]
'38'
'50'
'52'
'167'
['38', '50', '52', '167']
parsed_discourse_facet ['method_citation']
<S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'151'", "'165'", "'167'", "'168'"]
'151'
'165'
'167'
'168'
['151', '165', '167', '168']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="1" ssid="1">We describe an annotation scheme and a tool developed for creating linguistically annotated corpora for non-configurational languages.</S><S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks\) for stochastic grammar induction.</S><S sid="159" ssid="1">As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'4'", "'159'", "'165'"]
'1'
'4'
'159'
'165'
['1', '4', '159', '165']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="0">An Annotation Scheme for Free Word Order Languages</S><S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="159" ssid="1">As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.</S><S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'15'", "'159'", "'160'"]
'0'
'15'
'159'
'160'
['0', '15', '159', '160']
parsed_discourse_facet ['hypothesis_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="71" ssid="16">However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.</S><S sid="80" ssid="25">Separable verb prefixes are labeled SVP.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'71'", "'80'", "'167'"]
'15'
'71'
'80'
'167'
['15', '71', '80', '167']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks\) for stochastic grammar induction.</S><S sid="13" ssid="3">The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.</S><S sid="150" ssid="31">To keep the human annotator from missing errors made by the tagger, we additionally calculate the strongest competitor for each label G. If its probability is close to the winner (closeness is defined by a threshold on the quotient), the assignment is regarded as unreliable, and the annotator is asked to confirm the assignment.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'13'", "'150'", "'168'"]
'4'
'13'
'150'
'168'
['4', '13', '150', '168']
parsed_discourse_facet ['hypothesis_citation']
<S sid="12" ssid="2">Realworld texts annotated with different strata of linguistic information can be used for grammar induction.</S><S sid="33" ssid="23">(Lehmann et al., 1996), (Marcus et al., 1994), (Sampson, 1995)).</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'33'", "'137'", "'140'"]
'12'
'33'
'137'
'140'
['12', '33', '137', '140']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="14">The typical treebank architecture is as follows: Structures: A context-free backbone is augmented with trace-filler representations of non-local dependencies.</S><S sid="31" ssid="21">Due to the substantial differences between existing models of constituent structure, the question arises of how the theory independencf requirement, can be satisfied.</S><S sid="149" ssid="30">During annotation, the highest rated grammatical function labels Gi are calculated using the Viterbi algorithm and assigned to the structure, i.e., we calculate argma.x11 PQ (Ti 1Z-1, Ti.-2) PQ (Gi ITi).</S><S sid="158" ssid="39">Owing to the partial automation, the average annotation efficiency improves by 25% (from around 4 minutes to 3 minutes per sentence).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'31'", "'149'", "'158'"]
'24'
'31'
'149'
'158'
['24', '31', '149', '158']
parsed_discourse_facet ['method_citation']
<S sid="50" ssid="40">Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.</S><S sid="52" ssid="42">(Hudson, 1984).</S><S sid="74" ssid="19">During the first phase, the focus is on annotating correct structures and a coarse-grained classification of grammatical functions, which represent the following areas of information: Dependency type: complements are further classified according to features such as category and case: clausal complements (OC), accusative objects (OA), datives (DA), etc.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'52'", "'74'", "'167'"]
'50'
'52'
'74'
'167'
['50', '52', '74', '167']
parsed_discourse_facet ['method_citation']
dict_values(['We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.'])
dict_values(['Realworld texts annotated with different strata of linguistic information can be used for grammar induction.', 'The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.', 'For the implementation, we used Tcl/Tk Version 4.1.', 'In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00163', '(95%-conf.int.', '0.00163', '-', '0.00163)']
['system', 'ROUGE-S*', 'Average_P:', '0.03636', '(95%-conf.int.', '0.03636', '-', '0.03636)']
['system', 'ROUGE-S*', 'Average_F:', '0.00312', '(95%-conf.int.', '0.00313', '-', '0.00313)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:55', 'F:2']
dict_values(['For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).'])
dict_values(['Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.', 'For the implementation, we used Tcl/Tk Version 4.1.', 'The corpus is stored in a SQL database.', 'Sentences annotated in previous steps are used as training material for further processing.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00357', '(95%-conf.int.', '0.00357', '-', '0.00357)']
['system', 'ROUGE-S*', 'Average_P:', '0.03636', '(95%-conf.int.', '0.03636', '-', '0.03636)']
['system', 'ROUGE-S*', 'Average_F:', '0.00649', '(95%-conf.int.', '0.00649', '-', '0.00649)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:561', 'P:55', 'F:2']
dict_values(['Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.'])
dict_values(['Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.', 'In order to reduce their ambiguity potential, rather simple, \\flat\\ trees should be employed, while more information can be expressed by a rich system of function labels.', 'This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.', 'A tree meeting these requirements is given below: Adv V NP NP V CPL NP V damn wird ihn Anna erkennen, dais er \\vein!'])
['system', 'ROUGE-S*', 'Average_R:', '0.06818', '(95%-conf.int.', '0.06818', '-', '0.06818)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.12766', '(95%-conf.int.', '0.12766', '-', '0.12766)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1540', 'P:105', 'F:105']
dict_values(['In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
dict_values(['Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.', 'Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.', '(Hudson, 1984).', 'In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
['system', 'ROUGE-S*', 'Average_R:', '0.11667', '(95%-conf.int.', '0.11667', '-', '0.11667)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.20896', '(95%-conf.int.', '0.20896', '-', '0.20896)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:780', 'P:91', 'F:91']
dict_values(['We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.'])
dict_values(['For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).', 'In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.', 'In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.', 'We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02909', '(95%-conf.int.', '0.02909', '-', '0.02909)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.05653', '(95%-conf.int.', '0.05653', '-', '0.05653)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:55', 'F:55']
dict_values(['These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.'])
dict_values(['An Annotation Scheme for Free Word Order Languages', 'Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.', 'As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.', 'These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02561', '(95%-conf.int.', '0.02561', '-', '0.02561)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.04994', '(95%-conf.int.', '0.04994', '-', '0.04994)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:21', 'F:21']
dict_values(['As the need for certain functionalities becomes obvious with growing annotation experience, we have decided to implement the tool in two stages.'])
dict_values(['Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.', 'However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.', 'Separable verb prefixes are labeled SVP.', 'In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:36', 'F:0']
dict_values(["Consider the German sentence (1) daran wird ihn Anna erkennen, &di er weint at-it will him Anna recognise that he cries 'Anna will recognise him at his cry' A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes."])
dict_values(['The work reported in this paper aims at providing syntactically annotated corpora (treebanks\\) for stochastic grammar induction.', 'The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.', 'To keep the human annotator from missing errors made by the tagger, we additionally calculate the strongest competitor for each label G. If its probability is close to the winner (closeness is defined by a threshold on the quotient), the assignment is regarded as unreliable, and the annotator is asked to confirm the assignment.', 'We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:406', 'F:0']
dict_values(['In order to avoid inconsistencies, the corpus is annotated in two stages: basic annotation and nfirtellte714.'])
dict_values(['Realworld texts annotated with different strata of linguistic information can be used for grammar induction.', '(Lehmann et al., 1996), (Marcus et al., 1994), (Sampson, 1995)).', 'The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.', 'For the implementation, we used Tcl/Tk Version 4.1.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00202', '(95%-conf.int.', '0.00202', '-', '0.00202)']
['system', 'ROUGE-S*', 'Average_P:', '0.02778', '(95%-conf.int.', '0.02778', '-', '0.02778)']
['system', 'ROUGE-S*', 'Average_F:', '0.00376', '(95%-conf.int.', '0.00376', '-', '0.00376)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:496', 'P:36', 'F:1']
dict_values(["The work reported in this paper aims at providing syntactically annotated corpora (treebanks') for stochastic grammar induction."])
dict_values(['The typical treebank architecture is as follows: Structures: A context-free backbone is augmented with trace-filler representations of non-local dependencies.', 'Due to the substantial differences between existing models of constituent structure, the question arises of how the theory independencf requirement, can be satisfied.', 'During annotation, the highest rated grammatical function labels Gi are calculated using the Viterbi algorithm and assigned to the structure, i.e., we calculate argma.x11 PQ (Ti 1Z-1, Ti.-2) PQ (Gi ITi).', 'Owing to the partial automation, the average annotation efficiency improves by 25% (from around 4 minutes to 3 minutes per sentence).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:66', 'F:0']
dict_values(["The work reported in this paper aims at providing syntactically annotated corpora (treebanks') for stochastic grammar induction."])
dict_values(['Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.', '(Hudson, 1984).', 'During the first phase, the focus is on annotating correct structures and a coarse-grained classification of grammatical functions, which represent the following areas of information: Dependency type: complements are further classified according to features such as category and case: clausal complements (OC), accusative objects (OA), datives (DA), etc.', 'In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00226', '(95%-conf.int.', '0.00226', '-', '0.00226)']
['system', 'ROUGE-S*', 'Average_P:', '0.04545', '(95%-conf.int.', '0.04545', '-', '0.04545)']
['system', 'ROUGE-S*', 'Average_F:', '0.00431', '(95%-conf.int.', '0.00431', '-', '0.00431)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1326', 'P:66', 'F:3']
0.37690454202814055 0.022639090703280997 0.04188818143738017





input/ref/Task1/A97-1014_sweta.csv
input/res/Task1/A97-1014.annv3.csv
parsing: input/ref/Task1/A97-1014_sweta.csv
<S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["168'"]
168'
['168']
parsed_discourse_facet ['method_citation']
<S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["165'"]
165'
['165']
parsed_discourse_facet ['method_citation']
<S sid="145" ssid="26">This amount of data suffices as training material to reliably assign the grammatical functions if the user determines the elements of a phrase and its type (step 1 of the list above).</S>
original cit marker offset is 0
new cit marker offset is 0



["145'"]
145'
['145']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.<
original cit marker offset is 0
new cit marker offset is 0



["15'"]
15'
['15']
parsed_discourse_facet ['method_citation']
<S sid="41" ssid="31">Apart from this rather technical problem, two further arguments speak against phrase structure as the structural pivot of the annotation scheme: Finally, the structural handling of free word order means stating well-formedness constraints on structures involving many trace-filler dependencies, which has proved tedious.</S>
original cit marker offset is 0
new cit marker offset is 0



["41'"]
41'
['41']
parsed_discourse_facet ['method_citation']
<S sid="47" ssid="37">Argument structure can be represented in terms of unordered trees (with crossing branches).</S>
original cit marker offset is 0
new cit marker offset is 0



["47'"]
47'
['47']
parsed_discourse_facet ['method_citation']
<S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["167'"]
167'
['167']
parsed_discourse_facet ['method_citation']
 <S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["167'"]
167'
['167']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="29">Consider the German sentence (1) daran wird ihn Anna erkennen, &amp;di er weint at-it will him Anna recognise that he cries 'Anna will recognise him at his cry' A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["39'"]
39'
['39']
parsed_discourse_facet ['method_citation']
<S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["160'"]
160'
['160']
parsed_discourse_facet ['method_citation']
<S sid="166" ssid="8">Syntactically annotated corpora of German have been missing until now.</S>
original cit marker offset is 0
new cit marker offset is 0



["166'"]
166'
['166']
parsed_discourse_facet ['method_citation']
<S sid="166" ssid="8">Syntactically annotated corpora of German have been missing until now.</S>
original cit marker offset is 0
new cit marker offset is 0



["166'"]
166'
['166']
parsed_discourse_facet ['method_citation']
<S sid="143" ssid="24">Sentences annotated in previous steps are used as training material for further processing.</S>
original cit marker offset is 0
new cit marker offset is 0



["143'"]
143'
['143']
parsed_discourse_facet ['method_citation']
  <S sid="71" ssid="16">However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["71'"]
71'
['71']
parsed_discourse_facet ['method_citation']
  <S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["167'"]
167'
['167']
parsed_discourse_facet ['method_citation']
<S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S>
original cit marker offset is 0
new cit marker offset is 0



["151'"]
151'
['151']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A97-1014.annv3.csv
<S sid="13" ssid="3">The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S><S sid="169" ssid="11">Since the combinatorics of syntactic constructions creates a. demand for very large corpora., efficiency of annotation is an important. criterion for the success of the developed methodology and tools.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'137'", "'168'", "'169'"]
'13'
'137'
'168'
'169'
['13', '137', '168', '169']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="2">Realworld texts annotated with different strata of linguistic information can be used for grammar induction.</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'137'", "'140'", "'165'"]
'12'
'137'
'140'
'165'
['12', '137', '140', '165']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="28">Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S><S sid="141" ssid="22">The corpus is stored in a SQL database.</S><S sid="143" ssid="24">Sentences annotated in previous steps are used as training material for further processing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'140'", "'141'", "'143'"]
'38'
'140'
'141'
'143'
['38', '140', '141', '143']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="48" ssid="38">In order to reduce their ambiguity potential, rather simple, \flat\ trees should be employed, while more information can be expressed by a rich system of function labels.</S><S sid="51" ssid="41">This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.</S><S sid="53" ssid="43">A tree meeting these requirements is given below: Adv V NP NP V CPL NP V damn wird ihn Anna erkennen, dais er \vein!</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'48'", "'51'", "'53'"]
'15'
'48'
'51'
'53'
['15', '48', '51', '53']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="15">The underlying argument SirlteilITC is not represented directly, but can be recovered from the tree and trace-filler annotations.</S><S sid="39" ssid="29">Consider the German sentence (1) daran wird ihn Anna erkennen, &amp;di er weint at-it will him Anna recognise that he cries \Anna will recognise him at his cry\ A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes.</S><S sid="47" ssid="37">Argument structure can be represented in terms of unordered trees (with crossing branches).</S><S sid="51" ssid="41">This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'", "'39'", "'47'", "'51'"]
'25'
'39'
'47'
'51'
['25', '39', '47', '51']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="28">Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.</S><S sid="50" ssid="40">Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.</S><S sid="52" ssid="42">(Hudson, 1984).</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'50'", "'52'", "'167'"]
'38'
'50'
'52'
'167'
['38', '50', '52', '167']
parsed_discourse_facet ['method_citation']
<S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'151'", "'165'", "'167'", "'168'"]
'151'
'165'
'167'
'168'
['151', '165', '167', '168']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="1" ssid="1">We describe an annotation scheme and a tool developed for creating linguistically annotated corpora for non-configurational languages.</S><S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks\) for stochastic grammar induction.</S><S sid="159" ssid="1">As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'4'", "'159'", "'165'"]
'1'
'4'
'159'
'165'
['1', '4', '159', '165']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="0">An Annotation Scheme for Free Word Order Languages</S><S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="159" ssid="1">As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.</S><S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'15'", "'159'", "'160'"]
'0'
'15'
'159'
'160'
['0', '15', '159', '160']
parsed_discourse_facet ['hypothesis_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="71" ssid="16">However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.</S><S sid="80" ssid="25">Separable verb prefixes are labeled SVP.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'71'", "'80'", "'167'"]
'15'
'71'
'80'
'167'
['15', '71', '80', '167']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks\) for stochastic grammar induction.</S><S sid="13" ssid="3">The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.</S><S sid="150" ssid="31">To keep the human annotator from missing errors made by the tagger, we additionally calculate the strongest competitor for each label G. If its probability is close to the winner (closeness is defined by a threshold on the quotient), the assignment is regarded as unreliable, and the annotator is asked to confirm the assignment.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'13'", "'150'", "'168'"]
'4'
'13'
'150'
'168'
['4', '13', '150', '168']
parsed_discourse_facet ['hypothesis_citation']
<S sid="12" ssid="2">Realworld texts annotated with different strata of linguistic information can be used for grammar induction.</S><S sid="33" ssid="23">(Lehmann et al., 1996), (Marcus et al., 1994), (Sampson, 1995)).</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'33'", "'137'", "'140'"]
'12'
'33'
'137'
'140'
['12', '33', '137', '140']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="14">The typical treebank architecture is as follows: Structures: A context-free backbone is augmented with trace-filler representations of non-local dependencies.</S><S sid="31" ssid="21">Due to the substantial differences between existing models of constituent structure, the question arises of how the theory independencf requirement, can be satisfied.</S><S sid="149" ssid="30">During annotation, the highest rated grammatical function labels Gi are calculated using the Viterbi algorithm and assigned to the structure, i.e., we calculate argma.x11 PQ (Ti 1Z-1, Ti.-2) PQ (Gi ITi).</S><S sid="158" ssid="39">Owing to the partial automation, the average annotation efficiency improves by 25% (from around 4 minutes to 3 minutes per sentence).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'31'", "'149'", "'158'"]
'24'
'31'
'149'
'158'
['24', '31', '149', '158']
parsed_discourse_facet ['method_citation']
<S sid="50" ssid="40">Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.</S><S sid="52" ssid="42">(Hudson, 1984).</S><S sid="74" ssid="19">During the first phase, the focus is on annotating correct structures and a coarse-grained classification of grammatical functions, which represent the following areas of information: Dependency type: complements are further classified according to features such as category and case: clausal complements (OC), accusative objects (OA), datives (DA), etc.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'52'", "'74'", "'167'"]
'50'
'52'
'74'
'167'
['50', '52', '74', '167']
parsed_discourse_facet ['method_citation']
dict_values(['In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.'])
dict_values(['Realworld texts annotated with different strata of linguistic information can be used for grammar induction.', 'The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.', 'For the implementation, we used Tcl/Tk Version 4.1.', 'In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.'])
['system', 'ROUGE-S*', 'Average_R:', '0.26531', '(95%-conf.int.', '0.26531', '-', '0.26531)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.41935', '(95%-conf.int.', '0.41935', '-', '0.41935)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:325', 'F:325']
dict_values(['This amount of data suffices as training material to reliably assign the grammatical functions if the user determines the elements of a phrase and its type (step 1 of the list above).'])
dict_values(['Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.', 'For the implementation, we used Tcl/Tk Version 4.1.', 'The corpus is stored in a SQL database.', 'Sentences annotated in previous steps are used as training material for further processing.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00178', '(95%-conf.int.', '0.00178', '-', '0.00178)']
['system', 'ROUGE-S*', 'Average_P:', '0.00735', '(95%-conf.int.', '0.00735', '-', '0.00735)']
['system', 'ROUGE-S*', 'Average_F:', '0.00287', '(95%-conf.int.', '0.00287', '-', '0.00287)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:561', 'P:136', 'F:1']
dict_values(['Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.'])
dict_values(['Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.', 'In order to reduce their ambiguity potential, rather simple, \\flat\\ trees should be employed, while more information can be expressed by a rich system of function labels.', 'This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.', 'A tree meeting these requirements is given below: Adv V NP NP V CPL NP V damn wird ihn Anna erkennen, dais er \\vein!'])
['system', 'ROUGE-S*', 'Average_R:', '0.06818', '(95%-conf.int.', '0.06818', '-', '0.06818)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.12766', '(95%-conf.int.', '0.12766', '-', '0.12766)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1540', 'P:105', 'F:105']
dict_values(['In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
dict_values(['Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.', 'Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.', '(Hudson, 1984).', 'In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
['system', 'ROUGE-S*', 'Average_R:', '0.11667', '(95%-conf.int.', '0.11667', '-', '0.11667)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.20896', '(95%-conf.int.', '0.20896', '-', '0.20896)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:780', 'P:91', 'F:91']
dict_values(['In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
dict_values(['For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).', 'In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.', 'In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.', 'We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.04812', '(95%-conf.int.', '0.04812', '-', '0.04812)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.09183', '(95%-conf.int.', '0.09183', '-', '0.09183)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:91', 'F:91']
dict_values(['These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.'])
dict_values(['An Annotation Scheme for Free Word Order Languages', 'Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.', 'As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.', 'These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02561', '(95%-conf.int.', '0.02561', '-', '0.02561)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.04994', '(95%-conf.int.', '0.04994', '-', '0.04994)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:21', 'F:21']
dict_values(['Syntactically annotated corpora of German have been missing until now.'])
dict_values(['Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.', 'However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.', 'Separable verb prefixes are labeled SVP.', 'In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00116', '(95%-conf.int.', '0.00116', '-', '0.00116)']
['system', 'ROUGE-S*', 'Average_P:', '0.10000', '(95%-conf.int.', '0.10000', '-', '0.10000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00230', '(95%-conf.int.', '0.00230', '-', '0.00230)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:10', 'F:1']
dict_values(['Syntactically annotated corpora of German have been missing until now.'])
dict_values(['The work reported in this paper aims at providing syntactically annotated corpora (treebanks\\) for stochastic grammar induction.', 'The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.', 'To keep the human annotator from missing errors made by the tagger, we additionally calculate the strongest competitor for each label G. If its probability is close to the winner (closeness is defined by a threshold on the quotient), the assignment is regarded as unreliable, and the annotator is asked to confirm the assignment.', 'We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00526', '(95%-conf.int.', '0.00526', '-', '0.00526)']
['system', 'ROUGE-S*', 'Average_P:', '0.90000', '(95%-conf.int.', '0.90000', '-', '0.90000)']
['system', 'ROUGE-S*', 'Average_F:', '0.01046', '(95%-conf.int.', '0.01046', '-', '0.01046)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:10', 'F:9']
dict_values(['Sentences annotated in previous steps are used as training material for further processing.'])
dict_values(['Realworld texts annotated with different strata of linguistic information can be used for grammar induction.', '(Lehmann et al., 1996), (Marcus et al., 1994), (Sampson, 1995)).', 'The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.', 'For the implementation, we used Tcl/Tk Version 4.1.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:496', 'P:21', 'F:0']
dict_values(['However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.'])
dict_values(['The typical treebank architecture is as follows: Structures: A context-free backbone is augmented with trace-filler representations of non-local dependencies.', 'Due to the substantial differences between existing models of constituent structure, the question arises of how the theory independencf requirement, can be satisfied.', 'During annotation, the highest rated grammatical function labels Gi are calculated using the Viterbi algorithm and assigned to the structure, i.e., we calculate argma.x11 PQ (Ti 1Z-1, Ti.-2) PQ (Gi ITi).', 'Owing to the partial automation, the average annotation efficiency improves by 25% (from around 4 minutes to 3 minutes per sentence).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00051', '(95%-conf.int.', '0.00051', '-', '0.00051)']
['system', 'ROUGE-S*', 'Average_P:', '0.03571', '(95%-conf.int.', '0.03571', '-', '0.03571)']
['system', 'ROUGE-S*', 'Average_F:', '0.00101', '(95%-conf.int.', '0.00101', '-', '0.00101)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:28', 'F:1']
dict_values(['For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).'])
dict_values(['Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.', '(Hudson, 1984).', 'During the first phase, the focus is on annotating correct structures and a coarse-grained classification of grammatical functions, which represent the following areas of information: Dependency type: complements are further classified according to features such as category and case: clausal complements (OC), accusative objects (OA), datives (DA), etc.', 'In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00075', '(95%-conf.int.', '0.00075', '-', '0.00075)']
['system', 'ROUGE-S*', 'Average_P:', '0.01818', '(95%-conf.int.', '0.01818', '-', '0.01818)']
['system', 'ROUGE-S*', 'Average_F:', '0.00145', '(95%-conf.int.', '0.00145', '-', '0.00145)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1326', 'P:55', 'F:1']
0.551021813172529 0.04848636319557854 0.08325727197038843





input/ref/Task1/A97-1014_vardha.csv
input/res/Task1/A97-1014.annv3.csv
parsing: input/ref/Task1/A97-1014_vardha.csv
<S sid="72" ssid="17">In order to avoid inconsistencies, the corpus is annotated in two stages: basic annotation and nfirtellte714.</S>
original cit marker offset is 0
new cit marker offset is 0



["'72'"]
'72'
['72']
parsed_discourse_facet ['method_citation']
 <S sid="144" ssid="25">We distinguish five degrees of automation: So far, about 1100 sentences of our corpus have been annotated.</S>
original cit marker offset is 0
new cit marker offset is 0



["'144'"]
'144'
['144']
parsed_discourse_facet ['method_citation']
<S sid="14" ssid="4">Corpora annotated with syntactic structures are commonly referred to as trctbank.5.</S>
original cit marker offset is 0
new cit marker offset is 0



["'14'"]
'14'
['14']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'"]
'15'
['15']
parsed_discourse_facet ['method_citation']
  <S sid="36" ssid="26">As for free word order languages, the following features may cause problems: sition between the two poles.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
 <S sid="24" ssid="14">The typical treebank architecture is as follows: Structures: A context-free backbone is augmented with trace-filler representations of non-local dependencies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
 <S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["'160'"]
'160'
['160']
parsed_discourse_facet ['method_citation']
 <S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S>
original cit marker offset is 0
new cit marker offset is 0



["'151'"]
'151'
['151']
parsed_discourse_facet ['method_citation']
 <S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks') for stochastic grammar induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'"]
'4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["'160'"]
'160'
['160']
parsed_discourse_facet ['method_citation']
 <S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'167'"]
'167'
['167']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="29">Consider the German sentence (1) daran wird ihn Anna erkennen, &amp;di er weint at-it will him Anna recognise that he cries 'Anna will recognise him at his cry' A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'"]
'39'
['39']
parsed_discourse_facet ['method_citation']
 <S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S>
original cit marker offset is 0
new cit marker offset is 0



["'151'"]
'151'
['151']
parsed_discourse_facet ['method_citation']
<S sid="71" ssid="16">However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'71'"]
'71'
['71']
parsed_discourse_facet ['method_citation']
 <S sid="144" ssid="25">We distinguish five degrees of automation: So far, about 1100 sentences of our corpus have been annotated.</S>
original cit marker offset is 0
new cit marker offset is 0



["'144'"]
'144'
['144']
parsed_discourse_facet ['method_citation']
<S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["'160'"]
'160'
['160']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/A97-1014.annv3.csv
<S sid="13" ssid="3">The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S><S sid="169" ssid="11">Since the combinatorics of syntactic constructions creates a. demand for very large corpora., efficiency of annotation is an important. criterion for the success of the developed methodology and tools.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'137'", "'168'", "'169'"]
'13'
'137'
'168'
'169'
['13', '137', '168', '169']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="2">Realworld texts annotated with different strata of linguistic information can be used for grammar induction.</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'137'", "'140'", "'165'"]
'12'
'137'
'140'
'165'
['12', '137', '140', '165']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="28">Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S><S sid="141" ssid="22">The corpus is stored in a SQL database.</S><S sid="143" ssid="24">Sentences annotated in previous steps are used as training material for further processing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'140'", "'141'", "'143'"]
'38'
'140'
'141'
'143'
['38', '140', '141', '143']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="48" ssid="38">In order to reduce their ambiguity potential, rather simple, \flat\ trees should be employed, while more information can be expressed by a rich system of function labels.</S><S sid="51" ssid="41">This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.</S><S sid="53" ssid="43">A tree meeting these requirements is given below: Adv V NP NP V CPL NP V damn wird ihn Anna erkennen, dais er \vein!</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'48'", "'51'", "'53'"]
'15'
'48'
'51'
'53'
['15', '48', '51', '53']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="15">The underlying argument SirlteilITC is not represented directly, but can be recovered from the tree and trace-filler annotations.</S><S sid="39" ssid="29">Consider the German sentence (1) daran wird ihn Anna erkennen, &amp;di er weint at-it will him Anna recognise that he cries \Anna will recognise him at his cry\ A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes.</S><S sid="47" ssid="37">Argument structure can be represented in terms of unordered trees (with crossing branches).</S><S sid="51" ssid="41">This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'", "'39'", "'47'", "'51'"]
'25'
'39'
'47'
'51'
['25', '39', '47', '51']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="28">Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.</S><S sid="50" ssid="40">Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.</S><S sid="52" ssid="42">(Hudson, 1984).</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'50'", "'52'", "'167'"]
'38'
'50'
'52'
'167'
['38', '50', '52', '167']
parsed_discourse_facet ['method_citation']
<S sid="151" ssid="32">For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'151'", "'165'", "'167'", "'168'"]
'151'
'165'
'167'
'168'
['151', '165', '167', '168']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="1" ssid="1">We describe an annotation scheme and a tool developed for creating linguistically annotated corpora for non-configurational languages.</S><S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks\) for stochastic grammar induction.</S><S sid="159" ssid="1">As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.</S><S sid="165" ssid="7">In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'4'", "'159'", "'165'"]
'1'
'4'
'159'
'165'
['1', '4', '159', '165']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="0">An Annotation Scheme for Free Word Order Languages</S><S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="159" ssid="1">As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.</S><S sid="160" ssid="2">These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'15'", "'159'", "'160'"]
'0'
'15'
'159'
'160'
['0', '15', '159', '160']
parsed_discourse_facet ['hypothesis_citation']
<S sid="15" ssid="5">Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.</S><S sid="71" ssid="16">However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.</S><S sid="80" ssid="25">Separable verb prefixes are labeled SVP.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'71'", "'80'", "'167'"]
'15'
'71'
'80'
'167'
['15', '71', '80', '167']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="1">The work reported in this paper aims at providing syntactically annotated corpora (treebanks\) for stochastic grammar induction.</S><S sid="13" ssid="3">The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.</S><S sid="150" ssid="31">To keep the human annotator from missing errors made by the tagger, we additionally calculate the strongest competitor for each label G. If its probability is close to the winner (closeness is defined by a threshold on the quotient), the assignment is regarded as unreliable, and the annotator is asked to confirm the assignment.</S><S sid="168" ssid="10">We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'13'", "'150'", "'168'"]
'4'
'13'
'150'
'168'
['4', '13', '150', '168']
parsed_discourse_facet ['hypothesis_citation']
<S sid="12" ssid="2">Realworld texts annotated with different strata of linguistic information can be used for grammar induction.</S><S sid="33" ssid="23">(Lehmann et al., 1996), (Marcus et al., 1994), (Sampson, 1995)).</S><S sid="137" ssid="18">The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.</S><S sid="140" ssid="21">For the implementation, we used Tcl/Tk Version 4.1.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'33'", "'137'", "'140'"]
'12'
'33'
'137'
'140'
['12', '33', '137', '140']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="14">The typical treebank architecture is as follows: Structures: A context-free backbone is augmented with trace-filler representations of non-local dependencies.</S><S sid="31" ssid="21">Due to the substantial differences between existing models of constituent structure, the question arises of how the theory independencf requirement, can be satisfied.</S><S sid="149" ssid="30">During annotation, the highest rated grammatical function labels Gi are calculated using the Viterbi algorithm and assigned to the structure, i.e., we calculate argma.x11 PQ (Ti 1Z-1, Ti.-2) PQ (Gi ITi).</S><S sid="158" ssid="39">Owing to the partial automation, the average annotation efficiency improves by 25% (from around 4 minutes to 3 minutes per sentence).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'31'", "'149'", "'158'"]
'24'
'31'
'149'
'158'
['24', '31', '149', '158']
parsed_discourse_facet ['method_citation']
<S sid="50" ssid="40">Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.</S><S sid="52" ssid="42">(Hudson, 1984).</S><S sid="74" ssid="19">During the first phase, the focus is on annotating correct structures and a coarse-grained classification of grammatical functions, which represent the following areas of information: Dependency type: complements are further classified according to features such as category and case: clausal complements (OC), accusative objects (OA), datives (DA), etc.</S><S sid="167" ssid="9">In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'52'", "'74'", "'167'"]
'50'
'52'
'74'
'167'
['50', '52', '74', '167']
parsed_discourse_facet ['method_citation']
dict_values(['We distinguish five degrees of automation: So far, about 1100 sentences of our corpus have been annotated.'])
dict_values(['Realworld texts annotated with different strata of linguistic information can be used for grammar induction.', 'The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.', 'For the implementation, we used Tcl/Tk Version 4.1.', 'In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:21', 'F:0']
dict_values(['Corpora annotated with syntactic structures are commonly referred to as trctbank.5.'])
dict_values(['Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.', 'For the implementation, we used Tcl/Tk Version 4.1.', 'The corpus is stored in a SQL database.', 'Sentences annotated in previous steps are used as training material for further processing.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00178', '(95%-conf.int.', '0.00178', '-', '0.00178)']
['system', 'ROUGE-S*', 'Average_P:', '0.03571', '(95%-conf.int.', '0.03571', '-', '0.03571)']
['system', 'ROUGE-S*', 'Average_F:', '0.00340', '(95%-conf.int.', '0.00340', '-', '0.00340)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:561', 'P:28', 'F:1']
dict_values(['Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.'])
dict_values(['Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.', 'In order to reduce their ambiguity potential, rather simple, \\flat\\ trees should be employed, while more information can be expressed by a rich system of function labels.', 'This requirement speaks against the traditional sort of dependency trees, in which heads a,re represented as non-terminal nodes, cf.', 'A tree meeting these requirements is given below: Adv V NP NP V CPL NP V damn wird ihn Anna erkennen, dais er \\vein!'])
['system', 'ROUGE-S*', 'Average_R:', '0.06818', '(95%-conf.int.', '0.06818', '-', '0.06818)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.12766', '(95%-conf.int.', '0.12766', '-', '0.12766)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1540', 'P:105', 'F:105']
dict_values(['These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.'])
dict_values(['Due to the frequency of discontinuous constituents in non-configurational languages, the filler-trace mechanism would be used very often, yielding syntactic trees fairly different from the underlying predicate-argument structures.', 'Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.', '(Hudson, 1984).', 'In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:780', 'P:21', 'F:0']
dict_values(['For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).'])
dict_values(['For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).', 'In addition the approach provides empirical material for psycholinguistic investigation, since preferences for the choice of certain syntactic constructions, linea.rizations, and attachments that have been observed in online experiments of language production and comprehension can now be put in relation with the frequency of these alternatives in larger amounts of texts.', 'In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.', 'We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02909', '(95%-conf.int.', '0.02909', '-', '0.02909)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.05653', '(95%-conf.int.', '0.05653', '-', '0.05653)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:55', 'F:55']
dict_values(['These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.'])
dict_values(['An Annotation Scheme for Free Word Order Languages', 'Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.', 'As the annotation scheme described in this paper focusses on annotating argument structure rather than constituent trees, it differs from existing treebanks in several aspects.', 'These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02561', '(95%-conf.int.', '0.02561', '-', '0.02561)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.04994', '(95%-conf.int.', '0.04994', '-', '0.04994)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:21', 'F:21']
dict_values(['In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
dict_values(['Existing treebank annotation schemes exhibit a fairly uniform architecture, as they all have to meet the same basic requirements, namely: Descriptivity: Grammatical phenomena are to be described rather than explained.', 'However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.', 'Separable verb prefixes are labeled SVP.', 'In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
['system', 'ROUGE-S*', 'Average_R:', '0.10569', '(95%-conf.int.', '0.10569', '-', '0.10569)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.19118', '(95%-conf.int.', '0.19118', '-', '0.19118)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:91', 'F:91']
dict_values(["Consider the German sentence (1) daran wird ihn Anna erkennen, &di er weint at-it will him Anna recognise that he cries 'Anna will recognise him at his cry' A sample constituent structure is given below: The fairly short sentence contains three non-local dependencies, marked by co-references between traces and the corresponding nodes."])
dict_values(['The work reported in this paper aims at providing syntactically annotated corpora (treebanks\\) for stochastic grammar induction.', 'The data-drivenness of this approach presents a clear advantage over the traditional, idealised notion of competence grammar.', 'To keep the human annotator from missing errors made by the tagger, we additionally calculate the strongest competitor for each label G. If its probability is close to the winner (closeness is defined by a threshold on the quotient), the assignment is regarded as unreliable, and the annotator is asked to confirm the assignment.', 'We will closely coordinate the further development of our corpus with the annotation work in Verbmobil and with other German efforts in corpus annotation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:406', 'F:0']
dict_values(['For evaluation, the already annotated sentences were divided into two disjoint sets, one for training (90% of the corpus), the other one for testing (10%).'])
dict_values(['Realworld texts annotated with different strata of linguistic information can be used for grammar induction.', '(Lehmann et al., 1996), (Marcus et al., 1994), (Sampson, 1995)).', 'The following commands are available: The three tagsets used by the annotation tool (for words, phrases, and edges) are variable and are stored together with the corpus.', 'For the implementation, we used Tcl/Tk Version 4.1.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00202', '(95%-conf.int.', '0.00202', '-', '0.00202)']
['system', 'ROUGE-S*', 'Average_P:', '0.01818', '(95%-conf.int.', '0.01818', '-', '0.01818)']
['system', 'ROUGE-S*', 'Average_F:', '0.00363', '(95%-conf.int.', '0.00363', '-', '0.00363)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:496', 'P:55', 'F:1']
dict_values(['However, there is a trade-off between the granularity of information encoded in the labels and the speed and accuracy of annotation.'])
dict_values(['The typical treebank architecture is as follows: Structures: A context-free backbone is augmented with trace-filler representations of non-local dependencies.', 'Due to the substantial differences between existing models of constituent structure, the question arises of how the theory independencf requirement, can be satisfied.', 'During annotation, the highest rated grammatical function labels Gi are calculated using the Viterbi algorithm and assigned to the structure, i.e., we calculate argma.x11 PQ (Ti 1Z-1, Ti.-2) PQ (Gi ITi).', 'Owing to the partial automation, the average annotation efficiency improves by 25% (from around 4 minutes to 3 minutes per sentence).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00051', '(95%-conf.int.', '0.00051', '-', '0.00051)']
['system', 'ROUGE-S*', 'Average_P:', '0.03571', '(95%-conf.int.', '0.03571', '-', '0.03571)']
['system', 'ROUGE-S*', 'Average_F:', '0.00101', '(95%-conf.int.', '0.00101', '-', '0.00101)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:28', 'F:1']
dict_values(['These differences can be illustrated by a comparison with the Penn Treebank annotation scheme.'])
dict_values(['Thus, notions such as head should be distinguished at the level of syntactic functions rather than structures.', '(Hudson, 1984).', 'During the first phase, the focus is on annotating correct structures and a coarse-grained classification of grammatical functions, which represent the following areas of information: Dependency type: complements are further classified according to features such as category and case: clausal complements (OC), accusative objects (OA), datives (DA), etc.', 'In the second phase of the project Verbmobil a. treebank for :30,000 German spoken sentences as well as for the same amount of English and Japanese sentences will be created.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1326', 'P:21', 'F:0']
0.3717818148019835 0.02117090889844629 0.03939545418731405





input/ref/Task1/D09-1092_swastika.csv
input/res/Task1/D09-1092.annv3.csv
parsing: input/ref/Task1/D09-1092_swastika.csv
<S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



['193']
193
['193']
parsed_discourse_facet ['result_citation']
<S sid="114" ssid="63">Ideally, the &#8220;glue&#8221; documents in g will be sufficient to align the topics across languages, and will cause comparable documents in S to have similar distributions over topics even though they are modeled independently.</S>
original cit marker offset is 0
new cit marker offset is 0



['114']
114
['114']
parsed_discourse_facet ['aim_citation']
<S sid="138" ssid="87">We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.</S>
original cit marker offset is 0
new cit marker offset is 0



['138']
138
['138']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="14">In this paper, we use two polylingual corpora to answer various critical questions related to polylingual topic models.</S>
original cit marker offset is 0
new cit marker offset is 0



['18']
18
['18']
parsed_discourse_facet ['method_citation']
<S sid="55" ssid="4">The EuroParl corpus consists of parallel texts in eleven western European languages: Danish, German, Greek, English, Spanish, Finnish, French, Italian, Dutch, Portuguese and Swedish.</S>
original cit marker offset is 0
new cit marker offset is 0



['55']
55
['55']
parsed_discourse_facet ['method_citation']
<S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['192']
192
['192']
parsed_discourse_facet ['result_citation']
<S sid="119" ssid="68">The lower the divergence, the more similar the distributions are to each other.</S>
original cit marker offset is 0
new cit marker offset is 0



['119']
119
['119']
parsed_discourse_facet ['result_citation']
<S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S>
original cit marker offset is 0
new cit marker offset is 0



['148']
148
['148']
parsed_discourse_facet ['method_citation']
<S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



['193']
193
['193']
parsed_discourse_facet ['result_citation']
<S sid="184" ssid="18">Interestingly, we find that almost all languages in our corpus, including several pairs that have historically been in conflict, show average JS divergences of between approximately 0.08 and 0.12 for T = 400, consistent with our findings for EuroParl translations.</S>
original cit marker offset is 0
new cit marker offset is 0



['184']
184
['184']
parsed_discourse_facet ['result_citation']
<S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



['193']
193
['193']
parsed_discourse_facet ['result_citation']
<S sid="163" ssid="112">Performance continues to improve with longer documents, most likely due to better topic inference.</S>
original cit marker offset is 0
new cit marker offset is 0



['163']
163
['163']
parsed_discourse_facet ['result_citation']
<S sid="184" ssid="18">Interestingly, we find that almost all languages in our corpus, including several pairs that have historically been in conflict, show average JS divergences of between approximately 0.08 and 0.12 for T = 400, consistent with our findings for EuroParl translations.</S>
original cit marker offset is 0
new cit marker offset is 0



['184']
184
['184']
parsed_discourse_facet ['result_citation']
<S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S>
original cit marker offset is 0
new cit marker offset is 0



['148']
148
['148']
parsed_discourse_facet ['method_citation']
<S sid="184" ssid="18">Interestingly, we find that almost all languages in our corpus, including several pairs that have historically been in conflict, show average JS divergences of between approximately 0.08 and 0.12 for T = 400, consistent with our findings for EuroParl translations.</S>
original cit marker offset is 0
new cit marker offset is 0



['184']
184
['184']
parsed_discourse_facet ['result_citation']
<S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



['193']
193
['193']
parsed_discourse_facet ['result_citation']
<S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['192']
192
['192']
parsed_discourse_facet ['result_citation']
<S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['105']
105
['105']
parsed_discourse_facet ['method_citation']
    <S sid="10" ssid="6">We demonstrate its utility and explore its characteristics using two polylingual corpora: proceedings of the European parliament (in eleven languages) and a collection of Wikipedia articles (in twelve languages).</S>
original cit marker offset is 0
new cit marker offset is 0



['10']
10
['10']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/D09-1092.annv3.csv
<S sid="21" ssid="17">The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.</S><S sid="142" ssid="91">EN &#8220;comitology&#8221; and IT lang Topics at P = 0.01 &#8220;comitalogia&#8221;) that simply were not in the lexica.</S><S sid="185" ssid="19">Subtle differences of sentiment may be below the granularity of the model. sadwrn blaned gallair at lloeren mytholeg space nasa sojus flug mission &#948;&#953;&#945;&#963;&#964;&#951;&#956;&#953;&#954;&#972; sts nasa &#945;&#947;&#947;&#955; small space mission launch satellite nasa spacecraft sojuz nasa apollo ensimm&#352;inen space lento spatiale mission orbite mars satellite spatial &#1514;&#1497;&#1504;&#1499;&#1493;&#1514; &#1488; &#1512;&#1493;&#1491;&#1499; &#1500;&#1500; &#1495; &#1509;&#1512; &#1488;&#1492; &#1500;&#1500;&#1495;&#1492; spaziale missione programma space sojuz stazione misja kosmicznej stacji misji space nasa &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080;&#1081; &#1089;&#1086;&#1102;&#1079; &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1075;&#1086; &#1089;&#1087;&#1091;&#1090;&#1085;&#1080;&#1082; &#1089;&#1090;&#1072;&#1085;&#1094;&#1080;&#1080; uzay soyuz ay uzaya salyut sovyetler sbaen madrid el la jos6 sbaeneg de spanischer spanischen spanien madrid la &#953;&#963;&#960;&#945;&#957;&#943;&#945;&#962; &#953;&#963;&#960;&#945;&#957;&#943;&#945; de &#953;&#963;&#960;&#945;&#957;&#972;&#962; &#957;&#964;&#949; &#956;&#945;&#948;&#961;&#943;&#964;&#951; de spanish spain la madrid y espanja de espanjan madrid la real espagnol espagne madrid espagnole juan y de spagna spagnolo spagnola madrid el de hiszpa&#324;ski hiszpanii la juan y &#1076;&#1077; &#1084;&#1072;&#1076;&#1088;&#1080;&#1076; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1080; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1103; &#1080;&#1089;&#1087;&#1072;&#1085;&#1089;&#1082;&#1080;&#1081; de ispanya ispanyol madrid la kOba real bardd gerddi iaith beirdd fardd gymraeg dichter schriftsteller literatur gedichte gedicht werk &#960;&#959;&#953;&#951;&#964;&#942;&#962; &#960;&#959;&#943;&#951;&#963;&#951; &#960;&#959;&#953;&#951;&#964;&#942; &#941;&#961;&#947;&#959; &#960;&#959;&#953;&#951;&#964;&#941;&#962; &#960;&#959;&#953;&#942;&#956;&#945;&#964;&#945; poet poetry literature literary poems poem runoilija kirjailija kirjallisuuden kirjoitti runo julkaisi poste 6crivain litt6rature po6sie litt6raire ses Overall, these scores indicate that although individual pages may show disagreement, Wikipedia is on average consistent between languages.</S><S sid="186" ssid="20">Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'142'", "'185'", "'186'"]
'21'
'142'
'185'
'186'
['21', '142', '185', '186']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="78" ssid="27">Although the model does not distinguish between topic assignment variables within a given document tuple (so it is technically incorrect to speak of different posterior distributions over topics for different documents in a given tuple), we can nevertheless divide topic assignment variables between languages and use them to estimate a Dirichlet-multinomial posterior distribution for each language in each tuple.</S><S sid="172" ssid="6">Second, because comparable texts may not use exactly the same topics, it becomes crucially important to be able to characterize differences in topic prevalence at the document level (do different languages have different perspectives on the same article?) and at the language-wide level (which topics do particular languages focus on?).</S><S sid="177" ssid="11">In the English version of Wikipedia we dropped all articles that were not linked to by any other language in our set.</S><S sid="186" ssid="20">Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'78'", "'172'", "'177'", "'186'"]
'78'
'172'
'177'
'186'
['78', '172', '177', '186']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="58">One simple way to achieve this topic alignment is to add a small set of comparable document tuples that provide sufficient &#8220;glue&#8221; to bind the topics together.</S><S sid="128" ssid="77">Although the PLTM is clearly not a substitute for a machine translation system&#8212;it has no way to represent syntax or even multi-word phrases&#8212;it is clear from the examples in figure 2 that the sets of high probability words in different languages for a given topic are likely to include translations.</S><S sid="137" ssid="86">For every topic t we select a small number K of the most probable words in English (e) and in each &#8220;translation&#8221; language (E): Wte and Wtt, respectively.</S><S sid="138" ssid="87">We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.</S>
original cit marker offset is 0
new cit marker offset is 0



["'109'", "'128'", "'137'", "'138'"]
'109'
'128'
'137'
'138'
['109', '128', '137', '138']
parsed_discourse_facet ['method_citation']
<S sid="0">Polylingual Topic Models</S><S sid="2" ssid="2">Meanwhile, massive collections of interlinked documents in dozens of languages, such as Wikipedia, are now widely available, calling for tools that can characterize content in many languages.</S><S sid="25" ssid="1">Bilingual topic models for parallel texts with word-to-word alignments have been studied previously using the HM-bitam model (Zhao and Xing, 2007).</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'25'", "'30'"]
'0'
'2'
'25'
'30'
['0', '2', '25', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S><S sid="21" ssid="17">The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.</S><S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'22'", "'148'"]
'20'
'21'
'22'
'148'
['20', '21', '22', '148']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="9" ssid="5">In this paper, we present the polylingual topic model (PLTM).</S><S sid="92" ssid="41">We perform five estimation runs for each document and then calculate standard errors using a bootstrap method.</S><S sid="107" ssid="56">No paper is exactly comparable to any other paper, but they are all roughly topically similar.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'92'", "'107'", "'192'"]
'9'
'92'
'107'
'192'
['9', '92', '107', '192']
parsed_discourse_facet ['hypothesis_citation']
<S sid="118" ssid="67">We calculate the Jensen-Shannon divergence between the topic distributions for each pair of individual documents in S that were originally part of the same tuple prior to separation.</S><S sid="119" ssid="68">The lower the divergence, the more similar the distributions are to each other.</S><S sid="121" ssid="70">Table 3 shows mean JS divergences for each value of p. As expected, JS divergence is greater than that obtained when all tuples are left intact.</S><S sid="122" ssid="71">Divergence drops significantly when the proportion of &#8220;glue&#8221; tuples increases from 0.01 to 0.25.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'", "'119'", "'121'", "'122'"]
'118'
'119'
'121'
'122'
['118', '119', '121', '122']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="36" ssid="2">Each tuple is a set of documents that are loosely equivalent to each other, but written in different languages, e.g., corresponding Wikipedia articles in French, English and German.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'36'", "'105'", "'192'"]
'3'
'36'
'105'
'192'
['3', '36', '105', '192']
parsed_discourse_facet ['aim_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="18" ssid="14">In this paper, we use two polylingual corpora to answer various critical questions related to polylingual topic models.</S><S sid="65" ssid="14">This topic provides an illustration of the variation in technical terminology captured by PLTM, including the wide array of acronyms used by different languages.</S><S sid="99" ssid="48">Figure 5 shows the proportion of all tokens in English and Finnish assigned to each topic under LDA and PLTM with 800 topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'18'", "'65'", "'99'"]
'3'
'18'
'65'
'99'
['3', '18', '65', '99']
parsed_discourse_facet ['hypothesis_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="4" ssid="4">We explore the model&#8217;s characteristics using two large corpora, each with over ten different languages, and demonstrate its usefulness in supporting machine translation and tracking topic trends across languages.</S><S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'4'", "'19'", "'30'"]
'3'
'4'
'19'
'30'
['3', '4', '19', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</S><S sid="155" ssid="104">Finally, for each pair of languages (&#8220;query&#8221; and &#8220;target&#8221;) we calculate the difference between the topic distribution for each held-out document in the query language and the topic distribution for each held-out document in the target language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'30'", "'77'", "'155'"]
'22'
'30'
'77'
'155'
['22', '30', '77', '155']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="31" ssid="7">They also provide little analysis of the differences between polylingual and single-language topic models.</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'30'", "'31'", "'154'"]
'22'
'30'
'31'
'154'
['22', '30', '31', '154']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S><S sid="155" ssid="104">Finally, for each pair of languages (&#8220;query&#8221; and &#8220;target&#8221;) we calculate the difference between the topic distribution for each held-out document in the query language and the topic distribution for each held-out document in the target language.</S><S sid="156" ssid="105">We use both Jensen-Shannon divergence and cosine distance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'154'", "'155'", "'156'"]
'6'
'154'
'155'
'156'
['6', '154', '155', '156']
parsed_discourse_facet ['aim_citation', 'implication_citation']
<S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S><S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S><S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'20'", "'148'", "'154'"]
'19'
'20'
'148'
'154'
['19', '20', '148', '154']
parsed_discourse_facet ['method_citation', 'implication_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'30'", "'35'", "'105'"]
'6'
'30'
'35'
'105'
['6', '30', '35', '105']
parsed_discourse_facet ['aim_citation']
<S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S><S sid="169" ssid="3">In this section, we explore two questions relating to comparable text corpora and polylingual topic modeling.</S><S sid="170" ssid="4">First, we explore whether comparable document tuples support the alignment of fine-grained topics, as demonstrated earlier using parallel documents.</S><S sid="171" ssid="5">This property is useful for building machine translation systems as well as for human readers who are either learning new languages or analyzing texts in languages they do not know.</S>
original cit marker offset is 0
new cit marker offset is 0



["'35'", "'169'", "'170'", "'171'"]
'35'
'169'
'170'
'171'
['35', '169', '170', '171']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="75">These results demonstrate that PLTM is appropriate for aligning topics in corpora that have only a small subset of comparable documents.</S><S sid="147" ssid="96">These aligned document pairs could then be fed into standard machine translation systems as training data.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S><S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'", "'147'", "'192'", "'193'"]
'126'
'147'
'192'
'193'
['126', '147', '192', '193']
parsed_discourse_facet ['results_citation']
<S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="85" ssid="34">Smoothed histograms of inter&#8722;language JS divergence A topic model specifies a probability distribution over documents, or in the case of PLTM, document tuples.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S><S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'85'", "'105'", "'193'"]
'30'
'85'
'105'
'193'
['30', '85', '105', '193']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="24" ssid="20">By linking topics across languages, polylingual topic models can increase cross-cultural understanding by providing readers with the ability to characterize the contents of collections in unfamiliar languages and identify trends in topic prevalence.</S><S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'24'", "'77'", "'192'"]
'3'
'24'
'77'
'192'
['3', '24', '77', '192']
parsed_discourse_facet ['method_citation', 'aim_citation']
dict_values(['We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.'])
dict_values(['The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.', 'EN &#8220;comitology&#8221; and IT lang Topics at P = 0.01 &#8220;comitalogia&#8221;) that simply were not in the lexica.', 'Subtle differences of sentiment may be below the granularity of the model. sadwrn blaned gallair at lloeren mytholeg space nasa sojus flug mission &#948;&#953;&#945;&#963;&#964;&#951;&#956;&#953;&#954;&#972; sts nasa &#945;&#947;&#947;&#955; small space mission launch satellite nasa spacecraft sojuz nasa apollo ensimm&#352;inen space lento spatiale mission orbite mars satellite spatial &#1514;&#1497;&#1504;&#1499;&#1493;&#1514; &#1488; &#1512;&#1493;&#1491;&#1499; &#1500;&#1500; &#1495; &#1509;&#1512; &#1488;&#1492; &#1500;&#1500;&#1495;&#1492; spaziale missione programma space sojuz stazione misja kosmicznej stacji misji space nasa &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080;&#1081; &#1089;&#1086;&#1102;&#1079; &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1075;&#1086; &#1089;&#1087;&#1091;&#1090;&#1085;&#1080;&#1082; &#1089;&#1090;&#1072;&#1085;&#1094;&#1080;&#1080; uzay soyuz ay uzaya salyut sovyetler sbaen madrid el la jos6 sbaeneg de spanischer spanischen spanien madrid la &#953;&#963;&#960;&#945;&#957;&#943;&#945;&#962; &#953;&#963;&#960;&#945;&#957;&#943;&#945; de &#953;&#963;&#960;&#945;&#957;&#972;&#962; &#957;&#964;&#949; &#956;&#945;&#948;&#961;&#943;&#964;&#951; de spanish spain la madrid y espanja de espanjan madrid la real espagnol espagne madrid espagnole juan y de spagna spagnolo spagnola madrid el de hiszpa&#324;ski hiszpanii la juan y &#1076;&#1077; &#1084;&#1072;&#1076;&#1088;&#1080;&#1076; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1080; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1103; &#1080;&#1089;&#1087;&#1072;&#1085;&#1089;&#1082;&#1080;&#1081; de ispanya ispanyol madrid la kOba real bardd gerddi iaith beirdd fardd gymraeg dichter schriftsteller literatur gedichte gedicht werk &#960;&#959;&#953;&#951;&#964;&#942;&#962; &#960;&#959;&#943;&#951;&#963;&#951; &#960;&#959;&#953;&#951;&#964;&#942; &#941;&#961;&#947;&#959; &#960;&#959;&#953;&#951;&#964;&#941;&#962; &#960;&#959;&#953;&#942;&#956;&#945;&#964;&#945; poet poetry literature literary poems poem runoilija kirjailija kirjallisuuden kirjoitti runo julkaisi poste 6crivain litt6rature po6sie litt6raire ses Overall, these scores indicate that although individual pages may show disagreement, Wikipedia is on average consistent between languages.', 'Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:65703', 'P:45', 'F:0']
dict_values(['Ideally, the &#8220;glue&#8221; documents in g will be sufficient to align the topics across languages, and will cause comparable documents in S to have similar distributions over topics even though they are modeled independently.'])
dict_values(['Although the model does not distinguish between topic assignment variables within a given document tuple (so it is technically incorrect to speak of different posterior distributions over topics for different documents in a given tuple), we can nevertheless divide topic assignment variables between languages and use them to estimate a Dirichlet-multinomial posterior distribution for each language in each tuple.', 'Second, because comparable texts may not use exactly the same topics, it becomes crucially important to be able to characterize differences in topic prevalence at the document level (do different languages have different perspectives on the same article?) and at the language-wide level (which topics do particular languages focus on?).', 'In the English version of Wikipedia we dropped all articles that were not linked to by any other language in our set.', 'Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00989', '(95%-conf.int.', '0.00989', '-', '0.00989)']
['system', 'ROUGE-S*', 'Average_P:', '0.21667', '(95%-conf.int.', '0.21667', '-', '0.21667)']
['system', 'ROUGE-S*', 'Average_F:', '0.01892', '(95%-conf.int.', '0.01892', '-', '0.01892)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2628', 'P:120', 'F:26']
dict_values(['We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.'])
dict_values(['One simple way to achieve this topic alignment is to add a small set of comparable document tuples that provide sufficient &#8220;glue&#8221; to bind the topics together.', 'Although the PLTM is clearly not a substitute for a machine translation system&#8212;it has no way to represent syntax or even multi-word phrases&#8212;it is clear from the examples in figure 2 that the sets of high probability words in different languages for a given topic are likely to include translations.', 'For every topic t we select a small number K of the most probable words in English (e) and in each &#8220;translation&#8221; language (E): Wte and Wtt, respectively.', 'We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03528', '(95%-conf.int.', '0.03528', '-', '0.03528)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.06815', '(95%-conf.int.', '0.06815', '-', '0.06815)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2211', 'P:78', 'F:78']
dict_values(['In this paper, we use two polylingual corpora to answer various critical questions related to polylingual topic models.'])
dict_values(['Polylingual Topic Models', 'Meanwhile, massive collections of interlinked documents in dozens of languages, such as Wikipedia, are now widely available, calling for tools that can characterize content in many languages.', 'Bilingual topic models for parallel texts with word-to-word alignments have been studied previously using the HM-bitam model (Zhao and Xing, 2007).', 'However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00610', '(95%-conf.int.', '0.00610', '-', '0.00610)']
['system', 'ROUGE-S*', 'Average_P:', '0.11111', '(95%-conf.int.', '0.11111', '-', '0.11111)']
['system', 'ROUGE-S*', 'Average_F:', '0.01156', '(95%-conf.int.', '0.01156', '-', '0.01156)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:45', 'F:5']
dict_values(['The EuroParl corpus consists of parallel texts in eleven western European languages: Danish, German, Greek, English, Spanish, Finnish, French, Italian, Dutch, Portuguese and Swedish.'])
dict_values(['We also explore how the characteristics of different languages affect topic model performance.', 'The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.', 'We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.', 'To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00157', '(95%-conf.int.', '0.00157', '-', '0.00157)']
['system', 'ROUGE-S*', 'Average_P:', '0.01053', '(95%-conf.int.', '0.01053', '-', '0.01053)']
['system', 'ROUGE-S*', 'Average_F:', '0.00273', '(95%-conf.int.', '0.00273', '-', '0.00273)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1275', 'P:190', 'F:2']
dict_values(['The lower the divergence, the more similar the distributions are to each other.'])
dict_values(['We calculate the Jensen-Shannon divergence between the topic distributions for each pair of individual documents in S that were originally part of the same tuple prior to separation.', 'The lower the divergence, the more similar the distributions are to each other.', 'Table 3 shows mean JS divergences for each value of p. As expected, JS divergence is greater than that obtained when all tuples are left intact.', 'Divergence drops significantly when the proportion of &#8220;glue&#8221; tuples increases from 0.01 to 0.25.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00634', '(95%-conf.int.', '0.00634', '-', '0.00634)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.01261', '(95%-conf.int.', '0.01261', '-', '0.01261)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:946', 'P:6', 'F:6']
dict_values(['To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.'])
dict_values(['We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.', 'We also explore how the characteristics of different languages affect topic model performance.', 'To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.', 'We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).'])
['system', 'ROUGE-S*', 'Average_R:', '0.12274', '(95%-conf.int.', '0.12274', '-', '0.12274)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.21864', '(95%-conf.int.', '0.21864', '-', '0.21864)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:210', 'F:210']
dict_values(['Interestingly, we find that almost all languages in our corpus, including several pairs that have historically been in conflict, show average JS divergences of between approximately 0.08 and 0.12 for T = 400, consistent with our findings for EuroParl translations.'])
dict_values(['Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).', 'However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.', 'The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.', 'An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3160', 'P:231', 'F:0']
dict_values(['We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.'])
dict_values(['These results demonstrate that PLTM is appropriate for aligning topics in corpora that have only a small subset of comparable documents.', 'These aligned document pairs could then be fed into standard machine translation systems as training data.', 'We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.', 'We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05769', '(95%-conf.int.', '0.05769', '-', '0.05769)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10909', '(95%-conf.int.', '0.10909', '-', '0.10909)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:780', 'P:45', 'F:45']
dict_values(['We demonstrate its utility and explore its characteristics using two polylingual corpora: proceedings of the European parliament (in eleven languages) and a collection of Wikipedia articles (in twelve languages).'])
dict_values(['We introduce a polylingual topic model that discovers topics aligned across multiple languages.', 'By linking topics across languages, polylingual topic models can increase cross-cultural understanding by providing readers with the ability to characterize the contents of collections in unfamiliar languages and identify trends in topic prevalence.', 'Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.', 'We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00307', '(95%-conf.int.', '0.00307', '-', '0.00307)']
['system', 'ROUGE-S*', 'Average_P:', '0.05000', '(95%-conf.int.', '0.05000', '-', '0.05000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00579', '(95%-conf.int.', '0.00579', '-', '0.00579)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:120', 'F:6']
0.43883099561169003 0.02426799975732 0.044748999552510015





input/ref/Task1/D09-1092_sweta.csv
input/res/Task1/D09-1092.annv3.csv
parsing: input/ref/Task1/D09-1092_sweta.csv
 <S sid="32" ssid="8">Outside of the field of topic modeling, Kawaba et al. (Kawaba et al., 2008) use a Wikipedia-based model to perform sentiment analysis of blog posts.</S>
original cit marker offset is 0
new cit marker offset is 0



["32'"]
32'
['32']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">Additionally, PLTM assumes that each &#8220;topic&#8221; consists of a set of discrete distributions over words&#8212;one for each language l = 1, ... , L. In other words, rather than using a single set of topics &#934; = {&#966;1, ... , &#966;T}, as in LDA, there are L sets of language-specific topics, &#934;1, ... , &#934;L, each of which is drawn from a language-specific symmetric Dirichlet with concentration parameter &#946;l.</S>
original cit marker offset is 0
new cit marker offset is 0



["39'"]
39'
['39']
parsed_discourse_facet ['method_citation']
<S sid="138" ssid="87">We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.</S>
original cit marker offset is 0
new cit marker offset is 0



["138'"]
138'
['138']
parsed_discourse_facet ['method_citation']
 <S sid="196" ssid="5">When applied to comparable document collections such as Wikipedia, PLTM supports data-driven analysis of differences and similarities across all languages for readers who understand any one language.</S>
original cit marker offset is 0
new cit marker offset is 0



["196'"]
196'
['196']
parsed_discourse_facet ['method_citation']
<S sid="111" ssid="60">In order to simulate this scenario we create a set of variations of the EuroParl corpus by treating some documents as if they have no parallel/comparable texts &#8211; i.e., we put each of these documents in a single-document tuple.</S>
original cit marker offset is 0
new cit marker offset is 0



["111'"]
111'
['111']
parsed_discourse_facet ['method_citation']
<S sid="128" ssid="77">Although the PLTM is clearly not a substitute for a machine translation system&#8212;it has no way to represent syntax or even multi-word phrases&#8212;it is clear from the examples in figure 2 that the sets of high probability words in different languages for a given topic are likely to include translations.</S>
original cit marker offset is 0
new cit marker offset is 0



["128'"]
128'
['128']
parsed_discourse_facet ['method_citation']
<S sid="122" ssid="71">Divergence drops significantly when the proportion of &#8220;glue&#8221; tuples increases from 0.01 to 0.25.</S>
original cit marker offset is 0
new cit marker offset is 0



["122'"]
122'
['122']
parsed_discourse_facet ['method_citation']
 <S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S>
original cit marker offset is 0
new cit marker offset is 0



["35'"]
35'
['35']
parsed_discourse_facet ['method_citation']
 <S sid="110" ssid="59">Continuing with the example above, one might extract a set of connected Wikipedia articles related to the focus of the journal and then train PLTM on a joint corpus consisting of journal papers and Wikipedia articles.</S>
original cit marker offset is 0
new cit marker offset is 0



["110'"]
110'
['110']
parsed_discourse_facet ['method_citation']
<S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["30'"]
30'
['30']
parsed_discourse_facet ['method_citation']
    <S sid="146" ssid="95">In addition to enhancing lexicons by aligning topic-specific vocabulary, PLTM may also be useful for adapting machine translation systems to new domains by finding translations or near translations in an unstructured corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["146'"]
146'
['146']
parsed_discourse_facet ['method_citation']
<S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</
original cit marker offset is 0
new cit marker offset is 0



["77'"]
77'
['77']
parsed_discourse_facet ['method_citation']
 <S sid="156" ssid="105">We use both Jensen-Shannon divergence and cosine distance.</S>
original cit marker offset is 0
new cit marker offset is 0



["156'"]
156'
['156']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="7">They also provide little analysis of the differences between polylingual and single-language topic models.</S>
original cit marker offset is 0
new cit marker offset is 0



["31'"]
31'
['31']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S>
original cit marker offset is 0
new cit marker offset is 0



["19'"]
19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="131" ssid="80">We evaluate sets of high-probability words in each topic and multilingual &#8220;synsets&#8221; by comparing them to entries in human-constructed bilingual dictionaries, as done by Haghighi et al. (2008).</S>
original cit marker offset is 0
new cit marker offset is 0



["131'"]
131'
['131']
parsed_discourse_facet ['method_citation']
<S sid="196" ssid="5">When applied to comparable document collections such as Wikipedia, PLTM supports data-driven analysis of differences and similarities across all languages for readers who understand any one language.</S>
original cit marker offset is 0
new cit marker offset is 0



["196'"]
196'
['196']
parsed_discourse_facet ['method_citation']
<S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["192'"]
192'
['192']
parsed_discourse_facet ['method_citation']
<S sid="195" ssid="4">Additionally, PLTM can support the creation of bilingual lexica for low resource language pairs, providing candidate translations for more computationally intense alignment processes without the sentence-aligned translations typically used in such tasks.</S>
original cit marker offset is 0
new cit marker offset is 0



["195'"]
195'
['195']
parsed_discourse_facet ['method_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["6'"]
6'
['6']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/D09-1092.annv3.csv
<S sid="21" ssid="17">The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.</S><S sid="142" ssid="91">EN &#8220;comitology&#8221; and IT lang Topics at P = 0.01 &#8220;comitalogia&#8221;) that simply were not in the lexica.</S><S sid="185" ssid="19">Subtle differences of sentiment may be below the granularity of the model. sadwrn blaned gallair at lloeren mytholeg space nasa sojus flug mission &#948;&#953;&#945;&#963;&#964;&#951;&#956;&#953;&#954;&#972; sts nasa &#945;&#947;&#947;&#955; small space mission launch satellite nasa spacecraft sojuz nasa apollo ensimm&#352;inen space lento spatiale mission orbite mars satellite spatial &#1514;&#1497;&#1504;&#1499;&#1493;&#1514; &#1488; &#1512;&#1493;&#1491;&#1499; &#1500;&#1500; &#1495; &#1509;&#1512; &#1488;&#1492; &#1500;&#1500;&#1495;&#1492; spaziale missione programma space sojuz stazione misja kosmicznej stacji misji space nasa &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080;&#1081; &#1089;&#1086;&#1102;&#1079; &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1075;&#1086; &#1089;&#1087;&#1091;&#1090;&#1085;&#1080;&#1082; &#1089;&#1090;&#1072;&#1085;&#1094;&#1080;&#1080; uzay soyuz ay uzaya salyut sovyetler sbaen madrid el la jos6 sbaeneg de spanischer spanischen spanien madrid la &#953;&#963;&#960;&#945;&#957;&#943;&#945;&#962; &#953;&#963;&#960;&#945;&#957;&#943;&#945; de &#953;&#963;&#960;&#945;&#957;&#972;&#962; &#957;&#964;&#949; &#956;&#945;&#948;&#961;&#943;&#964;&#951; de spanish spain la madrid y espanja de espanjan madrid la real espagnol espagne madrid espagnole juan y de spagna spagnolo spagnola madrid el de hiszpa&#324;ski hiszpanii la juan y &#1076;&#1077; &#1084;&#1072;&#1076;&#1088;&#1080;&#1076; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1080; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1103; &#1080;&#1089;&#1087;&#1072;&#1085;&#1089;&#1082;&#1080;&#1081; de ispanya ispanyol madrid la kOba real bardd gerddi iaith beirdd fardd gymraeg dichter schriftsteller literatur gedichte gedicht werk &#960;&#959;&#953;&#951;&#964;&#942;&#962; &#960;&#959;&#943;&#951;&#963;&#951; &#960;&#959;&#953;&#951;&#964;&#942; &#941;&#961;&#947;&#959; &#960;&#959;&#953;&#951;&#964;&#941;&#962; &#960;&#959;&#953;&#942;&#956;&#945;&#964;&#945; poet poetry literature literary poems poem runoilija kirjailija kirjallisuuden kirjoitti runo julkaisi poste 6crivain litt6rature po6sie litt6raire ses Overall, these scores indicate that although individual pages may show disagreement, Wikipedia is on average consistent between languages.</S><S sid="186" ssid="20">Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'142'", "'185'", "'186'"]
'21'
'142'
'185'
'186'
['21', '142', '185', '186']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="78" ssid="27">Although the model does not distinguish between topic assignment variables within a given document tuple (so it is technically incorrect to speak of different posterior distributions over topics for different documents in a given tuple), we can nevertheless divide topic assignment variables between languages and use them to estimate a Dirichlet-multinomial posterior distribution for each language in each tuple.</S><S sid="172" ssid="6">Second, because comparable texts may not use exactly the same topics, it becomes crucially important to be able to characterize differences in topic prevalence at the document level (do different languages have different perspectives on the same article?) and at the language-wide level (which topics do particular languages focus on?).</S><S sid="177" ssid="11">In the English version of Wikipedia we dropped all articles that were not linked to by any other language in our set.</S><S sid="186" ssid="20">Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'78'", "'172'", "'177'", "'186'"]
'78'
'172'
'177'
'186'
['78', '172', '177', '186']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="58">One simple way to achieve this topic alignment is to add a small set of comparable document tuples that provide sufficient &#8220;glue&#8221; to bind the topics together.</S><S sid="128" ssid="77">Although the PLTM is clearly not a substitute for a machine translation system&#8212;it has no way to represent syntax or even multi-word phrases&#8212;it is clear from the examples in figure 2 that the sets of high probability words in different languages for a given topic are likely to include translations.</S><S sid="137" ssid="86">For every topic t we select a small number K of the most probable words in English (e) and in each &#8220;translation&#8221; language (E): Wte and Wtt, respectively.</S><S sid="138" ssid="87">We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.</S>
original cit marker offset is 0
new cit marker offset is 0



["'109'", "'128'", "'137'", "'138'"]
'109'
'128'
'137'
'138'
['109', '128', '137', '138']
parsed_discourse_facet ['method_citation']
<S sid="0">Polylingual Topic Models</S><S sid="2" ssid="2">Meanwhile, massive collections of interlinked documents in dozens of languages, such as Wikipedia, are now widely available, calling for tools that can characterize content in many languages.</S><S sid="25" ssid="1">Bilingual topic models for parallel texts with word-to-word alignments have been studied previously using the HM-bitam model (Zhao and Xing, 2007).</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'25'", "'30'"]
'0'
'2'
'25'
'30'
['0', '2', '25', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S><S sid="21" ssid="17">The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.</S><S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'22'", "'148'"]
'20'
'21'
'22'
'148'
['20', '21', '22', '148']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="9" ssid="5">In this paper, we present the polylingual topic model (PLTM).</S><S sid="92" ssid="41">We perform five estimation runs for each document and then calculate standard errors using a bootstrap method.</S><S sid="107" ssid="56">No paper is exactly comparable to any other paper, but they are all roughly topically similar.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'92'", "'107'", "'192'"]
'9'
'92'
'107'
'192'
['9', '92', '107', '192']
parsed_discourse_facet ['hypothesis_citation']
<S sid="118" ssid="67">We calculate the Jensen-Shannon divergence between the topic distributions for each pair of individual documents in S that were originally part of the same tuple prior to separation.</S><S sid="119" ssid="68">The lower the divergence, the more similar the distributions are to each other.</S><S sid="121" ssid="70">Table 3 shows mean JS divergences for each value of p. As expected, JS divergence is greater than that obtained when all tuples are left intact.</S><S sid="122" ssid="71">Divergence drops significantly when the proportion of &#8220;glue&#8221; tuples increases from 0.01 to 0.25.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'", "'119'", "'121'", "'122'"]
'118'
'119'
'121'
'122'
['118', '119', '121', '122']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="36" ssid="2">Each tuple is a set of documents that are loosely equivalent to each other, but written in different languages, e.g., corresponding Wikipedia articles in French, English and German.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'36'", "'105'", "'192'"]
'3'
'36'
'105'
'192'
['3', '36', '105', '192']
parsed_discourse_facet ['aim_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="18" ssid="14">In this paper, we use two polylingual corpora to answer various critical questions related to polylingual topic models.</S><S sid="65" ssid="14">This topic provides an illustration of the variation in technical terminology captured by PLTM, including the wide array of acronyms used by different languages.</S><S sid="99" ssid="48">Figure 5 shows the proportion of all tokens in English and Finnish assigned to each topic under LDA and PLTM with 800 topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'18'", "'65'", "'99'"]
'3'
'18'
'65'
'99'
['3', '18', '65', '99']
parsed_discourse_facet ['hypothesis_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="4" ssid="4">We explore the model&#8217;s characteristics using two large corpora, each with over ten different languages, and demonstrate its usefulness in supporting machine translation and tracking topic trends across languages.</S><S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'4'", "'19'", "'30'"]
'3'
'4'
'19'
'30'
['3', '4', '19', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</S><S sid="155" ssid="104">Finally, for each pair of languages (&#8220;query&#8221; and &#8220;target&#8221;) we calculate the difference between the topic distribution for each held-out document in the query language and the topic distribution for each held-out document in the target language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'30'", "'77'", "'155'"]
'22'
'30'
'77'
'155'
['22', '30', '77', '155']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="31" ssid="7">They also provide little analysis of the differences between polylingual and single-language topic models.</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'30'", "'31'", "'154'"]
'22'
'30'
'31'
'154'
['22', '30', '31', '154']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S><S sid="155" ssid="104">Finally, for each pair of languages (&#8220;query&#8221; and &#8220;target&#8221;) we calculate the difference between the topic distribution for each held-out document in the query language and the topic distribution for each held-out document in the target language.</S><S sid="156" ssid="105">We use both Jensen-Shannon divergence and cosine distance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'154'", "'155'", "'156'"]
'6'
'154'
'155'
'156'
['6', '154', '155', '156']
parsed_discourse_facet ['aim_citation', 'implication_citation']
<S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S><S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S><S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'20'", "'148'", "'154'"]
'19'
'20'
'148'
'154'
['19', '20', '148', '154']
parsed_discourse_facet ['method_citation', 'implication_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'30'", "'35'", "'105'"]
'6'
'30'
'35'
'105'
['6', '30', '35', '105']
parsed_discourse_facet ['aim_citation']
<S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S><S sid="169" ssid="3">In this section, we explore two questions relating to comparable text corpora and polylingual topic modeling.</S><S sid="170" ssid="4">First, we explore whether comparable document tuples support the alignment of fine-grained topics, as demonstrated earlier using parallel documents.</S><S sid="171" ssid="5">This property is useful for building machine translation systems as well as for human readers who are either learning new languages or analyzing texts in languages they do not know.</S>
original cit marker offset is 0
new cit marker offset is 0



["'35'", "'169'", "'170'", "'171'"]
'35'
'169'
'170'
'171'
['35', '169', '170', '171']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="75">These results demonstrate that PLTM is appropriate for aligning topics in corpora that have only a small subset of comparable documents.</S><S sid="147" ssid="96">These aligned document pairs could then be fed into standard machine translation systems as training data.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S><S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'", "'147'", "'192'", "'193'"]
'126'
'147'
'192'
'193'
['126', '147', '192', '193']
parsed_discourse_facet ['results_citation']
<S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="85" ssid="34">Smoothed histograms of inter&#8722;language JS divergence A topic model specifies a probability distribution over documents, or in the case of PLTM, document tuples.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S><S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'85'", "'105'", "'193'"]
'30'
'85'
'105'
'193'
['30', '85', '105', '193']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="24" ssid="20">By linking topics across languages, polylingual topic models can increase cross-cultural understanding by providing readers with the ability to characterize the contents of collections in unfamiliar languages and identify trends in topic prevalence.</S><S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'24'", "'77'", "'192'"]
'3'
'24'
'77'
'192'
['3', '24', '77', '192']
parsed_discourse_facet ['method_citation', 'aim_citation']
dict_values(['Outside of the field of topic modeling, Kawaba et al. (Kawaba et al., 2008) use a Wikipedia-based model to perform sentiment analysis of blog posts.'])
dict_values(['The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.', 'EN &#8220;comitology&#8221; and IT lang Topics at P = 0.01 &#8220;comitalogia&#8221;) that simply were not in the lexica.', 'Subtle differences of sentiment may be below the granularity of the model. sadwrn blaned gallair at lloeren mytholeg space nasa sojus flug mission &#948;&#953;&#945;&#963;&#964;&#951;&#956;&#953;&#954;&#972; sts nasa &#945;&#947;&#947;&#955; small space mission launch satellite nasa spacecraft sojuz nasa apollo ensimm&#352;inen space lento spatiale mission orbite mars satellite spatial &#1514;&#1497;&#1504;&#1499;&#1493;&#1514; &#1488; &#1512;&#1493;&#1491;&#1499; &#1500;&#1500; &#1495; &#1509;&#1512; &#1488;&#1492; &#1500;&#1500;&#1495;&#1492; spaziale missione programma space sojuz stazione misja kosmicznej stacji misji space nasa &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080;&#1081; &#1089;&#1086;&#1102;&#1079; &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1075;&#1086; &#1089;&#1087;&#1091;&#1090;&#1085;&#1080;&#1082; &#1089;&#1090;&#1072;&#1085;&#1094;&#1080;&#1080; uzay soyuz ay uzaya salyut sovyetler sbaen madrid el la jos6 sbaeneg de spanischer spanischen spanien madrid la &#953;&#963;&#960;&#945;&#957;&#943;&#945;&#962; &#953;&#963;&#960;&#945;&#957;&#943;&#945; de &#953;&#963;&#960;&#945;&#957;&#972;&#962; &#957;&#964;&#949; &#956;&#945;&#948;&#961;&#943;&#964;&#951; de spanish spain la madrid y espanja de espanjan madrid la real espagnol espagne madrid espagnole juan y de spagna spagnolo spagnola madrid el de hiszpa&#324;ski hiszpanii la juan y &#1076;&#1077; &#1084;&#1072;&#1076;&#1088;&#1080;&#1076; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1080; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1103; &#1080;&#1089;&#1087;&#1072;&#1085;&#1089;&#1082;&#1080;&#1081; de ispanya ispanyol madrid la kOba real bardd gerddi iaith beirdd fardd gymraeg dichter schriftsteller literatur gedichte gedicht werk &#960;&#959;&#953;&#951;&#964;&#942;&#962; &#960;&#959;&#943;&#951;&#963;&#951; &#960;&#959;&#953;&#951;&#964;&#942; &#941;&#961;&#947;&#959; &#960;&#959;&#953;&#951;&#964;&#941;&#962; &#960;&#959;&#953;&#942;&#956;&#945;&#964;&#945; poet poetry literature literary poems poem runoilija kirjailija kirjallisuuden kirjoitti runo julkaisi poste 6crivain litt6rature po6sie litt6raire ses Overall, these scores indicate that although individual pages may show disagreement, Wikipedia is on average consistent between languages.', 'Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00015', '(95%-conf.int.', '0.00015', '-', '0.00015)']
['system', 'ROUGE-S*', 'Average_P:', '0.08333', '(95%-conf.int.', '0.08333', '-', '0.08333)']
['system', 'ROUGE-S*', 'Average_F:', '0.00030', '(95%-conf.int.', '0.00030', '-', '0.00030)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:65703', 'P:120', 'F:10']
dict_values(['Additionally, PLTM assumes that each &#8220;topic&#8221; consists of a set of discrete distributions over words&#8212;one for each language l = 1, ... , L. In other words, rather than using a single set of topics &#934; = {&#966;1, ... , &#966;T}, as in LDA, there are L sets of language-specific topics, &#934;1, ... , &#934;L, each of which is drawn from a language-specific symmetric Dirichlet with concentration parameter &#946;l.'])
dict_values(['Although the model does not distinguish between topic assignment variables within a given document tuple (so it is technically incorrect to speak of different posterior distributions over topics for different documents in a given tuple), we can nevertheless divide topic assignment variables between languages and use them to estimate a Dirichlet-multinomial posterior distribution for each language in each tuple.', 'Second, because comparable texts may not use exactly the same topics, it becomes crucially important to be able to characterize differences in topic prevalence at the document level (do different languages have different perspectives on the same article?) and at the language-wide level (which topics do particular languages focus on?).', 'In the English version of Wikipedia we dropped all articles that were not linked to by any other language in our set.', 'Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01484', '(95%-conf.int.', '0.01484', '-', '0.01484)']
['system', 'ROUGE-S*', 'Average_P:', '0.05548', '(95%-conf.int.', '0.05548', '-', '0.05548)']
['system', 'ROUGE-S*', 'Average_F:', '0.02342', '(95%-conf.int.', '0.02342', '-', '0.02342)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2628', 'P:703', 'F:39']
dict_values(['We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.'])
dict_values(['One simple way to achieve this topic alignment is to add a small set of comparable document tuples that provide sufficient &#8220;glue&#8221; to bind the topics together.', 'Although the PLTM is clearly not a substitute for a machine translation system&#8212;it has no way to represent syntax or even multi-word phrases&#8212;it is clear from the examples in figure 2 that the sets of high probability words in different languages for a given topic are likely to include translations.', 'For every topic t we select a small number K of the most probable words in English (e) and in each &#8220;translation&#8221; language (E): Wte and Wtt, respectively.', 'We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03528', '(95%-conf.int.', '0.03528', '-', '0.03528)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.06815', '(95%-conf.int.', '0.06815', '-', '0.06815)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2211', 'P:78', 'F:78']
dict_values(['When applied to comparable document collections such as Wikipedia, PLTM supports data-driven analysis of differences and similarities across all languages for readers who understand any one language.'])
dict_values(['Polylingual Topic Models', 'Meanwhile, massive collections of interlinked documents in dozens of languages, such as Wikipedia, are now widely available, calling for tools that can characterize content in many languages.', 'Bilingual topic models for parallel texts with word-to-word alignments have been studied previously using the HM-bitam model (Zhao and Xing, 2007).', 'However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01585', '(95%-conf.int.', '0.01585', '-', '0.01585)']
['system', 'ROUGE-S*', 'Average_P:', '0.10833', '(95%-conf.int.', '0.10833', '-', '0.10833)']
['system', 'ROUGE-S*', 'Average_F:', '0.02766', '(95%-conf.int.', '0.02766', '-', '0.02766)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:120', 'F:13']
dict_values(['In order to simulate this scenario we create a set of variations of the EuroParl corpus by treating some documents as if they have no parallel/comparable texts &#8211; i.e., we put each of these documents in a single-document tuple.'])
dict_values(['We also explore how the characteristics of different languages affect topic model performance.', 'The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.', 'We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.', 'To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01804', '(95%-conf.int.', '0.01804', '-', '0.01804)']
['system', 'ROUGE-S*', 'Average_P:', '0.13450', '(95%-conf.int.', '0.13450', '-', '0.13450)']
['system', 'ROUGE-S*', 'Average_F:', '0.03181', '(95%-conf.int.', '0.03181', '-', '0.03181)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1275', 'P:171', 'F:23']
dict_values(['Divergence drops significantly when the proportion of &#8220;glue&#8221; tuples increases from 0.01 to 0.25.'])
dict_values(['We calculate the Jensen-Shannon divergence between the topic distributions for each pair of individual documents in S that were originally part of the same tuple prior to separation.', 'The lower the divergence, the more similar the distributions are to each other.', 'Table 3 shows mean JS divergences for each value of p. As expected, JS divergence is greater than that obtained when all tuples are left intact.', 'Divergence drops significantly when the proportion of &#8220;glue&#8221; tuples increases from 0.01 to 0.25.'])
['system', 'ROUGE-S*', 'Average_R:', '0.08245', '(95%-conf.int.', '0.08245', '-', '0.08245)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.15234', '(95%-conf.int.', '0.15234', '-', '0.15234)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:946', 'P:78', 'F:78']
dict_values(['We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.'])
dict_values(['We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.', 'We also explore how the characteristics of different languages affect topic model performance.', 'To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.', 'We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).'])
['system', 'ROUGE-S*', 'Average_R:', '0.05319', '(95%-conf.int.', '0.05319', '-', '0.05319)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10100', '(95%-conf.int.', '0.10100', '-', '0.10100)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:91', 'F:91']
dict_values(['We evaluate sets of high-probability words in each topic and multilingual &#8220;synsets&#8221; by comparing them to entries in human-constructed bilingual dictionaries, as done by Haghighi et al. (2008).'])
dict_values(['Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).', 'However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.', 'The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.', 'An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00316', '(95%-conf.int.', '0.00316', '-', '0.00316)']
['system', 'ROUGE-S*', 'Average_P:', '0.05848', '(95%-conf.int.', '0.05848', '-', '0.05848)']
['system', 'ROUGE-S*', 'Average_F:', '0.00600', '(95%-conf.int.', '0.00600', '-', '0.00600)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3160', 'P:171', 'F:10']
dict_values(['We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.'])
dict_values(['These results demonstrate that PLTM is appropriate for aligning topics in corpora that have only a small subset of comparable documents.', 'These aligned document pairs could then be fed into standard machine translation systems as training data.', 'We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.', 'We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05769', '(95%-conf.int.', '0.05769', '-', '0.05769)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10909', '(95%-conf.int.', '0.10909', '-', '0.10909)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:780', 'P:45', 'F:45']
dict_values(['Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).'])
dict_values(['We introduce a polylingual topic model that discovers topics aligned across multiple languages.', 'By linking topics across languages, polylingual topic models can increase cross-cultural understanding by providing readers with the ability to characterize the contents of collections in unfamiliar languages and identify trends in topic prevalence.', 'Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.', 'We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00512', '(95%-conf.int.', '0.00512', '-', '0.00512)']
['system', 'ROUGE-S*', 'Average_P:', '0.01587', '(95%-conf.int.', '0.01587', '-', '0.01587)']
['system', 'ROUGE-S*', 'Average_F:', '0.00774', '(95%-conf.int.', '0.00774', '-', '0.00774)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:630', 'F:10']
0.44559899554401006 0.028576999714230007 0.05275099947249001





input/ref/Task1/D09-1092_vardha.csv
input/res/Task1/D09-1092.annv3.csv
parsing: input/ref/Task1/D09-1092_vardha.csv
<S sid="17" ssid="13">We argue that topic modeling is both a useful and appropriate tool for leveraging correspondences between semantically comparable documents in multiple different languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'"]
'17'
['17']
parsed_discourse_facet ['method_citation']
 <S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
    <S sid="138" ssid="87">We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'"]
'138'
['138']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">We demonstrate its utility and explore its characteristics using two polylingual corpora: proceedings of the European parliament (in eleven languages) and a collection of Wikipedia articles (in twelve languages).</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
   <S sid="55" ssid="4">The EuroParl corpus consists of parallel texts in eleven western European languages: Danish, German, Greek, English, Spanish, Finnish, French, Italian, Dutch, Portuguese and Swedish.</S>
original cit marker offset is 0
new cit marker offset is 0



["'55'"]
'55'
['55']
parsed_discourse_facet ['method_citation']
 sid="9" ssid="5">In this paper, we present the polylingual topic model (PLTM).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
Error in Reference Offset
<S sid="118" ssid="67">We calculate the Jensen-Shannon divergence between the topic distributions for each pair of individual documents in S that were originally part of the same tuple prior to separation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'"]
'118'
['118']
parsed_discourse_facet ['method_citation']
<S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'35'"]
'35'
['35']
parsed_discourse_facet ['method_citation']
<S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'35'"]
'35'
['35']
parsed_discourse_facet ['method_citation']
 <S sid="55" ssid="4">The EuroParl corpus consists of parallel texts in eleven western European languages: Danish, German, Greek, English, Spanish, Finnish, French, Italian, Dutch, Portuguese and Swedish.</S>
original cit marker offset is 0
new cit marker offset is 0



["'55'"]
'55'
['55']
parsed_discourse_facet ['method_citation']
<S sid="102" ssid="51">In contrast, PLTM assigns a significant number of tokens to almost all 800 topics, in very similar proportions in both languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'102'"]
'102'
['102']
parsed_discourse_facet ['method_citation']
 <S sid="38" ssid="4">This is unlike LDA, in which each document is assumed to have its own document-specific distribution over topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'"]
'38'
['38']
parsed_discourse_facet ['method_citation']
 <S sid="156" ssid="105">We use both Jensen-Shannon divergence and cosine distance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'156'"]
'156'
['156']
parsed_discourse_facet ['method_citation']
    <S sid="36" ssid="2">Each tuple is a set of documents that are loosely equivalent to each other, but written in different languages, e.g., corresponding Wikipedia articles in French, English and German.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
  <S sid="170" ssid="4">First, we explore whether comparable document tuples support the alignment of fine-grained topics, as demonstrated earlier using parallel documents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'170'"]
'170'
['170']
parsed_discourse_facet ['method_citation']
    <S sid="29" ssid="5">A recent extended abstract, developed concurrently by Ni et al. (Ni et al., 2009), discusses a multilingual topic model similar to the one presented here.</S>
original cit marker offset is 0
new cit marker offset is 0



["'29'"]
'29'
['29']
parsed_discourse_facet ['method_citation']
  <S sid="170" ssid="4">First, we explore whether comparable document tuples support the alignment of fine-grained topics, as demonstrated earlier using parallel documents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'170'"]
'170'
['170']
parsed_discourse_facet ['method_citation']
<S sid="168" ssid="2">However, the growth of the web, and in particular Wikipedia, has made comparable text corpora &#8211; documents that are topically similar but are not direct translations of one another &#8211; considerably more abundant than true parallel corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'168'"]
'168'
['168']
parsed_discourse_facet ['method_citation']
    <S sid="29" ssid="5">A recent extended abstract, developed concurrently by Ni et al. (Ni et al., 2009), discusses a multilingual topic model similar to the one presented here.</S>
original cit marker offset is 0
new cit marker offset is 0



["'29'"]
'29'
['29']
parsed_discourse_facet ['method_citation']
 <S sid="110" ssid="59">Continuing with the example above, one might extract a set of connected Wikipedia articles related to the focus of the journal and then train PLTM on a joint corpus consisting of journal papers and Wikipedia articles.</S>
original cit marker offset is 0
new cit marker offset is 0



["'110'"]
'110'
['110']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/D09-1092.annv3.csv
<S sid="21" ssid="17">The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.</S><S sid="142" ssid="91">EN &#8220;comitology&#8221; and IT lang Topics at P = 0.01 &#8220;comitalogia&#8221;) that simply were not in the lexica.</S><S sid="185" ssid="19">Subtle differences of sentiment may be below the granularity of the model. sadwrn blaned gallair at lloeren mytholeg space nasa sojus flug mission &#948;&#953;&#945;&#963;&#964;&#951;&#956;&#953;&#954;&#972; sts nasa &#945;&#947;&#947;&#955; small space mission launch satellite nasa spacecraft sojuz nasa apollo ensimm&#352;inen space lento spatiale mission orbite mars satellite spatial &#1514;&#1497;&#1504;&#1499;&#1493;&#1514; &#1488; &#1512;&#1493;&#1491;&#1499; &#1500;&#1500; &#1495; &#1509;&#1512; &#1488;&#1492; &#1500;&#1500;&#1495;&#1492; spaziale missione programma space sojuz stazione misja kosmicznej stacji misji space nasa &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080;&#1081; &#1089;&#1086;&#1102;&#1079; &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1075;&#1086; &#1089;&#1087;&#1091;&#1090;&#1085;&#1080;&#1082; &#1089;&#1090;&#1072;&#1085;&#1094;&#1080;&#1080; uzay soyuz ay uzaya salyut sovyetler sbaen madrid el la jos6 sbaeneg de spanischer spanischen spanien madrid la &#953;&#963;&#960;&#945;&#957;&#943;&#945;&#962; &#953;&#963;&#960;&#945;&#957;&#943;&#945; de &#953;&#963;&#960;&#945;&#957;&#972;&#962; &#957;&#964;&#949; &#956;&#945;&#948;&#961;&#943;&#964;&#951; de spanish spain la madrid y espanja de espanjan madrid la real espagnol espagne madrid espagnole juan y de spagna spagnolo spagnola madrid el de hiszpa&#324;ski hiszpanii la juan y &#1076;&#1077; &#1084;&#1072;&#1076;&#1088;&#1080;&#1076; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1080; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1103; &#1080;&#1089;&#1087;&#1072;&#1085;&#1089;&#1082;&#1080;&#1081; de ispanya ispanyol madrid la kOba real bardd gerddi iaith beirdd fardd gymraeg dichter schriftsteller literatur gedichte gedicht werk &#960;&#959;&#953;&#951;&#964;&#942;&#962; &#960;&#959;&#943;&#951;&#963;&#951; &#960;&#959;&#953;&#951;&#964;&#942; &#941;&#961;&#947;&#959; &#960;&#959;&#953;&#951;&#964;&#941;&#962; &#960;&#959;&#953;&#942;&#956;&#945;&#964;&#945; poet poetry literature literary poems poem runoilija kirjailija kirjallisuuden kirjoitti runo julkaisi poste 6crivain litt6rature po6sie litt6raire ses Overall, these scores indicate that although individual pages may show disagreement, Wikipedia is on average consistent between languages.</S><S sid="186" ssid="20">Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'142'", "'185'", "'186'"]
'21'
'142'
'185'
'186'
['21', '142', '185', '186']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="78" ssid="27">Although the model does not distinguish between topic assignment variables within a given document tuple (so it is technically incorrect to speak of different posterior distributions over topics for different documents in a given tuple), we can nevertheless divide topic assignment variables between languages and use them to estimate a Dirichlet-multinomial posterior distribution for each language in each tuple.</S><S sid="172" ssid="6">Second, because comparable texts may not use exactly the same topics, it becomes crucially important to be able to characterize differences in topic prevalence at the document level (do different languages have different perspectives on the same article?) and at the language-wide level (which topics do particular languages focus on?).</S><S sid="177" ssid="11">In the English version of Wikipedia we dropped all articles that were not linked to by any other language in our set.</S><S sid="186" ssid="20">Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'78'", "'172'", "'177'", "'186'"]
'78'
'172'
'177'
'186'
['78', '172', '177', '186']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="58">One simple way to achieve this topic alignment is to add a small set of comparable document tuples that provide sufficient &#8220;glue&#8221; to bind the topics together.</S><S sid="128" ssid="77">Although the PLTM is clearly not a substitute for a machine translation system&#8212;it has no way to represent syntax or even multi-word phrases&#8212;it is clear from the examples in figure 2 that the sets of high probability words in different languages for a given topic are likely to include translations.</S><S sid="137" ssid="86">For every topic t we select a small number K of the most probable words in English (e) and in each &#8220;translation&#8221; language (E): Wte and Wtt, respectively.</S><S sid="138" ssid="87">We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.</S>
original cit marker offset is 0
new cit marker offset is 0



["'109'", "'128'", "'137'", "'138'"]
'109'
'128'
'137'
'138'
['109', '128', '137', '138']
parsed_discourse_facet ['method_citation']
<S sid="0">Polylingual Topic Models</S><S sid="2" ssid="2">Meanwhile, massive collections of interlinked documents in dozens of languages, such as Wikipedia, are now widely available, calling for tools that can characterize content in many languages.</S><S sid="25" ssid="1">Bilingual topic models for parallel texts with word-to-word alignments have been studied previously using the HM-bitam model (Zhao and Xing, 2007).</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'25'", "'30'"]
'0'
'2'
'25'
'30'
['0', '2', '25', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S><S sid="21" ssid="17">The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.</S><S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'22'", "'148'"]
'20'
'21'
'22'
'148'
['20', '21', '22', '148']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="9" ssid="5">In this paper, we present the polylingual topic model (PLTM).</S><S sid="92" ssid="41">We perform five estimation runs for each document and then calculate standard errors using a bootstrap method.</S><S sid="107" ssid="56">No paper is exactly comparable to any other paper, but they are all roughly topically similar.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'92'", "'107'", "'192'"]
'9'
'92'
'107'
'192'
['9', '92', '107', '192']
parsed_discourse_facet ['hypothesis_citation']
<S sid="118" ssid="67">We calculate the Jensen-Shannon divergence between the topic distributions for each pair of individual documents in S that were originally part of the same tuple prior to separation.</S><S sid="119" ssid="68">The lower the divergence, the more similar the distributions are to each other.</S><S sid="121" ssid="70">Table 3 shows mean JS divergences for each value of p. As expected, JS divergence is greater than that obtained when all tuples are left intact.</S><S sid="122" ssid="71">Divergence drops significantly when the proportion of &#8220;glue&#8221; tuples increases from 0.01 to 0.25.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'", "'119'", "'121'", "'122'"]
'118'
'119'
'121'
'122'
['118', '119', '121', '122']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="36" ssid="2">Each tuple is a set of documents that are loosely equivalent to each other, but written in different languages, e.g., corresponding Wikipedia articles in French, English and German.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'36'", "'105'", "'192'"]
'3'
'36'
'105'
'192'
['3', '36', '105', '192']
parsed_discourse_facet ['aim_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="18" ssid="14">In this paper, we use two polylingual corpora to answer various critical questions related to polylingual topic models.</S><S sid="65" ssid="14">This topic provides an illustration of the variation in technical terminology captured by PLTM, including the wide array of acronyms used by different languages.</S><S sid="99" ssid="48">Figure 5 shows the proportion of all tokens in English and Finnish assigned to each topic under LDA and PLTM with 800 topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'18'", "'65'", "'99'"]
'3'
'18'
'65'
'99'
['3', '18', '65', '99']
parsed_discourse_facet ['hypothesis_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="4" ssid="4">We explore the model&#8217;s characteristics using two large corpora, each with over ten different languages, and demonstrate its usefulness in supporting machine translation and tracking topic trends across languages.</S><S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'4'", "'19'", "'30'"]
'3'
'4'
'19'
'30'
['3', '4', '19', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</S><S sid="155" ssid="104">Finally, for each pair of languages (&#8220;query&#8221; and &#8220;target&#8221;) we calculate the difference between the topic distribution for each held-out document in the query language and the topic distribution for each held-out document in the target language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'30'", "'77'", "'155'"]
'22'
'30'
'77'
'155'
['22', '30', '77', '155']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="22" ssid="18">We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="31" ssid="7">They also provide little analysis of the differences between polylingual and single-language topic models.</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'30'", "'31'", "'154'"]
'22'
'30'
'31'
'154'
['22', '30', '31', '154']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S><S sid="155" ssid="104">Finally, for each pair of languages (&#8220;query&#8221; and &#8220;target&#8221;) we calculate the difference between the topic distribution for each held-out document in the query language and the topic distribution for each held-out document in the target language.</S><S sid="156" ssid="105">We use both Jensen-Shannon divergence and cosine distance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'154'", "'155'", "'156'"]
'6'
'154'
'155'
'156'
['6', '154', '155', '156']
parsed_discourse_facet ['aim_citation', 'implication_citation']
<S sid="19" ssid="15">We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.</S><S sid="20" ssid="16">We also explore how the characteristics of different languages affect topic model performance.</S><S sid="148" ssid="97">To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.</S><S sid="154" ssid="103">We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'20'", "'148'", "'154'"]
'19'
'20'
'148'
'154'
['19', '20', '148', '154']
parsed_discourse_facet ['method_citation', 'implication_citation']
<S sid="6" ssid="2">Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).</S><S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'30'", "'35'", "'105'"]
'6'
'30'
'35'
'105'
['6', '30', '35', '105']
parsed_discourse_facet ['aim_citation']
<S sid="35" ssid="1">The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.</S><S sid="169" ssid="3">In this section, we explore two questions relating to comparable text corpora and polylingual topic modeling.</S><S sid="170" ssid="4">First, we explore whether comparable document tuples support the alignment of fine-grained topics, as demonstrated earlier using parallel documents.</S><S sid="171" ssid="5">This property is useful for building machine translation systems as well as for human readers who are either learning new languages or analyzing texts in languages they do not know.</S>
original cit marker offset is 0
new cit marker offset is 0



["'35'", "'169'", "'170'", "'171'"]
'35'
'169'
'170'
'171'
['35', '169', '170', '171']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="75">These results demonstrate that PLTM is appropriate for aligning topics in corpora that have only a small subset of comparable documents.</S><S sid="147" ssid="96">These aligned document pairs could then be fed into standard machine translation systems as training data.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S><S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'", "'147'", "'192'", "'193'"]
'126'
'147'
'192'
'193'
['126', '147', '192', '193']
parsed_discourse_facet ['results_citation']
<S sid="30" ssid="6">However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.</S><S sid="85" ssid="34">Smoothed histograms of inter&#8722;language JS divergence A topic model specifies a probability distribution over documents, or in the case of PLTM, document tuples.</S><S sid="105" ssid="54">An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.</S><S sid="193" ssid="2">We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'85'", "'105'", "'193'"]
'30'
'85'
'105'
'193'
['30', '85', '105', '193']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">We introduce a polylingual topic model that discovers topics aligned across multiple languages.</S><S sid="24" ssid="20">By linking topics across languages, polylingual topic models can increase cross-cultural understanding by providing readers with the ability to characterize the contents of collections in unfamiliar languages and identify trends in topic prevalence.</S><S sid="77" ssid="26">Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.</S><S sid="192" ssid="1">We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'24'", "'77'", "'192'"]
'3'
'24'
'77'
'192'
['3', '24', '77', '192']
parsed_discourse_facet ['method_citation', 'aim_citation']
dict_values(['We argue that topic modeling is both a useful and appropriate tool for leveraging correspondences between semantically comparable documents in multiple different languages.'])
dict_values(['The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.', 'EN &#8220;comitology&#8221; and IT lang Topics at P = 0.01 &#8220;comitalogia&#8221;) that simply were not in the lexica.', 'Subtle differences of sentiment may be below the granularity of the model. sadwrn blaned gallair at lloeren mytholeg space nasa sojus flug mission &#948;&#953;&#945;&#963;&#964;&#951;&#956;&#953;&#954;&#972; sts nasa &#945;&#947;&#947;&#955; small space mission launch satellite nasa spacecraft sojuz nasa apollo ensimm&#352;inen space lento spatiale mission orbite mars satellite spatial &#1514;&#1497;&#1504;&#1499;&#1493;&#1514; &#1488; &#1512;&#1493;&#1491;&#1499; &#1500;&#1500; &#1495; &#1509;&#1512; &#1488;&#1492; &#1500;&#1500;&#1495;&#1492; spaziale missione programma space sojuz stazione misja kosmicznej stacji misji space nasa &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080;&#1081; &#1089;&#1086;&#1102;&#1079; &#1082;&#1086;&#1089;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1075;&#1086; &#1089;&#1087;&#1091;&#1090;&#1085;&#1080;&#1082; &#1089;&#1090;&#1072;&#1085;&#1094;&#1080;&#1080; uzay soyuz ay uzaya salyut sovyetler sbaen madrid el la jos6 sbaeneg de spanischer spanischen spanien madrid la &#953;&#963;&#960;&#945;&#957;&#943;&#945;&#962; &#953;&#963;&#960;&#945;&#957;&#943;&#945; de &#953;&#963;&#960;&#945;&#957;&#972;&#962; &#957;&#964;&#949; &#956;&#945;&#948;&#961;&#943;&#964;&#951; de spanish spain la madrid y espanja de espanjan madrid la real espagnol espagne madrid espagnole juan y de spagna spagnolo spagnola madrid el de hiszpa&#324;ski hiszpanii la juan y &#1076;&#1077; &#1084;&#1072;&#1076;&#1088;&#1080;&#1076; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1080; &#1080;&#1089;&#1087;&#1072;&#1085;&#1080;&#1103; &#1080;&#1089;&#1087;&#1072;&#1085;&#1089;&#1082;&#1080;&#1081; de ispanya ispanyol madrid la kOba real bardd gerddi iaith beirdd fardd gymraeg dichter schriftsteller literatur gedichte gedicht werk &#960;&#959;&#953;&#951;&#964;&#942;&#962; &#960;&#959;&#943;&#951;&#963;&#951; &#960;&#959;&#953;&#951;&#964;&#942; &#941;&#961;&#947;&#959; &#960;&#959;&#953;&#951;&#964;&#941;&#962; &#960;&#959;&#953;&#942;&#956;&#945;&#964;&#945; poet poetry literature literary poems poem runoilija kirjailija kirjallisuuden kirjoitti runo julkaisi poste 6crivain litt6rature po6sie litt6raire ses Overall, these scores indicate that although individual pages may show disagreement, Wikipedia is on average consistent between languages.', 'Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00006', '(95%-conf.int.', '0.00006', '-', '0.00006)']
['system', 'ROUGE-S*', 'Average_P:', '0.07273', '(95%-conf.int.', '0.07273', '-', '0.07273)']
['system', 'ROUGE-S*', 'Average_F:', '0.00012', '(95%-conf.int.', '0.00012', '-', '0.00012)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:65703', 'P:55', 'F:4']
dict_values(['We also explore how the characteristics of different languages affect topic model performance.'])
dict_values(['Although the model does not distinguish between topic assignment variables within a given document tuple (so it is technically incorrect to speak of different posterior distributions over topics for different documents in a given tuple), we can nevertheless divide topic assignment variables between languages and use them to estimate a Dirichlet-multinomial posterior distribution for each language in each tuple.', 'Second, because comparable texts may not use exactly the same topics, it becomes crucially important to be able to characterize differences in topic prevalence at the document level (do different languages have different perspectives on the same article?) and at the language-wide level (which topics do particular languages focus on?).', 'In the English version of Wikipedia we dropped all articles that were not linked to by any other language in our set.', 'Although we find that if Wikipedia contains an article on a particular subject in some language, the article will tend to be topically similar to the articles about that subject in other languages, we also find that across the whole collection different languages emphasize topics to different extents.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00038', '(95%-conf.int.', '0.00038', '-', '0.00038)']
['system', 'ROUGE-S*', 'Average_P:', '0.04762', '(95%-conf.int.', '0.04762', '-', '0.04762)']
['system', 'ROUGE-S*', 'Average_F:', '0.00076', '(95%-conf.int.', '0.00076', '-', '0.00076)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2628', 'P:21', 'F:1']
dict_values(['We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.'])
dict_values(['One simple way to achieve this topic alignment is to add a small set of comparable document tuples that provide sufficient &#8220;glue&#8221; to bind the topics together.', 'Although the PLTM is clearly not a substitute for a machine translation system&#8212;it has no way to represent syntax or even multi-word phrases&#8212;it is clear from the examples in figure 2 that the sets of high probability words in different languages for a given topic are likely to include translations.', 'For every topic t we select a small number K of the most probable words in English (e) and in each &#8220;translation&#8221; language (E): Wte and Wtt, respectively.', 'We then add the Cartesian product of these sets for every topic to a set of candidate translations C. We report the number of elements of C that appear in the reference lexica.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03528', '(95%-conf.int.', '0.03528', '-', '0.03528)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.06815', '(95%-conf.int.', '0.06815', '-', '0.06815)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2211', 'P:78', 'F:78']
dict_values(['We demonstrate its utility and explore its characteristics using two polylingual corpora: proceedings of the European parliament (in eleven languages) and a collection of Wikipedia articles (in twelve languages).'])
dict_values(['Polylingual Topic Models', 'Meanwhile, massive collections of interlinked documents in dozens of languages, such as Wikipedia, are now widely available, calling for tools that can characterize content in many languages.', 'Bilingual topic models for parallel texts with word-to-word alignments have been studied previously using the HM-bitam model (Zhao and Xing, 2007).', 'However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01098', '(95%-conf.int.', '0.01098', '-', '0.01098)']
['system', 'ROUGE-S*', 'Average_P:', '0.07500', '(95%-conf.int.', '0.07500', '-', '0.07500)']
['system', 'ROUGE-S*', 'Average_F:', '0.01915', '(95%-conf.int.', '0.01915', '-', '0.01915)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:120', 'F:9']
dict_values(['The EuroParl corpus consists of parallel texts in eleven western European languages: Danish, German, Greek, English, Spanish, Finnish, French, Italian, Dutch, Portuguese and Swedish.'])
dict_values(['We also explore how the characteristics of different languages affect topic model performance.', 'The second corpus, Wikipedia articles in twelve languages, contains sets of documents that are not translations of one another, but are very likely to be about similar concepts.', 'We use this corpus to explore the ability of the model both to infer similarities between vocabularies in different languages, and to detect differences in topic emphasis between languages.', 'To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00157', '(95%-conf.int.', '0.00157', '-', '0.00157)']
['system', 'ROUGE-S*', 'Average_P:', '0.01053', '(95%-conf.int.', '0.01053', '-', '0.01053)']
['system', 'ROUGE-S*', 'Average_F:', '0.00273', '(95%-conf.int.', '0.00273', '-', '0.00273)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1275', 'P:190', 'F:2']
dict_values(['We calculate the Jensen-Shannon divergence between the topic distributions for each pair of individual documents in S that were originally part of the same tuple prior to separation.'])
dict_values(['We calculate the Jensen-Shannon divergence between the topic distributions for each pair of individual documents in S that were originally part of the same tuple prior to separation.', 'The lower the divergence, the more similar the distributions are to each other.', 'Table 3 shows mean JS divergences for each value of p. As expected, JS divergence is greater than that obtained when all tuples are left intact.', 'Divergence drops significantly when the proportion of &#8220;glue&#8221; tuples increases from 0.01 to 0.25.'])
['system', 'ROUGE-S*', 'Average_R:', '0.09619', '(95%-conf.int.', '0.09619', '-', '0.09619)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.17551', '(95%-conf.int.', '0.17551', '-', '0.17551)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:946', 'P:91', 'F:91']
dict_values(['First, we explore whether comparable document tuples support the alignment of fine-grained topics, as demonstrated earlier using parallel documents.'])
dict_values(['We employ a set of direct translations, the EuroParl corpus, to evaluate whether PLTM can accurately infer topics when documents genuinely contain the same content.', 'We also explore how the characteristics of different languages affect topic model performance.', 'To evaluate this scenario, we train PLTM on a set of document tuples from EuroParl, infer topic distributions for a set of held-out documents, and then measure our ability to align documents in one language with their translations in another language.', 'We then use this model to infer topic distributions for each of the 11 documents in each of the held-out document tuples using a method similar to that used to calculate held-out probabilities (Wallach et al., 2009).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00877', '(95%-conf.int.', '0.00877', '-', '0.00877)']
['system', 'ROUGE-S*', 'Average_P:', '0.16484', '(95%-conf.int.', '0.16484', '-', '0.16484)']
['system', 'ROUGE-S*', 'Average_F:', '0.01665', '(95%-conf.int.', '0.01665', '-', '0.01665)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:91', 'F:15']
dict_values(['A recent extended abstract, developed concurrently by Ni et al. (Ni et al., 2009), discusses a multilingual topic model similar to the one presented here.'])
dict_values(['Topic models have been used for analyzing topic trends in research literature (Mann et al., 2006; Hall et al., 2008), inferring captions for images (Blei and Jordan, 2003), social network analysis in email (McCallum et al., 2005), and expanding queries with topically related words in information retrieval (Wei and Croft, 2006).', 'However, they evaluate their model on only two languages (English and Chinese), and do not use the model to detect differences between languages.', 'The polylingual topic model (PLTM) is an extension of latent Dirichlet allocation (LDA) (Blei et al., 2003) for modeling polylingual document tuples.', 'An important application for polylingual topic modeling is to use small numbers of comparable document tuples to link topics in larger collections of distinct, non-comparable documents in multiple languages.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00190', '(95%-conf.int.', '0.00190', '-', '0.00190)']
['system', 'ROUGE-S*', 'Average_P:', '0.05000', '(95%-conf.int.', '0.05000', '-', '0.05000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00366', '(95%-conf.int.', '0.00366', '-', '0.00366)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3160', 'P:120', 'F:6']
dict_values(['However, the growth of the web, and in particular Wikipedia, has made comparable text corpora &#8211; documents that are topically similar but are not direct translations of one another &#8211; considerably more abundant than true parallel corpora.'])
dict_values(['These results demonstrate that PLTM is appropriate for aligning topics in corpora that have only a small subset of comparable documents.', 'These aligned document pairs could then be fed into standard machine translation systems as training data.', 'We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.', 'We analyzed the characteristics of PLTM in comparison to monolingual LDA, and demonstrated that it is possible to discover aligned topics.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01282', '(95%-conf.int.', '0.01282', '-', '0.01282)']
['system', 'ROUGE-S*', 'Average_P:', '0.05848', '(95%-conf.int.', '0.05848', '-', '0.05848)']
['system', 'ROUGE-S*', 'Average_F:', '0.02103', '(95%-conf.int.', '0.02103', '-', '0.02103)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:780', 'P:171', 'F:10']
dict_values(['Continuing with the example above, one might extract a set of connected Wikipedia articles related to the focus of the journal and then train PLTM on a joint corpus consisting of journal papers and Wikipedia articles.'])
dict_values(['We introduce a polylingual topic model that discovers topics aligned across multiple languages.', 'By linking topics across languages, polylingual topic models can increase cross-cultural understanding by providing readers with the ability to characterize the contents of collections in unfamiliar languages and identify trends in topic prevalence.', 'Maximum topic probability in document Although the posterior distribution over topics for each tuple is not concentrated on one topic, it is worth checking that this is not simply because the model is assigning a single topic to the 1We use the R density function. tokens in each of the languages.', 'We introduced a polylingual topic model (PLTM) that discovers topics aligned across multiple languages.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:153', 'F:0']
0.24791999752079996 0.016794999832050003 0.030775999692240003





input/ref/Task1/D10-1044_aakansha.csv
input/res/Task1/D10-1044.annv3.csv
parsing: input/ref/Task1/D10-1044_aakansha.csv
<S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'144'"]
'144'
['144']
parsed_discourse_facet ['method_citation']
<S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S>
    <S sid="96" ssid="33">We used it to score all phrase pairs in the OUT table, in order to provide a feature for the instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'95'", "'96'"]
'95'
'96'
['95', '96']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="6">In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'62'"]
'62'
['62']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'"]
'28'
['28']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'"]
'23'
['23']
parsed_discourse_facet ['method_citation']
<S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'144'"]
'144'
['144']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="6">In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'"]
'28'
['28']
parsed_discourse_facet ['method_citation']
<S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



["'75'"]
'75'
['75']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S>
original cit marker offset is 0
new cit marker offset is 0



["'31'"]
'31'
['31']
parsed_discourse_facet ['method_citation']
<S sid="22" ssid="19">Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'"]
'22'
['22']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'"]
'23'
['23']
parsed_discourse_facet ['method_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'62'"]
'62'
['62']
parsed_discourse_facet ['method_citation']
<S sid="119" ssid="23">The 2nd block contains the IR system, which was tuned by selecting text in multiples of the size of the EMEA training corpus, according to dev set performance.</S>
    <S sid="120" ssid="24">This significantly underperforms log-linear combination.</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'120'"]
'119'
'120'
['119', '120']
parsed_discourse_facet ['result_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S>
    <S sid="24" ssid="21">Sentence pairs are the natural instances for SMT, but sentences often contain a mix of domain-specific and general language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'24'"]
'23'
'24'
['23', '24']
parsed_discourse_facet ['method_citation']
<S sid="40" ssid="4">We focus here instead on adapting the two most important features: the language model (LM), which estimates the probability p(wIh) of a target word w following an ngram h; and the translation models (TM) p(slt) and p(t1s), which give the probability of source phrase s translating to target phrase t, and vice versa.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'"]
'40'
['40']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/D10-1044.annv3.csv
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="10" ssid="7">This is a standard adaptation problem for SMT.</S><S sid="14" ssid="11">There is a fairly large body of work on SMT adaptation.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'10'", "'14'", "'31'"]
'0'
'10'
'14'
'31'
['0', '10', '14', '31']
parsed_discourse_facet ['results_citation']
<S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S><S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S><S sid="132" ssid="1">We have already mentioned the closely related work by Matsoukas et al (2009) on discriminative corpus weighting, and Jiang and Zhai (2007) on (nondiscriminative) instance weighting.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'65'", "'95'", "'132'", "'152'"]
'65'
'95'
'132'
'152'
['65', '95', '132', '152']
parsed_discourse_facet ['method_citation']
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="4" ssid="1">Domain adaptation is a common concern when optimizing empirical NLP applications.</S><S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S><S sid="143" ssid="12">Other work includes transferring latent topic distributions from source to target language for LM adaptation, (Tam et al., 2007) and adapting features at the sentence level to different categories of sentence (Finch and Sumita, 2008).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'4'", "'141'", "'143'"]
'0'
'4'
'141'
'143'
['0', '4', '141', '143']
parsed_discourse_facet ['aim_citation']
<S sid="24" ssid="21">Sentence pairs are the natural instances for SMT, but sentences often contain a mix of domain-specific and general language.</S><S sid="25" ssid="22">For instance, the sentence Similar improvements in haemoglobin levels were reported in the scientific literature for other epoetins would likely be considered domain-specific despite the presence of general phrases like were reported in.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'31'", "'62'"]
'24'
'25'
'31'
'62'
['24', '25', '31', '62']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="51" ssid="15">For the LM, adaptive weights are set as follows: where &#945; is a weight vector containing an element &#945;i for each domain (just IN and OUT in our case), pi are the corresponding domain-specific models, and &#732;p(w, h) is an empirical distribution from a targetlanguage training corpus&#8212;we used the IN dev set for this.</S><S sid="71" ssid="8">Finally, we incorporate the instance-weighting model into a general linear combination, and learn weights and mixing parameters simultaneously. where c&#955;(s, t) is a modified count for pair (s, t) in OUT, u(s|t) is a prior distribution, and y is a prior weight.</S><S sid="72" ssid="9">The original OUT counts co(s, t) are weighted by a logistic function w&#955;(s, t): To motivate weighting joint OUT counts as in (6), we begin with the &#8220;ideal&#8221; objective for setting multinomial phrase probabilities 0 = {p(s|t), dst}, which is the likelihood with respect to the true IN distribution pi(s, t).</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'51'", "'71'", "'72'"]
'50'
'51'
'71'
'72'
['50', '51', '71', '72']
parsed_discourse_facet ['method_citation']
<S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S><S sid="67" ssid="4">We extend the Matsoukas et al approach in several ways.</S><S sid="151" ssid="8">In future work we plan to try this approach with more competitive SMT systems, and to extend instance weighting to other standard SMT components such as the LM, lexical phrase weights, and lexicalized distortion.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'65'", "'67'", "'151'", "'152'"]
'65'
'67'
'151'
'152'
['65', '67', '151', '152']
parsed_discourse_facet ['method_citation']
<S sid="49" ssid="13">This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="145" ssid="2">Each out-of-domain phrase pair is characterized by a set of simple features intended to reflect how useful it will be.</S><S sid="147" ssid="4">These estimates are in turn combined linearly with relative-frequency estimates from an in-domain phrase table.</S>
original cit marker offset is 0
new cit marker offset is 0



["'49'", "'50'", "'145'", "'147'"]
'49'
'50'
'145'
'147'
['49', '50', '145', '147']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="2">Even when there is training data available in the domain of interest, there is often additional data from other domains that could in principle be used to improve performance.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="54" ssid="18">However, we note that the final conditional estimates p(s|t) from a given phrase table maximize the likelihood of joint empirical phrase pair counts over a word-aligned corpus.</S><S sid="133" ssid="2">It is difficult to directly compare the Matsoukas et al results with ours, since our out-of-domain corpus is homogeneous; given heterogeneous training data, however, it would be trivial to include Matsoukas-style identity features in our instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'50'", "'54'", "'133'"]
'5'
'50'
'54'
'133'
['5', '50', '54', '133']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="44" ssid="8">When OUT is large and distinct, its contribution can be controlled by training separate IN and OUT models, and weighting their combination.</S><S sid="49" ssid="13">This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'44'", "'49'", "'50'"]
'30'
'44'
'49'
'50'
['30', '44', '49', '50']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'", "'30'", "'50'", "'141'"]
'28'
'30'
'50'
'141'
['28', '30', '50', '141']
parsed_discourse_facet ['aim_citation']
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="33" ssid="30">The paper is structured as follows.</S><S sid="105" ssid="9">Compared to the EMEA/EP setting, the two domains in the NIST setting are less homogeneous and more similar to each other; there is also considerably more IN text available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'30'", "'33'", "'105'"]
'0'
'30'
'33'
'105'
['0', '30', '33', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="52" ssid="16">It is not immediately obvious how to formulate an equivalent to equation (1) for an adapted TM, because there is no well-defined objective for learning TMs from parallel corpora.</S><S sid="53" ssid="17">This has led previous workers to adopt ad hoc linear weighting schemes (Finch and Sumita, 2008; Foster and Kuhn, 2007; L&#168;u et al., 2007).</S><S sid="74" ssid="11">(7) &#966; s,t This is a somewhat less direct objective than used by Matsoukas et al, who make an iterative approximation to expected TER.</S><S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'", "'53'", "'74'", "'75'"]
'52'
'53'
'74'
'75'
['52', '53', '74', '75']
parsed_discourse_facet ['method_citation']
<S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="60" ssid="24">The matching sentence pairs are then added to the IN corpus, and the system is re-trained.</S><S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'31'", "'60'", "'65'"]
'30'
'31'
'60'
'65'
['30', '31', '60', '65']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="16">The idea of distinguishing between general and domain-specific examples is due to Daum&#180;e and Marcu (2006), who used a maximum-entropy model with latent variables to capture the degree of specificity.</S><S sid="21" ssid="18">This highly effective approach is not directly applicable to the multinomial models used for core SMT components, which have no natural method for combining split features, so we rely on an instance-weighting approach (Jiang and Zhai, 2007) to downweight domain-specific examples in OUT.</S><S sid="22" ssid="19">Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.</S><S sid="89" ssid="26">We used 22 features for the logistic weighting model, divided into two groups: one intended to reflect the degree to which a phrase pair belongs to general language, and one intended to capture similarity to the IN domain.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'21'", "'22'", "'89'"]
'19'
'21'
'22'
'89'
['19', '21', '22', '89']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'30'", "'144'", "'152'"]
'23'
'30'
'144'
'152'
['23', '30', '144', '152']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="8" ssid="5">), which precludes a single universal approach to adaptation.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S><S sid="142" ssid="11">There has also been some work on adapting the word alignment model prior to phrase extraction (Civera and Juan, 2007; Wu et al., 2005), and on dynamically choosing a dev set (Xu et al., 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'31'", "'62'", "'142'"]
'8'
'31'
'62'
'142'
['8', '31', '62', '142']
parsed_discourse_facet ['hypothesis_citation']
<S sid="51" ssid="15">For the LM, adaptive weights are set as follows: where &#945; is a weight vector containing an element &#945;i for each domain (just IN and OUT in our case), pi are the corresponding domain-specific models, and &#732;p(w, h) is an empirical distribution from a targetlanguage training corpus&#8212;we used the IN dev set for this.</S><S sid="119" ssid="23">The 2nd block contains the IR system, which was tuned by selecting text in multiples of the size of the EMEA training corpus, according to dev set performance.</S><S sid="134" ssid="3">Although these authors report better gains than ours, they are with respect to a non-adapted baseline.</S><S sid="148" ssid="5">Mixing, smoothing, and instance-feature weights are learned at the same time using an efficient maximum-likelihood procedure that relies on only a small in-domain development corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'119'", "'134'", "'148'"]
'51'
'119'
'134'
'148'
['51', '119', '134', '148']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S><S sid="55" ssid="19">This suggests a direct parallel to (1): where &#732;p(s, t) is a joint empirical distribution extracted from the IN dev set using the standard procedure.2 An alternative form of linear combination is a maximum a posteriori (MAP) combination (Bacchiani et al., 2004).</S><S sid="68" ssid="5">First, we learn weights on individual phrase pairs rather than sentences.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'55'", "'68'", "'152'"]
'23'
'55'
'68'
'152'
['23', '55', '68', '152']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="40" ssid="4">We focus here instead on adapting the two most important features: the language model (LM), which estimates the probability p(wIh) of a target word w following an ngram h; and the translation models (TM) p(slt) and p(t1s), which give the probability of source phrase s translating to target phrase t, and vice versa.</S><S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S><S sid="137" ssid="6">At first glance, this seems only peripherally related to our work, since the specific/general distinction is made for features rather than instances.</S><S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'", "'95'", "'137'", "'144'"]
'40'
'95'
'137'
'144'
['40', '95', '137', '144']
parsed_discourse_facet ['method_citation']
dict_values(['In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.'])
dict_values(['Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation', 'This is a standard adaptation problem for SMT.', 'There is a fairly large body of work on SMT adaptation.', 'For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00645', '(95%-conf.int.', '0.00645', '-', '0.00645)']
['system', 'ROUGE-S*', 'Average_P:', '0.03846', '(95%-conf.int.', '0.03846', '-', '0.03846)']
['system', 'ROUGE-S*', 'Average_F:', '0.01105', '(95%-conf.int.', '0.01105', '-', '0.01105)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:465', 'P:78', 'F:3']
dict_values(['Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.', 'We used it to score all phrase pairs in the OUT table, in order to provide a feature for the instance-weighting model.'])
dict_values(['Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.', 'Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.', 'We have already mentioned the closely related work by Matsoukas et al (2009) on discriminative corpus weighting, and Jiang and Zhai (2007) on (nondiscriminative) instance weighting.', 'We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.'])
['system', 'ROUGE-S*', 'Average_R:', '0.19882', '(95%-conf.int.', '0.19882', '-', '0.19882)']
['system', 'ROUGE-S*', 'Average_P:', '0.76387', '(95%-conf.int.', '0.76387', '-', '0.76387)']
['system', 'ROUGE-S*', 'Average_F:', '0.31551', '(95%-conf.int.', '0.31551', '-', '0.31551)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2701', 'P:703', 'F:537']
dict_values(['In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.'])
dict_values(['Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation', 'Domain adaptation is a common concern when optimizing empirical NLP applications.', 'Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).', 'Other work includes transferring latent topic distributions from source to target language for LM adaptation, (Tam et al., 2007) and adapting features at the sentence level to different categories of sentence (Finch and Sumita, 2008).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00210', '(95%-conf.int.', '0.00210', '-', '0.00210)']
['system', 'ROUGE-S*', 'Average_P:', '0.04286', '(95%-conf.int.', '0.04286', '-', '0.04286)']
['system', 'ROUGE-S*', 'Average_F:', '0.00401', '(95%-conf.int.', '0.00401', '-', '0.00401)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4278', 'P:210', 'F:9']
dict_values(['To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.'])
dict_values(['Sentence pairs are the natural instances for SMT, but sentences often contain a mix of domain-specific and general language.', 'For instance, the sentence Similar improvements in haemoglobin levels were reported in the scientific literature for other epoetins would likely be considered domain-specific despite the presence of general phrases like were reported in.', 'For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.', 'To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07519', '(95%-conf.int.', '0.07519', '-', '0.07519)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.13986', '(95%-conf.int.', '0.13986', '-', '0.13986)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:120', 'F:120']
dict_values(['In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.'])
dict_values(['A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.', 'When OUT is large and distinct, its contribution can be controlled by training separate IN and OUT models, and weighting their combination.', 'This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.', 'Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00198', '(95%-conf.int.', '0.00198', '-', '0.00198)']
['system', 'ROUGE-S*', 'Average_P:', '0.01905', '(95%-conf.int.', '0.01905', '-', '0.01905)']
['system', 'ROUGE-S*', 'Average_F:', '0.00359', '(95%-conf.int.', '0.00359', '-', '0.00359)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:210', 'F:4']
dict_values(['Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.'])
dict_values(['The idea of distinguishing between general and domain-specific examples is due to Daum&#180;e and Marcu (2006), who used a maximum-entropy model with latent variables to capture the degree of specificity.', 'This highly effective approach is not directly applicable to the multinomial models used for core SMT components, which have no natural method for combining split features, so we rely on an instance-weighting approach (Jiang and Zhai, 2007) to downweight domain-specific examples in OUT.', 'Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.', 'We used 22 features for the logistic weighting model, divided into two groups: one intended to reflect the degree to which a phrase pair belongs to general language, and one intended to capture similarity to the IN domain.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02666', '(95%-conf.int.', '0.02666', '-', '0.02666)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.05193', '(95%-conf.int.', '0.05193', '-', '0.05193)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2926', 'P:78', 'F:78']
dict_values(['Our second contribution is to apply instance weighting at the level of phrase pairs.'])
dict_values(['Our second contribution is to apply instance weighting at the level of phrase pairs.', 'A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.', 'In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.', 'We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02220', '(95%-conf.int.', '0.02220', '-', '0.02220)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.04343', '(95%-conf.int.', '0.04343', '-', '0.04343)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:946', 'P:21', 'F:21']
dict_values(['Our second contribution is to apply instance weighting at the level of phrase pairs.', 'Sentence pairs are the natural instances for SMT, but sentences often contain a mix of domain-specific and general language.'])
dict_values(['Our second contribution is to apply instance weighting at the level of phrase pairs.', 'This suggests a direct parallel to (1): where &#732;p(s, t) is a joint empirical distribution extracted from the IN dev set using the standard procedure.2 An alternative form of linear combination is a maximum a posteriori (MAP) combination (Bacchiani et al., 2004).', 'First, we learn weights on individual phrase pairs rather than sentences.', 'We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03030', '(95%-conf.int.', '0.03030', '-', '0.03030)']
['system', 'ROUGE-S*', 'Average_P:', '0.29412', '(95%-conf.int.', '0.29412', '-', '0.29412)']
['system', 'ROUGE-S*', 'Average_F:', '0.05495', '(95%-conf.int.', '0.05495', '-', '0.05495)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:153', 'F:45']
dict_values(['We focus here instead on adapting the two most important features: the language model (LM), which estimates the probability p(wIh) of a target word w following an ngram h; and the translation models (TM) p(slt) and p(t1s), which give the probability of source phrase s translating to target phrase t, and vice versa.'])
dict_values(['We focus here instead on adapting the two most important features: the language model (LM), which estimates the probability p(wIh) of a target word w following an ngram h; and the translation models (TM) p(slt) and p(t1s), which give the probability of source phrase s translating to target phrase t, and vice versa.', 'Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.', 'At first glance, this seems only peripherally related to our work, since the specific/general distinction is made for features rather than instances.', 'In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.'])
['system', 'ROUGE-S*', 'Average_R:', '0.11392', '(95%-conf.int.', '0.11392', '-', '0.11392)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.20455', '(95%-conf.int.', '0.20455', '-', '0.20455)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3081', 'P:351', 'F:351']
0.5731511047427655 0.05306888829923458 0.09209777675446916





input/ref/Task1/D10-1044_swastika.csv
input/res/Task1/D10-1044.annv3.csv
parsing: input/ref/Task1/D10-1044_swastika.csv
<S sid="9" ssid="6">In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.</S>
original cit marker offset is 0
new cit marker offset is 0



['9']
9
['9']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="6">In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.</S>
original cit marker offset is 0
new cit marker offset is 0



['9']
9
['9']
parsed_discourse_facet ['aim_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



['62']
62
['62']
parsed_discourse_facet ['method_citation']
<S sid="71" ssid="8">Finally, we incorporate the instance-weighting model into a general linear combination, and learn weights and mixing parameters simultaneously. where c&#955;(s, t) is a modified count for pair (s, t) in OUT, u(s|t) is a prior distribution, and y is a prior weight.</S>
original cit marker offset is 0
new cit marker offset is 0



['71']
71
['71']
parsed_discourse_facet ['method_citation']
<S sid="96" ssid="33">We used it to score all phrase pairs in the OUT table, in order to provide a feature for the instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



['96']
96
['96']
parsed_discourse_facet ['aim_citation']
<S sid="71" ssid="8">Finally, we incorporate the instance-weighting model into a general linear combination, and learn weights and mixing parameters simultaneously. where c&#955;(s, t) is a modified count for pair (s, t) in OUT, u(s|t) is a prior distribution, and y is a prior weight.</S>
original cit marker offset is 0
new cit marker offset is 0



['71']
71
['71']
parsed_discourse_facet ['result_citation']
<S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



['144']
144
['144']
parsed_discourse_facet ['result_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



['62']
62
['62']
parsed_discourse_facet ['method_citation']
<S sid="45" ssid="9">An easy way to achieve this is to put the domain-specific LMs and TMs into the top-level log-linear model and learn optimal weights with MERT (Och, 2003).</S>
original cit marker offset is 0
new cit marker offset is 0



['45']
45
['45']
parsed_discourse_facet ['method_citation']
<S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



['75']
75
['75']
parsed_discourse_facet ['method_citation']
<S sid="22" ssid="19">Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.</S>
original cit marker offset is 0
new cit marker offset is 0



['22']
22
['22']
parsed_discourse_facet ['method_citation']
<S sid="96" ssid="33">We used it to score all phrase pairs in the OUT table, in order to provide a feature for the instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



['96']
96
['96']
parsed_discourse_facet ['aim_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



['62']
62
['62']
parsed_discourse_facet ['method_citation']
  <S sid="42" ssid="6">The natural baseline approach is to concatenate data from IN and OUT.</S>
original cit marker offset is 0
new cit marker offset is 0



['42']
42
['42']
parsed_discourse_facet ['aim_citation']
<S sid="96" ssid="33">We used it to score all phrase pairs in the OUT table, in order to provide a feature for the instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



['96']
96
['96']
parsed_discourse_facet ['aim_citation']
parsing: input/res/Task1/D10-1044.annv3.csv
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="10" ssid="7">This is a standard adaptation problem for SMT.</S><S sid="14" ssid="11">There is a fairly large body of work on SMT adaptation.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'10'", "'14'", "'31'"]
'0'
'10'
'14'
'31'
['0', '10', '14', '31']
parsed_discourse_facet ['results_citation']
<S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S><S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S><S sid="132" ssid="1">We have already mentioned the closely related work by Matsoukas et al (2009) on discriminative corpus weighting, and Jiang and Zhai (2007) on (nondiscriminative) instance weighting.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'65'", "'95'", "'132'", "'152'"]
'65'
'95'
'132'
'152'
['65', '95', '132', '152']
parsed_discourse_facet ['method_citation']
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="4" ssid="1">Domain adaptation is a common concern when optimizing empirical NLP applications.</S><S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S><S sid="143" ssid="12">Other work includes transferring latent topic distributions from source to target language for LM adaptation, (Tam et al., 2007) and adapting features at the sentence level to different categories of sentence (Finch and Sumita, 2008).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'4'", "'141'", "'143'"]
'0'
'4'
'141'
'143'
['0', '4', '141', '143']
parsed_discourse_facet ['aim_citation']
<S sid="24" ssid="21">Sentence pairs are the natural instances for SMT, but sentences often contain a mix of domain-specific and general language.</S><S sid="25" ssid="22">For instance, the sentence Similar improvements in haemoglobin levels were reported in the scientific literature for other epoetins would likely be considered domain-specific despite the presence of general phrases like were reported in.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'31'", "'62'"]
'24'
'25'
'31'
'62'
['24', '25', '31', '62']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="51" ssid="15">For the LM, adaptive weights are set as follows: where &#945; is a weight vector containing an element &#945;i for each domain (just IN and OUT in our case), pi are the corresponding domain-specific models, and &#732;p(w, h) is an empirical distribution from a targetlanguage training corpus&#8212;we used the IN dev set for this.</S><S sid="71" ssid="8">Finally, we incorporate the instance-weighting model into a general linear combination, and learn weights and mixing parameters simultaneously. where c&#955;(s, t) is a modified count for pair (s, t) in OUT, u(s|t) is a prior distribution, and y is a prior weight.</S><S sid="72" ssid="9">The original OUT counts co(s, t) are weighted by a logistic function w&#955;(s, t): To motivate weighting joint OUT counts as in (6), we begin with the &#8220;ideal&#8221; objective for setting multinomial phrase probabilities 0 = {p(s|t), dst}, which is the likelihood with respect to the true IN distribution pi(s, t).</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'51'", "'71'", "'72'"]
'50'
'51'
'71'
'72'
['50', '51', '71', '72']
parsed_discourse_facet ['method_citation']
<S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S><S sid="67" ssid="4">We extend the Matsoukas et al approach in several ways.</S><S sid="151" ssid="8">In future work we plan to try this approach with more competitive SMT systems, and to extend instance weighting to other standard SMT components such as the LM, lexical phrase weights, and lexicalized distortion.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'65'", "'67'", "'151'", "'152'"]
'65'
'67'
'151'
'152'
['65', '67', '151', '152']
parsed_discourse_facet ['method_citation']
<S sid="49" ssid="13">This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="145" ssid="2">Each out-of-domain phrase pair is characterized by a set of simple features intended to reflect how useful it will be.</S><S sid="147" ssid="4">These estimates are in turn combined linearly with relative-frequency estimates from an in-domain phrase table.</S>
original cit marker offset is 0
new cit marker offset is 0



["'49'", "'50'", "'145'", "'147'"]
'49'
'50'
'145'
'147'
['49', '50', '145', '147']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="2">Even when there is training data available in the domain of interest, there is often additional data from other domains that could in principle be used to improve performance.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="54" ssid="18">However, we note that the final conditional estimates p(s|t) from a given phrase table maximize the likelihood of joint empirical phrase pair counts over a word-aligned corpus.</S><S sid="133" ssid="2">It is difficult to directly compare the Matsoukas et al results with ours, since our out-of-domain corpus is homogeneous; given heterogeneous training data, however, it would be trivial to include Matsoukas-style identity features in our instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'50'", "'54'", "'133'"]
'5'
'50'
'54'
'133'
['5', '50', '54', '133']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="44" ssid="8">When OUT is large and distinct, its contribution can be controlled by training separate IN and OUT models, and weighting their combination.</S><S sid="49" ssid="13">This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'44'", "'49'", "'50'"]
'30'
'44'
'49'
'50'
['30', '44', '49', '50']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'", "'30'", "'50'", "'141'"]
'28'
'30'
'50'
'141'
['28', '30', '50', '141']
parsed_discourse_facet ['aim_citation']
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="33" ssid="30">The paper is structured as follows.</S><S sid="105" ssid="9">Compared to the EMEA/EP setting, the two domains in the NIST setting are less homogeneous and more similar to each other; there is also considerably more IN text available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'30'", "'33'", "'105'"]
'0'
'30'
'33'
'105'
['0', '30', '33', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="52" ssid="16">It is not immediately obvious how to formulate an equivalent to equation (1) for an adapted TM, because there is no well-defined objective for learning TMs from parallel corpora.</S><S sid="53" ssid="17">This has led previous workers to adopt ad hoc linear weighting schemes (Finch and Sumita, 2008; Foster and Kuhn, 2007; L&#168;u et al., 2007).</S><S sid="74" ssid="11">(7) &#966; s,t This is a somewhat less direct objective than used by Matsoukas et al, who make an iterative approximation to expected TER.</S><S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'", "'53'", "'74'", "'75'"]
'52'
'53'
'74'
'75'
['52', '53', '74', '75']
parsed_discourse_facet ['method_citation']
<S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="60" ssid="24">The matching sentence pairs are then added to the IN corpus, and the system is re-trained.</S><S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'31'", "'60'", "'65'"]
'30'
'31'
'60'
'65'
['30', '31', '60', '65']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="16">The idea of distinguishing between general and domain-specific examples is due to Daum&#180;e and Marcu (2006), who used a maximum-entropy model with latent variables to capture the degree of specificity.</S><S sid="21" ssid="18">This highly effective approach is not directly applicable to the multinomial models used for core SMT components, which have no natural method for combining split features, so we rely on an instance-weighting approach (Jiang and Zhai, 2007) to downweight domain-specific examples in OUT.</S><S sid="22" ssid="19">Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.</S><S sid="89" ssid="26">We used 22 features for the logistic weighting model, divided into two groups: one intended to reflect the degree to which a phrase pair belongs to general language, and one intended to capture similarity to the IN domain.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'21'", "'22'", "'89'"]
'19'
'21'
'22'
'89'
['19', '21', '22', '89']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'30'", "'144'", "'152'"]
'23'
'30'
'144'
'152'
['23', '30', '144', '152']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="8" ssid="5">), which precludes a single universal approach to adaptation.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S><S sid="142" ssid="11">There has also been some work on adapting the word alignment model prior to phrase extraction (Civera and Juan, 2007; Wu et al., 2005), and on dynamically choosing a dev set (Xu et al., 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'31'", "'62'", "'142'"]
'8'
'31'
'62'
'142'
['8', '31', '62', '142']
parsed_discourse_facet ['hypothesis_citation']
<S sid="51" ssid="15">For the LM, adaptive weights are set as follows: where &#945; is a weight vector containing an element &#945;i for each domain (just IN and OUT in our case), pi are the corresponding domain-specific models, and &#732;p(w, h) is an empirical distribution from a targetlanguage training corpus&#8212;we used the IN dev set for this.</S><S sid="119" ssid="23">The 2nd block contains the IR system, which was tuned by selecting text in multiples of the size of the EMEA training corpus, according to dev set performance.</S><S sid="134" ssid="3">Although these authors report better gains than ours, they are with respect to a non-adapted baseline.</S><S sid="148" ssid="5">Mixing, smoothing, and instance-feature weights are learned at the same time using an efficient maximum-likelihood procedure that relies on only a small in-domain development corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'119'", "'134'", "'148'"]
'51'
'119'
'134'
'148'
['51', '119', '134', '148']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S><S sid="55" ssid="19">This suggests a direct parallel to (1): where &#732;p(s, t) is a joint empirical distribution extracted from the IN dev set using the standard procedure.2 An alternative form of linear combination is a maximum a posteriori (MAP) combination (Bacchiani et al., 2004).</S><S sid="68" ssid="5">First, we learn weights on individual phrase pairs rather than sentences.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'55'", "'68'", "'152'"]
'23'
'55'
'68'
'152'
['23', '55', '68', '152']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="40" ssid="4">We focus here instead on adapting the two most important features: the language model (LM), which estimates the probability p(wIh) of a target word w following an ngram h; and the translation models (TM) p(slt) and p(t1s), which give the probability of source phrase s translating to target phrase t, and vice versa.</S><S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S><S sid="137" ssid="6">At first glance, this seems only peripherally related to our work, since the specific/general distinction is made for features rather than instances.</S><S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'", "'95'", "'137'", "'144'"]
'40'
'95'
'137'
'144'
['40', '95', '137', '144']
parsed_discourse_facet ['method_citation']
dict_values(['In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.'])
dict_values(['Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation', 'This is a standard adaptation problem for SMT.', 'There is a fairly large body of work on SMT adaptation.', 'For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:465', 'P:210', 'F:0']
dict_values(['In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.'])
dict_values(['Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation', 'Domain adaptation is a common concern when optimizing empirical NLP applications.', 'Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).', 'Other work includes transferring latent topic distributions from source to target language for LM adaptation, (Tam et al., 2007) and adapting features at the sentence level to different categories of sentence (Finch and Sumita, 2008).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00210', '(95%-conf.int.', '0.00210', '-', '0.00210)']
['system', 'ROUGE-S*', 'Average_P:', '0.04286', '(95%-conf.int.', '0.04286', '-', '0.04286)']
['system', 'ROUGE-S*', 'Average_F:', '0.00401', '(95%-conf.int.', '0.00401', '-', '0.00401)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4278', 'P:210', 'F:9']
dict_values(['To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.'])
dict_values(['Sentence pairs are the natural instances for SMT, but sentences often contain a mix of domain-specific and general language.', 'For instance, the sentence Similar improvements in haemoglobin levels were reported in the scientific literature for other epoetins would likely be considered domain-specific despite the presence of general phrases like were reported in.', 'For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.', 'To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07519', '(95%-conf.int.', '0.07519', '-', '0.07519)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.13986', '(95%-conf.int.', '0.13986', '-', '0.13986)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:120', 'F:120']
dict_values(['To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.'])
dict_values(['A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.', 'When OUT is large and distinct, its contribution can be controlled by training separate IN and OUT models, and weighting their combination.', 'This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.', 'Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00050', '(95%-conf.int.', '0.00050', '-', '0.00050)']
['system', 'ROUGE-S*', 'Average_P:', '0.00833', '(95%-conf.int.', '0.00833', '-', '0.00833)']
['system', 'ROUGE-S*', 'Average_F:', '0.00094', '(95%-conf.int.', '0.00094', '-', '0.00094)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:120', 'F:1']
dict_values(['Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.'])
dict_values(['The idea of distinguishing between general and domain-specific examples is due to Daum&#180;e and Marcu (2006), who used a maximum-entropy model with latent variables to capture the degree of specificity.', 'This highly effective approach is not directly applicable to the multinomial models used for core SMT components, which have no natural method for combining split features, so we rely on an instance-weighting approach (Jiang and Zhai, 2007) to downweight domain-specific examples in OUT.', 'Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.', 'We used 22 features for the logistic weighting model, divided into two groups: one intended to reflect the degree to which a phrase pair belongs to general language, and one intended to capture similarity to the IN domain.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02666', '(95%-conf.int.', '0.02666', '-', '0.02666)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.05193', '(95%-conf.int.', '0.05193', '-', '0.05193)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2926', 'P:78', 'F:78']
dict_values(['We used it to score all phrase pairs in the OUT table, in order to provide a feature for the instance-weighting model.'])
dict_values(['Our second contribution is to apply instance weighting at the level of phrase pairs.', 'A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.', 'In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.', 'We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01374', '(95%-conf.int.', '0.01374', '-', '0.01374)']
['system', 'ROUGE-S*', 'Average_P:', '0.28889', '(95%-conf.int.', '0.28889', '-', '0.28889)']
['system', 'ROUGE-S*', 'Average_F:', '0.02624', '(95%-conf.int.', '0.02624', '-', '0.02624)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:946', 'P:45', 'F:13']
dict_values(['We used it to score all phrase pairs in the OUT table, in order to provide a feature for the instance-weighting model.'])
dict_values(['Our second contribution is to apply instance weighting at the level of phrase pairs.', 'This suggests a direct parallel to (1): where &#732;p(s, t) is a joint empirical distribution extracted from the IN dev set using the standard procedure.2 An alternative form of linear combination is a maximum a posteriori (MAP) combination (Bacchiani et al., 2004).', 'First, we learn weights on individual phrase pairs rather than sentences.', 'We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00471', '(95%-conf.int.', '0.00471', '-', '0.00471)']
['system', 'ROUGE-S*', 'Average_P:', '0.15556', '(95%-conf.int.', '0.15556', '-', '0.15556)']
['system', 'ROUGE-S*', 'Average_F:', '0.00915', '(95%-conf.int.', '0.00915', '-', '0.00915)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:45', 'F:7']
0.3565199949068572 0.017557142606326535 0.03316142809769388





input/ref/Task1/D10-1044_sweta.csv
input/res/Task1/D10-1044.annv3.csv
parsing: input/ref/Task1/D10-1044_sweta.csv
<S sid="4" ssid="1">Domain adaptation is a common concern when optimizing empirical NLP applications.</S>
original cit marker offset is 0
new cit marker offset is 0



["4'"]
4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="132" ssid="1">We have already mentioned the closely related work by Matsoukas et al (2009) on discriminative corpus weighting, and Jiang and Zhai (2007) on (nondiscriminative) instance weighting.</S>
original cit marker offset is 0
new cit marker offset is 0



["132'"]
132'
['132']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="4">For developers of Statistical Machine Translation (SMT) systems, an additional complication is the heterogeneous nature of SMT components (word-alignment model, language model, translation model, etc.</S>
original cit marker offset is 0
new cit marker offset is 0



["7'"]
7'
['7']
parsed_discourse_facet ['method_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["62'"]
62'
['62']
parsed_discourse_facet ['method_citation']
<S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S>
original cit marker offset is 0
new cit marker offset is 0



["50'"]
50'
['50']
parsed_discourse_facet ['method_citation']
<S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["152'"]
152'
['152']
parsed_discourse_facet ['method_citation']
<S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["144'"]
144'
['144']
parsed_discourse_facet ['method_citation']
 <S sid="9" ssid="6">In this paper we study the problem of using a parallel corpus from a background domain (OUT) to improve performance on a target domain (IN) for which a smaller amount of parallel training material&#8212;though adequate for reasonable performance&#8212;is also available.</S>
original cit marker offset is 0
new cit marker offset is 0



["9'"]
9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



["75'"]
75'
['75']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S>
original cit marker offset is 0
new cit marker offset is 0



["28'"]
28'
['28']
parsed_discourse_facet ['method_citation']
<S sid="97" ssid="1">We carried out translation experiments in two different settings.</S>
original cit marker offset is 0
new cit marker offset is 0



["97'"]
97'
['97']
parsed_discourse_facet ['method_citation']
<S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



["75'"]
75'
['75']
parsed_discourse_facet ['method_citation']
<S sid="143" ssid="12">Other work includes transferring latent topic distributions from source to target language for LM adaptation, (Tam et al., 2007) and adapting features at the sentence level to different categories of sentence (Finch and Sumita, 2008).</S>
original cit marker offset is 0
new cit marker offset is 0



["143'"]
143'
['143']
parsed_discourse_facet ['method_citation']
<S sid="153" ssid="10">Finally, we intend to explore more sophisticated instanceweighting features for capturing the degree of generality of phrase pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["153'"]
153'
['153']
parsed_discourse_facet ['method_citation']
<S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["144'"]
144'
['144']
parsed_discourse_facet ['method_citation']
<S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["62'"]
62'
['62']
parsed_discourse_facet ['method_citation']
<S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["141'"]
141'
['141']
parsed_discourse_facet ['method_citation']
 <S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S>
original cit marker offset is 0
new cit marker offset is 0



["28'"]
28'
['28']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="1">Standard SMT systems have a hierarchical parameter structure: top-level log-linear weights are used to combine a small set of complex features, interpreted as log probabilities, many of which have their own internal parameters and objectives.</S>
original cit marker offset is 0
new cit marker offset is 0



["37'"]
37'
['37']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/D10-1044.annv3.csv
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="10" ssid="7">This is a standard adaptation problem for SMT.</S><S sid="14" ssid="11">There is a fairly large body of work on SMT adaptation.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'10'", "'14'", "'31'"]
'0'
'10'
'14'
'31'
['0', '10', '14', '31']
parsed_discourse_facet ['results_citation']
<S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S><S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S><S sid="132" ssid="1">We have already mentioned the closely related work by Matsoukas et al (2009) on discriminative corpus weighting, and Jiang and Zhai (2007) on (nondiscriminative) instance weighting.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'65'", "'95'", "'132'", "'152'"]
'65'
'95'
'132'
'152'
['65', '95', '132', '152']
parsed_discourse_facet ['method_citation']
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="4" ssid="1">Domain adaptation is a common concern when optimizing empirical NLP applications.</S><S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S><S sid="143" ssid="12">Other work includes transferring latent topic distributions from source to target language for LM adaptation, (Tam et al., 2007) and adapting features at the sentence level to different categories of sentence (Finch and Sumita, 2008).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'4'", "'141'", "'143'"]
'0'
'4'
'141'
'143'
['0', '4', '141', '143']
parsed_discourse_facet ['aim_citation']
<S sid="24" ssid="21">Sentence pairs are the natural instances for SMT, but sentences often contain a mix of domain-specific and general language.</S><S sid="25" ssid="22">For instance, the sentence Similar improvements in haemoglobin levels were reported in the scientific literature for other epoetins would likely be considered domain-specific despite the presence of general phrases like were reported in.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'31'", "'62'"]
'24'
'25'
'31'
'62'
['24', '25', '31', '62']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="51" ssid="15">For the LM, adaptive weights are set as follows: where &#945; is a weight vector containing an element &#945;i for each domain (just IN and OUT in our case), pi are the corresponding domain-specific models, and &#732;p(w, h) is an empirical distribution from a targetlanguage training corpus&#8212;we used the IN dev set for this.</S><S sid="71" ssid="8">Finally, we incorporate the instance-weighting model into a general linear combination, and learn weights and mixing parameters simultaneously. where c&#955;(s, t) is a modified count for pair (s, t) in OUT, u(s|t) is a prior distribution, and y is a prior weight.</S><S sid="72" ssid="9">The original OUT counts co(s, t) are weighted by a logistic function w&#955;(s, t): To motivate weighting joint OUT counts as in (6), we begin with the &#8220;ideal&#8221; objective for setting multinomial phrase probabilities 0 = {p(s|t), dst}, which is the likelihood with respect to the true IN distribution pi(s, t).</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'51'", "'71'", "'72'"]
'50'
'51'
'71'
'72'
['50', '51', '71', '72']
parsed_discourse_facet ['method_citation']
<S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S><S sid="67" ssid="4">We extend the Matsoukas et al approach in several ways.</S><S sid="151" ssid="8">In future work we plan to try this approach with more competitive SMT systems, and to extend instance weighting to other standard SMT components such as the LM, lexical phrase weights, and lexicalized distortion.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'65'", "'67'", "'151'", "'152'"]
'65'
'67'
'151'
'152'
['65', '67', '151', '152']
parsed_discourse_facet ['method_citation']
<S sid="49" ssid="13">This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="145" ssid="2">Each out-of-domain phrase pair is characterized by a set of simple features intended to reflect how useful it will be.</S><S sid="147" ssid="4">These estimates are in turn combined linearly with relative-frequency estimates from an in-domain phrase table.</S>
original cit marker offset is 0
new cit marker offset is 0



["'49'", "'50'", "'145'", "'147'"]
'49'
'50'
'145'
'147'
['49', '50', '145', '147']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="2">Even when there is training data available in the domain of interest, there is often additional data from other domains that could in principle be used to improve performance.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="54" ssid="18">However, we note that the final conditional estimates p(s|t) from a given phrase table maximize the likelihood of joint empirical phrase pair counts over a word-aligned corpus.</S><S sid="133" ssid="2">It is difficult to directly compare the Matsoukas et al results with ours, since our out-of-domain corpus is homogeneous; given heterogeneous training data, however, it would be trivial to include Matsoukas-style identity features in our instance-weighting model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'50'", "'54'", "'133'"]
'5'
'50'
'54'
'133'
['5', '50', '54', '133']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="44" ssid="8">When OUT is large and distinct, its contribution can be controlled by training separate IN and OUT models, and weighting their combination.</S><S sid="49" ssid="13">This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'44'", "'49'", "'50'"]
'30'
'44'
'49'
'50'
['30', '44', '49', '50']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="25">We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="50" ssid="14">Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.</S><S sid="141" ssid="10">Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'", "'30'", "'50'", "'141'"]
'28'
'30'
'50'
'141'
['28', '30', '50', '141']
parsed_discourse_facet ['aim_citation']
<S sid="0">Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="33" ssid="30">The paper is structured as follows.</S><S sid="105" ssid="9">Compared to the EMEA/EP setting, the two domains in the NIST setting are less homogeneous and more similar to each other; there is also considerably more IN text available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'30'", "'33'", "'105'"]
'0'
'30'
'33'
'105'
['0', '30', '33', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="52" ssid="16">It is not immediately obvious how to formulate an equivalent to equation (1) for an adapted TM, because there is no well-defined objective for learning TMs from parallel corpora.</S><S sid="53" ssid="17">This has led previous workers to adopt ad hoc linear weighting schemes (Finch and Sumita, 2008; Foster and Kuhn, 2007; L&#168;u et al., 2007).</S><S sid="74" ssid="11">(7) &#966; s,t This is a somewhat less direct objective than used by Matsoukas et al, who make an iterative approximation to expected TER.</S><S sid="75" ssid="12">However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'", "'53'", "'74'", "'75'"]
'52'
'53'
'74'
'75'
['52', '53', '74', '75']
parsed_discourse_facet ['method_citation']
<S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="60" ssid="24">The matching sentence pairs are then added to the IN corpus, and the system is re-trained.</S><S sid="65" ssid="2">Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'", "'31'", "'60'", "'65'"]
'30'
'31'
'60'
'65'
['30', '31', '60', '65']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="16">The idea of distinguishing between general and domain-specific examples is due to Daum&#180;e and Marcu (2006), who used a maximum-entropy model with latent variables to capture the degree of specificity.</S><S sid="21" ssid="18">This highly effective approach is not directly applicable to the multinomial models used for core SMT components, which have no natural method for combining split features, so we rely on an instance-weighting approach (Jiang and Zhai, 2007) to downweight domain-specific examples in OUT.</S><S sid="22" ssid="19">Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.</S><S sid="89" ssid="26">We used 22 features for the logistic weighting model, divided into two groups: one intended to reflect the degree to which a phrase pair belongs to general language, and one intended to capture similarity to the IN domain.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'21'", "'22'", "'89'"]
'19'
'21'
'22'
'89'
['19', '21', '22', '89']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S><S sid="30" ssid="27">A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.</S><S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'30'", "'144'", "'152'"]
'23'
'30'
'144'
'152'
['23', '30', '144', '152']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="8" ssid="5">), which precludes a single universal approach to adaptation.</S><S sid="31" ssid="28">For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.</S><S sid="62" ssid="26">To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.</S><S sid="142" ssid="11">There has also been some work on adapting the word alignment model prior to phrase extraction (Civera and Juan, 2007; Wu et al., 2005), and on dynamically choosing a dev set (Xu et al., 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'31'", "'62'", "'142'"]
'8'
'31'
'62'
'142'
['8', '31', '62', '142']
parsed_discourse_facet ['hypothesis_citation']
<S sid="51" ssid="15">For the LM, adaptive weights are set as follows: where &#945; is a weight vector containing an element &#945;i for each domain (just IN and OUT in our case), pi are the corresponding domain-specific models, and &#732;p(w, h) is an empirical distribution from a targetlanguage training corpus&#8212;we used the IN dev set for this.</S><S sid="119" ssid="23">The 2nd block contains the IR system, which was tuned by selecting text in multiples of the size of the EMEA training corpus, according to dev set performance.</S><S sid="134" ssid="3">Although these authors report better gains than ours, they are with respect to a non-adapted baseline.</S><S sid="148" ssid="5">Mixing, smoothing, and instance-feature weights are learned at the same time using an efficient maximum-likelihood procedure that relies on only a small in-domain development corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'119'", "'134'", "'148'"]
'51'
'119'
'134'
'148'
['51', '119', '134', '148']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="20">Our second contribution is to apply instance weighting at the level of phrase pairs.</S><S sid="55" ssid="19">This suggests a direct parallel to (1): where &#732;p(s, t) is a joint empirical distribution extracted from the IN dev set using the standard procedure.2 An alternative form of linear combination is a maximum a posteriori (MAP) combination (Bacchiani et al., 2004).</S><S sid="68" ssid="5">First, we learn weights on individual phrase pairs rather than sentences.</S><S sid="152" ssid="9">We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'55'", "'68'", "'152'"]
'23'
'55'
'68'
'152'
['23', '55', '68', '152']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="40" ssid="4">We focus here instead on adapting the two most important features: the language model (LM), which estimates the probability p(wIh) of a target word w following an ngram h; and the translation models (TM) p(slt) and p(t1s), which give the probability of source phrase s translating to target phrase t, and vice versa.</S><S sid="95" ssid="32">Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.</S><S sid="137" ssid="6">At first glance, this seems only peripherally related to our work, since the specific/general distinction is made for features rather than instances.</S><S sid="144" ssid="1">In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'", "'95'", "'137'", "'144'"]
'40'
'95'
'137'
'144'
['40', '95', '137', '144']
parsed_discourse_facet ['method_citation']
dict_values(['Domain adaptation is a common concern when optimizing empirical NLP applications.'])
dict_values(['Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation', 'This is a standard adaptation problem for SMT.', 'There is a fairly large body of work on SMT adaptation.', 'For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00215', '(95%-conf.int.', '0.00215', '-', '0.00215)']
['system', 'ROUGE-S*', 'Average_P:', '0.03571', '(95%-conf.int.', '0.03571', '-', '0.03571)']
['system', 'ROUGE-S*', 'Average_F:', '0.00406', '(95%-conf.int.', '0.00406', '-', '0.00406)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:465', 'P:28', 'F:1']
dict_values(['We have already mentioned the closely related work by Matsoukas et al (2009) on discriminative corpus weighting, and Jiang and Zhai (2007) on (nondiscriminative) instance weighting.'])
dict_values(['Matsoukas et al (2009) generalize it by learning weights on sentence pairs that are used when estimating relative-frequency phrase-pair probabilities.', 'Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.', 'We have already mentioned the closely related work by Matsoukas et al (2009) on discriminative corpus weighting, and Jiang and Zhai (2007) on (nondiscriminative) instance weighting.', 'We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.'])
['system', 'ROUGE-S*', 'Average_R:', '0.04443', '(95%-conf.int.', '0.04443', '-', '0.04443)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.08508', '(95%-conf.int.', '0.08508', '-', '0.08508)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2701', 'P:120', 'F:120']
dict_values(['For developers of Statistical Machine Translation (SMT) systems, an additional complication is the heterogeneous nature of SMT components (word-alignment model, language model, translation model, etc.'])
dict_values(['Discriminative Instance Weighting for Domain Adaptation in Statistical Machine Translation', 'Domain adaptation is a common concern when optimizing empirical NLP applications.', 'Moving beyond directly related work, major themes in SMT adaptation include the IR (Hildebrand et al., 2005; L&#168;u et al., 2007; Zhao et al., 2004) and mixture (Finch and Sumita, 2008; Foster and Kuhn, 2007; Koehn and Schroeder, 2007; L&#168;u et al., 2007) approaches for LMs and TMs described above, as well as methods for exploiting monolingual in-domain text, typically by translating it automatically and then performing self training (Bertoldi and Federico, 2009; Ueffing et al., 2007; Schwenk and Senellart, 2009).', 'Other work includes transferring latent topic distributions from source to target language for LM adaptation, (Tam et al., 2007) and adapting features at the sentence level to different categories of sentence (Finch and Sumita, 2008).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00327', '(95%-conf.int.', '0.00327', '-', '0.00327)']
['system', 'ROUGE-S*', 'Average_P:', '0.08187', '(95%-conf.int.', '0.08187', '-', '0.08187)']
['system', 'ROUGE-S*', 'Average_F:', '0.00629', '(95%-conf.int.', '0.00629', '-', '0.00629)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4278', 'P:171', 'F:14']
dict_values(['To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.'])
dict_values(['Sentence pairs are the natural instances for SMT, but sentences often contain a mix of domain-specific and general language.', 'For instance, the sentence Similar improvements in haemoglobin levels were reported in the scientific literature for other epoetins would likely be considered domain-specific despite the presence of general phrases like were reported in.', 'For comparison to information-retrieval inspired baselines, eg (L&#168;u et al., 2007), we select sentences from OUT using language model perplexities from IN.', 'To approximate these baselines, we implemented a very simple sentence selection algorithm in which parallel sentence pairs from OUT are ranked by the perplexity of their target half according to the IN language model.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07519', '(95%-conf.int.', '0.07519', '-', '0.07519)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.13986', '(95%-conf.int.', '0.13986', '-', '0.13986)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:120', 'F:120']
dict_values(['However, it is robust, efficient, and easy to implement.4 To perform the maximization in (7), we used the popular L-BFGS algorithm (Liu and Nocedal, 1989), which requires gradient information.'])
dict_values(['A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.', 'When OUT is large and distinct, its contribution can be controlled by training separate IN and OUT models, and weighting their combination.', 'This leads to a linear combination of domain-specific probabilities, with weights in 0, 1, normalized to sum to 1.', 'Linear weights are difficult to incorporate into the standard MERT procedure because they are &#8220;hidden&#8221; within a top-level probability that represents the linear combination.1 Following previous work (Foster and Kuhn, 2007), we circumvent this problem by choosing weights to optimize corpus loglikelihood, which is roughly speaking the training criterion used by the LM and TM themselves.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:136', 'F:0']
dict_values(['Finally, we intend to explore more sophisticated instanceweighting features for capturing the degree of generality of phrase pairs.'])
dict_values(['The idea of distinguishing between general and domain-specific examples is due to Daum&#180;e and Marcu (2006), who used a maximum-entropy model with latent variables to capture the degree of specificity.', 'This highly effective approach is not directly applicable to the multinomial models used for core SMT components, which have no natural method for combining split features, so we rely on an instance-weighting approach (Jiang and Zhai, 2007) to downweight domain-specific examples in OUT.', 'Within this framework, we use features intended to capture degree of generality, including the output from an SVM classifier that uses the intersection between IN and OUT as positive examples.', 'We used 22 features for the logistic weighting model, divided into two groups: one intended to reflect the degree to which a phrase pair belongs to general language, and one intended to capture similarity to the IN domain.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00718', '(95%-conf.int.', '0.00718', '-', '0.00718)']
['system', 'ROUGE-S*', 'Average_P:', '0.38182', '(95%-conf.int.', '0.38182', '-', '0.38182)']
['system', 'ROUGE-S*', 'Average_F:', '0.01409', '(95%-conf.int.', '0.01409', '-', '0.01409)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2926', 'P:55', 'F:21']
dict_values(['In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.'])
dict_values(['Our second contribution is to apply instance weighting at the level of phrase pairs.', 'A similar maximumlikelihood approach was used by Foster and Kuhn (2007), but for language models only.', 'In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.', 'We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.'])
['system', 'ROUGE-S*', 'Average_R:', '0.08245', '(95%-conf.int.', '0.08245', '-', '0.08245)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.15234', '(95%-conf.int.', '0.15234', '-', '0.15234)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:946', 'P:78', 'F:78']
dict_values(['We train linear mixture models for conditional phrase pair probabilities over IN and OUT so as to maximize the likelihood of an empirical joint phrase-pair distribution extracted from a development set.'])
dict_values(['Our second contribution is to apply instance weighting at the level of phrase pairs.', 'This suggests a direct parallel to (1): where &#732;p(s, t) is a joint empirical distribution extracted from the IN dev set using the standard procedure.2 An alternative form of linear combination is a maximum a posteriori (MAP) combination (Bacchiani et al., 2004).', 'First, we learn weights on individual phrase pairs rather than sentences.', 'We will also directly compare with a baseline similar to the Matsoukas et al approach in order to measure the benefit from weighting phrase pairs (or ngrams) rather than full sentences.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02222', '(95%-conf.int.', '0.02222', '-', '0.02222)']
['system', 'ROUGE-S*', 'Average_P:', '0.21569', '(95%-conf.int.', '0.21569', '-', '0.21569)']
['system', 'ROUGE-S*', 'Average_F:', '0.04029', '(95%-conf.int.', '0.04029', '-', '0.04029)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:153', 'F:33']
dict_values(['Standard SMT systems have a hierarchical parameter structure: top-level log-linear weights are used to combine a small set of complex features, interpreted as log probabilities, many of which have their own internal parameters and objectives.'])
dict_values(['We focus here instead on adapting the two most important features: the language model (LM), which estimates the probability p(wIh) of a target word w following an ngram h; and the translation models (TM) p(slt) and p(t1s), which give the probability of source phrase s translating to target phrase t, and vice versa.', 'Phrase tables were extracted from the IN and OUT training corpora (not the dev as was used for instance weighting models), and phrase pairs in the intersection of the IN and OUT phrase tables were used as positive examples, with two alternate definitions of negative examples: The classifier trained using the 2nd definition had higher accuracy on a development set.', 'At first glance, this seems only peripherally related to our work, since the specific/general distinction is made for features rather than instances.', 'In this paper we have proposed an approach for instance-weighting phrase pairs in an out-of-domain corpus in order to improve in-domain performance.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00130', '(95%-conf.int.', '0.00130', '-', '0.00130)']
['system', 'ROUGE-S*', 'Average_P:', '0.01732', '(95%-conf.int.', '0.01732', '-', '0.01732)']
['system', 'ROUGE-S*', 'Average_F:', '0.00242', '(95%-conf.int.', '0.00242', '-', '0.00242)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3081', 'P:231', 'F:4']
0.41471221761430865 0.026465555261493832 0.0493811105624321





input/ref/Task1/E03-1005_aakansha.csv
input/res/Task1/E03-1005.annv3.csv
parsing: input/ref/Task1/E03-1005_aakansha.csv
<S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'105'"]
'105'
['105']
parsed_discourse_facet ['method_citation']
<S sid="145" ssid="10">This paper showed that a PCFG-reduction of DOP in combination with a new notion of the best parse tree results in fast processing times and very competitive accuracy on the Wall Street Journal treebank.</S>
original cit marker offset is 0
new cit marker offset is 0



["'145'"]
'145'
['145']
parsed_discourse_facet ['method_citation']
<S sid="80" ssid="32">DOP1 has a serious bias: its subtree estimator provides more probability to nodes with more subtrees (Bonnema et al. 1999).</S>
original cit marker offset is 0
new cit marker offset is 0



["'80'"]
'80'
['80']
parsed_discourse_facet ['method_citation']
<S sid="143" ssid="8">While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.</S>
original cit marker offset is 0
new cit marker offset is 0



["'143'"]
'143'
['143']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S><S sid="141" ssid="6">This is roughly an 11% relative reduction in error rate over Charniak (2000) and Bods PCFG-reduction reported in Table 1.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'", "'141'"]
'140'
'141'
['140', '141']
parsed_discourse_facet ['result_citation']
<S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['result_citation']
<S sid="102" ssid="5">In case the shortest derivation is not unique, Bod (2000b) proposes to back off to a frequency ordering of the subtrees.</S>
    <S sid="103" ssid="6">That is, all subtrees of each root label are assigned a rank according to their frequency in the treebank: the most frequent subtree (or subtrees) of each root label gets rank 1, the second most frequent subtree gets rank 2, etc.</S>
original cit marker offset is 0
new cit marker offset is 0



["'102'", "'103'"]
'102'
'103'
['102', '103']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['result_citation']
<S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['result_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'"]
'46'
['46']
parsed_discourse_facet ['method_citation']
<S sid="85" ssid="37">For example, Bod (2001) samples a fixed number of subtrees of each depth, which has the effect of assigning roughly equal weight to each node in the training data, and roughly exponentially less probability for larger trees (see Goodman 2002: 12).</S>
    <S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S>
original cit marker offset is 0
new cit marker offset is 0



["'85'", "'86'"]
'85'
'86'
['85', '86']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['result_citation']
<S sid="115" ssid="18">The only thing that needs to be changed for Simplicity-DOP is that all subtrees should be assigned equal probabilities.</S>
original cit marker offset is 0
new cit marker offset is 0



["'115'"]
'115'
['115']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/E03-1005.annv3.csv
<S sid="52" ssid="4">The probability of a parse tree T is the sum of the probabilities of its distinct derivations.</S><S sid="75" ssid="27">This means that summing up over derivations of a tree in DOP yields the same probability as summing over all the isomorphic derivations in the PCFG.</S><S sid="77" ssid="29">But Goodman shows that with his PCFG-reduction he can efficiently compute the aforementioned maximum constituents parse.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'", "'75'", "'77'", "'105'"]
'52'
'75'
'77'
'105'
['52', '75', '77', '105']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Together with a PCFGreduction of DOP we obtain improved accuracy and efficiency on the Wall Street Journal treebank Our results show an 11% relative reduction in error rate over previous models, and an average processing time of 3.6 seconds per WSJ sentence.</S><S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'38'", "'39'", "'105'"]
'3'
'38'
'39'
'105'
['3', '38', '39', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="40" ssid="37">Goodman (2002) furthermore showed how Bonnema et al. \s (1999) and Bod\s (2001) estimators can be incorporated in his PCFGreduction, but did not report any experiments with these reductions.</S><S sid="79" ssid="31">While Bod (2001) needed to use a very large sample from the WSJ subtrees to do this, Goodman\s method can do the same job with a more compact grammar.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'", "'79'", "'134'", "'135'"]
'40'
'79'
'134'
'135'
['40', '79', '134', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="143" ssid="8">While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.</S><S sid="144" ssid="9">While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'87'", "'143'", "'144'"]
'38'
'87'
'143'
'144'
['38', '87', '143', '144']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S><S sid="106" ssid="9">What is more important, is, that the best parse trees predicted by Simplicity-DOP are quite different from the best parse trees predicted by Likelihood-DOP.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'", "'99'", "'100'", "'106'"]
'46'
'99'
'100'
'106'
['46', '99', '100', '106']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'99'", "'134'", "'135'"]
'38'
'99'
'134'
'135'
['38', '99', '134', '135']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="34">Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="85" ssid="37">For example, Bod (2001) samples a fixed number of subtrees of each depth, which has the effect of assigning roughly equal weight to each node in the training data, and roughly exponentially less probability for larger trees (see Goodman 2002: 12).</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'85'", "'86'"]
'37'
'39'
'85'
'86'
['37', '39', '85', '86']
parsed_discourse_facet ['method_citation']
<S sid="44" ssid="41">But while Bod\s estimator obtains state-of-the-art results on the WSJ, comparable to Charniak (2000) and Collins (2000), Bonnema et al. \s estimator performs worse and is comparable to Collins (1996).</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S><S sid="144" ssid="9">While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'134'", "'135'", "'144'"]
'44'
'134'
'135'
'144'
['44', '134', '135', '144']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="21">However, the problem of computing the most probable parse turns out to be NP-hard (Sima\an 1996), mainly because the same parse tree can be generated by exponentially many derivations.</S><S sid="25" ssid="22">Many implementations of DOP1 therefore estimate the most probable parse by Monte Carlo techniques (Bod 1998; Chappelier &amp; Rajman 2000), or by Viterbi n-best search (Bod 2001), or by restricting the set of subtrees (Sima\an 1999; Chappelier et al. 2002).</S><S sid="97" ssid="49">In this paper, we will estimate the most probable parse by computing the 10,000 most probable derivations by means of Viterbi n-best, from which the most likely parse is estimated by summing up the probabilities of the derivations that generate the same parse.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'97'", "'135'"]
'24'
'25'
'97'
'135'
['24', '25', '97', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'105'", "'134'"]
'38'
'39'
'105'
'134'
['38', '39', '105', '134']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S><S sid="98" ssid="1">Most DOP models, such as in Bod (1993), Goodman (1996), Bonnema et al. (1997), Sima\an (2000) and Collins &amp; Duffy (2002), use a likelihood criterion in defining the best parse tree: they take (some notion of) the most likely (i.e. most probable) tree as a candidate for the best tree of a sentence.</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'", "'98'", "'99'", "'100'"]
'46'
'98'
'99'
'100'
['46', '98', '99', '100']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="2" ssid="2">This paper proposes an integration of the two models which outperforms each of them separately.</S><S sid="82" ssid="34">Bonnema et al. (1999) show that as a consequence too much weight is given to larger subtrees, and that the parse accuracy of DOP1 deteriorates if (very) large subtrees are included.</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'82'", "'87'", "'99'"]
'2'
'82'
'87'
'99'
['2', '82', '87', '99']
parsed_discourse_facet ['hypothesis_citation']
<S sid="12" ssid="9">This approach has now gained wide usage, as exemplified by the work of Collins (1996, 1999), Charniak (1996, 1997), Johnson (1998), Chiang (2000), and many others.</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="88" ssid="40">In this paper, we will test a simple extension of Goodman\s compact PCFG-reduction of DOP which has the same property as the normalization proposed in Bod (2001) in that it assigns roughly equal weight to each node in the training data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'86'", "'87'", "'88'"]
'12'
'86'
'87'
'88'
['12', '86', '87', '88']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'86'", "'134'", "'135'"]
'38'
'86'
'134'
'135'
['38', '86', '134', '135']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="36" ssid="33">As an alternative, Bonnema et al. (1999) propose a subtree estimator which reduces the probability of a tree by a factor of two for each non-root non-terminal it contains.</S><S sid="37" ssid="34">Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="90" ssid="42">Then we slightly modify the PCFG-reduction in figure 2 as follows: We will also test the proposal by Bonnema et al. (1999) which reduces the probability of a subtree by a factor of two for each non-root nonterminal it contains.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'", "'37'", "'86'", "'90'"]
'36'
'37'
'86'
'90'
['36', '37', '86', '90']
parsed_discourse_facet ['method_citation']
dict_values(['The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.'])
dict_values(['The probability of a parse tree T is the sum of the probabilities of its distinct derivations.', 'This means that summing up over derivations of a tree in DOP yields the same probability as summing over all the isomorphic derivations in the PCFG.', 'But Goodman shows that with his PCFG-reduction he can efficiently compute the aforementioned maximum constituents parse.', 'The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.'])
['system', 'ROUGE-S*', 'Average_R:', '0.21771', '(95%-conf.int.', '0.21771', '-', '0.21771)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.35757', '(95%-conf.int.', '0.35757', '-', '0.35757)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:300', 'F:300']
dict_values(['DOP1 has a serious bias: its subtree estimator provides more probability to nodes with more subtrees (Bonnema et al. 1999).'])
dict_values(['Goodman (2002) furthermore showed how Bonnema et al. \\s (1999) and Bod\\s (2001) estimators can be incorporated in his PCFGreduction, but did not report any experiments with these reductions.', 'While Bod (2001) needed to use a very large sample from the WSJ subtrees to do this, Goodman\\s method can do the same job with a more compact grammar.', 'This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.', 'In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00273', '(95%-conf.int.', '0.00273', '-', '0.00273)']
['system', 'ROUGE-S*', 'Average_P:', '0.11111', '(95%-conf.int.', '0.11111', '-', '0.11111)']
['system', 'ROUGE-S*', 'Average_F:', '0.00533', '(95%-conf.int.', '0.00533', '-', '0.00533)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:45', 'F:5']
dict_values(['While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.'])
dict_values(['Although Bod\\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).', 'Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).', 'While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.', 'While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.12316', '(95%-conf.int.', '0.12316', '-', '0.12316)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.21931', '(95%-conf.int.', '0.21931', '-', '0.21931)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2850', 'P:351', 'F:351']
dict_values(['The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.'])
dict_values(['Although Bod\\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).', 'We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &quot;Likelihood-DOP&quot; the PCFG-reduction of Bod (2001) given in Section 2.2.', 'This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.', 'In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00402', '(95%-conf.int.', '0.00402', '-', '0.00402)']
['system', 'ROUGE-S*', 'Average_P:', '0.12821', '(95%-conf.int.', '0.12821', '-', '0.12821)']
['system', 'ROUGE-S*', 'Average_F:', '0.00780', '(95%-conf.int.', '0.00780', '-', '0.00780)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2485', 'P:78', 'F:10']
dict_values(['In case the shortest derivation is not unique, Bod (2000b) proposes to back off to a frequency ordering of the subtrees.', 'That is, all subtrees of each root label are assigned a rank according to their frequency in the treebank: the most frequent subtree (or subtrees) of each root label gets rank 1, the second most frequent subtree gets rank 2, etc.'])
dict_values(['Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.', 'Collins & Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.', 'For example, Bod (2001) samples a fixed number of subtrees of each depth, which has the effect of assigning roughly equal weight to each node in the training data, and roughly exponentially less probability for larger trees (see Goodman 2002: 12).', 'Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00866', '(95%-conf.int.', '0.00866', '-', '0.00866)']
['system', 'ROUGE-S*', 'Average_P:', '0.06404', '(95%-conf.int.', '0.06404', '-', '0.06404)']
['system', 'ROUGE-S*', 'Average_F:', '0.01525', '(95%-conf.int.', '0.01525', '-', '0.01525)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:406', 'F:26']
dict_values(['The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.'])
dict_values(['However, the problem of computing the most probable parse turns out to be NP-hard (Sima\\an 1996), mainly because the same parse tree can be generated by exponentially many derivations.', 'Many implementations of DOP1 therefore estimate the most probable parse by Monte Carlo techniques (Bod 1998; Chappelier & Rajman 2000), or by Viterbi n-best search (Bod 2001), or by restricting the set of subtrees (Sima\\an 1999; Chappelier et al. 2002).', 'In this paper, we will estimate the most probable parse by computing the 10,000 most probable derivations by means of Viterbi n-best, from which the most likely parse is estimated by summing up the probabilities of the derivations that generate the same parse.', 'In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00036', '(95%-conf.int.', '0.00036', '-', '0.00036)']
['system', 'ROUGE-S*', 'Average_P:', '0.01282', '(95%-conf.int.', '0.01282', '-', '0.01282)']
['system', 'ROUGE-S*', 'Average_F:', '0.00070', '(95%-conf.int.', '0.00070', '-', '0.00070)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:78', 'F:1']
dict_values(['The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.'])
dict_values(['Although Bod\\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).', 'Collins & Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.', 'The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.', 'This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00151', '(95%-conf.int.', '0.00151', '-', '0.00151)']
['system', 'ROUGE-S*', 'Average_P:', '0.06410', '(95%-conf.int.', '0.06410', '-', '0.06410)']
['system', 'ROUGE-S*', 'Average_F:', '0.00294', '(95%-conf.int.', '0.00294', '-', '0.00294)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3321', 'P:78', 'F:5']
dict_values(['For example, Bod (2001) samples a fixed number of subtrees of each depth, which has the effect of assigning roughly equal weight to each node in the training data, and roughly exponentially less probability for larger trees (see Goodman 2002: 12).', 'Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).'])
dict_values(['This approach has now gained wide usage, as exemplified by the work of Collins (1996, 1999), Charniak (1996, 1997), Johnson (1998), Chiang (2000), and many others.', 'Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).', 'Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).', 'In this paper, we will test a simple extension of Goodman\\s compact PCFG-reduction of DOP which has the same property as the normalization proposed in Bod (2001) in that it assigns roughly equal weight to each node in the training data.'])
['system', 'ROUGE-S*', 'Average_R:', '0.08858', '(95%-conf.int.', '0.08858', '-', '0.08858)']
['system', 'ROUGE-S*', 'Average_P:', '0.25641', '(95%-conf.int.', '0.25641', '-', '0.25641)']
['system', 'ROUGE-S*', 'Average_F:', '0.13167', '(95%-conf.int.', '0.13167', '-', '0.13167)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:741', 'F:190']
dict_values(['The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.'])
dict_values(['Although Bod\\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).', 'Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).', 'This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.', 'In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00512', '(95%-conf.int.', '0.00512', '-', '0.00512)']
['system', 'ROUGE-S*', 'Average_P:', '0.15385', '(95%-conf.int.', '0.15385', '-', '0.15385)']
['system', 'ROUGE-S*', 'Average_F:', '0.00990', '(95%-conf.int.', '0.00990', '-', '0.00990)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:78', 'F:12']
dict_values(['The only thing that needs to be changed for Simplicity-DOP is that all subtrees should be assigned equal probabilities.'])
dict_values(['As an alternative, Bonnema et al. (1999) propose a subtree estimator which reduces the probability of a tree by a factor of two for each non-root non-terminal it contains.', 'Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.', 'Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).', 'Then we slightly modify the PCFG-reduction in figure 2 as follows: We will also test the proposal by Bonnema et al. (1999) which reduces the probability of a subtree by a factor of two for each non-root nonterminal it contains.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00307', '(95%-conf.int.', '0.00307', '-', '0.00307)']
['system', 'ROUGE-S*', 'Average_P:', '0.21429', '(95%-conf.int.', '0.21429', '-', '0.21429)']
['system', 'ROUGE-S*', 'Average_F:', '0.00606', '(95%-conf.int.', '0.00606', '-', '0.00606)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:28', 'F:6']
0.30048299699517 0.045491999545080014 0.07565299924347002





input/ref/Task1/E03-1005_swastika.csv
input/res/Task1/E03-1005.annv3.csv
parsing: input/ref/Task1/E03-1005_swastika.csv
<S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



['105']
105
['105']
parsed_discourse_facet ['result_citation']
    <S sid="41" ssid="38">This paper presents the first published results with Goodman's PCFG-reductions of both Bonnema et al. 's (1999) and Bod's (2001) estimators on the WSJ.</S>
original cit marker offset is 0
new cit marker offset is 0



['41']
41
['41']
parsed_discourse_facet ['aim_citation']
<S sid="80" ssid="32">DOP1 has a serious bias: its subtree estimator provides more probability to nodes with more subtrees (Bonnema et al. 1999).</S>
original cit marker offset is 0
new cit marker offset is 0



['80']
80
['80']
parsed_discourse_facet ['result_citation']
<S sid="143" ssid="8">While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.</S>
original cit marker offset is 0
new cit marker offset is 0



['143']
143
['143']
parsed_discourse_facet ['method_citation']
<S sid="146" ssid="11">This paper also re-affirmed that the coarsegrained approach of using all subtrees from a treebank outperforms the fine-grained approach of specifically modeling lexical-syntactic depen dencies (as e.g. in Collins 1999 and Charniak 2000).</S>
original cit marker offset is 0
new cit marker offset is 0



['146']
146
['146']
parsed_discourse_facet ['method_citation']
    <S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



['140']
140
['140']
parsed_discourse_facet ['result_citation']
<S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



['105']
105
['105']
parsed_discourse_facet ['result_citation']
    <S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



['140']
140
['140']
parsed_discourse_facet ['result_citation']
<S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S>
original cit marker offset is 0
new cit marker offset is 0



['100']
100
['100']
parsed_discourse_facet ['result_citation']
    <S sid="30" ssid="27">Bod (2000a) solved this problem by training the subtree probabilities by a maximum likelihood procedure based on Expectation-Maximization.</S>
original cit marker offset is 0
new cit marker offset is 0



['30']
30
['30']
parsed_discourse_facet ['method_citation']
    <S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



['140']
140
['140']
parsed_discourse_facet ['result_citation']
    <S sid="30" ssid="27">Bod (2000a) solved this problem by training the subtree probabilities by a maximum likelihood procedure based on Expectation-Maximization.</S>
original cit marker offset is 0
new cit marker offset is 0



['30']
30
['30']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/E03-1005.annv3.csv
<S sid="52" ssid="4">The probability of a parse tree T is the sum of the probabilities of its distinct derivations.</S><S sid="75" ssid="27">This means that summing up over derivations of a tree in DOP yields the same probability as summing over all the isomorphic derivations in the PCFG.</S><S sid="77" ssid="29">But Goodman shows that with his PCFG-reduction he can efficiently compute the aforementioned maximum constituents parse.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'", "'75'", "'77'", "'105'"]
'52'
'75'
'77'
'105'
['52', '75', '77', '105']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Together with a PCFGreduction of DOP we obtain improved accuracy and efficiency on the Wall Street Journal treebank Our results show an 11% relative reduction in error rate over previous models, and an average processing time of 3.6 seconds per WSJ sentence.</S><S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'38'", "'39'", "'105'"]
'3'
'38'
'39'
'105'
['3', '38', '39', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="40" ssid="37">Goodman (2002) furthermore showed how Bonnema et al. \s (1999) and Bod\s (2001) estimators can be incorporated in his PCFGreduction, but did not report any experiments with these reductions.</S><S sid="79" ssid="31">While Bod (2001) needed to use a very large sample from the WSJ subtrees to do this, Goodman\s method can do the same job with a more compact grammar.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'", "'79'", "'134'", "'135'"]
'40'
'79'
'134'
'135'
['40', '79', '134', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="143" ssid="8">While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.</S><S sid="144" ssid="9">While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'87'", "'143'", "'144'"]
'38'
'87'
'143'
'144'
['38', '87', '143', '144']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S><S sid="106" ssid="9">What is more important, is, that the best parse trees predicted by Simplicity-DOP are quite different from the best parse trees predicted by Likelihood-DOP.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'", "'99'", "'100'", "'106'"]
'46'
'99'
'100'
'106'
['46', '99', '100', '106']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'99'", "'134'", "'135'"]
'38'
'99'
'134'
'135'
['38', '99', '134', '135']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="34">Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="85" ssid="37">For example, Bod (2001) samples a fixed number of subtrees of each depth, which has the effect of assigning roughly equal weight to each node in the training data, and roughly exponentially less probability for larger trees (see Goodman 2002: 12).</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'85'", "'86'"]
'37'
'39'
'85'
'86'
['37', '39', '85', '86']
parsed_discourse_facet ['method_citation']
<S sid="44" ssid="41">But while Bod\s estimator obtains state-of-the-art results on the WSJ, comparable to Charniak (2000) and Collins (2000), Bonnema et al. \s estimator performs worse and is comparable to Collins (1996).</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S><S sid="144" ssid="9">While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'134'", "'135'", "'144'"]
'44'
'134'
'135'
'144'
['44', '134', '135', '144']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="21">However, the problem of computing the most probable parse turns out to be NP-hard (Sima\an 1996), mainly because the same parse tree can be generated by exponentially many derivations.</S><S sid="25" ssid="22">Many implementations of DOP1 therefore estimate the most probable parse by Monte Carlo techniques (Bod 1998; Chappelier &amp; Rajman 2000), or by Viterbi n-best search (Bod 2001), or by restricting the set of subtrees (Sima\an 1999; Chappelier et al. 2002).</S><S sid="97" ssid="49">In this paper, we will estimate the most probable parse by computing the 10,000 most probable derivations by means of Viterbi n-best, from which the most likely parse is estimated by summing up the probabilities of the derivations that generate the same parse.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'97'", "'135'"]
'24'
'25'
'97'
'135'
['24', '25', '97', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'105'", "'134'"]
'38'
'39'
'105'
'134'
['38', '39', '105', '134']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S><S sid="98" ssid="1">Most DOP models, such as in Bod (1993), Goodman (1996), Bonnema et al. (1997), Sima\an (2000) and Collins &amp; Duffy (2002), use a likelihood criterion in defining the best parse tree: they take (some notion of) the most likely (i.e. most probable) tree as a candidate for the best tree of a sentence.</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'", "'98'", "'99'", "'100'"]
'46'
'98'
'99'
'100'
['46', '98', '99', '100']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="2" ssid="2">This paper proposes an integration of the two models which outperforms each of them separately.</S><S sid="82" ssid="34">Bonnema et al. (1999) show that as a consequence too much weight is given to larger subtrees, and that the parse accuracy of DOP1 deteriorates if (very) large subtrees are included.</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'82'", "'87'", "'99'"]
'2'
'82'
'87'
'99'
['2', '82', '87', '99']
parsed_discourse_facet ['hypothesis_citation']
<S sid="12" ssid="9">This approach has now gained wide usage, as exemplified by the work of Collins (1996, 1999), Charniak (1996, 1997), Johnson (1998), Chiang (2000), and many others.</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="88" ssid="40">In this paper, we will test a simple extension of Goodman\s compact PCFG-reduction of DOP which has the same property as the normalization proposed in Bod (2001) in that it assigns roughly equal weight to each node in the training data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'86'", "'87'", "'88'"]
'12'
'86'
'87'
'88'
['12', '86', '87', '88']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'86'", "'134'", "'135'"]
'38'
'86'
'134'
'135'
['38', '86', '134', '135']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="36" ssid="33">As an alternative, Bonnema et al. (1999) propose a subtree estimator which reduces the probability of a tree by a factor of two for each non-root non-terminal it contains.</S><S sid="37" ssid="34">Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="90" ssid="42">Then we slightly modify the PCFG-reduction in figure 2 as follows: We will also test the proposal by Bonnema et al. (1999) which reduces the probability of a subtree by a factor of two for each non-root nonterminal it contains.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'", "'37'", "'86'", "'90'"]
'36'
'37'
'86'
'90'
['36', '37', '86', '90']
parsed_discourse_facet ['method_citation']
dict_values(['The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.'])
dict_values(['The probability of a parse tree T is the sum of the probabilities of its distinct derivations.', 'This means that summing up over derivations of a tree in DOP yields the same probability as summing over all the isomorphic derivations in the PCFG.', 'But Goodman shows that with his PCFG-reduction he can efficiently compute the aforementioned maximum constituents parse.', 'The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.'])
['system', 'ROUGE-S*', 'Average_R:', '0.21771', '(95%-conf.int.', '0.21771', '-', '0.21771)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.35757', '(95%-conf.int.', '0.35757', '-', '0.35757)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:300', 'F:300']
dict_values(['DOP1 has a serious bias: its subtree estimator provides more probability to nodes with more subtrees (Bonnema et al. 1999).'])
dict_values(['Goodman (2002) furthermore showed how Bonnema et al. \\s (1999) and Bod\\s (2001) estimators can be incorporated in his PCFGreduction, but did not report any experiments with these reductions.', 'While Bod (2001) needed to use a very large sample from the WSJ subtrees to do this, Goodman\\s method can do the same job with a more compact grammar.', 'This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.', 'In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00273', '(95%-conf.int.', '0.00273', '-', '0.00273)']
['system', 'ROUGE-S*', 'Average_P:', '0.11111', '(95%-conf.int.', '0.11111', '-', '0.11111)']
['system', 'ROUGE-S*', 'Average_F:', '0.00533', '(95%-conf.int.', '0.00533', '-', '0.00533)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:45', 'F:5']
dict_values(['While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.'])
dict_values(['Although Bod\\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).', 'Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).', 'While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.', 'While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.12316', '(95%-conf.int.', '0.12316', '-', '0.12316)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.21931', '(95%-conf.int.', '0.21931', '-', '0.21931)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2850', 'P:351', 'F:351']
dict_values(['The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.'])
dict_values(['Although Bod\\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).', 'We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &quot;Likelihood-DOP&quot; the PCFG-reduction of Bod (2001) given in Section 2.2.', 'This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.', 'In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00402', '(95%-conf.int.', '0.00402', '-', '0.00402)']
['system', 'ROUGE-S*', 'Average_P:', '0.12821', '(95%-conf.int.', '0.12821', '-', '0.12821)']
['system', 'ROUGE-S*', 'Average_F:', '0.00780', '(95%-conf.int.', '0.00780', '-', '0.00780)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2485', 'P:78', 'F:10']
dict_values(['The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.'])
dict_values(['However, the problem of computing the most probable parse turns out to be NP-hard (Sima\\an 1996), mainly because the same parse tree can be generated by exponentially many derivations.', 'Many implementations of DOP1 therefore estimate the most probable parse by Monte Carlo techniques (Bod 1998; Chappelier & Rajman 2000), or by Viterbi n-best search (Bod 2001), or by restricting the set of subtrees (Sima\\an 1999; Chappelier et al. 2002).', 'In this paper, we will estimate the most probable parse by computing the 10,000 most probable derivations by means of Viterbi n-best, from which the most likely parse is estimated by summing up the probabilities of the derivations that generate the same parse.', 'In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01766', '(95%-conf.int.', '0.01766', '-', '0.01766)']
['system', 'ROUGE-S*', 'Average_P:', '0.16333', '(95%-conf.int.', '0.16333', '-', '0.16333)']
['system', 'ROUGE-S*', 'Average_F:', '0.03187', '(95%-conf.int.', '0.03187', '-', '0.03187)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:300', 'F:49']
dict_values(['The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.'])
dict_values(['Although Bod\\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).', 'Collins & Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.', 'The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.', 'This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00151', '(95%-conf.int.', '0.00151', '-', '0.00151)']
['system', 'ROUGE-S*', 'Average_P:', '0.06410', '(95%-conf.int.', '0.06410', '-', '0.06410)']
['system', 'ROUGE-S*', 'Average_F:', '0.00294', '(95%-conf.int.', '0.00294', '-', '0.00294)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3321', 'P:78', 'F:5']
dict_values(['Bod (2000a) solved this problem by training the subtree probabilities by a maximum likelihood procedure based on Expectation-Maximization.'])
dict_values(['This approach has now gained wide usage, as exemplified by the work of Collins (1996, 1999), Charniak (1996, 1997), Johnson (1998), Chiang (2000), and many others.', 'Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).', 'Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).', 'In this paper, we will test a simple extension of Goodman\\s compact PCFG-reduction of DOP which has the same property as the normalization proposed in Bod (2001) in that it assigns roughly equal weight to each node in the training data.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00093', '(95%-conf.int.', '0.00093', '-', '0.00093)']
['system', 'ROUGE-S*', 'Average_P:', '0.02564', '(95%-conf.int.', '0.02564', '-', '0.02564)']
['system', 'ROUGE-S*', 'Average_F:', '0.00180', '(95%-conf.int.', '0.00180', '-', '0.00180)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:78', 'F:2']
dict_values(['The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.'])
dict_values(['Although Bod\\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).', 'Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).', 'This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.', 'In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00512', '(95%-conf.int.', '0.00512', '-', '0.00512)']
['system', 'ROUGE-S*', 'Average_P:', '0.15385', '(95%-conf.int.', '0.15385', '-', '0.15385)']
['system', 'ROUGE-S*', 'Average_F:', '0.00990', '(95%-conf.int.', '0.00990', '-', '0.00990)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:78', 'F:12']
dict_values(['Bod (2000a) solved this problem by training the subtree probabilities by a maximum likelihood procedure based on Expectation-Maximization.'])
dict_values(['As an alternative, Bonnema et al. (1999) propose a subtree estimator which reduces the probability of a tree by a factor of two for each non-root non-terminal it contains.', 'Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.', 'Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).', 'Then we slightly modify the PCFG-reduction in figure 2 as follows: We will also test the proposal by Bonnema et al. (1999) which reduces the probability of a subtree by a factor of two for each non-root nonterminal it contains.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00307', '(95%-conf.int.', '0.00307', '-', '0.00307)']
['system', 'ROUGE-S*', 'Average_P:', '0.07692', '(95%-conf.int.', '0.07692', '-', '0.07692)']
['system', 'ROUGE-S*', 'Average_F:', '0.00591', '(95%-conf.int.', '0.00591', '-', '0.00591)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:78', 'F:6']
0.30257332997140746 0.04176777731369138 0.07138111031798768





input/ref/Task1/E03-1005_sweta.csv
input/res/Task1/E03-1005.annv3.csv
parsing: input/ref/Task1/E03-1005_sweta.csv
<S sid="20" ssid="17">Thus the major innovations of DOP are: 2. the use of arbitrarily large fragments rather than restricted ones Both have gained or are gaining wide usage, and are also becoming relevant for theoretical linguistics (see Bod et al. 2003a).</S>
original cit marker offset is 0
new cit marker offset is 0



["20'"]
20'
['20']
parsed_discourse_facet ['method_citation']
 <S sid="74" ssid="26">Goodman's main theorem is that this construction produces PCFG derivations isomorphic to DOP derivations with equal probability.</S>
original cit marker offset is 0
new cit marker offset is 0



["74'"]
74'
['74']
parsed_discourse_facet ['method_citation']
<S sid="44" ssid="41">But while Bod's estimator obtains state-of-the-art results on the WSJ, comparable to Charniak (2000) and Collins (2000), Bonnema et al. 's estimator performs worse and is comparable to Collins (1996).</S>
original cit marker offset is 0
new cit marker offset is 0



["44'"]
44'
['44']
parsed_discourse_facet ['method_citation']
<S sid="143" ssid="8">While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.</S>
original cit marker offset is 0
new cit marker offset is 0



["143'"]
143'
['143']
parsed_discourse_facet ['method_citation']
<S sid="145" ssid="10">This paper showed that a PCFG-reduction of DOP in combination with a new notion of the best parse tree results in fast processing times and very competitive accuracy on the Wall Street Journal treebank.</S>
original cit marker offset is 0
new cit marker offset is 0



["145'"]
145'
['145']
parsed_discourse_facet ['method_citation']
<S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S>
original cit marker offset is 0
new cit marker offset is 0



["134'"]
134'
['134']
parsed_discourse_facet ['method_citation']
<S sid="22" ssid="19">DOP1 combines subtrees from a treebank by means of node-substitution and computes the probability of a tree from the normalized frequencies of the subtrees (see Section 2 for a full definition).</S>
original cit marker offset is 0
new cit marker offset is 0



["22'"]
22'
['22']
parsed_discourse_facet ['method_citation']
<S sid="133" ssid="14">It should be mentioned that the best precision and recall scores reported in Bod (2001) are slightly better than the ones reported here (the difference is only 0.2% for sentences 100 words).</S>
original cit marker offset is 0
new cit marker offset is 0



["133'"]
133'
['133']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="22">Many implementations of DOP1 therefore estimate the most probable parse by Monte Carlo techniques (Bod 1998; Chappelier &amp; Rajman 2000), or by Viterbi n-best search (Bod 2001), or by restricting the set of subtrees (Sima'an 1999; Chappelier et al. 2002).</S>
original cit marker offset is 0
new cit marker offset is 0



["25'"]
25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="35">Although Bod's method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S>
original cit marker offset is 0
new cit marker offset is 0



["38'"]
38'
['38']
parsed_discourse_facet ['method_citation']
 <S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S>
original cit marker offset is 0
new cit marker offset is 0



["100'"]
100'
['100']
parsed_discourse_facet ['method_citation']
<S sid="32" ssid="29">However, ML-DOP suffers from overlearning if the subtrees are trained on the same treebank trees as they are derived from.</S>
original cit marker offset is 0
new cit marker offset is 0



["32'"]
32'
['32']
parsed_discourse_facet ['method_citation']
 <S sid="130" ssid="11">While the PCFG reduction of Bod (2001) obtains state-of-the-art results on the WSJ, comparable to Charniak (2000), Bonnema et al. 's estimator performs worse and is comparable to Collins (1996).</S>
original cit marker offset is 0
new cit marker offset is 0



["130'"]
130'
['130']
parsed_discourse_facet ['method_citation']
 <S sid="140" ssid="5">The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.</S>
original cit marker offset is 0
new cit marker offset is 0



["140'"]
140'
['140']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="24">Goodman (1996, 1998) developed a polynomial time PCFG-reduction of DOP1 whose size is linear in the size of the training set, thus converting the exponential number of subtrees to a compact grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["27'"]
27'
['27']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/E03-1005.annv3.csv
<S sid="52" ssid="4">The probability of a parse tree T is the sum of the probabilities of its distinct derivations.</S><S sid="75" ssid="27">This means that summing up over derivations of a tree in DOP yields the same probability as summing over all the isomorphic derivations in the PCFG.</S><S sid="77" ssid="29">But Goodman shows that with his PCFG-reduction he can efficiently compute the aforementioned maximum constituents parse.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'", "'75'", "'77'", "'105'"]
'52'
'75'
'77'
'105'
['52', '75', '77', '105']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Together with a PCFGreduction of DOP we obtain improved accuracy and efficiency on the Wall Street Journal treebank Our results show an 11% relative reduction in error rate over previous models, and an average processing time of 3.6 seconds per WSJ sentence.</S><S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'38'", "'39'", "'105'"]
'3'
'38'
'39'
'105'
['3', '38', '39', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="40" ssid="37">Goodman (2002) furthermore showed how Bonnema et al. \s (1999) and Bod\s (2001) estimators can be incorporated in his PCFGreduction, but did not report any experiments with these reductions.</S><S sid="79" ssid="31">While Bod (2001) needed to use a very large sample from the WSJ subtrees to do this, Goodman\s method can do the same job with a more compact grammar.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'", "'79'", "'134'", "'135'"]
'40'
'79'
'134'
'135'
['40', '79', '134', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="143" ssid="8">While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.</S><S sid="144" ssid="9">While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'87'", "'143'", "'144'"]
'38'
'87'
'143'
'144'
['38', '87', '143', '144']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S><S sid="106" ssid="9">What is more important, is, that the best parse trees predicted by Simplicity-DOP are quite different from the best parse trees predicted by Likelihood-DOP.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'", "'99'", "'100'", "'106'"]
'46'
'99'
'100'
'106'
['46', '99', '100', '106']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'99'", "'134'", "'135'"]
'38'
'99'
'134'
'135'
['38', '99', '134', '135']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="34">Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="85" ssid="37">For example, Bod (2001) samples a fixed number of subtrees of each depth, which has the effect of assigning roughly equal weight to each node in the training data, and roughly exponentially less probability for larger trees (see Goodman 2002: 12).</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'85'", "'86'"]
'37'
'39'
'85'
'86'
['37', '39', '85', '86']
parsed_discourse_facet ['method_citation']
<S sid="44" ssid="41">But while Bod\s estimator obtains state-of-the-art results on the WSJ, comparable to Charniak (2000) and Collins (2000), Bonnema et al. \s estimator performs worse and is comparable to Collins (1996).</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S><S sid="144" ssid="9">While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'134'", "'135'", "'144'"]
'44'
'134'
'135'
'144'
['44', '134', '135', '144']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="21">However, the problem of computing the most probable parse turns out to be NP-hard (Sima\an 1996), mainly because the same parse tree can be generated by exponentially many derivations.</S><S sid="25" ssid="22">Many implementations of DOP1 therefore estimate the most probable parse by Monte Carlo techniques (Bod 1998; Chappelier &amp; Rajman 2000), or by Viterbi n-best search (Bod 2001), or by restricting the set of subtrees (Sima\an 1999; Chappelier et al. 2002).</S><S sid="97" ssid="49">In this paper, we will estimate the most probable parse by computing the 10,000 most probable derivations by means of Viterbi n-best, from which the most likely parse is estimated by summing up the probabilities of the derivations that generate the same parse.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'97'", "'135'"]
'24'
'25'
'97'
'135'
['24', '25', '97', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="39" ssid="36">Collins &amp; Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.</S><S sid="105" ssid="8">The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'105'", "'134'"]
'38'
'39'
'105'
'134'
['38', '39', '105', '134']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="43">Most previous notions of best parse tree in DOP1 were based on a probabilistic metric, with Bod (2000b) as a notable exception, who used a simplicity metric based on the shortest derivation.</S><S sid="98" ssid="1">Most DOP models, such as in Bod (1993), Goodman (1996), Bonnema et al. (1997), Sima\an (2000) and Collins &amp; Duffy (2002), use a likelihood criterion in defining the best parse tree: they take (some notion of) the most likely (i.e. most probable) tree as a candidate for the best tree of a sentence.</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S><S sid="100" ssid="3">In Bod (2000b), an alternative notion for the best parse tree was proposed based on a simplicity criterion: instead of producing the most probable tree, this model produced the tree generated by the shortest derivation with the fewest training subtrees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'", "'98'", "'99'", "'100'"]
'46'
'98'
'99'
'100'
['46', '98', '99', '100']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="2" ssid="2">This paper proposes an integration of the two models which outperforms each of them separately.</S><S sid="82" ssid="34">Bonnema et al. (1999) show that as a consequence too much weight is given to larger subtrees, and that the parse accuracy of DOP1 deteriorates if (very) large subtrees are included.</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="99" ssid="2">We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &amp;quot;Likelihood-DOP&amp;quot; the PCFG-reduction of Bod (2001) given in Section 2.2.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'82'", "'87'", "'99'"]
'2'
'82'
'87'
'99'
['2', '82', '87', '99']
parsed_discourse_facet ['hypothesis_citation']
<S sid="12" ssid="9">This approach has now gained wide usage, as exemplified by the work of Collins (1996, 1999), Charniak (1996, 1997), Johnson (1998), Chiang (2000), and many others.</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="87" ssid="39">Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).</S><S sid="88" ssid="40">In this paper, we will test a simple extension of Goodman\s compact PCFG-reduction of DOP which has the same property as the normalization proposed in Bod (2001) in that it assigns roughly equal weight to each node in the training data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'86'", "'87'", "'88'"]
'12'
'86'
'87'
'88'
['12', '86', '87', '88']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="38" ssid="35">Although Bod\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="134" ssid="15">This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.</S><S sid="135" ssid="16">In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'86'", "'134'", "'135'"]
'38'
'86'
'134'
'135'
['38', '86', '134', '135']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="36" ssid="33">As an alternative, Bonnema et al. (1999) propose a subtree estimator which reduces the probability of a tree by a factor of two for each non-root non-terminal it contains.</S><S sid="37" ssid="34">Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.</S><S sid="86" ssid="38">Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).</S><S sid="90" ssid="42">Then we slightly modify the PCFG-reduction in figure 2 as follows: We will also test the proposal by Bonnema et al. (1999) which reduces the probability of a subtree by a factor of two for each non-root nonterminal it contains.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'", "'37'", "'86'", "'90'"]
'36'
'37'
'86'
'90'
['36', '37', '86', '90']
parsed_discourse_facet ['method_citation']
dict_values(['Thus the major innovations of DOP are: 2. the use of arbitrarily large fragments rather than restricted ones Both have gained or are gaining wide usage, and are also becoming relevant for theoretical linguistics (see Bod et al. 2003a).'])
dict_values(['The probability of a parse tree T is the sum of the probabilities of its distinct derivations.', 'This means that summing up over derivations of a tree in DOP yields the same probability as summing over all the isomorphic derivations in the PCFG.', 'But Goodman shows that with his PCFG-reduction he can efficiently compute the aforementioned maximum constituents parse.', 'The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00073', '(95%-conf.int.', '0.00073', '-', '0.00073)']
['system', 'ROUGE-S*', 'Average_P:', '0.00654', '(95%-conf.int.', '0.00654', '-', '0.00654)']
['system', 'ROUGE-S*', 'Average_F:', '0.00131', '(95%-conf.int.', '0.00131', '-', '0.00131)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:153', 'F:1']
dict_values(["But while Bod's estimator obtains state-of-the-art results on the WSJ, comparable to Charniak (2000) and Collins (2000), Bonnema et al. 's estimator performs worse and is comparable to Collins (1996)."])
dict_values(['Goodman (2002) furthermore showed how Bonnema et al. \\s (1999) and Bod\\s (2001) estimators can be incorporated in his PCFGreduction, but did not report any experiments with these reductions.', 'While Bod (2001) needed to use a very large sample from the WSJ subtrees to do this, Goodman\\s method can do the same job with a more compact grammar.', 'This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.', 'In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00601', '(95%-conf.int.', '0.00601', '-', '0.00601)']
['system', 'ROUGE-S*', 'Average_P:', '0.05789', '(95%-conf.int.', '0.05789', '-', '0.05789)']
['system', 'ROUGE-S*', 'Average_F:', '0.01089', '(95%-conf.int.', '0.01089', '-', '0.01089)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:190', 'F:11']
dict_values(['While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.'])
dict_values(['Although Bod\\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).', 'Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).', 'While SL-DOP and LS-DOP have been compared before in Bod (2002), especially in the context of musical parsing, this paper presents the The DOP approach is based on two distinctive features: (1) the use of corpus fragments rather than grammar rules, and (2) the use of arbitrarily large fragments rather than restricted ones.', 'While the first feature has been generally adopted in statistical NLP, the second feature has for a long time been a serious bottleneck, as it results in exponential processing time when the most probable parse tree is computed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.12316', '(95%-conf.int.', '0.12316', '-', '0.12316)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.21931', '(95%-conf.int.', '0.21931', '-', '0.21931)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2850', 'P:351', 'F:351']
dict_values(['This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.'])
dict_values(['Although Bod\\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).', 'We will refer to these models as Likelihood-DOP models, but in this paper we will specifically mean by &quot;Likelihood-DOP&quot; the PCFG-reduction of Bod (2001) given in Section 2.2.', 'This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.', 'In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).'])
['system', 'ROUGE-S*', 'Average_R:', '0.05473', '(95%-conf.int.', '0.05473', '-', '0.05473)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10378', '(95%-conf.int.', '0.10378', '-', '0.10378)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2485', 'P:136', 'F:136']
dict_values(['DOP1 combines subtrees from a treebank by means of node-substitution and computes the probability of a tree from the normalized frequencies of the subtrees (see Section 2 for a full definition).'])
dict_values(['Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.', 'Collins & Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.', 'For example, Bod (2001) samples a fixed number of subtrees of each depth, which has the effect of assigning roughly equal weight to each node in the training data, and roughly exponentially less probability for larger trees (see Goodman 2002: 12).', 'Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00666', '(95%-conf.int.', '0.00666', '-', '0.00666)']
['system', 'ROUGE-S*', 'Average_P:', '0.14706', '(95%-conf.int.', '0.14706', '-', '0.14706)']
['system', 'ROUGE-S*', 'Average_F:', '0.01274', '(95%-conf.int.', '0.01274', '-', '0.01274)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:136', 'F:20']
dict_values(["Many implementations of DOP1 therefore estimate the most probable parse by Monte Carlo techniques (Bod 1998; Chappelier & Rajman 2000), or by Viterbi n-best search (Bod 2001), or by restricting the set of subtrees (Sima'an 1999; Chappelier et al. 2002)."])
dict_values(['However, the problem of computing the most probable parse turns out to be NP-hard (Sima\\an 1996), mainly because the same parse tree can be generated by exponentially many derivations.', 'Many implementations of DOP1 therefore estimate the most probable parse by Monte Carlo techniques (Bod 1998; Chappelier & Rajman 2000), or by Viterbi n-best search (Bod 2001), or by restricting the set of subtrees (Sima\\an 1999; Chappelier et al. 2002).', 'In this paper, we will estimate the most probable parse by computing the 10,000 most probable derivations by means of Viterbi n-best, from which the most likely parse is estimated by summing up the probabilities of the derivations that generate the same parse.', 'In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).'])
['system', 'ROUGE-S*', 'Average_R:', '0.10811', '(95%-conf.int.', '0.10811', '-', '0.10811)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.19512', '(95%-conf.int.', '0.19512', '-', '0.19512)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:300', 'F:300']
dict_values(["Although Bod's method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003)."])
dict_values(['Although Bod\\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).', 'Collins & Duffy (2002) showed how the perceptron algorithm can be used to efficiently compute the best parse with DOP1\\s subtrees, reporting a 5.1% relative reduction in error rate over the model in Collins (1999) on the WSJ.', 'The derivation with the smallest sum, or highest rank, is taken as the final best derivation producing the best parse tree in Simplicity-DOP.3 Although Bod (2000b) reports that Simplicity DOP is outperformed by Likelihood-DOP, its results are still rather impressive for such a simple model.', 'This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.'])
['system', 'ROUGE-S*', 'Average_R:', '0.04607', '(95%-conf.int.', '0.04607', '-', '0.04607)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.08808', '(95%-conf.int.', '0.08808', '-', '0.08808)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3321', 'P:153', 'F:153']
dict_values(["While the PCFG reduction of Bod (2001) obtains state-of-the-art results on the WSJ, comparable to Charniak (2000), Bonnema et al. 's estimator performs worse and is comparable to Collins (1996)."])
dict_values(['This approach has now gained wide usage, as exemplified by the work of Collins (1996, 1999), Charniak (1996, 1997), Johnson (1998), Chiang (2000), and many others.', 'Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).', 'Yet, his grammar contains more than 5 million subtrees and processing times of over 200 seconds per WSJ sentence are reported (Bod 2003).', 'In this paper, we will test a simple extension of Goodman\\s compact PCFG-reduction of DOP which has the same property as the normalization proposed in Bod (2001) in that it assigns roughly equal weight to each node in the training data.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00886', '(95%-conf.int.', '0.00886', '-', '0.00886)']
['system', 'ROUGE-S*', 'Average_P:', '0.10000', '(95%-conf.int.', '0.10000', '-', '0.10000)']
['system', 'ROUGE-S*', 'Average_F:', '0.01627', '(95%-conf.int.', '0.01627', '-', '0.01627)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:190', 'F:19']
dict_values(['The highest accuracy is obtained by SL-DOP at 12 n 14: an LP of 90.8% and an LR of 90.7%.'])
dict_values(['Although Bod\\s method obtains very competitive results on the Wall Street Journal (WSJ) task, the parsing time was reported to be over 200 seconds per sentence (Bod 2003).', 'Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).', 'This may be explained by the fact our best results in Bod (2001) were obtained by testing various subtree restrictions until the highest accuracy was obtained, while in the current experiment we used all subtrees as given by the PCFG-reduction.', 'In the following section first results of SL-DOP and LS-DOP with a compact PCFG-reduction. we will see that our new definition of best parse tree also outperforms the best results obtained in Bod (2001).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00512', '(95%-conf.int.', '0.00512', '-', '0.00512)']
['system', 'ROUGE-S*', 'Average_P:', '0.15385', '(95%-conf.int.', '0.15385', '-', '0.15385)']
['system', 'ROUGE-S*', 'Average_F:', '0.00990', '(95%-conf.int.', '0.00990', '-', '0.00990)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:78', 'F:12']
dict_values(['Goodman (1996, 1998) developed a polynomial time PCFG-reduction of DOP1 whose size is linear in the size of the training set, thus converting the exponential number of subtrees to a compact grammar.'])
dict_values(['As an alternative, Bonnema et al. (1999) propose a subtree estimator which reduces the probability of a tree by a factor of two for each non-root non-terminal it contains.', 'Bod (2001) used an alternative technique which samples a fixed number of subtrees of each depth and which has the effect of assigning roughly equal weight to each node in the training data.', 'Bod reports state-of-the-art results with this method, and observes no decrease in parse accuracy when larger subtrees are included (using subtrees up to depth 14).', 'Then we slightly modify the PCFG-reduction in figure 2 as follows: We will also test the proposal by Bonnema et al. (1999) which reduces the probability of a subtree by a factor of two for each non-root nonterminal it contains.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00256', '(95%-conf.int.', '0.00256', '-', '0.00256)']
['system', 'ROUGE-S*', 'Average_P:', '0.02632', '(95%-conf.int.', '0.02632', '-', '0.02632)']
['system', 'ROUGE-S*', 'Average_F:', '0.00467', '(95%-conf.int.', '0.00467', '-', '0.00467)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:190', 'F:5']
0.44916599550834 0.036200999637990006 0.06620699933793





input/ref/Task1/J01-2004_aakansha.csv
input/res/Task1/J01-2004.annv3.csv
parsing: input/ref/Task1/J01-2004_aakansha.csv
<S sid="372" ssid="128">The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.</S>
original cit marker offset is 0
new cit marker offset is 0



["'372'"]
'372'
['372']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="5">This paper will examine language modeling for speech recognition from a natural language processing point of view.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'"]
'17'
['17']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="302" ssid="58">In the beam search approach outlined above, we can estimate the string's probability in the same manner, by summing the probabilities of the parses that the algorithm finds.</S>
original cit marker offset is 0
new cit marker offset is 0



["'302'"]
'302'
['302']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



["'31'"]
'31'
['31']
parsed_discourse_facet ['method_citation']
<S sid="79" ssid="37">This underspecification of the nonterminal predictions (e.g., VP-VBD in the example in Figure 2, as opposed to NP), allows lexical items to become part of the left context, and so be used to condition production probabilities, even the production probabilities of constituents that dominate them in the unfactored tree.</S>
    <S sid="80" ssid="38">It also brings words further downstream into the look-ahead at the point of specification.</S>
original cit marker offset is 0
new cit marker offset is 0



["'79'", "'80'"]
'79'
'80'
['79', '80']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="138" ssid="42">Our approach is found to yield very accurate parses efficiently, and, in addition, to lend itself straightforwardly to estimating word probabilities on-line, that is, in a single pass from left to right.</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'"]
'138'
['138']
parsed_discourse_facet ['method_citation']
<S sid="291" ssid="47">Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'291'"]
'291'
['291']
parsed_discourse_facet ['method_citation']
<S sid="372" ssid="128">The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.</S>
original cit marker offset is 0
new cit marker offset is 0



['372']
372
['372']
parsed_discourse_facet ['method_citation']
<S sid="209" ssid="113">This parser is essentially a stochastic version of the top-down parser described in Aho, Sethi, and Ullman (1986).</S>
    <S sid="210" ssid="114">It uses a PCFG with a conditional probability model of the sort defined in the previous section.</S>
original cit marker offset is 0
new cit marker offset is 0



["'209'", "'210'"]
'209'
'210'
['209', '210']
parsed_discourse_facet ['method_citation']
<S sid="372" ssid="128">The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.</S>
original cit marker offset is 0
new cit marker offset is 0



["'372'"]
'372'
['372']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S>
    <S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S><S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'32'"]
'20'
'21'
'32'
['20', '21', '32']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["'31'"]
'31'
['31']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="21">Because the rooted partial derivation is fully connected, all of the conditioning information that might be extracted from the top-down left context has already been specified, and a conditional probability model built on this information will not impose any additional burden on the search.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'"]
'33'
['33']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/J01-2004.annv3.csv
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S><S sid="16" ssid="4">While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.</S><S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S><S sid="93" ssid="51">The standard language model used in many speech recognition systems is the trigram model, i.e., a Markov model of order 2, which can be characterized by the following equation: To smooth the trigram models that are used in this paper, we interpolate the probability estimates of higher-order Markov models with lower-order Markov models (Jelinek and Mercer 1980).</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'16'", "'31'", "'93'"]
'15'
'16'
'31'
'93'
['15', '16', '31', '93']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S><S sid="16" ssid="4">While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.</S><S sid="141" ssid="45">We will then present empirical results in two domains: one to compare with previous work in the parsing literature, and the other to compare with previous work using parsing for language modeling for speech recognition, in particular with the Chelba and Jelinek results mentioned above.</S><S sid="399" ssid="12">In addition, as mentioned above, we would like to further test our language model in speech recognition tasks, to see if the perplexity improvement that we have seen can lead to significant reductions in word error rate.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'16'", "'141'", "'399'"]
'15'
'16'
'141'
'399'
['15', '16', '141', '399']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S><S sid="143" ssid="47">It has been shown repeatedly&#8212;e.g., Briscoe and Carroll (1993), Charniak (1997), Collins (1997), Inui et al. (1997), Johnson (1998)&#8212;that conditioning the probabilities of structures on the context within which they appear, for example on the lexical head of a constituent (Charniak 1997; Collins 1997), on the label of its parent nonterminal (Johnson 1998), or, ideally, on both and many other things besides, leads to a much better parsing model and results in higher parsing accuracies.</S><S sid="277" ssid="33">The first set of results looks at the performance of the parser on the standard corpora for statistical parsing trials: Sections 2-21 (989,860 words, 39,832 sentences) of the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) served as the training data, Section 24 (34,199 words, 1,346 sentences) as the held-out data for parameter estimation, and Section 23 (59,100 words, 2,416 sentences) as the test data.</S><S sid="367" ssid="123">Table 5 reports the word and sentence error rates for five different models: (i) the trigram model that comes with the lattices, trained on approximately 40M words, with a vocabulary of 20,000; (ii) the best-performing model from Chelba (2000), which was interpolated with the lattice trigram at A -= 0.4; (iii) our parsing model, with the same training and vocabulary as the perplexity trials above; (iv) a trigram model with the same training and vocabulary as the parsing model; and (v) no language model at all.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'143'", "'277'", "'367'"]
'20'
'143'
'277'
'367'
['20', '143', '277', '367']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S><S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S><S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S><S sid="277" ssid="33">The first set of results looks at the performance of the parser on the standard corpora for statistical parsing trials: Sections 2-21 (989,860 words, 39,832 sentences) of the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) served as the training data, Section 24 (34,199 words, 1,346 sentences) as the held-out data for parameter estimation, and Section 23 (59,100 words, 2,416 sentences) as the test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'31'", "'32'", "'277'"]
'20'
'31'
'32'
'277'
['20', '31', '32', '277']
parsed_discourse_facet ['method_citation']
<S sid="133" ssid="37">Statistically based heuristic best-first or beam-search strategies (Caraballo and Charniak 1998; Charniak, Goldwater, and Johnson 1998; Goodman 1997) have yielded an enormous improvement in the quality and speed of parsers, even without any guarantee that the parse returned is, in fact, that with the maximum likelihood for the probability model.</S><S sid="134" ssid="38">The parsers with the highest published broad-coverage parsing accuracy, which include Charniak (1997, 2000), Collins (1997, 1999), and Ratnaparkhi (1997), all utilize simple and straightforward statistically based search heuristics, pruning the search-space quite dramatically!\</S><S sid="135" ssid="39">Such methods are nearly always used in conjunction with some form of dynamic programming (henceforth DP).</S><S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'134'", "'135'", "'282'"]
'133'
'134'
'135'
'282'
['133', '134', '135', '282']
parsed_discourse_facet ['method_citation']
<S sid="135" ssid="39">Such methods are nearly always used in conjunction with some form of dynamic programming (henceforth DP).</S><S sid="269" ssid="25">In such a model, it is possible to commit to a set of partial analyses at a particular point that cannot be completed given the rest of the input string (i.e., the parser can &amp;quot;garden path&amp;quot;).</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S><S sid="403" ssid="16">Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.</S>
original cit marker offset is 0
new cit marker offset is 0



["'135'", "'269'", "'402'", "'403'"]
'135'
'269'
'402'
'403'
['135', '269', '402', '403']
parsed_discourse_facet ['method_citation']
<S sid="182" ssid="86">The functions that we have chosen for this paper follow from the intuition (and experience) that what helps parsing is different depending on the constituent that is being expanded.</S><S sid="184" ssid="88">If the POS is leftmost within its constituent, then very often the lexical item is sensitive to the governing category to which it is attaching.</S><S sid="185" ssid="89">For example, if the POS is a preposition, then its probability of expanding to a particular word is very different if it is attaching to a noun phrase than if it is attaching to a verb phrase, and perhaps quite different depending on the head of the constituent to which it is attaching.</S><S sid="231" ssid="135">Since we do not know the POS for the word, we must sum the LAP for all POS For a PCFG G, a stack S = Ao An$ (which we will write AN and a look-ahead terminal item wi, we define the look-ahead probability as follows: We recursively estimate this with two empirically observed conditional probabilities for every nonterminal A,: 13(A, w,a) and P(A, c).</S>
original cit marker offset is 0
new cit marker offset is 0



["'182'", "'184'", "'185'", "'231'"]
'182'
'184'
'185'
'231'
['182', '184', '185', '231']
parsed_discourse_facet ['method_citation']
<S sid="136" ssid="40">That is, search efficiency for these parsers is improved by both statistical search heuristics and DP.</S><S sid="267" ssid="23">In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.</S><S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S><S sid="298" ssid="54">What is perhaps surprising is that the difference is not greater.</S>
original cit marker offset is 0
new cit marker offset is 0



["'136'", "'267'", "'282'", "'298'"]
'136'
'267'
'282'
'298'
['136', '267', '282', '298']
parsed_discourse_facet ['method_citation']
<S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S><S sid="290" ssid="46">Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.</S><S sid="377" ssid="133">The point of this small experiment was to see if our parsing model could provide useful information even in the case that recognition errors occur, as opposed to the (generally) fully grammatical strings upon which the perplexity results were obtained.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'282'", "'290'", "'377'", "'402'"]
'282'
'290'
'377'
'402'
['282', '290', '377', '402']
parsed_discourse_facet ['results_citation']
<S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S><S sid="281" ssid="37">First, and least surprising, is that the accuracy of the parses improved as we conditioned on more and more information.</S><S sid="290" ssid="46">Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.</S><S sid="291" ssid="47">Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'281'", "'290'", "'291'"]
'32'
'281'
'290'
'291'
['32', '281', '290', '291']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="27">The top-down guidance that is provided makes this approach quite efficient in practice.</S><S sid="76" ssid="34">The leftfactorization transform that we use is identical to what is called right binarization in Roark and Johnson (1999).</S><S sid="96" ssid="54">This interpolation is recursively applied to the smaller-order n-grams until the bigram is finally interpolated with the unigram, i.e., Ao = 1.</S><S sid="378" ssid="134">As one reviewer pointed out, given that our model relies so heavily on context, it may have difficulty recovering from even one recognition error, perhaps more difficulty than a more locally oriented trigram.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'76'", "'96'", "'378'"]
'39'
'76'
'96'
'378'
['39', '76', '96', '378']
parsed_discourse_facet ['method_citation']
<S sid="101" ssid="5">As mentioned in Section 2.1, a PCFG defines a probability distribution over strings of words.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S><S sid="403" ssid="16">Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.</S>
original cit marker offset is 0
new cit marker offset is 0



["'101'", "'401'", "'402'", "'403'"]
'101'
'401'
'402'
'403'
['101', '401', '402', '403']
parsed_discourse_facet ['method_citation']
<S sid="235" ssid="139">The basic idea is that we want the beam to be very wide if there are few analyses that have been advanced, but relatively narrow if many analyses have been advanced.</S><S sid="239" ssid="143">After 1,000 candidates, the beam has narrowed to 10-2p.</S><S sid="267" ssid="23">In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.</S><S sid="349" ssid="105">One way to test this is the following: at each point in the sentence, calculate the conditional probability of each word in the vocabulary given the previous words, and sum them.\</S>
original cit marker offset is 0
new cit marker offset is 0



["'235'", "'239'", "'267'", "'349'"]
'235'
'239'
'267'
'349'
['235', '239', '267', '349']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="142" ssid="46">A simple PCFG conditions rule probabilities on the left-hand side of the rule.</S><S sid="363" ssid="119">Splitting of the contractions is critical for parsing, since the two parts oftentimes (as in the previous example) fall in different constituents.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'142'", "'363'", "'401'", "'402'"]
'142'
'363'
'401'
'402'
['142', '363', '401', '402']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">A lexicalized probabilistic topdown parser is then presented, which performs very well, in terms of both the accuracy of returned parses and the efficiency with which they are found, relative to the best broad-coverage statistical parsers.</S><S sid="9" ssid="3">A lexicalized probabilistic topdown parser is then presented, which performs very well, in terms of both the accuracy of returned parses and the efficiency with which they are found, relative to the best broad-coverage statistical parsers.</S><S sid="142" ssid="46">A simple PCFG conditions rule probabilities on the left-hand side of the rule.</S><S sid="143" ssid="47">It has been shown repeatedly&#8212;e.g., Briscoe and Carroll (1993), Charniak (1997), Collins (1997), Inui et al. (1997), Johnson (1998)&#8212;that conditioning the probabilities of structures on the context within which they appear, for example on the lexical head of a constituent (Charniak 1997; Collins 1997), on the label of its parent nonterminal (Johnson 1998), or, ideally, on both and many other things besides, leads to a much better parsing model and results in higher parsing accuracies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'9'", "'142'", "'143'"]
'3'
'9'
'142'
'143'
['3', '9', '142', '143']
parsed_discourse_facet ['aim_citation']
<S sid="99" ssid="3">These can be divided into two rough groups: those that use the grammar as a language model, and those that use a parser to uncover phrasal heads standing in an important relation (c-command) to the current word.</S><S sid="322" ssid="78">Thus, Chelba and Jelinek (1998a, 1998b) also used a parser to help assign word probabilities, via the structured language model outlined in Section 3.2.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'99'", "'322'", "'401'", "'402'"]
'99'
'322'
'401'
'402'
['99', '322', '401', '402']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S><S sid="268" ssid="24">This is an incremental parser with a pruning strategy and no backtracking.</S><S sid="309" ssid="65">Let Ht be the priority queue H, before any processing has begun with word w, in the look-ahead.</S><S sid="310" ssid="66">This is a subset of the possible leftmost partial derivations with respect to the prefix string W. Since RV is produced by expanding only analyses on priority queue H;\, the set of complete trees consistent with the partial derivations on priority queue Ht is a subset of the set of complete trees consistent with the partial derivations on priority queue HT\\, that is, the total probability mass represented by the priority queues is monotonically decreasing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'268'", "'309'", "'310'"]
'21'
'268'
'309'
'310'
['21', '268', '309', '310']
parsed_discourse_facet ['method_citation']
dict_values(['The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.'])
dict_values(['In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.', 'While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.', 'Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).', 'The standard language model used in many speech recognition systems is the trigram model, i.e., a Markov model of order 2, which can be characterized by the following equation: To smooth the trigram models that are used in this paper, we interpolate the probability estimates of higher-order Markov models with lower-order Markov models (Jelinek and Mercer 1980).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5151', 'P:91', 'F:0']
dict_values(['This paper will examine language modeling for speech recognition from a natural language processing point of view.'])
dict_values(['In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.', 'While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.', 'We will then present empirical results in two domains: one to compare with previous work in the parsing literature, and the other to compare with previous work using parsing for language modeling for speech recognition, in particular with the Chelba and Jelinek results mentioned above.', 'In addition, as mentioned above, we would like to further test our language model in speech recognition tasks, to see if the perplexity improvement that we have seen can lead to significant reductions in word error rate.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00512', '(95%-conf.int.', '0.00512', '-', '0.00512)']
['system', 'ROUGE-S*', 'Average_P:', '0.30909', '(95%-conf.int.', '0.30909', '-', '0.30909)']
['system', 'ROUGE-S*', 'Average_F:', '0.01007', '(95%-conf.int.', '0.01007', '-', '0.01007)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3321', 'P:55', 'F:17']
dict_values(['This underspecification of the nonterminal predictions (e.g., VP-VBD in the example in Figure 2, as opposed to NP), allows lexical items to become part of the left context, and so be used to condition production probabilities, even the production probabilities of constituents that dominate them in the unfactored tree.', 'It also brings words further downstream into the look-ahead at the point of specification.'])
dict_values(['The functions that we have chosen for this paper follow from the intuition (and experience) that what helps parsing is different depending on the constituent that is being expanded.', 'If the POS is leftmost within its constituent, then very often the lexical item is sensitive to the governing category to which it is attaching.', 'For example, if the POS is a preposition, then its probability of expanding to a particular word is very different if it is attaching to a noun phrase than if it is attaching to a verb phrase, and perhaps quite different depending on the head of the constituent to which it is attaching.', 'Since we do not know the POS for the word, we must sum the LAP for all POS For a PCFG G, a stack S = Ao An$ (which we will write AN and a look-ahead terminal item wi, we define the look-ahead probability as follows: We recursively estimate this with two empirically observed conditional probabilities for every nonterminal A,: 13(A, w,a) and P(A, c).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01344', '(95%-conf.int.', '0.01344', '-', '0.01344)']
['system', 'ROUGE-S*', 'Average_P:', '0.05665', '(95%-conf.int.', '0.05665', '-', '0.05665)']
['system', 'ROUGE-S*', 'Average_F:', '0.02173', '(95%-conf.int.', '0.02173', '-', '0.02173)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:406', 'F:23']
dict_values(['Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.'])
dict_values(['A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.', 'First, and least surprising, is that the accuracy of the parses improved as we conditioned on more and more information.', 'Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.', 'Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.'])
['system', 'ROUGE-S*', 'Average_R:', '0.21577', '(95%-conf.int.', '0.21577', '-', '0.21577)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.35496', '(95%-conf.int.', '0.35496', '-', '0.35496)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:435', 'F:435']
dict_values(['The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.'])
dict_values(['The top-down guidance that is provided makes this approach quite efficient in practice.', 'The leftfactorization transform that we use is identical to what is called right binarization in Roark and Johnson (1999).', 'This interpolation is recursively applied to the smaller-order n-grams until the bigram is finally interpolated with the unigram, i.e., Ao = 1.', 'As one reviewer pointed out, given that our model relies so heavily on context, it may have difficulty recovering from even one recognition error, perhaps more difficulty than a more locally oriented trigram.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00122', '(95%-conf.int.', '0.00122', '-', '0.00122)']
['system', 'ROUGE-S*', 'Average_P:', '0.01099', '(95%-conf.int.', '0.01099', '-', '0.01099)']
['system', 'ROUGE-S*', 'Average_F:', '0.00220', '(95%-conf.int.', '0.00220', '-', '0.00220)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:91', 'F:1']
dict_values(['This parser is essentially a stochastic version of the top-down parser described in Aho, Sethi, and Ullman (1986).', 'It uses a PCFG with a conditional probability model of the sort defined in the previous section.'])
dict_values(['As mentioned in Section 2.1, a PCFG defines a probability distribution over strings of words.', 'Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.', 'In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.', 'Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00510', '(95%-conf.int.', '0.00510', '-', '0.00510)']
['system', 'ROUGE-S*', 'Average_P:', '0.03922', '(95%-conf.int.', '0.03922', '-', '0.03922)']
['system', 'ROUGE-S*', 'Average_F:', '0.00903', '(95%-conf.int.', '0.00903', '-', '0.00903)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:153', 'F:6']
dict_values(['The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.'])
dict_values(['The basic idea is that we want the beam to be very wide if there are few analyses that have been advanced, but relatively narrow if many analyses have been advanced.', 'After 1,000 candidates, the beam has narrowed to 10-2p.', 'In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.', 'One way to test this is the following: at each point in the sentence, calculate the conditional probability of each word in the vocabulary given the previous words, and sum them.\\'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:91', 'F:0']
dict_values(['Because the rooted partial derivation is fully connected, all of the conditioning information that might be extracted from the top-down left context has already been specified, and a conditional probability model built on this information will not impose any additional burden on the search.'])
dict_values(['First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.', 'This is an incremental parser with a pruning strategy and no backtracking.', 'Let Ht be the priority queue H, before any processing has begun with word w, in the look-ahead.', 'This is a subset of the possible leftmost partial derivations with respect to the prefix string W. Since RV is produced by expanding only analyses on priority queue H;\\, the set of complete trees consistent with the partial derivations on priority queue Ht is a subset of the set of complete trees consistent with the partial derivations on priority queue HT\\\\, that is, the total probability mass represented by the priority queues is monotonically decreasing.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00500', '(95%-conf.int.', '0.00500', '-', '0.00500)']
['system', 'ROUGE-S*', 'Average_P:', '0.07895', '(95%-conf.int.', '0.07895', '-', '0.07895)']
['system', 'ROUGE-S*', 'Average_F:', '0.00940', '(95%-conf.int.', '0.00940', '-', '0.00940)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:190', 'F:15']
0.1868624976642188 0.03070624961617188 0.05092374936345313





input/ref/Task1/J01-2004_swastika.csv
input/res/Task1/J01-2004.annv3.csv
parsing: input/ref/Task1/J01-2004_swastika.csv
<S sid="372" ssid="128">The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.</S>
original cit marker offset is 0
new cit marker offset is 0



['372']
372
['372']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S>
original cit marker offset is 0
new cit marker offset is 0



['15']
15
['15']
parsed_discourse_facet ['result_citation']
    <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



['31']
31
['31']
parsed_discourse_facet ['result_citation']
    <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



['31']
31
['31']
parsed_discourse_facet ['result_citation']
    <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



['31']
31
['31']
parsed_discourse_facet ['result_citation']
    <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



['31']
31
['31']
parsed_discourse_facet ['result_citation']
<S sid="215" ssid="119">The first word in the string remaining to be parsed, w1, we will call the look-ahead word.</S>
original cit marker offset is 0
new cit marker offset is 0



['215']
215
['215']
parsed_discourse_facet ['method_citation']
    <S sid="302" ssid="58">In the beam search approach outlined above, we can estimate the string's probability in the same manner, by summing the probabilities of the parses that the algorithm finds.</S>
original cit marker offset is 0
new cit marker offset is 0



['302']
302
['302']
parsed_discourse_facet ['method_citation']
<S sid="372" ssid="128">The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.</S>
original cit marker offset is 0
new cit marker offset is 0



['372']
372
['372']
parsed_discourse_facet ['result_citation']
    <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



['31']
31
['31']
parsed_discourse_facet ['result_citation']
    <S sid="100" ssid="4">The approach that we will subsequently present uses the probabilistic grammar as its language model, but only includes probability mass from those parses that are found, that is, it uses the parser to find a subset of the total set of parses (hopefully most of the high-probability parses) and uses the sum of their probabilities as an estimate of the true probability given the grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



['100']
100
['100']
parsed_discourse_facet ['method_citation']
    <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



['31']
31
['31']
parsed_discourse_facet ['result_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



['21']
21
['21']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/J01-2004.annv3.csv
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S><S sid="16" ssid="4">While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.</S><S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S><S sid="93" ssid="51">The standard language model used in many speech recognition systems is the trigram model, i.e., a Markov model of order 2, which can be characterized by the following equation: To smooth the trigram models that are used in this paper, we interpolate the probability estimates of higher-order Markov models with lower-order Markov models (Jelinek and Mercer 1980).</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'16'", "'31'", "'93'"]
'15'
'16'
'31'
'93'
['15', '16', '31', '93']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S><S sid="16" ssid="4">While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.</S><S sid="141" ssid="45">We will then present empirical results in two domains: one to compare with previous work in the parsing literature, and the other to compare with previous work using parsing for language modeling for speech recognition, in particular with the Chelba and Jelinek results mentioned above.</S><S sid="399" ssid="12">In addition, as mentioned above, we would like to further test our language model in speech recognition tasks, to see if the perplexity improvement that we have seen can lead to significant reductions in word error rate.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'16'", "'141'", "'399'"]
'15'
'16'
'141'
'399'
['15', '16', '141', '399']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S><S sid="143" ssid="47">It has been shown repeatedly&#8212;e.g., Briscoe and Carroll (1993), Charniak (1997), Collins (1997), Inui et al. (1997), Johnson (1998)&#8212;that conditioning the probabilities of structures on the context within which they appear, for example on the lexical head of a constituent (Charniak 1997; Collins 1997), on the label of its parent nonterminal (Johnson 1998), or, ideally, on both and many other things besides, leads to a much better parsing model and results in higher parsing accuracies.</S><S sid="277" ssid="33">The first set of results looks at the performance of the parser on the standard corpora for statistical parsing trials: Sections 2-21 (989,860 words, 39,832 sentences) of the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) served as the training data, Section 24 (34,199 words, 1,346 sentences) as the held-out data for parameter estimation, and Section 23 (59,100 words, 2,416 sentences) as the test data.</S><S sid="367" ssid="123">Table 5 reports the word and sentence error rates for five different models: (i) the trigram model that comes with the lattices, trained on approximately 40M words, with a vocabulary of 20,000; (ii) the best-performing model from Chelba (2000), which was interpolated with the lattice trigram at A -= 0.4; (iii) our parsing model, with the same training and vocabulary as the perplexity trials above; (iv) a trigram model with the same training and vocabulary as the parsing model; and (v) no language model at all.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'143'", "'277'", "'367'"]
'20'
'143'
'277'
'367'
['20', '143', '277', '367']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S><S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S><S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S><S sid="277" ssid="33">The first set of results looks at the performance of the parser on the standard corpora for statistical parsing trials: Sections 2-21 (989,860 words, 39,832 sentences) of the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) served as the training data, Section 24 (34,199 words, 1,346 sentences) as the held-out data for parameter estimation, and Section 23 (59,100 words, 2,416 sentences) as the test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'31'", "'32'", "'277'"]
'20'
'31'
'32'
'277'
['20', '31', '32', '277']
parsed_discourse_facet ['method_citation']
<S sid="133" ssid="37">Statistically based heuristic best-first or beam-search strategies (Caraballo and Charniak 1998; Charniak, Goldwater, and Johnson 1998; Goodman 1997) have yielded an enormous improvement in the quality and speed of parsers, even without any guarantee that the parse returned is, in fact, that with the maximum likelihood for the probability model.</S><S sid="134" ssid="38">The parsers with the highest published broad-coverage parsing accuracy, which include Charniak (1997, 2000), Collins (1997, 1999), and Ratnaparkhi (1997), all utilize simple and straightforward statistically based search heuristics, pruning the search-space quite dramatically!\</S><S sid="135" ssid="39">Such methods are nearly always used in conjunction with some form of dynamic programming (henceforth DP).</S><S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'134'", "'135'", "'282'"]
'133'
'134'
'135'
'282'
['133', '134', '135', '282']
parsed_discourse_facet ['method_citation']
<S sid="135" ssid="39">Such methods are nearly always used in conjunction with some form of dynamic programming (henceforth DP).</S><S sid="269" ssid="25">In such a model, it is possible to commit to a set of partial analyses at a particular point that cannot be completed given the rest of the input string (i.e., the parser can &amp;quot;garden path&amp;quot;).</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S><S sid="403" ssid="16">Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.</S>
original cit marker offset is 0
new cit marker offset is 0



["'135'", "'269'", "'402'", "'403'"]
'135'
'269'
'402'
'403'
['135', '269', '402', '403']
parsed_discourse_facet ['method_citation']
<S sid="182" ssid="86">The functions that we have chosen for this paper follow from the intuition (and experience) that what helps parsing is different depending on the constituent that is being expanded.</S><S sid="184" ssid="88">If the POS is leftmost within its constituent, then very often the lexical item is sensitive to the governing category to which it is attaching.</S><S sid="185" ssid="89">For example, if the POS is a preposition, then its probability of expanding to a particular word is very different if it is attaching to a noun phrase than if it is attaching to a verb phrase, and perhaps quite different depending on the head of the constituent to which it is attaching.</S><S sid="231" ssid="135">Since we do not know the POS for the word, we must sum the LAP for all POS For a PCFG G, a stack S = Ao An$ (which we will write AN and a look-ahead terminal item wi, we define the look-ahead probability as follows: We recursively estimate this with two empirically observed conditional probabilities for every nonterminal A,: 13(A, w,a) and P(A, c).</S>
original cit marker offset is 0
new cit marker offset is 0



["'182'", "'184'", "'185'", "'231'"]
'182'
'184'
'185'
'231'
['182', '184', '185', '231']
parsed_discourse_facet ['method_citation']
<S sid="136" ssid="40">That is, search efficiency for these parsers is improved by both statistical search heuristics and DP.</S><S sid="267" ssid="23">In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.</S><S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S><S sid="298" ssid="54">What is perhaps surprising is that the difference is not greater.</S>
original cit marker offset is 0
new cit marker offset is 0



["'136'", "'267'", "'282'", "'298'"]
'136'
'267'
'282'
'298'
['136', '267', '282', '298']
parsed_discourse_facet ['method_citation']
<S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S><S sid="290" ssid="46">Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.</S><S sid="377" ssid="133">The point of this small experiment was to see if our parsing model could provide useful information even in the case that recognition errors occur, as opposed to the (generally) fully grammatical strings upon which the perplexity results were obtained.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'282'", "'290'", "'377'", "'402'"]
'282'
'290'
'377'
'402'
['282', '290', '377', '402']
parsed_discourse_facet ['results_citation']
<S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S><S sid="281" ssid="37">First, and least surprising, is that the accuracy of the parses improved as we conditioned on more and more information.</S><S sid="290" ssid="46">Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.</S><S sid="291" ssid="47">Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'281'", "'290'", "'291'"]
'32'
'281'
'290'
'291'
['32', '281', '290', '291']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="27">The top-down guidance that is provided makes this approach quite efficient in practice.</S><S sid="76" ssid="34">The leftfactorization transform that we use is identical to what is called right binarization in Roark and Johnson (1999).</S><S sid="96" ssid="54">This interpolation is recursively applied to the smaller-order n-grams until the bigram is finally interpolated with the unigram, i.e., Ao = 1.</S><S sid="378" ssid="134">As one reviewer pointed out, given that our model relies so heavily on context, it may have difficulty recovering from even one recognition error, perhaps more difficulty than a more locally oriented trigram.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'76'", "'96'", "'378'"]
'39'
'76'
'96'
'378'
['39', '76', '96', '378']
parsed_discourse_facet ['method_citation']
<S sid="101" ssid="5">As mentioned in Section 2.1, a PCFG defines a probability distribution over strings of words.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S><S sid="403" ssid="16">Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.</S>
original cit marker offset is 0
new cit marker offset is 0



["'101'", "'401'", "'402'", "'403'"]
'101'
'401'
'402'
'403'
['101', '401', '402', '403']
parsed_discourse_facet ['method_citation']
<S sid="235" ssid="139">The basic idea is that we want the beam to be very wide if there are few analyses that have been advanced, but relatively narrow if many analyses have been advanced.</S><S sid="239" ssid="143">After 1,000 candidates, the beam has narrowed to 10-2p.</S><S sid="267" ssid="23">In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.</S><S sid="349" ssid="105">One way to test this is the following: at each point in the sentence, calculate the conditional probability of each word in the vocabulary given the previous words, and sum them.\</S>
original cit marker offset is 0
new cit marker offset is 0



["'235'", "'239'", "'267'", "'349'"]
'235'
'239'
'267'
'349'
['235', '239', '267', '349']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="142" ssid="46">A simple PCFG conditions rule probabilities on the left-hand side of the rule.</S><S sid="363" ssid="119">Splitting of the contractions is critical for parsing, since the two parts oftentimes (as in the previous example) fall in different constituents.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'142'", "'363'", "'401'", "'402'"]
'142'
'363'
'401'
'402'
['142', '363', '401', '402']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">A lexicalized probabilistic topdown parser is then presented, which performs very well, in terms of both the accuracy of returned parses and the efficiency with which they are found, relative to the best broad-coverage statistical parsers.</S><S sid="9" ssid="3">A lexicalized probabilistic topdown parser is then presented, which performs very well, in terms of both the accuracy of returned parses and the efficiency with which they are found, relative to the best broad-coverage statistical parsers.</S><S sid="142" ssid="46">A simple PCFG conditions rule probabilities on the left-hand side of the rule.</S><S sid="143" ssid="47">It has been shown repeatedly&#8212;e.g., Briscoe and Carroll (1993), Charniak (1997), Collins (1997), Inui et al. (1997), Johnson (1998)&#8212;that conditioning the probabilities of structures on the context within which they appear, for example on the lexical head of a constituent (Charniak 1997; Collins 1997), on the label of its parent nonterminal (Johnson 1998), or, ideally, on both and many other things besides, leads to a much better parsing model and results in higher parsing accuracies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'9'", "'142'", "'143'"]
'3'
'9'
'142'
'143'
['3', '9', '142', '143']
parsed_discourse_facet ['aim_citation']
<S sid="99" ssid="3">These can be divided into two rough groups: those that use the grammar as a language model, and those that use a parser to uncover phrasal heads standing in an important relation (c-command) to the current word.</S><S sid="322" ssid="78">Thus, Chelba and Jelinek (1998a, 1998b) also used a parser to help assign word probabilities, via the structured language model outlined in Section 3.2.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'99'", "'322'", "'401'", "'402'"]
'99'
'322'
'401'
'402'
['99', '322', '401', '402']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S><S sid="268" ssid="24">This is an incremental parser with a pruning strategy and no backtracking.</S><S sid="309" ssid="65">Let Ht be the priority queue H, before any processing has begun with word w, in the look-ahead.</S><S sid="310" ssid="66">This is a subset of the possible leftmost partial derivations with respect to the prefix string W. Since RV is produced by expanding only analyses on priority queue H;\, the set of complete trees consistent with the partial derivations on priority queue Ht is a subset of the set of complete trees consistent with the partial derivations on priority queue HT\\, that is, the total probability mass represented by the priority queues is monotonically decreasing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'268'", "'309'", "'310'"]
'21'
'268'
'309'
'310'
['21', '268', '309', '310']
parsed_discourse_facet ['method_citation']
dict_values(['The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.'])
dict_values(['In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.', 'While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.', 'Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).', 'The standard language model used in many speech recognition systems is the trigram model, i.e., a Markov model of order 2, which can be characterized by the following equation: To smooth the trigram models that are used in this paper, we interpolate the probability estimates of higher-order Markov models with lower-order Markov models (Jelinek and Mercer 1980).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5151', 'P:91', 'F:0']
dict_values(['In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.'])
dict_values(['In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.', 'While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.', 'We will then present empirical results in two domains: one to compare with previous work in the parsing literature, and the other to compare with previous work using parsing for language modeling for speech recognition, in particular with the Chelba and Jelinek results mentioned above.', 'In addition, as mentioned above, we would like to further test our language model in speech recognition tasks, to see if the perplexity improvement that we have seen can lead to significant reductions in word error rate.'])
['system', 'ROUGE-S*', 'Average_R:', '0.09033', '(95%-conf.int.', '0.09033', '-', '0.09033)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.16570', '(95%-conf.int.', '0.16570', '-', '0.16570)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3321', 'P:300', 'F:300']
dict_values(['The first word in the string remaining to be parsed, w1, we will call the look-ahead word.'])
dict_values(['The functions that we have chosen for this paper follow from the intuition (and experience) that what helps parsing is different depending on the constituent that is being expanded.', 'If the POS is leftmost within its constituent, then very often the lexical item is sensitive to the governing category to which it is attaching.', 'For example, if the POS is a preposition, then its probability of expanding to a particular word is very different if it is attaching to a noun phrase than if it is attaching to a verb phrase, and perhaps quite different depending on the head of the constituent to which it is attaching.', 'Since we do not know the POS for the word, we must sum the LAP for all POS For a PCFG G, a stack S = Ao An$ (which we will write AN and a look-ahead terminal item wi, we define the look-ahead probability as follows: We recursively estimate this with two empirically observed conditional probabilities for every nonterminal A,: 13(A, w,a) and P(A, c).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00234', '(95%-conf.int.', '0.00234', '-', '0.00234)']
['system', 'ROUGE-S*', 'Average_P:', '0.11111', '(95%-conf.int.', '0.11111', '-', '0.11111)']
['system', 'ROUGE-S*', 'Average_F:', '0.00458', '(95%-conf.int.', '0.00458', '-', '0.00458)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:36', 'F:4']
dict_values(["In the beam search approach outlined above, we can estimate the string's probability in the same manner, by summing the probabilities of the parses that the algorithm finds."])
dict_values(['A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.', 'First, and least surprising, is that the accuracy of the parses improved as we conditioned on more and more information.', 'Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.', 'Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00248', '(95%-conf.int.', '0.00248', '-', '0.00248)']
['system', 'ROUGE-S*', 'Average_P:', '0.06410', '(95%-conf.int.', '0.06410', '-', '0.06410)']
['system', 'ROUGE-S*', 'Average_F:', '0.00478', '(95%-conf.int.', '0.00478', '-', '0.00478)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:78', 'F:5']
dict_values(['The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.'])
dict_values(['The top-down guidance that is provided makes this approach quite efficient in practice.', 'The leftfactorization transform that we use is identical to what is called right binarization in Roark and Johnson (1999).', 'This interpolation is recursively applied to the smaller-order n-grams until the bigram is finally interpolated with the unigram, i.e., Ao = 1.', 'As one reviewer pointed out, given that our model relies so heavily on context, it may have difficulty recovering from even one recognition error, perhaps more difficulty than a more locally oriented trigram.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00122', '(95%-conf.int.', '0.00122', '-', '0.00122)']
['system', 'ROUGE-S*', 'Average_P:', '0.01099', '(95%-conf.int.', '0.01099', '-', '0.01099)']
['system', 'ROUGE-S*', 'Average_F:', '0.00220', '(95%-conf.int.', '0.00220', '-', '0.00220)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:91', 'F:1']
dict_values(['Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).'])
dict_values(['As mentioned in Section 2.1, a PCFG defines a probability distribution over strings of words.', 'Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.', 'In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.', 'Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05272', '(95%-conf.int.', '0.05272', '-', '0.05272)']
['system', 'ROUGE-S*', 'Average_P:', '0.20667', '(95%-conf.int.', '0.20667', '-', '0.20667)']
['system', 'ROUGE-S*', 'Average_F:', '0.08401', '(95%-conf.int.', '0.08401', '-', '0.08401)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:300', 'F:62']
dict_values(['The approach that we will subsequently present uses the probabilistic grammar as its language model, but only includes probability mass from those parses that are found, that is, it uses the parser to find a subset of the total set of parses (hopefully most of the high-probability parses) and uses the sum of their probabilities as an estimate of the true probability given the grammar.'])
dict_values(['The basic idea is that we want the beam to be very wide if there are few analyses that have been advanced, but relatively narrow if many analyses have been advanced.', 'After 1,000 candidates, the beam has narrowed to 10-2p.', 'In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.', 'One way to test this is the following: at each point in the sentence, calculate the conditional probability of each word in the vocabulary given the previous words, and sum them.\\'])
['system', 'ROUGE-S*', 'Average_R:', '0.00245', '(95%-conf.int.', '0.00245', '-', '0.00245)']
['system', 'ROUGE-S*', 'Average_P:', '0.00855', '(95%-conf.int.', '0.00855', '-', '0.00855)']
['system', 'ROUGE-S*', 'Average_F:', '0.00381', '(95%-conf.int.', '0.00381', '-', '0.00381)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:351', 'F:3']
dict_values(['First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.'])
dict_values(['First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.', 'This is an incremental parser with a pruning strategy and no backtracking.', 'Let Ht be the priority queue H, before any processing has begun with word w, in the look-ahead.', 'This is a subset of the possible leftmost partial derivations with respect to the prefix string W. Since RV is produced by expanding only analyses on priority queue H;\\, the set of complete trees consistent with the partial derivations on priority queue Ht is a subset of the set of complete trees consistent with the partial derivations on priority queue HT\\\\, that is, the total probability mass represented by the priority queues is monotonically decreasing.'])
['system', 'ROUGE-S*', 'Average_R:', '0.10823', '(95%-conf.int.', '0.10823', '-', '0.10823)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.19531', '(95%-conf.int.', '0.19531', '-', '0.19531)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:325', 'F:325']
0.3001774962477813 0.03247124959410938 0.05754874928064063





input/ref/Task1/J01-2004_sweta.csv
input/res/Task1/J01-2004.annv3.csv
parsing: input/ref/Task1/J01-2004_sweta.csv
<S sid="372" ssid="128">The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.</S>
original cit marker offset is 0
new cit marker offset is 0



["372'"]
372'
['372']
parsed_discourse_facet ['method_citation']
<S sid="40" ssid="28">The following section will provide some background in probabilistic context-free grammars and language modeling for speech recognition.</S>
    <S sid="41" ssid="29">There will also be a brief review of previous work using syntactic information for language modeling, before we introduce our model in Section 4.</S>
    <S sid="42" ssid="30">Three parse trees: (a) a complete parse tree; (b) a complete parse tree with an explicit stop symbol; and (c) a partial parse tree.</S>
original cit marker offset is 0
new cit marker offset is 0



["40'", "'41'", "'42'"]
40'
'41'
'42'
['40', '41', '42']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="13">A parser that is not left to right, but which has rooted derivations, e.g., a headfirst parser, will be able to calculate generative joint probabilities for entire strings; however, it will not be able to calculate probabilities for each word conditioned on previously generated words, unless each derivation generates the words in the string in exactly the same order.</S>
original cit marker offset is 0
new cit marker offset is 0



["25'"]
25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="364" ssid="120">We follow Chelba (2000) in dealing with this problem: for parsing purposes, we use the Penn Treebank tokenization; for interpolation with the provided trigram model, and for evaluation, the lattice tokenization is used.</S>
original cit marker offset is 0
new cit marker offset is 0



["364'"]
364'
['364']
parsed_discourse_facet ['method_citation']
<S sid="302" ssid="58">In the beam search approach outlined above, we can estimate the string's probability in the same manner, by summing the probabilities of the parses that the algorithm finds.</S>
original cit marker offset is 0
new cit marker offset is 0



["302'"]
302'
['302']
parsed_discourse_facet ['method_citation']
 <S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



["31'"]
31'
['31']
parsed_discourse_facet ['method_citation']
<S sid="231" ssid="135">Since we do not know the POS for the word, we must sum the LAP for all POS For a PCFG G, a stack S = Ao An$ (which we will write AN and a look-ahead terminal item wi, we define the look-ahead probability as follows: We recursively estimate this with two empirically observed conditional probabilities for every nonterminal A,: 13(A, w,a) and P(A, c).</S>
original cit marker offset is 0
new cit marker offset is 0



["231'"]
231'
['231']
parsed_discourse_facet ['method_citation']
<S sid="297" ssid="53">The differences between a k-best and a beam-search parser (not to mention the use of dynamic programming) make a running time difference unsurprising.</S>
original cit marker offset is 0
new cit marker offset is 0



["297'"]
297'
['297']
parsed_discourse_facet ['method_citation']
<S sid="133" ssid="37">Statistically based heuristic best-first or beam-search strategies (Caraballo and Charniak 1998; Charniak, Goldwater, and Johnson 1998; Goodman 1997) have yielded an enormous improvement in the quality and speed of parsers, even without any guarantee that the parse returned is, in fact, that with the maximum likelihood for the probability model.</S>
original cit marker offset is 0
new cit marker offset is 0



["133'"]
133'
['133']
parsed_discourse_facet ['method_citation']
<S sid="291" ssid="47">Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["291'"]
291'
['291']
parsed_discourse_facet ['method_citation']
<S sid="355" ssid="111">In order to get a sense of whether these perplexity reduction results can translate to improvement in a speech recognition task, we performed a very small preliminary experiment on n-best lists.</S>
original cit marker offset is 0
new cit marker offset is 0



["355'"]
355'
['355']
parsed_discourse_facet ['method_citation']
<S sid="59" ssid="17">A PCFG is a CFG with a probability assigned to each rule; specifically, each righthand side has a probability given the left-hand side of the rule.</S>
original cit marker offset is 0
new cit marker offset is 0



["59'"]
59'
['59']
parsed_discourse_facet ['method_citation']
<S sid="100" ssid="4">The approach that we will subsequently present uses the probabilistic grammar as its language model, but only includes probability mass from those parses that are found, that is, it uses the parser to find a subset of the total set of parses (hopefully most of the high-probability parses) and uses the sum of their probabilities as an estimate of the true probability given the grammar.</S>
original cit marker offset is 0
new cit marker offset is 0



["100'"]
100'
['100']
parsed_discourse_facet ['method_citation']
<S sid="108" ssid="12">Another approach that uses syntactic structure for language modeling has been to use a shift-reduce parser to &amp;quot;surface&amp;quot; c-commanding phrasal headwords or part-of-speech (POS) tags from arbitrarily far back in the prefix string, for use in a trigram-like model.</S>
original cit marker offset is 0
new cit marker offset is 0



["108'"]
108'
['108']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



["31'"]
31'
['31']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S>
original cit marker offset is 0
new cit marker offset is 0



["31'"]
31'
['31']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/J01-2004.annv3.csv
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S><S sid="16" ssid="4">While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.</S><S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S><S sid="93" ssid="51">The standard language model used in many speech recognition systems is the trigram model, i.e., a Markov model of order 2, which can be characterized by the following equation: To smooth the trigram models that are used in this paper, we interpolate the probability estimates of higher-order Markov models with lower-order Markov models (Jelinek and Mercer 1980).</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'16'", "'31'", "'93'"]
'15'
'16'
'31'
'93'
['15', '16', '31', '93']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="3">In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.</S><S sid="16" ssid="4">While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.</S><S sid="141" ssid="45">We will then present empirical results in two domains: one to compare with previous work in the parsing literature, and the other to compare with previous work using parsing for language modeling for speech recognition, in particular with the Chelba and Jelinek results mentioned above.</S><S sid="399" ssid="12">In addition, as mentioned above, we would like to further test our language model in speech recognition tasks, to see if the perplexity improvement that we have seen can lead to significant reductions in word error rate.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'16'", "'141'", "'399'"]
'15'
'16'
'141'
'399'
['15', '16', '141', '399']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S><S sid="143" ssid="47">It has been shown repeatedly&#8212;e.g., Briscoe and Carroll (1993), Charniak (1997), Collins (1997), Inui et al. (1997), Johnson (1998)&#8212;that conditioning the probabilities of structures on the context within which they appear, for example on the lexical head of a constituent (Charniak 1997; Collins 1997), on the label of its parent nonterminal (Johnson 1998), or, ideally, on both and many other things besides, leads to a much better parsing model and results in higher parsing accuracies.</S><S sid="277" ssid="33">The first set of results looks at the performance of the parser on the standard corpora for statistical parsing trials: Sections 2-21 (989,860 words, 39,832 sentences) of the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) served as the training data, Section 24 (34,199 words, 1,346 sentences) as the held-out data for parameter estimation, and Section 23 (59,100 words, 2,416 sentences) as the test data.</S><S sid="367" ssid="123">Table 5 reports the word and sentence error rates for five different models: (i) the trigram model that comes with the lattices, trained on approximately 40M words, with a vocabulary of 20,000; (ii) the best-performing model from Chelba (2000), which was interpolated with the lattice trigram at A -= 0.4; (iii) our parsing model, with the same training and vocabulary as the perplexity trials above; (iv) a trigram model with the same training and vocabulary as the parsing model; and (v) no language model at all.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'143'", "'277'", "'367'"]
'20'
'143'
'277'
'367'
['20', '143', '277', '367']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="8">Two features of our top-down parsing approach will emerge as key to its success.</S><S sid="31" ssid="19">Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).</S><S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S><S sid="277" ssid="33">The first set of results looks at the performance of the parser on the standard corpora for statistical parsing trials: Sections 2-21 (989,860 words, 39,832 sentences) of the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) served as the training data, Section 24 (34,199 words, 1,346 sentences) as the held-out data for parameter estimation, and Section 23 (59,100 words, 2,416 sentences) as the test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'31'", "'32'", "'277'"]
'20'
'31'
'32'
'277'
['20', '31', '32', '277']
parsed_discourse_facet ['method_citation']
<S sid="133" ssid="37">Statistically based heuristic best-first or beam-search strategies (Caraballo and Charniak 1998; Charniak, Goldwater, and Johnson 1998; Goodman 1997) have yielded an enormous improvement in the quality and speed of parsers, even without any guarantee that the parse returned is, in fact, that with the maximum likelihood for the probability model.</S><S sid="134" ssid="38">The parsers with the highest published broad-coverage parsing accuracy, which include Charniak (1997, 2000), Collins (1997, 1999), and Ratnaparkhi (1997), all utilize simple and straightforward statistically based search heuristics, pruning the search-space quite dramatically!\</S><S sid="135" ssid="39">Such methods are nearly always used in conjunction with some form of dynamic programming (henceforth DP).</S><S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'134'", "'135'", "'282'"]
'133'
'134'
'135'
'282'
['133', '134', '135', '282']
parsed_discourse_facet ['method_citation']
<S sid="135" ssid="39">Such methods are nearly always used in conjunction with some form of dynamic programming (henceforth DP).</S><S sid="269" ssid="25">In such a model, it is possible to commit to a set of partial analyses at a particular point that cannot be completed given the rest of the input string (i.e., the parser can &amp;quot;garden path&amp;quot;).</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S><S sid="403" ssid="16">Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.</S>
original cit marker offset is 0
new cit marker offset is 0



["'135'", "'269'", "'402'", "'403'"]
'135'
'269'
'402'
'403'
['135', '269', '402', '403']
parsed_discourse_facet ['method_citation']
<S sid="182" ssid="86">The functions that we have chosen for this paper follow from the intuition (and experience) that what helps parsing is different depending on the constituent that is being expanded.</S><S sid="184" ssid="88">If the POS is leftmost within its constituent, then very often the lexical item is sensitive to the governing category to which it is attaching.</S><S sid="185" ssid="89">For example, if the POS is a preposition, then its probability of expanding to a particular word is very different if it is attaching to a noun phrase than if it is attaching to a verb phrase, and perhaps quite different depending on the head of the constituent to which it is attaching.</S><S sid="231" ssid="135">Since we do not know the POS for the word, we must sum the LAP for all POS For a PCFG G, a stack S = Ao An$ (which we will write AN and a look-ahead terminal item wi, we define the look-ahead probability as follows: We recursively estimate this with two empirically observed conditional probabilities for every nonterminal A,: 13(A, w,a) and P(A, c).</S>
original cit marker offset is 0
new cit marker offset is 0



["'182'", "'184'", "'185'", "'231'"]
'182'
'184'
'185'
'231'
['182', '184', '185', '231']
parsed_discourse_facet ['method_citation']
<S sid="136" ssid="40">That is, search efficiency for these parsers is improved by both statistical search heuristics and DP.</S><S sid="267" ssid="23">In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.</S><S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S><S sid="298" ssid="54">What is perhaps surprising is that the difference is not greater.</S>
original cit marker offset is 0
new cit marker offset is 0



["'136'", "'267'", "'282'", "'298'"]
'136'
'267'
'282'
'298'
['136', '267', '282', '298']
parsed_discourse_facet ['method_citation']
<S sid="282" ssid="38">Like the nonlexicalized parser in Roark and Johnson (1999), we found that the search efficiency, in terms of number of rule expansions considered or number of analyses advanced, also improved as we increased the amount of conditioning.</S><S sid="290" ssid="46">Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.</S><S sid="377" ssid="133">The point of this small experiment was to see if our parsing model could provide useful information even in the case that recognition errors occur, as opposed to the (generally) fully grammatical strings upon which the perplexity results were obtained.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'282'", "'290'", "'377'", "'402'"]
'282'
'290'
'377'
'402'
['282', '290', '377', '402']
parsed_discourse_facet ['results_citation']
<S sid="32" ssid="20">A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.</S><S sid="281" ssid="37">First, and least surprising, is that the accuracy of the parses improved as we conditioned on more and more information.</S><S sid="290" ssid="46">Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.</S><S sid="291" ssid="47">Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'281'", "'290'", "'291'"]
'32'
'281'
'290'
'291'
['32', '281', '290', '291']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="27">The top-down guidance that is provided makes this approach quite efficient in practice.</S><S sid="76" ssid="34">The leftfactorization transform that we use is identical to what is called right binarization in Roark and Johnson (1999).</S><S sid="96" ssid="54">This interpolation is recursively applied to the smaller-order n-grams until the bigram is finally interpolated with the unigram, i.e., Ao = 1.</S><S sid="378" ssid="134">As one reviewer pointed out, given that our model relies so heavily on context, it may have difficulty recovering from even one recognition error, perhaps more difficulty than a more locally oriented trigram.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'76'", "'96'", "'378'"]
'39'
'76'
'96'
'378'
['39', '76', '96', '378']
parsed_discourse_facet ['method_citation']
<S sid="101" ssid="5">As mentioned in Section 2.1, a PCFG defines a probability distribution over strings of words.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S><S sid="403" ssid="16">Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.</S>
original cit marker offset is 0
new cit marker offset is 0



["'101'", "'401'", "'402'", "'403'"]
'101'
'401'
'402'
'403'
['101', '401', '402', '403']
parsed_discourse_facet ['method_citation']
<S sid="235" ssid="139">The basic idea is that we want the beam to be very wide if there are few analyses that have been advanced, but relatively narrow if many analyses have been advanced.</S><S sid="239" ssid="143">After 1,000 candidates, the beam has narrowed to 10-2p.</S><S sid="267" ssid="23">In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.</S><S sid="349" ssid="105">One way to test this is the following: at each point in the sentence, calculate the conditional probability of each word in the vocabulary given the previous words, and sum them.\</S>
original cit marker offset is 0
new cit marker offset is 0



["'235'", "'239'", "'267'", "'349'"]
'235'
'239'
'267'
'349'
['235', '239', '267', '349']
parsed_discourse_facet ['method_citation', 'results_citation']
<S sid="142" ssid="46">A simple PCFG conditions rule probabilities on the left-hand side of the rule.</S><S sid="363" ssid="119">Splitting of the contractions is critical for parsing, since the two parts oftentimes (as in the previous example) fall in different constituents.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'142'", "'363'", "'401'", "'402'"]
'142'
'363'
'401'
'402'
['142', '363', '401', '402']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">A lexicalized probabilistic topdown parser is then presented, which performs very well, in terms of both the accuracy of returned parses and the efficiency with which they are found, relative to the best broad-coverage statistical parsers.</S><S sid="9" ssid="3">A lexicalized probabilistic topdown parser is then presented, which performs very well, in terms of both the accuracy of returned parses and the efficiency with which they are found, relative to the best broad-coverage statistical parsers.</S><S sid="142" ssid="46">A simple PCFG conditions rule probabilities on the left-hand side of the rule.</S><S sid="143" ssid="47">It has been shown repeatedly&#8212;e.g., Briscoe and Carroll (1993), Charniak (1997), Collins (1997), Inui et al. (1997), Johnson (1998)&#8212;that conditioning the probabilities of structures on the context within which they appear, for example on the lexical head of a constituent (Charniak 1997; Collins 1997), on the label of its parent nonterminal (Johnson 1998), or, ideally, on both and many other things besides, leads to a much better parsing model and results in higher parsing accuracies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'9'", "'142'", "'143'"]
'3'
'9'
'142'
'143'
['3', '9', '142', '143']
parsed_discourse_facet ['aim_citation']
<S sid="99" ssid="3">These can be divided into two rough groups: those that use the grammar as a language model, and those that use a parser to uncover phrasal heads standing in an important relation (c-command) to the current word.</S><S sid="322" ssid="78">Thus, Chelba and Jelinek (1998a, 1998b) also used a parser to help assign word probabilities, via the structured language model outlined in Section 3.2.</S><S sid="401" ssid="14">Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.</S><S sid="402" ssid="15">In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'99'", "'322'", "'401'", "'402'"]
'99'
'322'
'401'
'402'
['99', '322', '401', '402']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="9">First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.</S><S sid="268" ssid="24">This is an incremental parser with a pruning strategy and no backtracking.</S><S sid="309" ssid="65">Let Ht be the priority queue H, before any processing has begun with word w, in the look-ahead.</S><S sid="310" ssid="66">This is a subset of the possible leftmost partial derivations with respect to the prefix string W. Since RV is produced by expanding only analyses on priority queue H;\, the set of complete trees consistent with the partial derivations on priority queue Ht is a subset of the set of complete trees consistent with the partial derivations on priority queue HT\\, that is, the total probability mass represented by the priority queues is monotonically decreasing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'268'", "'309'", "'310'"]
'21'
'268'
'309'
'310'
['21', '268', '309', '310']
parsed_discourse_facet ['method_citation']
dict_values(['The small size of our training data, as well as the fact that we are rescoring n-best lists, rather than working directly on lattices, makes comparison with the other models not particularly informative.'])
dict_values(['In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.', 'While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.', 'Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).', 'The standard language model used in many speech recognition systems is the trigram model, i.e., a Markov model of order 2, which can be characterized by the following equation: To smooth the trigram models that are used in this paper, we interpolate the probability estimates of higher-order Markov models with lower-order Markov models (Jelinek and Mercer 1980).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5151', 'P:91', 'F:0']
dict_values(['The following section will provide some background in probabilistic context-free grammars and language modeling for speech recognition.', 'There will also be a brief review of previous work using syntactic information for language modeling, before we introduce our model in Section 4.', 'Three parse trees: (a) a complete parse tree; (b) a complete parse tree with an explicit stop symbol; and (c) a partial parse tree.'])
dict_values(['In the past few years, however, some improvements have been made over these language models through the use of statistical methods of natural language processing, and the development of innovative, linguistically well-motivated techniques for improving language models for speech recognition is generating more interest among computational linguists.', 'While language models built around shallow local dependencies are still the standard in state-of-the-art speech recognition systems, there is reason to hope that better language models can and will be developed by computational linguists for this task.', 'We will then present empirical results in two domains: one to compare with previous work in the parsing literature, and the other to compare with previous work using parsing for language modeling for speech recognition, in particular with the Chelba and Jelinek results mentioned above.', 'In addition, as mentioned above, we would like to further test our language model in speech recognition tasks, to see if the perplexity improvement that we have seen can lead to significant reductions in word error rate.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02017', '(95%-conf.int.', '0.02017', '-', '0.02017)']
['system', 'ROUGE-S*', 'Average_P:', '0.10635', '(95%-conf.int.', '0.10635', '-', '0.10635)']
['system', 'ROUGE-S*', 'Average_F:', '0.03392', '(95%-conf.int.', '0.03392', '-', '0.03392)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3321', 'P:630', 'F:67']
dict_values(['Since we do not know the POS for the word, we must sum the LAP for all POS For a PCFG G, a stack S = Ao An$ (which we will write AN and a look-ahead terminal item wi, we define the look-ahead probability as follows: We recursively estimate this with two empirically observed conditional probabilities for every nonterminal A,: 13(A, w,a) and P(A, c).'])
dict_values(['The functions that we have chosen for this paper follow from the intuition (and experience) that what helps parsing is different depending on the constituent that is being expanded.', 'If the POS is leftmost within its constituent, then very often the lexical item is sensitive to the governing category to which it is attaching.', 'For example, if the POS is a preposition, then its probability of expanding to a particular word is very different if it is attaching to a noun phrase than if it is attaching to a verb phrase, and perhaps quite different depending on the head of the constituent to which it is attaching.', 'Since we do not know the POS for the word, we must sum the LAP for all POS For a PCFG G, a stack S = Ao An$ (which we will write AN and a look-ahead terminal item wi, we define the look-ahead probability as follows: We recursively estimate this with two empirically observed conditional probabilities for every nonterminal A,: 13(A, w,a) and P(A, c).'])
['system', 'ROUGE-S*', 'Average_R:', '0.16131', '(95%-conf.int.', '0.16131', '-', '0.16131)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.27781', '(95%-conf.int.', '0.27781', '-', '0.27781)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:276', 'F:276']
dict_values(['Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.'])
dict_values(['A second key feature of our approach is that top-down guidance improves the efficiency of the search as more and more conditioning events are extracted from the derivation for use in the probabilistic model.', 'First, and least surprising, is that the accuracy of the parses improved as we conditioned on more and more information.', 'Of the 2,416 sentences in the section, 728 had the totally correct parse, 30.1 percent tree accuracy.', 'Also, the parser returns a set of candidate parses, from which we have been choosing the top ranked; if we use an oracle to choose the parse with the highest accuracy from among the candidates (which averaged 70.0 in number per sentence), we find an average labeled precision/recall of 94.1, for sentences of length &lt; 100.'])
['system', 'ROUGE-S*', 'Average_R:', '0.21577', '(95%-conf.int.', '0.21577', '-', '0.21577)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.35496', '(95%-conf.int.', '0.35496', '-', '0.35496)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:435', 'F:435']
dict_values(['In order to get a sense of whether these perplexity reduction results can translate to improvement in a speech recognition task, we performed a very small preliminary experiment on n-best lists.'])
dict_values(['The top-down guidance that is provided makes this approach quite efficient in practice.', 'The leftfactorization transform that we use is identical to what is called right binarization in Roark and Johnson (1999).', 'This interpolation is recursively applied to the smaller-order n-grams until the bigram is finally interpolated with the unigram, i.e., Ao = 1.', 'As one reviewer pointed out, given that our model relies so heavily on context, it may have difficulty recovering from even one recognition error, perhaps more difficulty than a more locally oriented trigram.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00122', '(95%-conf.int.', '0.00122', '-', '0.00122)']
['system', 'ROUGE-S*', 'Average_P:', '0.00952', '(95%-conf.int.', '0.00952', '-', '0.00952)']
['system', 'ROUGE-S*', 'Average_F:', '0.00216', '(95%-conf.int.', '0.00216', '-', '0.00216)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:105', 'F:1']
dict_values(['A PCFG is a CFG with a probability assigned to each rule; specifically, each righthand side has a probability given the left-hand side of the rule.'])
dict_values(['As mentioned in Section 2.1, a PCFG defines a probability distribution over strings of words.', 'Earley and left-corner parsers, as mentioned in the introduction, also have rooted derivations that can be used to calculated generative string prefix probabilities incrementally.', 'In fact, left-corner parsing can be simulated by a top-down parser by transforming the grammar, as was done in Roark and Johnson (1999), and so an approach very similar to the one outlined here could be used in that case.', 'Perhaps some compromise between the fully connected structures and extreme underspecification will yield an efficiency improvement.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00510', '(95%-conf.int.', '0.00510', '-', '0.00510)']
['system', 'ROUGE-S*', 'Average_P:', '0.07692', '(95%-conf.int.', '0.07692', '-', '0.07692)']
['system', 'ROUGE-S*', 'Average_F:', '0.00957', '(95%-conf.int.', '0.00957', '-', '0.00957)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:78', 'F:6']
dict_values(['The approach that we will subsequently present uses the probabilistic grammar as its language model, but only includes probability mass from those parses that are found, that is, it uses the parser to find a subset of the total set of parses (hopefully most of the high-probability parses) and uses the sum of their probabilities as an estimate of the true probability given the grammar.'])
dict_values(['The basic idea is that we want the beam to be very wide if there are few analyses that have been advanced, but relatively narrow if many analyses have been advanced.', 'After 1,000 candidates, the beam has narrowed to 10-2p.', 'In addition, we show the average number of rule expansions considered per word, that is, the number of rule expansions for which a probability was calculated (see Roark and Charniak 2000), and the average number of analyses advanced to the next priority queue per word.', 'One way to test this is the following: at each point in the sentence, calculate the conditional probability of each word in the vocabulary given the previous words, and sum them.\\'])
['system', 'ROUGE-S*', 'Average_R:', '0.00245', '(95%-conf.int.', '0.00245', '-', '0.00245)']
['system', 'ROUGE-S*', 'Average_P:', '0.00855', '(95%-conf.int.', '0.00855', '-', '0.00855)']
['system', 'ROUGE-S*', 'Average_F:', '0.00381', '(95%-conf.int.', '0.00381', '-', '0.00381)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:351', 'F:3']
dict_values(['Thus, our top-down parser allows for the incremental calculation of generative conditional word probabilities, a property it shares with other left-to-right parsers with rooted derivations such as Earley parsers (Earley 1970) or left-corner parsers (Rosenkrantz and Lewis 11 1970).'])
dict_values(['First, the top-down parsing algorithm builds a set of rooted candidate parse trees from left to right over the string, which allows it to calculate a generative probability for each prefix string from the probabilistic grammar, and hence a conditional probability for each word given the previous words and the probabilistic grammar.', 'This is an incremental parser with a pruning strategy and no backtracking.', 'Let Ht be the priority queue H, before any processing has begun with word w, in the look-ahead.', 'This is a subset of the possible leftmost partial derivations with respect to the prefix string W. Since RV is produced by expanding only analyses on priority queue H;\\, the set of complete trees consistent with the partial derivations on priority queue Ht is a subset of the set of complete trees consistent with the partial derivations on priority queue HT\\\\, that is, the total probability mass represented by the priority queues is monotonically decreasing.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01499', '(95%-conf.int.', '0.01499', '-', '0.01499)']
['system', 'ROUGE-S*', 'Average_P:', '0.15000', '(95%-conf.int.', '0.15000', '-', '0.15000)']
['system', 'ROUGE-S*', 'Average_F:', '0.02725', '(95%-conf.int.', '0.02725', '-', '0.02725)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:300', 'F:45']
0.2939174963260313 0.05262624934217189 0.08868499889143752





input/ref/Task1/P04-1036_aakansha.csv
input/res/Task1/P04-1036.annv3.csv
parsing: input/ref/Task1/P04-1036_aakansha.csv
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'"]
'15'
['15']
parsed_discourse_facet ['method_citation']
<S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'"]
'41'
['41']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="4">We present work on the use of a thesaurus acquired from raw textual corpora and the WordNet similarity package to find predominant noun senses automatically.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'"]
'4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'"]
'15'
['15']
parsed_discourse_facet ['method_citation']
<S sid="180" ssid="3">The automatically acquired predominant senses were evaluated against the hand-tagged resources SemCor and the SENSEVAL-2 English all-words task giving us a WSD precision of 64% on an all-nouns task.</S>
    <S sid="181" ssid="4">This is just 5% lower than results using the first sense in the manually labelled SemCor, and we obtain 67% precision on polysemous nouns that are not in SemCor.</S>
original cit marker offset is 0
new cit marker offset is 0



["'180'", "'181'"]
'180'
'181'
['180', '181']
parsed_discourse_facet ['result_citation']
<S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'"]
'126'
['126']
parsed_discourse_facet ['method_citation']
<S sid="48" ssid="4">To find the first sense of a word ( ) we take each sense in turn and obtain a score reflecting the prevalence which is used for ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'"]
'48'
['48']
parsed_discourse_facet ['method_citation']
<S sid="169" ssid="17">This method obtains precision of 61% and recall 51%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'169'"]
'169'
['169']
parsed_discourse_facet ['result_citation']
<S sid="171" ssid="19">In contrast, we use the neighbours lists and WordNet similarity measures to impose a prevalence ranking on the WordNet senses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'171'"]
'171'
['171']
parsed_discourse_facet ['method_citation']
<S sid="171" ssid="19">In contrast, we use the neighbours lists and WordNet similarity measures to impose a prevalence ranking on the WordNet senses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'171'"]
'171'
['171']
parsed_discourse_facet ['method_citation']
<S sid="115" ssid="13">Our automatically acquired predominant sense performs nearly as well as the first sense provided by SemCor, which is very encouraging given that our method only uses raw text, with no manual labelling.</S>
original cit marker offset is 0
new cit marker offset is 0



["'115'"]
'115'
['115']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'"]
'126'
['126']
parsed_discourse_facet ['method_citation']
<S sid="180" ssid="3">The automatically acquired predominant senses were evaluated against the hand-tagged resources SemCor and the SENSEVAL-2 English all-words task giving us a WSD precision of 64% on an all-nouns task.</S>
    <S sid="181" ssid="4">This is just 5% lower than results using the first sense in the manually labelled SemCor, and we obtain 67% precision on polysemous nouns that are not in SemCor.</S>
original cit marker offset is 0
new cit marker offset is 0



["'180'", "'181'"]
'180'
'181'
['180', '181']
parsed_discourse_facet ['result_citation']
<S sid="180" ssid="3">The automatically acquired predominant senses were evaluated against the hand-tagged resources SemCor and the SENSEVAL-2 English all-words task giving us a WSD precision of 64% on an all-nouns task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'180'"]
'180'
['180']
parsed_discourse_facet ['method_citation']
<S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'"]
'41'
['41']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P04-1036.annv3.csv
<S sid="2" ssid="2">The problem with using the predominant, or first sense heuristic, aside from the fact that it does not take surrounding context into account, is that it assumes some quantity of handtagged data.</S><S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="14" ssid="7">Even systems which show superior performance to this heuristic often make use of the heuristic where evidence from the context is not sufficient (Hoste et al., 2001).</S><S sid="23" ssid="16">The first sense of star in SemCor is celestial body, however, if one were disambiguating popular news celebrity would be preferred.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'8'", "'14'", "'23'"]
'2'
'8'
'14'
'23'
['2', '8', '14', '23']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S><S sid="21" ssid="14">We believe that an automatic means of finding a predominant sense would be useful for systems that use it as a means of backing-off (Wilks and Stevenson, 1998; Hoste et al., 2001) and for systems that use it in lexical acquisition (McCarthy, 1997; Merlo and Leybold, 2001; Korhonen, 2002) because of the limited size of hand-tagged resources.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'15'", "'21'", "'175'"]
'9'
'15'
'21'
'175'
['9', '15', '21', '175']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="32" ssid="25">We describe some related work in section 6 and conclude in section 7. are therefore investigating a method of automatically ranking WordNet senses from raw text.</S><S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="49" ssid="5">Let be the ordered set of the top scoring neighbours of from the thesaurus with associated distributional similarity scores The thesaurus was acquired using the method described by Lin (1998).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'41'", "'49'", "'175'"]
'32'
'41'
'49'
'175'
['32', '41', '49', '175']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="4" ssid="4">We present work on the use of a thesaurus acquired from raw textual corpora and the WordNet similarity package to find predominant noun senses automatically.</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="178" ssid="1">We have devised a method that uses raw corpus data to automatically find a predominant sense for nouns in WordNet.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'46'", "'166'", "'178'"]
'4'
'46'
'166'
'178'
['4', '46', '166', '178']
parsed_discourse_facet ['aim_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'47'", "'166'", "'175'"]
'0'
'47'
'166'
'175'
['0', '47', '166', '175']
parsed_discourse_facet ['results_citation']
<S sid="111" ssid="9">We give the results for this WSD task in table 2.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="167" ssid="15">In this work the lists of neighbours are themselves clustered to bring out the various senses of the word.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'111'", "'165'", "'167'", "'175'"]
'111'
'165'
'167'
'175'
['111', '165', '167', '175']
parsed_discourse_facet ['results_citation']
<S sid="3" ssid="3">Whilst there are a few hand-tagged corpora available for some languages, one would expect the frequency distribution of the senses of words, particularly topical words, to depend on the genre and domain of the text under consideration.</S><S sid="152" ssid="29">We see that both domains have a similarly high percentage of factotum (domain independent) labels, but as we would expect, the other peaks correspond to the economy label for the FINANCE corpus, and the sports label for the SPORTS corpus. inant senses for 38 polysemous words ranked using the SPORTS and FINANCE corpus.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'152'", "'165'", "'175'"]
'3'
'152'
'165'
'175'
['3', '152', '165', '175']
parsed_discourse_facet ['results_citation']
<S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'", "'47'", "'174'", "'176'"]
'41'
'47'
'174'
'176'
['41', '47', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="20">We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).</S><S sid="66" ssid="22">It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.</S><S sid="83" ssid="12">The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.</S><S sid="84" ssid="13">The random baseline for choosing the predominant sense over all these words ( ) is 32%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'66'", "'83'", "'84'"]
'64'
'66'
'83'
'84'
['64', '66', '83', '84']
parsed_discourse_facet ['results_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'174'", "'175'", "'176'"]
'9'
'174'
'175'
'176'
['9', '174', '175', '176']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="27" ssid="20">We use WordNet as our sense inventory for this work.</S><S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="164" ssid="12">They used syntactic evidence to find a prior distribution for verb classes, based on (Levin, 1993), and incorporate this in a WSD system.</S><S sid="189" ssid="12">Additionally, we need to determine whether senses which do not occur in a wide variety of grammatical contexts fare badly using distributional measures of similarity, and what can be done to combat this problem using relation specific thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'104'", "'164'", "'189'"]
'27'
'104'
'164'
'189'
['27', '104', '164', '189']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="133" ssid="10">We acquired thesauruses for these corpora using the procedure described in section 2.1.</S><S sid="158" ssid="6">We have evaluated our method using publically available resources, both for balanced and domain specific text.</S><S sid="168" ssid="16">They evaluate using the lin measure described above in section 2.2 to determine the precision and recall of these discovered classes with respect to WordNet synsets.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'158'", "'168'", "'175'"]
'133'
'158'
'168'
'175'
['133', '158', '168', '175']
parsed_discourse_facet ['results_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="160" ssid="8">Identification of these domain labels for word senses was semiautomatic and required a considerable amount of hand-labelling.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'46'", "'160'", "'176'"]
'0'
'46'
'160'
'176'
['0', '46', '160', '176']
parsed_discourse_facet ['hypothesis_citation']
<S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="154" ssid="2">In contrast, our work is aimed at discovering the predominant senses from raw text because the first sense heuristic is such a useful one, and because handtagged data is not always available.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'", "'154'", "'174'", "'175'"]
'104'
'154'
'174'
'175'
['104', '154', '174', '175']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.</S><S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="81" ssid="10">4 We calculate the accuracy of finding the predominant sense, when there is indeed one sense with a higher frequency than the others for this word in SemCor ( ).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'81'", "'175'"]
'1'
'9'
'81'
'175'
['1', '9', '81', '175']
parsed_discourse_facet ['results_citation']
<S sid="6" ssid="6">This is a very promising result given that our method does not require any hand-tagged text, such as SemCor.</S><S sid="7" ssid="7">Furthermore, we demonstrate that our method discovers appropriate predominant senses for words from two domainspecific corpora.</S><S sid="79" ssid="8">3 The experimental results reported here are obtained using IC counts from the BNC corpus.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'7'", "'79'", "'175'"]
'6'
'7'
'79'
'175'
['6', '7', '79', '175']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S><S sid="25" ssid="18">However, the most accurate WSD systems are those which require manually sense tagged data in the first place, and their accuracy depends on the quantity of training examples (Yarowsky and Florian, 2002) available.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'13'", "'25'", "'175'"]
'8'
'13'
'25'
'175'
['8', '13', '25', '175']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.'])
dict_values(['We describe some related work in section 6 and conclude in section 7. are therefore investigating a method of automatically ranking WordNet senses from raw text.', 'In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.', 'Let be the ordered set of the top scoring neighbours of from the thesaurus with associated distributional similarity scores The thesaurus was acquired using the method described by Lin (1998).', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05553', '(95%-conf.int.', '0.05553', '-', '0.05553)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10521', '(95%-conf.int.', '0.10521', '-', '0.10521)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:105', 'F:105']
dict_values(['The automatically acquired predominant senses were evaluated against the hand-tagged resources SemCor and the SENSEVAL-2 English all-words task giving us a WSD precision of 64% on an all-nouns task.', 'This is just 5% lower than results using the first sense in the manually labelled SemCor, and we obtain 67% precision on polysemous nouns that are not in SemCor.'])
dict_values(['We give the results for this WSD task in table 2.', 'Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.', 'In this work the lists of neighbours are themselves clustered to bring out the various senses of the word.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01582', '(95%-conf.int.', '0.01582', '-', '0.01582)']
['system', 'ROUGE-S*', 'Average_P:', '0.04991', '(95%-conf.int.', '0.04991', '-', '0.04991)']
['system', 'ROUGE-S*', 'Average_F:', '0.02402', '(95%-conf.int.', '0.02402', '-', '0.02402)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:561', 'F:28']
dict_values(['To find the first sense of a word ( ) we take each sense in turn and obtain a score reflecting the prevalence which is used for ranking.'])
dict_values(['In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.', 'We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.', 'We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.', 'The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00627', '(95%-conf.int.', '0.00627', '-', '0.00627)']
['system', 'ROUGE-S*', 'Average_P:', '0.14545', '(95%-conf.int.', '0.14545', '-', '0.14545)']
['system', 'ROUGE-S*', 'Average_F:', '0.01203', '(95%-conf.int.', '0.01203', '-', '0.01203)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1275', 'P:55', 'F:8']
dict_values(['This method obtains precision of 61% and recall 51%.'])
dict_values(['We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).', 'It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.', 'The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.', 'The random baseline for choosing the predominant sense over all these words ( ) is 32%.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:15', 'F:0']
dict_values(['Our automatically acquired predominant sense performs nearly as well as the first sense provided by SemCor, which is very encouraging given that our method only uses raw text, with no manual labelling.'])
dict_values(['We acquired thesauruses for these corpora using the procedure described in section 2.1.', 'We have evaluated our method using publically available resources, both for balanced and domain specific text.', 'They evaluate using the lin measure described above in section 2.2 to determine the precision and recall of these discovered classes with respect to WordNet synsets.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01159', '(95%-conf.int.', '0.01159', '-', '0.01159)']
['system', 'ROUGE-S*', 'Average_P:', '0.11429', '(95%-conf.int.', '0.11429', '-', '0.11429)']
['system', 'ROUGE-S*', 'Average_F:', '0.02105', '(95%-conf.int.', '0.02105', '-', '0.02105)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:105', 'F:12']
dict_values(['The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.'])
dict_values(['Finding Predominant Word Senses in Untagged Text', 'This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.', 'Identification of these domain labels for word senses was semiautomatic and required a considerable amount of hand-labelling.', 'The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:630', 'P:66', 'F:0']
dict_values(['We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.'])
dict_values(['7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.', 'In contrast, our work is aimed at discovering the predominant senses from raw text because the first sense heuristic is such a useful one, and because handtagged data is not always available.', 'We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00490', '(95%-conf.int.', '0.00490', '-', '0.00490)']
['system', 'ROUGE-S*', 'Average_P:', '0.21429', '(95%-conf.int.', '0.21429', '-', '0.21429)']
['system', 'ROUGE-S*', 'Average_F:', '0.00958', '(95%-conf.int.', '0.00958', '-', '0.00958)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:28', 'F:6']
dict_values(['The automatically acquired predominant senses were evaluated against the hand-tagged resources SemCor and the SENSEVAL-2 English all-words task giving us a WSD precision of 64% on an all-nouns task.', 'This is just 5% lower than results using the first sense in the manually labelled SemCor, and we obtain 67% precision on polysemous nouns that are not in SemCor.'])
dict_values(['word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.', 'This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).', '4 We calculate the accuracy of finding the predominant sense, when there is indeed one sense with a higher frequency than the others for this word in SemCor ( ).', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02765', '(95%-conf.int.', '0.02765', '-', '0.02765)']
['system', 'ROUGE-S*', 'Average_P:', '0.09626', '(95%-conf.int.', '0.09626', '-', '0.09626)']
['system', 'ROUGE-S*', 'Average_F:', '0.04296', '(95%-conf.int.', '0.04296', '-', '0.04296)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:561', 'F:54']
dict_values(['The automatically acquired predominant senses were evaluated against the hand-tagged resources SemCor and the SENSEVAL-2 English all-words task giving us a WSD precision of 64% on an all-nouns task.'])
dict_values(['This is a very promising result given that our method does not require any hand-tagged text, such as SemCor.', 'Furthermore, we demonstrate that our method discovers appropriate predominant senses for words from two domainspecific corpora.', '3 The experimental results reported here are obtained using IC counts from the BNC corpus.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01626', '(95%-conf.int.', '0.01626', '-', '0.01626)']
['system', 'ROUGE-S*', 'Average_P:', '0.07368', '(95%-conf.int.', '0.07368', '-', '0.07368)']
['system', 'ROUGE-S*', 'Average_F:', '0.02664', '(95%-conf.int.', '0.02664', '-', '0.02664)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:190', 'F:14']
dict_values(['In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.'])
dict_values(['The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.', 'The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.', 'However, the most accurate WSD systems are those which require manually sense tagged data in the first place, and their accuracy depends on the quantity of training examples (Yarowsky and Florian, 2002) available.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00242', '(95%-conf.int.', '0.00242', '-', '0.00242)']
['system', 'ROUGE-S*', 'Average_P:', '0.03810', '(95%-conf.int.', '0.03810', '-', '0.03810)']
['system', 'ROUGE-S*', 'Average_F:', '0.00455', '(95%-conf.int.', '0.00455', '-', '0.00455)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:105', 'F:4']
0.17319799826802004 0.014043999859560003 0.024603999753960003





input/ref/Task1/P04-1036_swastika.csv
input/res/Task1/P04-1036.annv3.csv
parsing: input/ref/Task1/P04-1036_swastika.csv
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



['8']
8
['8']
parsed_discourse_facet ['result_citation']
<S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S>
original cit marker offset is 0
new cit marker offset is 0



['15']
15
['15']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="24">We are of course able to apply the method to other versions of WordNet. synset, is incremented with the frequency counts from the corpus of all words belonging to that synset, directly or via the hyponymy relation.</S>
original cit marker offset is 0
new cit marker offset is 0



['68']
68
['68']
parsed_discourse_facet ['result_citation']
<S sid="83" ssid="12">The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.</S>
original cit marker offset is 0
new cit marker offset is 0



['83']
83
['83']
parsed_discourse_facet ['result_citation']
<S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S>
original cit marker offset is 0
new cit marker offset is 0



['15']
15
['15']
parsed_discourse_facet ['result_citation']
<S sid="101" ssid="30">Thus, if we used the sense ranking as a heuristic for an &#8220;all nouns&#8221; task we would expect to get precision in the region of 60%.</S>
original cit marker offset is 0
new cit marker offset is 0



['101']
101
['101']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



['126']
126
['126']
parsed_discourse_facet ['result_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



['8']
8
['8']
parsed_discourse_facet ['result_citation']
<S sid="83" ssid="12">The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.</S>
original cit marker offset is 0
new cit marker offset is 0



['83']
83
['83']
parsed_discourse_facet ['result_citation']
<S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



['126']
126
['126']
parsed_discourse_facet ['result_citation']
<S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S>
original cit marker offset is 0
new cit marker offset is 0



['46']
46
['46']
parsed_discourse_facet ['result_citation']
<S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



['126']
126
['126']
parsed_discourse_facet ['result_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



['8']
8
['8']
parsed_discourse_facet ['result_citation']
<S sid="105" ssid="3">We use an allwords task because the predominant senses will reflect the sense distributions of all nouns within the documents, rather than a lexical sample task, where the target words are manually determined and the results will depend on the skew of the words in the sample.</S>
original cit marker offset is 0
new cit marker offset is 0



['105']
105
['105']
parsed_discourse_facet ['result_citation']
<S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S>
original cit marker offset is 0
new cit marker offset is 0



['13']
13
['13']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S>
original cit marker offset is 0
new cit marker offset is 0



['13']
13
['13']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



['8']
8
['8']
parsed_discourse_facet ['result_citation']
parsing: input/res/Task1/P04-1036.annv3.csv
<S sid="2" ssid="2">The problem with using the predominant, or first sense heuristic, aside from the fact that it does not take surrounding context into account, is that it assumes some quantity of handtagged data.</S><S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="14" ssid="7">Even systems which show superior performance to this heuristic often make use of the heuristic where evidence from the context is not sufficient (Hoste et al., 2001).</S><S sid="23" ssid="16">The first sense of star in SemCor is celestial body, however, if one were disambiguating popular news celebrity would be preferred.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'8'", "'14'", "'23'"]
'2'
'8'
'14'
'23'
['2', '8', '14', '23']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S><S sid="21" ssid="14">We believe that an automatic means of finding a predominant sense would be useful for systems that use it as a means of backing-off (Wilks and Stevenson, 1998; Hoste et al., 2001) and for systems that use it in lexical acquisition (McCarthy, 1997; Merlo and Leybold, 2001; Korhonen, 2002) because of the limited size of hand-tagged resources.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'15'", "'21'", "'175'"]
'9'
'15'
'21'
'175'
['9', '15', '21', '175']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="32" ssid="25">We describe some related work in section 6 and conclude in section 7. are therefore investigating a method of automatically ranking WordNet senses from raw text.</S><S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="49" ssid="5">Let be the ordered set of the top scoring neighbours of from the thesaurus with associated distributional similarity scores The thesaurus was acquired using the method described by Lin (1998).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'41'", "'49'", "'175'"]
'32'
'41'
'49'
'175'
['32', '41', '49', '175']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="4" ssid="4">We present work on the use of a thesaurus acquired from raw textual corpora and the WordNet similarity package to find predominant noun senses automatically.</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="178" ssid="1">We have devised a method that uses raw corpus data to automatically find a predominant sense for nouns in WordNet.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'46'", "'166'", "'178'"]
'4'
'46'
'166'
'178'
['4', '46', '166', '178']
parsed_discourse_facet ['aim_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'47'", "'166'", "'175'"]
'0'
'47'
'166'
'175'
['0', '47', '166', '175']
parsed_discourse_facet ['results_citation']
<S sid="111" ssid="9">We give the results for this WSD task in table 2.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="167" ssid="15">In this work the lists of neighbours are themselves clustered to bring out the various senses of the word.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'111'", "'165'", "'167'", "'175'"]
'111'
'165'
'167'
'175'
['111', '165', '167', '175']
parsed_discourse_facet ['results_citation']
<S sid="3" ssid="3">Whilst there are a few hand-tagged corpora available for some languages, one would expect the frequency distribution of the senses of words, particularly topical words, to depend on the genre and domain of the text under consideration.</S><S sid="152" ssid="29">We see that both domains have a similarly high percentage of factotum (domain independent) labels, but as we would expect, the other peaks correspond to the economy label for the FINANCE corpus, and the sports label for the SPORTS corpus. inant senses for 38 polysemous words ranked using the SPORTS and FINANCE corpus.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'152'", "'165'", "'175'"]
'3'
'152'
'165'
'175'
['3', '152', '165', '175']
parsed_discourse_facet ['results_citation']
<S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'", "'47'", "'174'", "'176'"]
'41'
'47'
'174'
'176'
['41', '47', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="20">We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).</S><S sid="66" ssid="22">It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.</S><S sid="83" ssid="12">The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.</S><S sid="84" ssid="13">The random baseline for choosing the predominant sense over all these words ( ) is 32%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'66'", "'83'", "'84'"]
'64'
'66'
'83'
'84'
['64', '66', '83', '84']
parsed_discourse_facet ['results_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'174'", "'175'", "'176'"]
'9'
'174'
'175'
'176'
['9', '174', '175', '176']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="27" ssid="20">We use WordNet as our sense inventory for this work.</S><S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="164" ssid="12">They used syntactic evidence to find a prior distribution for verb classes, based on (Levin, 1993), and incorporate this in a WSD system.</S><S sid="189" ssid="12">Additionally, we need to determine whether senses which do not occur in a wide variety of grammatical contexts fare badly using distributional measures of similarity, and what can be done to combat this problem using relation specific thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'104'", "'164'", "'189'"]
'27'
'104'
'164'
'189'
['27', '104', '164', '189']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="133" ssid="10">We acquired thesauruses for these corpora using the procedure described in section 2.1.</S><S sid="158" ssid="6">We have evaluated our method using publically available resources, both for balanced and domain specific text.</S><S sid="168" ssid="16">They evaluate using the lin measure described above in section 2.2 to determine the precision and recall of these discovered classes with respect to WordNet synsets.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'158'", "'168'", "'175'"]
'133'
'158'
'168'
'175'
['133', '158', '168', '175']
parsed_discourse_facet ['results_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="160" ssid="8">Identification of these domain labels for word senses was semiautomatic and required a considerable amount of hand-labelling.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'46'", "'160'", "'176'"]
'0'
'46'
'160'
'176'
['0', '46', '160', '176']
parsed_discourse_facet ['hypothesis_citation']
<S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="154" ssid="2">In contrast, our work is aimed at discovering the predominant senses from raw text because the first sense heuristic is such a useful one, and because handtagged data is not always available.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'", "'154'", "'174'", "'175'"]
'104'
'154'
'174'
'175'
['104', '154', '174', '175']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.</S><S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="81" ssid="10">4 We calculate the accuracy of finding the predominant sense, when there is indeed one sense with a higher frequency than the others for this word in SemCor ( ).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'81'", "'175'"]
'1'
'9'
'81'
'175'
['1', '9', '81', '175']
parsed_discourse_facet ['results_citation']
<S sid="6" ssid="6">This is a very promising result given that our method does not require any hand-tagged text, such as SemCor.</S><S sid="7" ssid="7">Furthermore, we demonstrate that our method discovers appropriate predominant senses for words from two domainspecific corpora.</S><S sid="79" ssid="8">3 The experimental results reported here are obtained using IC counts from the BNC corpus.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'7'", "'79'", "'175'"]
'6'
'7'
'79'
'175'
['6', '7', '79', '175']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S><S sid="25" ssid="18">However, the most accurate WSD systems are those which require manually sense tagged data in the first place, and their accuracy depends on the quantity of training examples (Yarowsky and Florian, 2002) available.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'13'", "'25'", "'175'"]
'8'
'13'
'25'
'175'
['8', '13', '25', '175']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['We are of course able to apply the method to other versions of WordNet. synset, is incremented with the frequency counts from the corpus of all words belonging to that synset, directly or via the hyponymy relation.'])
dict_values(['We describe some related work in section 6 and conclude in section 7. are therefore investigating a method of automatically ranking WordNet senses from raw text.', 'In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.', 'Let be the ordered set of the top scoring neighbours of from the thesaurus with associated distributional similarity scores The thesaurus was acquired using the method described by Lin (1998).', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00159', '(95%-conf.int.', '0.00159', '-', '0.00159)']
['system', 'ROUGE-S*', 'Average_P:', '0.02857', '(95%-conf.int.', '0.02857', '-', '0.02857)']
['system', 'ROUGE-S*', 'Average_F:', '0.00301', '(95%-conf.int.', '0.00301', '-', '0.00301)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:105', 'F:3']
dict_values(['Thus, if we used the sense ranking as a heuristic for an &#8220;all nouns&#8221; task we would expect to get precision in the region of 60%.'])
dict_values(['We give the results for this WSD task in table 2.', 'Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.', 'In this work the lists of neighbours are themselves clustered to bring out the various senses of the word.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00169', '(95%-conf.int.', '0.00169', '-', '0.00169)']
['system', 'ROUGE-S*', 'Average_P:', '0.05455', '(95%-conf.int.', '0.05455', '-', '0.05455)']
['system', 'ROUGE-S*', 'Average_F:', '0.00329', '(95%-conf.int.', '0.00329', '-', '0.00329)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:55', 'F:3']
dict_values(['The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.'])
dict_values(['In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.', 'We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.', 'We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.', 'The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1275', 'P:66', 'F:0']
dict_values(['The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.'])
dict_values(['We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).', 'It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.', 'The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.', 'The random baseline for choosing the predominant sense over all these words ( ) is 32%.'])
['system', 'ROUGE-S*', 'Average_R:', '0.12409', '(95%-conf.int.', '0.12409', '-', '0.12409)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.22079', '(95%-conf.int.', '0.22079', '-', '0.22079)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:171', 'F:171']
dict_values(['We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.'])
dict_values(['We acquired thesauruses for these corpora using the procedure described in section 2.1.', 'We have evaluated our method using publically available resources, both for balanced and domain specific text.', 'They evaluate using the lin measure described above in section 2.2 to determine the precision and recall of these discovered classes with respect to WordNet synsets.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00580', '(95%-conf.int.', '0.00580', '-', '0.00580)']
['system', 'ROUGE-S*', 'Average_P:', '0.21429', '(95%-conf.int.', '0.21429', '-', '0.21429)']
['system', 'ROUGE-S*', 'Average_F:', '0.01129', '(95%-conf.int.', '0.01129', '-', '0.01129)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:28', 'F:6']
dict_values(['The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.'])
dict_values(['Finding Predominant Word Senses in Untagged Text', 'This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.', 'Identification of these domain labels for word senses was semiautomatic and required a considerable amount of hand-labelling.', 'The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:630', 'P:66', 'F:0']
dict_values(['We use an allwords task because the predominant senses will reflect the sense distributions of all nouns within the documents, rather than a lexical sample task, where the target words are manually determined and the results will depend on the skew of the words in the sample.'])
dict_values(['7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.', 'In contrast, our work is aimed at discovering the predominant senses from raw text because the first sense heuristic is such a useful one, and because handtagged data is not always available.', 'We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00490', '(95%-conf.int.', '0.00490', '-', '0.00490)']
['system', 'ROUGE-S*', 'Average_P:', '0.02857', '(95%-conf.int.', '0.02857', '-', '0.02857)']
['system', 'ROUGE-S*', 'Average_F:', '0.00836', '(95%-conf.int.', '0.00836', '-', '0.00836)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:210', 'F:6']
dict_values(['The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.'])
dict_values(['word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.', 'This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).', '4 We calculate the accuracy of finding the predominant sense, when there is indeed one sense with a higher frequency than the others for this word in SemCor ( ).', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00973', '(95%-conf.int.', '0.00973', '-', '0.00973)']
['system', 'ROUGE-S*', 'Average_P:', '0.34545', '(95%-conf.int.', '0.34545', '-', '0.34545)']
['system', 'ROUGE-S*', 'Average_F:', '0.01892', '(95%-conf.int.', '0.01892', '-', '0.01892)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:55', 'F:19']
dict_values(['The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.'])
dict_values(['This is a very promising result given that our method does not require any hand-tagged text, such as SemCor.', 'Furthermore, we demonstrate that our method discovers appropriate predominant senses for words from two domainspecific corpora.', '3 The experimental results reported here are obtained using IC counts from the BNC corpus.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00697', '(95%-conf.int.', '0.00697', '-', '0.00697)']
['system', 'ROUGE-S*', 'Average_P:', '0.10909', '(95%-conf.int.', '0.10909', '-', '0.10909)']
['system', 'ROUGE-S*', 'Average_F:', '0.01310', '(95%-conf.int.', '0.01310', '-', '0.01310)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:55', 'F:6']
dict_values(['The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.'])
dict_values(['The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.', 'The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.', 'However, the most accurate WSD systems are those which require manually sense tagged data in the first place, and their accuracy depends on the quantity of training examples (Yarowsky and Florian, 2002) available.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03993', '(95%-conf.int.', '0.03993', '-', '0.03993)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.07679', '(95%-conf.int.', '0.07679', '-', '0.07679)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:66', 'F:66']
0.27805199721948004 0.019469999805300002 0.03555499964445001





input/ref/Task1/P04-1036_sweta.csv
input/res/Task1/P04-1036.annv3.csv
parsing: input/ref/Task1/P04-1036_sweta.csv
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



["8'"]
8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="82" ssid="11">We also calculate the WSD accuracy that would be obtained on SemCor, when using our first sense in all contexts ( ).</S>
original cit marker offset is 0
new cit marker offset is 0



["82'"]
82'
['82']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="20">We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).</S>
original cit marker offset is 0
new cit marker offset is 0



["64'"]
64'
['64']
parsed_discourse_facet ['method_citation']
<S sid="172" ssid="20">We believe automatic ranking techniques such as ours will be useful for systems that rely on WordNet, for example those that use it for lexical acquisition or WSD.</S>
original cit marker offset is 0
new cit marker offset is 0



["172'"]
172'
['172']
parsed_discourse_facet ['method_citation']
<S sid="153" ssid="1">Most research in WSD concentrates on using contextual features, typically neighbouring words, to help determine the correct sense of a target word.</S>
original cit marker offset is 0
new cit marker offset is 0



["153'"]
153'
['153']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.</S>
original cit marker offset is 0
new cit marker offset is 0



["1'"]
1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S>
original cit marker offset is 0
new cit marker offset is 0



["165'"]
165'
['165']
parsed_discourse_facet ['method_citation']
<S sid="171" ssid="19">In contrast, we use the neighbours lists and WordNet similarity measures to impose a prevalence ranking on the WordNet senses.</S>
original cit marker offset is 0
new cit marker offset is 0



["171'"]
171'
['171']
parsed_discourse_facet ['method_citation']
<S sid="89" ssid="18">Since both measures gave comparable results we restricted our remaining experiments to jcn because this gave good results for finding the predominant sense, and is much more efficient than lesk, given the precompilation of the IC files.</S>
original cit marker offset is 0
new cit marker offset is 0



["89'"]
89'
['89']
parsed_discourse_facet ['method_citation']
<S sid="172" ssid="20">We believe automatic ranking techniques such as ours will be useful for systems that rely on WordNet, for example those that use it for lexical acquisition or WSD.</S>
original cit marker offset is 0
new cit marker offset is 0



["172'"]
172'
['172']
parsed_discourse_facet ['method_citation']
<S sid="189" ssid="12">Additionally, we need to determine whether senses which do not occur in a wide variety of grammatical contexts fare badly using distributional measures of similarity, and what can be done to combat this problem using relation specific thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["189'"]
189'
['189']
parsed_discourse_facet ['method_citation']
<S sid="87" ssid="16">Again, the automatic ranking outperforms this by a large margin.</S>
original cit marker offset is 0
new cit marker offset is 0



["87'"]
87'
['87']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.</S>
original cit marker offset is 0
new cit marker offset is 0



["1'"]
1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="89" ssid="18">Since both measures gave comparable results we restricted our remaining experiments to jcn because this gave good results for finding the predominant sense, and is much more efficient than lesk, given the precompilation of the IC files.</S>
original cit marker offset is 0
new cit marker offset is 0



["89'"]
89'
['89']
parsed_discourse_facet ['method_citation']
 <S sid="137" ssid="14">Additionally, we evaluated our method quantitatively using the Subject Field Codes (SFC) resource (Magnini and Cavagli`a, 2000) which annotates WordNet synsets with domain labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["137'"]
137'
['137']
parsed_discourse_facet ['method_citation']
<S sid="63" ssid="19">We experimented using six of these to provide the in equation 1 above and obtained results well over our baseline, but because of space limitations give results for the two which perform the best.</S>
original cit marker offset is 0
new cit marker offset is 0



["63'"]
63'
['63']
parsed_discourse_facet ['method_citation']
<S sid="159" ssid="7">Magnini and Cavagli`a (2000) have identified WordNet word senses with particular domains, and this has proven useful for high precision WSD (Magnini et al., 2001); indeed in section 5 we used these domain labels for evaluation.</S>
original cit marker offset is 0
new cit marker offset is 0



["159'"]
159'
['159']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P04-1036.annv3.csv
<S sid="2" ssid="2">The problem with using the predominant, or first sense heuristic, aside from the fact that it does not take surrounding context into account, is that it assumes some quantity of handtagged data.</S><S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="14" ssid="7">Even systems which show superior performance to this heuristic often make use of the heuristic where evidence from the context is not sufficient (Hoste et al., 2001).</S><S sid="23" ssid="16">The first sense of star in SemCor is celestial body, however, if one were disambiguating popular news celebrity would be preferred.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'8'", "'14'", "'23'"]
'2'
'8'
'14'
'23'
['2', '8', '14', '23']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S><S sid="21" ssid="14">We believe that an automatic means of finding a predominant sense would be useful for systems that use it as a means of backing-off (Wilks and Stevenson, 1998; Hoste et al., 2001) and for systems that use it in lexical acquisition (McCarthy, 1997; Merlo and Leybold, 2001; Korhonen, 2002) because of the limited size of hand-tagged resources.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'15'", "'21'", "'175'"]
'9'
'15'
'21'
'175'
['9', '15', '21', '175']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="32" ssid="25">We describe some related work in section 6 and conclude in section 7. are therefore investigating a method of automatically ranking WordNet senses from raw text.</S><S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="49" ssid="5">Let be the ordered set of the top scoring neighbours of from the thesaurus with associated distributional similarity scores The thesaurus was acquired using the method described by Lin (1998).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'41'", "'49'", "'175'"]
'32'
'41'
'49'
'175'
['32', '41', '49', '175']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="4" ssid="4">We present work on the use of a thesaurus acquired from raw textual corpora and the WordNet similarity package to find predominant noun senses automatically.</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="178" ssid="1">We have devised a method that uses raw corpus data to automatically find a predominant sense for nouns in WordNet.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'46'", "'166'", "'178'"]
'4'
'46'
'166'
'178'
['4', '46', '166', '178']
parsed_discourse_facet ['aim_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'47'", "'166'", "'175'"]
'0'
'47'
'166'
'175'
['0', '47', '166', '175']
parsed_discourse_facet ['results_citation']
<S sid="111" ssid="9">We give the results for this WSD task in table 2.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="167" ssid="15">In this work the lists of neighbours are themselves clustered to bring out the various senses of the word.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'111'", "'165'", "'167'", "'175'"]
'111'
'165'
'167'
'175'
['111', '165', '167', '175']
parsed_discourse_facet ['results_citation']
<S sid="3" ssid="3">Whilst there are a few hand-tagged corpora available for some languages, one would expect the frequency distribution of the senses of words, particularly topical words, to depend on the genre and domain of the text under consideration.</S><S sid="152" ssid="29">We see that both domains have a similarly high percentage of factotum (domain independent) labels, but as we would expect, the other peaks correspond to the economy label for the FINANCE corpus, and the sports label for the SPORTS corpus. inant senses for 38 polysemous words ranked using the SPORTS and FINANCE corpus.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'152'", "'165'", "'175'"]
'3'
'152'
'165'
'175'
['3', '152', '165', '175']
parsed_discourse_facet ['results_citation']
<S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'", "'47'", "'174'", "'176'"]
'41'
'47'
'174'
'176'
['41', '47', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="20">We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).</S><S sid="66" ssid="22">It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.</S><S sid="83" ssid="12">The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.</S><S sid="84" ssid="13">The random baseline for choosing the predominant sense over all these words ( ) is 32%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'66'", "'83'", "'84'"]
'64'
'66'
'83'
'84'
['64', '66', '83', '84']
parsed_discourse_facet ['results_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'174'", "'175'", "'176'"]
'9'
'174'
'175'
'176'
['9', '174', '175', '176']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="27" ssid="20">We use WordNet as our sense inventory for this work.</S><S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="164" ssid="12">They used syntactic evidence to find a prior distribution for verb classes, based on (Levin, 1993), and incorporate this in a WSD system.</S><S sid="189" ssid="12">Additionally, we need to determine whether senses which do not occur in a wide variety of grammatical contexts fare badly using distributional measures of similarity, and what can be done to combat this problem using relation specific thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'104'", "'164'", "'189'"]
'27'
'104'
'164'
'189'
['27', '104', '164', '189']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="133" ssid="10">We acquired thesauruses for these corpora using the procedure described in section 2.1.</S><S sid="158" ssid="6">We have evaluated our method using publically available resources, both for balanced and domain specific text.</S><S sid="168" ssid="16">They evaluate using the lin measure described above in section 2.2 to determine the precision and recall of these discovered classes with respect to WordNet synsets.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'158'", "'168'", "'175'"]
'133'
'158'
'168'
'175'
['133', '158', '168', '175']
parsed_discourse_facet ['results_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="160" ssid="8">Identification of these domain labels for word senses was semiautomatic and required a considerable amount of hand-labelling.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'46'", "'160'", "'176'"]
'0'
'46'
'160'
'176'
['0', '46', '160', '176']
parsed_discourse_facet ['hypothesis_citation']
<S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="154" ssid="2">In contrast, our work is aimed at discovering the predominant senses from raw text because the first sense heuristic is such a useful one, and because handtagged data is not always available.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'", "'154'", "'174'", "'175'"]
'104'
'154'
'174'
'175'
['104', '154', '174', '175']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.</S><S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="81" ssid="10">4 We calculate the accuracy of finding the predominant sense, when there is indeed one sense with a higher frequency than the others for this word in SemCor ( ).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'81'", "'175'"]
'1'
'9'
'81'
'175'
['1', '9', '81', '175']
parsed_discourse_facet ['results_citation']
<S sid="6" ssid="6">This is a very promising result given that our method does not require any hand-tagged text, such as SemCor.</S><S sid="7" ssid="7">Furthermore, we demonstrate that our method discovers appropriate predominant senses for words from two domainspecific corpora.</S><S sid="79" ssid="8">3 The experimental results reported here are obtained using IC counts from the BNC corpus.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'7'", "'79'", "'175'"]
'6'
'7'
'79'
'175'
['6', '7', '79', '175']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S><S sid="25" ssid="18">However, the most accurate WSD systems are those which require manually sense tagged data in the first place, and their accuracy depends on the quantity of training examples (Yarowsky and Florian, 2002) available.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'13'", "'25'", "'175'"]
'8'
'13'
'25'
'175'
['8', '13', '25', '175']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).'])
dict_values(['We describe some related work in section 6 and conclude in section 7. are therefore investigating a method of automatically ranking WordNet senses from raw text.', 'In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.', 'Let be the ordered set of the top scoring neighbours of from the thesaurus with associated distributional similarity scores The thesaurus was acquired using the method described by Lin (1998).', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:28', 'F:0']
dict_values(['word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.'])
dict_values(['We give the results for this WSD task in table 2.', 'Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.', 'In this work the lists of neighbours are themselves clustered to bring out the various senses of the word.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00904', '(95%-conf.int.', '0.00904', '-', '0.00904)']
['system', 'ROUGE-S*', 'Average_P:', '0.20513', '(95%-conf.int.', '0.20513', '-', '0.20513)']
['system', 'ROUGE-S*', 'Average_F:', '0.01732', '(95%-conf.int.', '0.01732', '-', '0.01732)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:78', 'F:16']
dict_values(['In contrast, we use the neighbours lists and WordNet similarity measures to impose a prevalence ranking on the WordNet senses.'])
dict_values(['In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.', 'We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.', 'We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.', 'The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01647', '(95%-conf.int.', '0.01647', '-', '0.01647)']
['system', 'ROUGE-S*', 'Average_P:', '0.38182', '(95%-conf.int.', '0.38182', '-', '0.38182)']
['system', 'ROUGE-S*', 'Average_F:', '0.03158', '(95%-conf.int.', '0.03158', '-', '0.03158)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1275', 'P:55', 'F:21']
dict_values(['Since both measures gave comparable results we restricted our remaining experiments to jcn because this gave good results for finding the predominant sense, and is much more efficient than lesk, given the precompilation of the IC files.'])
dict_values(['We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).', 'It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.', 'The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.', 'The random baseline for choosing the predominant sense over all these words ( ) is 32%.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01089', '(95%-conf.int.', '0.01089', '-', '0.01089)']
['system', 'ROUGE-S*', 'Average_P:', '0.08772', '(95%-conf.int.', '0.08772', '-', '0.08772)']
['system', 'ROUGE-S*', 'Average_F:', '0.01937', '(95%-conf.int.', '0.01937', '-', '0.01937)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:171', 'F:15']
dict_values(['Again, the automatic ranking outperforms this by a large margin.'])
dict_values(['We acquired thesauruses for these corpora using the procedure described in section 2.1.', 'We have evaluated our method using publically available resources, both for balanced and domain specific text.', 'They evaluate using the lin measure described above in section 2.2 to determine the precision and recall of these discovered classes with respect to WordNet synsets.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:10', 'F:0']
dict_values(['word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.'])
dict_values(['Finding Predominant Word Senses in Untagged Text', 'This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.', 'Identification of these domain labels for word senses was semiautomatic and required a considerable amount of hand-labelling.', 'The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01905', '(95%-conf.int.', '0.01905', '-', '0.01905)']
['system', 'ROUGE-S*', 'Average_P:', '0.15385', '(95%-conf.int.', '0.15385', '-', '0.15385)']
['system', 'ROUGE-S*', 'Average_F:', '0.03390', '(95%-conf.int.', '0.03390', '-', '0.03390)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:630', 'P:78', 'F:12']
dict_values(['Since both measures gave comparable results we restricted our remaining experiments to jcn because this gave good results for finding the predominant sense, and is much more efficient than lesk, given the precompilation of the IC files.'])
dict_values(['7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.', 'In contrast, our work is aimed at discovering the predominant senses from raw text because the first sense heuristic is such a useful one, and because handtagged data is not always available.', 'We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00163', '(95%-conf.int.', '0.00163', '-', '0.00163)']
['system', 'ROUGE-S*', 'Average_P:', '0.01170', '(95%-conf.int.', '0.01170', '-', '0.01170)']
['system', 'ROUGE-S*', 'Average_F:', '0.00287', '(95%-conf.int.', '0.00287', '-', '0.00287)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:171', 'F:2']
dict_values(['Additionally, we evaluated our method quantitatively using the Subject Field Codes (SFC) resource (Magnini and Cavagli`a, 2000) which annotates WordNet synsets with domain labels.'])
dict_values(['word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.', 'This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).', '4 We calculate the accuracy of finding the predominant sense, when there is indeed one sense with a higher frequency than the others for this word in SemCor ( ).', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00102', '(95%-conf.int.', '0.00102', '-', '0.00102)']
['system', 'ROUGE-S*', 'Average_P:', '0.01471', '(95%-conf.int.', '0.01471', '-', '0.01471)']
['system', 'ROUGE-S*', 'Average_F:', '0.00191', '(95%-conf.int.', '0.00191', '-', '0.00191)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:136', 'F:2']
dict_values(['We experimented using six of these to provide the in equation 1 above and obtained results well over our baseline, but because of space limitations give results for the two which perform the best.'])
dict_values(['This is a very promising result given that our method does not require any hand-tagged text, such as SemCor.', 'Furthermore, we demonstrate that our method discovers appropriate predominant senses for words from two domainspecific corpora.', '3 The experimental results reported here are obtained using IC counts from the BNC corpus.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00813', '(95%-conf.int.', '0.00813', '-', '0.00813)']
['system', 'ROUGE-S*', 'Average_P:', '0.10606', '(95%-conf.int.', '0.10606', '-', '0.10606)']
['system', 'ROUGE-S*', 'Average_F:', '0.01510', '(95%-conf.int.', '0.01510', '-', '0.01510)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:66', 'F:7']
dict_values(['Magnini and Cavagli`a (2000) have identified WordNet word senses with particular domains, and this has proven useful for high precision WSD (Magnini et al., 2001); indeed in section 5 we used these domain labels for evaluation.'])
dict_values(['The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.', 'The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.', 'However, the most accurate WSD systems are those which require manually sense tagged data in the first place, and their accuracy depends on the quantity of training examples (Yarowsky and Florian, 2002) available.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00907', '(95%-conf.int.', '0.00907', '-', '0.00907)']
['system', 'ROUGE-S*', 'Average_P:', '0.07895', '(95%-conf.int.', '0.07895', '-', '0.07895)']
['system', 'ROUGE-S*', 'Average_F:', '0.01628', '(95%-conf.int.', '0.01628', '-', '0.01628)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:190', 'F:15']
0.10399399896006002 0.0075299999247000005 0.01383299986167





input/ref/Task1/P04-1036_vardha.csv
input/res/Task1/P04-1036.annv3.csv
parsing: input/ref/Task1/P04-1036_vardha.csv
    <S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
    <S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'"]
'15'
['15']
parsed_discourse_facet ['method_citation']
<S sid="45" ssid="1">In order to find the predominant sense of a target word we use a thesaurus acquired from automatically parsed text based on the method of Lin (1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'45'"]
'45'
['45']
parsed_discourse_facet ['method_citation']
<S sid="66" ssid="22">It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'66'"]
'66'
['66']
parsed_discourse_facet ['method_citation']
 <S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'"]
'126'
['126']
parsed_discourse_facet ['method_citation']
<S sid="101" ssid="30">Thus, if we used the sense ranking as a heuristic for an &#8220;all nouns&#8221; task we would expect to get precision in the region of 60%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'101'"]
'101'
['101']
parsed_discourse_facet ['method_citation']
 <S sid="126" ssid="3">We demonstrate that choosing texts from a particular domain has a significant influence on the sense ranking.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'"]
'126'
['126']
parsed_discourse_facet ['method_citation']
 <S sid="115" ssid="13">Our automatically acquired predominant sense performs nearly as well as the first sense provided by SemCor, which is very encouraging given that our method only uses raw text, with no manual labelling.</S>
original cit marker offset is 0
new cit marker offset is 0



["'115'"]
'115'
['115']
parsed_discourse_facet ['method_citation']
  <S sid="89" ssid="18">Since both measures gave comparable results we restricted our remaining experiments to jcn because this gave good results for finding the predominant sense, and is much more efficient than lesk, given the precompilation of the IC files.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'"]
'89'
['89']
parsed_discourse_facet ['method_citation']
 <S sid="137" ssid="14">Additionally, we evaluated our method quantitatively using the Subject Field Codes (SFC) resource (Magnini and Cavagli`a, 2000) which annotates WordNet synsets with domain labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'137'"]
'137'
['137']
parsed_discourse_facet ['method_citation']
75 ssid="4">We generated a thesaurus entry for all polysemous nouns which occurred in SemCor with a frequency 2, and in the BNC with a frequency 10 in the grammatical relations listed in section 2.1 above.</S>
original cit marker offset is 0
new cit marker offset is 0



["'75'"]
'75'
['75']
Error in Reference Offset
 <S sid="155" ssid="3">A major benefit of our work, rather than reliance on hand-tagged training data such as SemCor, is that this method permits us to produce predominant senses for the domain and text type required.</S>
original cit marker offset is 0
new cit marker offset is 0



["'155'"]
'155'
['155']
parsed_discourse_facet ['method_citation']
  <S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
 <S sid="155" ssid="3">A major benefit of our work, rather than reliance on hand-tagged training data such as SemCor, is that this method permits us to produce predominant senses for the domain and text type required.</S>
original cit marker offset is 0
new cit marker offset is 0



["'155'"]
'155'
['155']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="24">We are of course able to apply the method to other versions of WordNet. synset, is incremented with the frequency counts from the corpus of all words belonging to that synset, directly or via the hyponymy relation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'"]
'68'
['68']
parsed_discourse_facet ['method_citation']
    <S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'"]
'13'
['13']
parsed_discourse_facet ['method_citation']
  <S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P04-1036.annv3.csv
<S sid="2" ssid="2">The problem with using the predominant, or first sense heuristic, aside from the fact that it does not take surrounding context into account, is that it assumes some quantity of handtagged data.</S><S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="14" ssid="7">Even systems which show superior performance to this heuristic often make use of the heuristic where evidence from the context is not sufficient (Hoste et al., 2001).</S><S sid="23" ssid="16">The first sense of star in SemCor is celestial body, however, if one were disambiguating popular news celebrity would be preferred.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'8'", "'14'", "'23'"]
'2'
'8'
'14'
'23'
['2', '8', '14', '23']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="15" ssid="8">Whilst a first sense heuristic based on a sense-tagged corpus such as SemCor is clearly useful, there is a strong case for obtaining a first, or predominant, sense from untagged corpus data so that a WSD system can be tuned to the genre or domain at hand.</S><S sid="21" ssid="14">We believe that an automatic means of finding a predominant sense would be useful for systems that use it as a means of backing-off (Wilks and Stevenson, 1998; Hoste et al., 2001) and for systems that use it in lexical acquisition (McCarthy, 1997; Merlo and Leybold, 2001; Korhonen, 2002) because of the limited size of hand-tagged resources.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'15'", "'21'", "'175'"]
'9'
'15'
'21'
'175'
['9', '15', '21', '175']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="32" ssid="25">We describe some related work in section 6 and conclude in section 7. are therefore investigating a method of automatically ranking WordNet senses from raw text.</S><S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="49" ssid="5">Let be the ordered set of the top scoring neighbours of from the thesaurus with associated distributional similarity scores The thesaurus was acquired using the method described by Lin (1998).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'", "'41'", "'49'", "'175'"]
'32'
'41'
'49'
'175'
['32', '41', '49', '175']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="4" ssid="4">We present work on the use of a thesaurus acquired from raw textual corpora and the WordNet similarity package to find predominant noun senses automatically.</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="178" ssid="1">We have devised a method that uses raw corpus data to automatically find a predominant sense for nouns in WordNet.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'46'", "'166'", "'178'"]
'4'
'46'
'166'
'178'
['4', '46', '166', '178']
parsed_discourse_facet ['aim_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="166" ssid="14">There has been some related work on using automatic thesauruses for discovering word senses from corpora Pantel and Lin (2002).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'47'", "'166'", "'175'"]
'0'
'47'
'166'
'175'
['0', '47', '166', '175']
parsed_discourse_facet ['results_citation']
<S sid="111" ssid="9">We give the results for this WSD task in table 2.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="167" ssid="15">In this work the lists of neighbours are themselves clustered to bring out the various senses of the word.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'111'", "'165'", "'167'", "'175'"]
'111'
'165'
'167'
'175'
['111', '165', '167', '175']
parsed_discourse_facet ['results_citation']
<S sid="3" ssid="3">Whilst there are a few hand-tagged corpora available for some languages, one would expect the frequency distribution of the senses of words, particularly topical words, to depend on the genre and domain of the text under consideration.</S><S sid="152" ssid="29">We see that both domains have a similarly high percentage of factotum (domain independent) labels, but as we would expect, the other peaks correspond to the economy label for the FINANCE corpus, and the sports label for the SPORTS corpus. inant senses for 38 polysemous words ranked using the SPORTS and FINANCE corpus.</S><S sid="165" ssid="13">Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'152'", "'165'", "'175'"]
'3'
'152'
'165'
'175'
['3', '152', '165', '175']
parsed_discourse_facet ['results_citation']
<S sid="41" ssid="34">In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.</S><S sid="47" ssid="3">We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'", "'47'", "'174'", "'176'"]
'41'
'47'
'174'
'176'
['41', '47', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="20">We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).</S><S sid="66" ssid="22">It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.</S><S sid="83" ssid="12">The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.</S><S sid="84" ssid="13">The random baseline for choosing the predominant sense over all these words ( ) is 32%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'66'", "'83'", "'84'"]
'64'
'66'
'83'
'84'
['64', '66', '83', '84']
parsed_discourse_facet ['results_citation']
<S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'174'", "'175'", "'176'"]
'9'
'174'
'175'
'176'
['9', '174', '175', '176']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="27" ssid="20">We use WordNet as our sense inventory for this work.</S><S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="164" ssid="12">They used syntactic evidence to find a prior distribution for verb classes, based on (Levin, 1993), and incorporate this in a WSD system.</S><S sid="189" ssid="12">Additionally, we need to determine whether senses which do not occur in a wide variety of grammatical contexts fare badly using distributional measures of similarity, and what can be done to combat this problem using relation specific thesauruses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'104'", "'164'", "'189'"]
'27'
'104'
'164'
'189'
['27', '104', '164', '189']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="133" ssid="10">We acquired thesauruses for these corpora using the procedure described in section 2.1.</S><S sid="158" ssid="6">We have evaluated our method using publically available resources, both for balanced and domain specific text.</S><S sid="168" ssid="16">They evaluate using the lin measure described above in section 2.2 to determine the precision and recall of these discovered classes with respect to WordNet synsets.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'158'", "'168'", "'175'"]
'133'
'158'
'168'
'175'
['133', '158', '168', '175']
parsed_discourse_facet ['results_citation']
<S sid="0">Finding Predominant Word Senses in Untagged Text</S><S sid="46" ssid="2">This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.</S><S sid="160" ssid="8">Identification of these domain labels for word senses was semiautomatic and required a considerable amount of hand-labelling.</S><S sid="176" ssid="24">The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'46'", "'160'", "'176'"]
'0'
'46'
'160'
'176'
['0', '46', '160', '176']
parsed_discourse_facet ['hypothesis_citation']
<S sid="104" ssid="2">7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.</S><S sid="154" ssid="2">In contrast, our work is aimed at discovering the predominant senses from raw text because the first sense heuristic is such a useful one, and because handtagged data is not always available.</S><S sid="174" ssid="22">We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'", "'154'", "'174'", "'175'"]
'104'
'154'
'174'
'175'
['104', '154', '174', '175']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.</S><S sid="9" ssid="2">This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).</S><S sid="81" ssid="10">4 We calculate the accuracy of finding the predominant sense, when there is indeed one sense with a higher frequency than the others for this word in SemCor ( ).</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'81'", "'175'"]
'1'
'9'
'81'
'175'
['1', '9', '81', '175']
parsed_discourse_facet ['results_citation']
<S sid="6" ssid="6">This is a very promising result given that our method does not require any hand-tagged text, such as SemCor.</S><S sid="7" ssid="7">Furthermore, we demonstrate that our method discovers appropriate predominant senses for words from two domainspecific corpora.</S><S sid="79" ssid="8">3 The experimental results reported here are obtained using IC counts from the BNC corpus.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'7'", "'79'", "'175'"]
'6'
'7'
'79'
'175'
['6', '7', '79', '175']
parsed_discourse_facet ['aim_citation', 'results_citation']
<S sid="8" ssid="1">The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.</S><S sid="13" ssid="6">The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.</S><S sid="25" ssid="18">However, the most accurate WSD systems are those which require manually sense tagged data in the first place, and their accuracy depends on the quantity of training examples (Yarowsky and Florian, 2002) available.</S><S sid="175" ssid="23">We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'13'", "'25'", "'175'"]
'8'
'13'
'25'
'175'
['8', '13', '25', '175']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['In order to find the predominant sense of a target word we use a thesaurus acquired from automatically parsed text based on the method of Lin (1998).'])
dict_values(['We describe some related work in section 6 and conclude in section 7. are therefore investigating a method of automatically ranking WordNet senses from raw text.', 'In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.', 'Let be the ordered set of the top scoring neighbours of from the thesaurus with associated distributional similarity scores The thesaurus was acquired using the method described by Lin (1998).', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02380', '(95%-conf.int.', '0.02380', '-', '0.02380)']
['system', 'ROUGE-S*', 'Average_P:', '0.42857', '(95%-conf.int.', '0.42857', '-', '0.42857)']
['system', 'ROUGE-S*', 'Average_F:', '0.04509', '(95%-conf.int.', '0.04509', '-', '0.04509)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:105', 'F:45']
dict_values(['Thus, if we used the sense ranking as a heuristic for an &#8220;all nouns&#8221; task we would expect to get precision in the region of 60%.'])
dict_values(['We give the results for this WSD task in table 2.', 'Lapata and Brew obtain their priors for verb classes directly from subcategorisation evidence in a parsed corpus, whereas we use parsed data to find distributionally similar words (nearest neighbours) to the target word which reflect the different senses of the word and have associated distributional similarity scores which can be used for ranking the senses according to prevalence.', 'In this work the lists of neighbours are themselves clustered to bring out the various senses of the word.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00169', '(95%-conf.int.', '0.00169', '-', '0.00169)']
['system', 'ROUGE-S*', 'Average_P:', '0.05455', '(95%-conf.int.', '0.05455', '-', '0.05455)']
['system', 'ROUGE-S*', 'Average_F:', '0.00329', '(95%-conf.int.', '0.00329', '-', '0.00329)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:55', 'F:3']
dict_values(['Our automatically acquired predominant sense performs nearly as well as the first sense provided by SemCor, which is very encouraging given that our method only uses raw text, with no manual labelling.'])
dict_values(['In this paper we describe and evaluate a method for ranking senses of nouns to obtain the predominant sense of a word using the neighbours from automatically acquired thesauruses.', 'We then use the WordNet similarity package (Patwardhan and Pedersen, 2003) to give us a semantic similarity measure (hereafter referred to as the WordNet similarity measure) to weight the contribution that each neighbour makes to the various senses of the target word.', 'We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.', 'The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00471', '(95%-conf.int.', '0.00471', '-', '0.00471)']
['system', 'ROUGE-S*', 'Average_P:', '0.05714', '(95%-conf.int.', '0.05714', '-', '0.05714)']
['system', 'ROUGE-S*', 'Average_F:', '0.00870', '(95%-conf.int.', '0.00870', '-', '0.00870)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1275', 'P:105', 'F:6']
dict_values(['Since both measures gave comparable results we restricted our remaining experiments to jcn because this gave good results for finding the predominant sense, and is much more efficient than lesk, given the precompilation of the IC files.'])
dict_values(['We briefly summarise the two measures here; for a more detailed summary see (Patwardhan et al., 2003).', 'It uses the glosses of semantically related (according to WordNet) senses too. jcn (Jiang and Conrath, 1997) This score uses corpus data to populate classes (synsets) in the WordNet hierarchy with frequency counts.', 'The results in table 1 show the accuracy of the ranking with respect to SemCor over the entire set of 2595 polysemous nouns in SemCor with the jcn and lesk WordNet similarity measures.', 'The random baseline for choosing the predominant sense over all these words ( ) is 32%.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01089', '(95%-conf.int.', '0.01089', '-', '0.01089)']
['system', 'ROUGE-S*', 'Average_P:', '0.08772', '(95%-conf.int.', '0.08772', '-', '0.08772)']
['system', 'ROUGE-S*', 'Average_F:', '0.01937', '(95%-conf.int.', '0.01937', '-', '0.01937)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:171', 'F:15']
dict_values(['A major benefit of our work, rather than reliance on hand-tagged training data such as SemCor, is that this method permits us to produce predominant senses for the domain and text type required.'])
dict_values(['We acquired thesauruses for these corpora using the procedure described in section 2.1.', 'We have evaluated our method using publically available resources, both for balanced and domain specific text.', 'They evaluate using the lin measure described above in section 2.2 to determine the precision and recall of these discovered classes with respect to WordNet synsets.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00580', '(95%-conf.int.', '0.00580', '-', '0.00580)']
['system', 'ROUGE-S*', 'Average_P:', '0.03922', '(95%-conf.int.', '0.03922', '-', '0.03922)']
['system', 'ROUGE-S*', 'Average_F:', '0.01010', '(95%-conf.int.', '0.01010', '-', '0.01010)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:153', 'F:6']
dict_values(['The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.'])
dict_values(['Finding Predominant Word Senses in Untagged Text', 'This provides the nearest neighbours to each target word, along with the distributional similarity score between the target word and its neighbour.', 'Identification of these domain labels for word senses was semiautomatic and required a considerable amount of hand-labelling.', 'The lesk measure can be used when ranking adjectives, and adverbs as well as nouns and verbs (which can also be ranked using jcn).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:630', 'P:66', 'F:0']
dict_values(['A major benefit of our work, rather than reliance on hand-tagged training data such as SemCor, is that this method permits us to produce predominant senses for the domain and text type required.'])
dict_values(['7 This is a hand-tagged test suite of 5,000 words of running text from three articles from the Penn Treebank II.', 'In contrast, our work is aimed at discovering the predominant senses from raw text because the first sense heuristic is such a useful one, and because handtagged data is not always available.', 'We have restricted ourselves to nouns in this work, since this PoS is perhaps most affected by domain.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02286', '(95%-conf.int.', '0.02286', '-', '0.02286)']
['system', 'ROUGE-S*', 'Average_P:', '0.18301', '(95%-conf.int.', '0.18301', '-', '0.18301)']
['system', 'ROUGE-S*', 'Average_F:', '0.04064', '(95%-conf.int.', '0.04064', '-', '0.04064)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:153', 'F:28']
dict_values(['We are of course able to apply the method to other versions of WordNet. synset, is incremented with the frequency counts from the corpus of all words belonging to that synset, directly or via the hyponymy relation.'])
dict_values(['word sense disambiguation the heuristic of choosing the most common sense is extremely powerful because the distribution of the senses of a word is often skewed.', 'This is shown by the results of the English all-words task in SENSEVAL-2 (Cotton et al., 1998) in figure 1 below, where the first sense is that listed in WordNet for the PoS given by the Penn TreeBank (Palmer et al., 2001).', '4 We calculate the accuracy of finding the predominant sense, when there is indeed one sense with a higher frequency than the others for this word in SemCor ( ).', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00154', '(95%-conf.int.', '0.00154', '-', '0.00154)']
['system', 'ROUGE-S*', 'Average_P:', '0.02857', '(95%-conf.int.', '0.02857', '-', '0.02857)']
['system', 'ROUGE-S*', 'Average_F:', '0.00292', '(95%-conf.int.', '0.00292', '-', '0.00292)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:105', 'F:3']
dict_values(['The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.'])
dict_values(['This is a very promising result given that our method does not require any hand-tagged text, such as SemCor.', 'Furthermore, we demonstrate that our method discovers appropriate predominant senses for words from two domainspecific corpora.', '3 The experimental results reported here are obtained using IC counts from the BNC corpus.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00697', '(95%-conf.int.', '0.00697', '-', '0.00697)']
['system', 'ROUGE-S*', 'Average_P:', '0.10909', '(95%-conf.int.', '0.10909', '-', '0.10909)']
['system', 'ROUGE-S*', 'Average_F:', '0.01310', '(95%-conf.int.', '0.01310', '-', '0.01310)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:55', 'F:6']
dict_values(['The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.'])
dict_values(['The first sense heuristic which is often used as a baseline for supervised WSD systems outperforms many of these systems which take surrounding context into account.', 'The high performance of the first sense baseline is due to the skewed frequency distribution of word senses.', 'However, the most accurate WSD systems are those which require manually sense tagged data in the first place, and their accuracy depends on the quantity of training examples (Yarowsky and Florian, 2002) available.', 'We are currently investigating the performance of the first sense heuristic, and this method, for other PoS on SENSEVAL-3 data (McCarthy et al., 2004), although not yet with rankings from domain specific corpora.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03993', '(95%-conf.int.', '0.03993', '-', '0.03993)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.07679', '(95%-conf.int.', '0.07679', '-', '0.07679)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:66', 'F:66']
0.19878699801213004 0.011818999881810004 0.021999999780000005





input/ref/Task1/P05-1013_aakansha.csv
input/res/Task1/P05-1013.annv3.csv
parsing: input/ref/Task1/P05-1013_aakansha.csv
<S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="20">We call this pseudoprojective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al., 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
<S sid="106" ssid="17">However, the accuracy is considerably higher than previously reported results for robust non-projective parsing of Czech, with a best performance of 73% UAS (Holan, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'106'"]
'106'
['106']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="13">As expected, the most informative encoding, Head+Path, gives the highest accuracy with over 99% of all non-projective arcs being recovered correctly in both data sets.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'"]
'86'
['86']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="7">As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'109'"]
'109'
['109']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="7">As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="19">By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'"]
'23'
['23']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="20">We call this pseudoprojective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al., 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
<S sid="80" ssid="7">As shown in Table 3, the proportion of sentences containing some non-projective dependency ranges from about 15% in DDT to almost 25% in PDT.</S>
    <S sid="81"  ssid="8">However, the overall percentage of non-projective arcs is less than 2% in PDT and less than 1% in DDT.</S>
original cit marker offset is 0
new cit marker offset is 0



["'80'", "'81'"]
'80'
'81'
['80', '81']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="20">We call this pseudoprojective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al., 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="20">We call this pseudoprojective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al., 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
<S sid="49" ssid="20">The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.</S>
original cit marker offset is 0
new cit marker offset is 0



["'49'"]
'49'
['49']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'109'"]
'109'
['109']
parsed_discourse_facet ['method_citation']
<S sid="14" ssid="10">While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'14'"]
'14'
['14']
parsed_discourse_facet ['method_citation']
<S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P05-1013.annv3.csv
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="61" ssid="32">Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'61'", "'62'", "'109'"]
'2'
'61'
'62'
'109'
['2', '61', '62', '109']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'62'", "'109'"]
'1'
'9'
'62'
'109'
['1', '9', '62', '109']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="3" ssid="3">Experiments using data from the Prague Dependency Treebank show that the combined system can handle nonprojective constructions with a precision sufficient to yield a significant improvement in overall parsing accuracy.</S><S sid="19" ssid="15">Finally, since non-projective constructions often involve long-distance dependencies, the problem is closely related to the recovery of empty categories and non-local dependencies in constituency-based parsing (Johnson, 2002; Dienes and Dubey, 2003; Jijkoun and de Rijke, 2004; Cahill et al., 2004; Levy and Manning, 2004; Campbell, 2004).</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'19'", "'20'"]
'2'
'3'
'19'
'20'
['2', '3', '19', '20']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'17'", "'21'"]
'1'
'2'
'17'
'21'
['1', '2', '17', '21']
parsed_discourse_facet ['results_citation']
<S sid="0">Pseudo-Projective Dependency Parsing</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'27'", "'109'"]
'0'
'2'
'27'
'109'
['0', '2', '27', '109']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'37'", "'50'", "'104'"]
'22'
'37'
'50'
'104'
['22', '37', '50', '104']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="40" ssid="11">Even this may be nondeterministic, in case the graph contains several non-projective arcs whose lifts interact, but we use the following algorithm to construct a minimal projective transformation D0 = (W, A0) of a (nonprojective) dependency graph D = (W, A): The function SMALLEST-NONP-ARC returns the non-projective arc with the shortest distance from head to dependent (breaking ties from left to right).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'40'"]
'2'
'20'
'21'
'40'
['2', '20', '21', '40']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.</S><S sid="36" ssid="7">As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'36'", "'37'", "'50'"]
'22'
'36'
'37'
'50'
['22', '36', '37', '50']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="107" ssid="18">Compared to related work on the recovery of long-distance dependencies in constituency-based parsing, our approach is similar to that of Dienes and Dubey (2003) in that the processing of non-local dependencies is partly integrated in the parsing process, via an extension of the set of syntactic categories, whereas most other approaches rely on postprocessing only.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'21'", "'62'", "'107'"]
'2'
'21'
'62'
'107'
['2', '21', '62', '107']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="105" ssid="16">Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'17'", "'62'", "'105'"]
'9'
'17'
'62'
'105'
['9', '17', '62', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="7" ssid="3">From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.</S><S sid="12" ssid="8">Prague Dependency Treebank (Haji&#711;c et al., 2001b), Danish Dependency Treebank (Kromann, 2003), and the METU Treebank of Turkish (Oflazer et al., 2003), which generally allow annotations with nonprojective dependency structures.</S><S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'7'", "'12'", "'95'"]
'2'
'7'
'12'
'95'
['2', '7', '12', '95']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="23" ssid="19">By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.</S><S sid="61" ssid="32">Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.</S><S sid="94" ssid="5">The first thing to note is that projectivizing helps in itself, even if no encoding is used, as seen from the fact that the projective baseline outperforms the non-projective training condition by more than half a percentage point on attachment score, although the gain is much smaller with respect to exact match.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'23'", "'61'", "'94'"]
'1'
'23'
'61'
'94'
['1', '23', '61', '94']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">Pseudo-Projective Dependency Parsing</S><S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="8" ssid="4">Thus, most broad-coverage parsers based on dependency grammar have been restricted to projective structures.</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'8'", "'104'"]
'0'
'1'
'8'
'104'
['0', '1', '8', '104']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="13" ssid="9">The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'21'", "'27'", "'62'"]
'13'
'21'
'27'
'62'
['13', '21', '27', '62']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'104'", "'109'"]
'1'
'2'
'104'
'109'
['1', '2', '104', '109']
parsed_discourse_facet ['results_citation']
<S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="49" ssid="20">The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'37'", "'49'", "'50'"]
'21'
'37'
'49'
'50'
['21', '37', '49', '50']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'17'", "'21'"]
'1'
'2'
'17'
'21'
['1', '2', '17', '21']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="13" ssid="9">The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S><S sid="39" ssid="10">However, since we want to preserve as much of the original structure as possible, we are interested in finding a transformation that involves a minimal number of lifts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'13'", "'20'", "'39'"]
'2'
'13'
'20'
'39'
['2', '13', '20', '39']
parsed_discourse_facet ['hypothesis_citation']
<S sid="14" ssid="10">While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.</S><S sid="79" ssid="6">In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.</S><S sid="92" ssid="3">Evaluation metrics used are Attachment Score (AS), i.e. the proportion of tokens that are attached to the correct head, and Exact Match (EM), i.e. the proportion of sentences for which the dependency graph exactly matches the gold standard.</S><S sid="106" ssid="17">However, the accuracy is considerably higher than previously reported results for robust non-projective parsing of Czech, with a best performance of 73% UAS (Holan, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'14'", "'79'", "'92'", "'106'"]
'14'
'79'
'92'
'106'
['14', '79', '92', '106']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="26" ssid="22">In section 2 we introduce the graph transformation techniques used to projectivize and deprojectivize dependency graphs, and in section 3 we describe the data-driven dependency parser that is the core of our system.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="105" ssid="16">Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'26'", "'27'", "'105'"]
'1'
'26'
'27'
'105'
['1', '26', '27', '105']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.', 'In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).', 'We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02732', '(95%-conf.int.', '0.02732', '-', '0.02732)']
['system', 'ROUGE-S*', 'Average_P:', '0.54945', '(95%-conf.int.', '0.54945', '-', '0.54945)']
['system', 'ROUGE-S*', 'Average_F:', '0.05206', '(95%-conf.int.', '0.05206', '-', '0.05206)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:91', 'F:50']
dict_values(['We call this pseudoprojective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al., 1998).'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).', 'In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).', 'We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00333', '(95%-conf.int.', '0.00333', '-', '0.00333)']
['system', 'ROUGE-S*', 'Average_P:', '0.18182', '(95%-conf.int.', '0.18182', '-', '0.18182)']
['system', 'ROUGE-S*', 'Average_F:', '0.00654', '(95%-conf.int.', '0.00654', '-', '0.00654)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:55', 'F:10']
dict_values(['However, the accuracy is considerably higher than previously reported results for robust non-projective parsing of Czech, with a best performance of 73% UAS (Holan, 2004).'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'Experiments using data from the Prague Dependency Treebank show that the combined system can handle nonprojective constructions with a precision sufficient to yield a significant improvement in overall parsing accuracy.', 'Finally, since non-projective constructions often involve long-distance dependencies, the problem is closely related to the recovery of empty categories and non-local dependencies in constituency-based parsing (Johnson, 2002; Dienes and Dubey, 2003; Jijkoun and de Rijke, 2004; Cahill et al., 2004; Levy and Manning, 2004; Campbell, 2004).', 'In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00181', '(95%-conf.int.', '0.00181', '-', '0.00181)']
['system', 'ROUGE-S*', 'Average_P:', '0.05714', '(95%-conf.int.', '0.05714', '-', '0.05714)']
['system', 'ROUGE-S*', 'Average_F:', '0.00350', '(95%-conf.int.', '0.00350', '-', '0.00350)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3321', 'P:105', 'F:6']
dict_values(['As expected, the most informative encoding, Head+Path, gives the highest accuracy with over 99% of all non-projective arcs being recovered correctly in both data sets.'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.', 'First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00166', '(95%-conf.int.', '0.00166', '-', '0.00166)']
['system', 'ROUGE-S*', 'Average_P:', '0.04396', '(95%-conf.int.', '0.04396', '-', '0.04396)']
['system', 'ROUGE-S*', 'Average_F:', '0.00319', '(95%-conf.int.', '0.00319', '-', '0.00319)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:91', 'F:4']
dict_values(['In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.'])
dict_values(['Pseudo-Projective Dependency Parsing', 'We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'We then evaluate the approach in two steps.', 'We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07808', '(95%-conf.int.', '0.07808', '-', '0.07808)']
['system', 'ROUGE-S*', 'Average_P:', '0.57143', '(95%-conf.int.', '0.57143', '-', '0.57143)']
['system', 'ROUGE-S*', 'Average_F:', '0.13738', '(95%-conf.int.', '0.13738', '-', '0.13738)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:666', 'P:91', 'F:52']
dict_values(['As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.'])
dict_values(['When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.', 'Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).', 'Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).', 'The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.'])
['system', 'ROUGE-S*', 'Average_R:', '0.04272', '(95%-conf.int.', '0.04272', '-', '0.04272)']
['system', 'ROUGE-S*', 'Average_P:', '0.35714', '(95%-conf.int.', '0.35714', '-', '0.35714)']
['system', 'ROUGE-S*', 'Average_F:', '0.07631', '(95%-conf.int.', '0.07631', '-', '0.07631)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3160', 'P:378', 'F:135']
dict_values(['We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.', 'First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.', 'Even this may be nondeterministic, in case the graph contains several non-projective arcs whose lifts interact, but we use the following algorithm to construct a minimal projective transformation D0 = (W, A0) of a (nonprojective) dependency graph D = (W, A): The function SMALLEST-NONP-ARC returns the non-projective arc with the shortest distance from head to dependent (breaking ties from left to right).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01665', '(95%-conf.int.', '0.01665', '-', '0.01665)']
['system', 'ROUGE-S*', 'Average_P:', '0.47619', '(95%-conf.int.', '0.47619', '-', '0.47619)']
['system', 'ROUGE-S*', 'Average_F:', '0.03218', '(95%-conf.int.', '0.03218', '-', '0.03218)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:105', 'F:50']
dict_values(['As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.'])
dict_values(['When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.', 'As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.', 'Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).', 'Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).'])
['system', 'ROUGE-S*', 'Average_R:', '0.07792', '(95%-conf.int.', '0.07792', '-', '0.07792)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.14458', '(95%-conf.int.', '0.14458', '-', '0.14458)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4851', 'P:378', 'F:378']
dict_values(['By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.', 'In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).', 'Compared to related work on the recovery of long-distance dependencies in constituency-based parsing, our approach is similar to that of Dienes and Dubey (2003) in that the processing of non-local dependencies is partly integrated in the parsing process, via an extension of the set of syntactic categories, whereas most other approaches rely on postprocessing only.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01905', '(95%-conf.int.', '0.01905', '-', '0.01905)']
['system', 'ROUGE-S*', 'Average_P:', '0.13710', '(95%-conf.int.', '0.13710', '-', '0.13710)']
['system', 'ROUGE-S*', 'Average_F:', '0.03345', '(95%-conf.int.', '0.03345', '-', '0.03345)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3570', 'P:496', 'F:68']
dict_values(['We call this pseudoprojective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al., 1998).'])
dict_values(['This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).', 'There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.', 'In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).', 'Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00055', '(95%-conf.int.', '0.00055', '-', '0.00055)']
['system', 'ROUGE-S*', 'Average_P:', '0.05455', '(95%-conf.int.', '0.05455', '-', '0.05455)']
['system', 'ROUGE-S*', 'Average_F:', '0.00109', '(95%-conf.int.', '0.00109', '-', '0.00109)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5460', 'P:55', 'F:3']
dict_values(['As shown in Table 3, the proportion of sentences containing some non-projective dependency ranges from about 15% in DDT to almost 25% in PDT.', 'However, the overall percentage of non-projective arcs is less than 2% in PDT and less than 1% in DDT.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.', 'Prague Dependency Treebank (Haji&#711;c et al., 2001b), Danish Dependency Treebank (Kromann, 2003), and the METU Treebank of Turkish (Oflazer et al., 2003), which generally allow annotations with nonprojective dependency structures.', 'The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00313', '(95%-conf.int.', '0.00313', '-', '0.00313)']
['system', 'ROUGE-S*', 'Average_P:', '0.04678', '(95%-conf.int.', '0.04678', '-', '0.04678)']
['system', 'ROUGE-S*', 'Average_F:', '0.00587', '(95%-conf.int.', '0.00587', '-', '0.00587)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2556', 'P:171', 'F:8']
dict_values(['We call this pseudoprojective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al., 1998).'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.', 'Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.', 'The first thing to note is that projectivizing helps in itself, even if no encoding is used, as seen from the fact that the projective baseline outperforms the non-projective training condition by more than half a percentage point on attachment score, although the gain is much smaller with respect to exact match.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00180', '(95%-conf.int.', '0.00180', '-', '0.00180)']
['system', 'ROUGE-S*', 'Average_P:', '0.09091', '(95%-conf.int.', '0.09091', '-', '0.09091)']
['system', 'ROUGE-S*', 'Average_F:', '0.00353', '(95%-conf.int.', '0.00353', '-', '0.00353)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:55', 'F:5']
dict_values(['The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.'])
dict_values(['First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.', 'Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).', 'The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.', 'Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).'])
['system', 'ROUGE-S*', 'Average_R:', '0.11921', '(95%-conf.int.', '0.11921', '-', '0.11921)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.21302', '(95%-conf.int.', '0.21302', '-', '0.21302)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:6216', 'P:741', 'F:741']
dict_values(['We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.', 'First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01988', '(95%-conf.int.', '0.01988', '-', '0.01988)']
['system', 'ROUGE-S*', 'Average_P:', '0.45714', '(95%-conf.int.', '0.45714', '-', '0.45714)']
['system', 'ROUGE-S*', 'Average_F:', '0.03810', '(95%-conf.int.', '0.03810', '-', '0.03810)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:105', 'F:48']
dict_values(['While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.', 'In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.', 'However, since we want to preserve as much of the original structure as possible, we are interested in finding a transformation that involves a minimal number of lifts.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00218', '(95%-conf.int.', '0.00218', '-', '0.00218)']
['system', 'ROUGE-S*', 'Average_P:', '0.03297', '(95%-conf.int.', '0.03297', '-', '0.03297)']
['system', 'ROUGE-S*', 'Average_F:', '0.00408', '(95%-conf.int.', '0.00408', '-', '0.00408)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:91', 'F:3']
dict_values(['In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'In section 2 we introduce the graph transformation techniques used to projectivize and deprojectivize dependency graphs, and in section 3 we describe the data-driven dependency parser that is the core of our system.', 'We then evaluate the approach in two steps.', 'Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01075', '(95%-conf.int.', '0.01075', '-', '0.01075)']
['system', 'ROUGE-S*', 'Average_P:', '0.23077', '(95%-conf.int.', '0.23077', '-', '0.23077)']
['system', 'ROUGE-S*', 'Average_F:', '0.02055', '(95%-conf.int.', '0.02055', '-', '0.02055)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:91', 'F:21']
0.33045937293462885 0.026627499833578126 0.04846437469709765





input/ref/Task1/P05-1013_swastika.csv
input/res/Task1/P05-1013.annv3.csv
parsing: input/ref/Task1/P05-1013_swastika.csv
<S sid="49" ssid="20">The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.</S>
original cit marker offset is 0
new cit marker offset is 0



['49']
49
['49']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
parsed_discourse_facet ['method_citation']
<S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



['95']
95
['95']
parsed_discourse_facet ['result_citation']
<S sid="79" ssid="6">In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.</S>
original cit marker offset is 0
new cit marker offset is 0



['79']
79
['79']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
parsed_discourse_facet ['result_citation']
<S sid="38" ssid="9">Projectivizing a dependency graph by lifting nonprojective arcs is a nondeterministic operation in the general case.</S>
original cit marker offset is 0
new cit marker offset is 0



['38']
38
['38']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
parsed_discourse_facet ['result_citation']
<S sid="79" ssid="6">In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.</S>
original cit marker offset is 0
new cit marker offset is 0



['79']
79
['79']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
parsed_discourse_facet ['result_citation']
S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
Error in Reference Offset
S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
Error in Reference Offset
    <S sid="86" ssid="13">As expected, the most informative encoding, Head+Path, gives the highest accuracy with over 99% of all non-projective arcs being recovered correctly in both data sets.</S>
original cit marker offset is 0
new cit marker offset is 0



['86']
86
['86']
parsed_discourse_facet ['method_citation']
<S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



['95']
95
['95']
parsed_discourse_facet ['method_citation']
<S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



['109']
109
['109']
parsed_discourse_facet ['result_citation']
 <S sid="51" ssid="22">In the second scheme, Head+Path, we in addition modify the label of every arc along the lifting path from the syntactic to the linear head so that if the original label is p the new label is p&#8595;.</S>
original cit marker offset is 0
new cit marker offset is 0



['51']
51
['51']
parsed_discourse_facet ['method_citation']
<S sid="99" ssid="10">This may seem surprising, given the experiments reported in section 4, but the explanation is probably that the non-projective dependencies that can be recovered at all are of the simple kind that only requires a single lift, where the encoding of path information is often redundant.</S>
original cit marker offset is 0
new cit marker offset is 0



['99']
99
['99']
parsed_discourse_facet ['result_citation']
<S sid="7" ssid="3">From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S>
original cit marker offset is 0
new cit marker offset is 0



['2']
2
['2']
parsed_discourse_facet ['aim_citation']
parsing: input/res/Task1/P05-1013.annv3.csv
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="61" ssid="32">Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'61'", "'62'", "'109'"]
'2'
'61'
'62'
'109'
['2', '61', '62', '109']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'62'", "'109'"]
'1'
'9'
'62'
'109'
['1', '9', '62', '109']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="3" ssid="3">Experiments using data from the Prague Dependency Treebank show that the combined system can handle nonprojective constructions with a precision sufficient to yield a significant improvement in overall parsing accuracy.</S><S sid="19" ssid="15">Finally, since non-projective constructions often involve long-distance dependencies, the problem is closely related to the recovery of empty categories and non-local dependencies in constituency-based parsing (Johnson, 2002; Dienes and Dubey, 2003; Jijkoun and de Rijke, 2004; Cahill et al., 2004; Levy and Manning, 2004; Campbell, 2004).</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'19'", "'20'"]
'2'
'3'
'19'
'20'
['2', '3', '19', '20']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'17'", "'21'"]
'1'
'2'
'17'
'21'
['1', '2', '17', '21']
parsed_discourse_facet ['results_citation']
<S sid="0">Pseudo-Projective Dependency Parsing</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'27'", "'109'"]
'0'
'2'
'27'
'109'
['0', '2', '27', '109']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'37'", "'50'", "'104'"]
'22'
'37'
'50'
'104'
['22', '37', '50', '104']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="40" ssid="11">Even this may be nondeterministic, in case the graph contains several non-projective arcs whose lifts interact, but we use the following algorithm to construct a minimal projective transformation D0 = (W, A0) of a (nonprojective) dependency graph D = (W, A): The function SMALLEST-NONP-ARC returns the non-projective arc with the shortest distance from head to dependent (breaking ties from left to right).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'40'"]
'2'
'20'
'21'
'40'
['2', '20', '21', '40']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.</S><S sid="36" ssid="7">As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'36'", "'37'", "'50'"]
'22'
'36'
'37'
'50'
['22', '36', '37', '50']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="107" ssid="18">Compared to related work on the recovery of long-distance dependencies in constituency-based parsing, our approach is similar to that of Dienes and Dubey (2003) in that the processing of non-local dependencies is partly integrated in the parsing process, via an extension of the set of syntactic categories, whereas most other approaches rely on postprocessing only.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'21'", "'62'", "'107'"]
'2'
'21'
'62'
'107'
['2', '21', '62', '107']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="105" ssid="16">Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'17'", "'62'", "'105'"]
'9'
'17'
'62'
'105'
['9', '17', '62', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="7" ssid="3">From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.</S><S sid="12" ssid="8">Prague Dependency Treebank (Haji&#711;c et al., 2001b), Danish Dependency Treebank (Kromann, 2003), and the METU Treebank of Turkish (Oflazer et al., 2003), which generally allow annotations with nonprojective dependency structures.</S><S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'7'", "'12'", "'95'"]
'2'
'7'
'12'
'95'
['2', '7', '12', '95']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="23" ssid="19">By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.</S><S sid="61" ssid="32">Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.</S><S sid="94" ssid="5">The first thing to note is that projectivizing helps in itself, even if no encoding is used, as seen from the fact that the projective baseline outperforms the non-projective training condition by more than half a percentage point on attachment score, although the gain is much smaller with respect to exact match.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'23'", "'61'", "'94'"]
'1'
'23'
'61'
'94'
['1', '23', '61', '94']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">Pseudo-Projective Dependency Parsing</S><S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="8" ssid="4">Thus, most broad-coverage parsers based on dependency grammar have been restricted to projective structures.</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'8'", "'104'"]
'0'
'1'
'8'
'104'
['0', '1', '8', '104']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="13" ssid="9">The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'21'", "'27'", "'62'"]
'13'
'21'
'27'
'62'
['13', '21', '27', '62']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'104'", "'109'"]
'1'
'2'
'104'
'109'
['1', '2', '104', '109']
parsed_discourse_facet ['results_citation']
<S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="49" ssid="20">The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'37'", "'49'", "'50'"]
'21'
'37'
'49'
'50'
['21', '37', '49', '50']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'17'", "'21'"]
'1'
'2'
'17'
'21'
['1', '2', '17', '21']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="13" ssid="9">The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S><S sid="39" ssid="10">However, since we want to preserve as much of the original structure as possible, we are interested in finding a transformation that involves a minimal number of lifts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'13'", "'20'", "'39'"]
'2'
'13'
'20'
'39'
['2', '13', '20', '39']
parsed_discourse_facet ['hypothesis_citation']
<S sid="14" ssid="10">While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.</S><S sid="79" ssid="6">In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.</S><S sid="92" ssid="3">Evaluation metrics used are Attachment Score (AS), i.e. the proportion of tokens that are attached to the correct head, and Exact Match (EM), i.e. the proportion of sentences for which the dependency graph exactly matches the gold standard.</S><S sid="106" ssid="17">However, the accuracy is considerably higher than previously reported results for robust non-projective parsing of Czech, with a best performance of 73% UAS (Holan, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'14'", "'79'", "'92'", "'106'"]
'14'
'79'
'92'
'106'
['14', '79', '92', '106']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="26" ssid="22">In section 2 we introduce the graph transformation techniques used to projectivize and deprojectivize dependency graphs, and in section 3 we describe the data-driven dependency parser that is the core of our system.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="105" ssid="16">Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'26'", "'27'", "'105'"]
'1'
'26'
'27'
'105'
['1', '26', '27', '105']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.', 'In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).', 'We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01093', '(95%-conf.int.', '0.01093', '-', '0.01093)']
['system', 'ROUGE-S*', 'Average_P:', '0.02699', '(95%-conf.int.', '0.02699', '-', '0.02699)']
['system', 'ROUGE-S*', 'Average_F:', '0.01556', '(95%-conf.int.', '0.01556', '-', '0.01556)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:741', 'F:20']
dict_values(['We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).', 'In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).', 'We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03497', '(95%-conf.int.', '0.03497', '-', '0.03497)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.06757', '(95%-conf.int.', '0.06757', '-', '0.06757)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:105', 'F:105']
dict_values(['The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'Experiments using data from the Prague Dependency Treebank show that the combined system can handle nonprojective constructions with a precision sufficient to yield a significant improvement in overall parsing accuracy.', 'Finally, since non-projective constructions often involve long-distance dependencies, the problem is closely related to the recovery of empty categories and non-local dependencies in constituency-based parsing (Johnson, 2002; Dienes and Dubey, 2003; Jijkoun and de Rijke, 2004; Cahill et al., 2004; Levy and Manning, 2004; Campbell, 2004).', 'In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00241', '(95%-conf.int.', '0.00241', '-', '0.00241)']
['system', 'ROUGE-S*', 'Average_P:', '0.05882', '(95%-conf.int.', '0.05882', '-', '0.05882)']
['system', 'ROUGE-S*', 'Average_F:', '0.00463', '(95%-conf.int.', '0.00463', '-', '0.00463)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3321', 'P:136', 'F:8']
dict_values(['In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.', 'First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00166', '(95%-conf.int.', '0.00166', '-', '0.00166)']
['system', 'ROUGE-S*', 'Average_P:', '0.08889', '(95%-conf.int.', '0.08889', '-', '0.08889)']
['system', 'ROUGE-S*', 'Average_F:', '0.00325', '(95%-conf.int.', '0.00325', '-', '0.00325)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:45', 'F:4']
dict_values(['We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
dict_values(['Pseudo-Projective Dependency Parsing', 'We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'We then evaluate the approach in two steps.', 'We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
['system', 'ROUGE-S*', 'Average_R:', '0.15766', '(95%-conf.int.', '0.15766', '-', '0.15766)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.27237', '(95%-conf.int.', '0.27237', '-', '0.27237)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:666', 'P:105', 'F:105']
dict_values(['Projectivizing a dependency graph by lifting nonprojective arcs is a nondeterministic operation in the general case.'])
dict_values(['When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.', 'Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).', 'Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).', 'The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00443', '(95%-conf.int.', '0.00443', '-', '0.00443)']
['system', 'ROUGE-S*', 'Average_P:', '0.31111', '(95%-conf.int.', '0.31111', '-', '0.31111)']
['system', 'ROUGE-S*', 'Average_F:', '0.00874', '(95%-conf.int.', '0.00874', '-', '0.00874)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3160', 'P:45', 'F:14']
dict_values(['We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.', 'First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.', 'Even this may be nondeterministic, in case the graph contains several non-projective arcs whose lifts interact, but we use the following algorithm to construct a minimal projective transformation D0 = (W, A0) of a (nonprojective) dependency graph D = (W, A): The function SMALLEST-NONP-ARC returns the non-projective arc with the shortest distance from head to dependent (breaking ties from left to right).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01665', '(95%-conf.int.', '0.01665', '-', '0.01665)']
['system', 'ROUGE-S*', 'Average_P:', '0.47619', '(95%-conf.int.', '0.47619', '-', '0.47619)']
['system', 'ROUGE-S*', 'Average_F:', '0.03218', '(95%-conf.int.', '0.03218', '-', '0.03218)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:105', 'F:50']
dict_values(['In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.'])
dict_values(['When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.', 'As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.', 'Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).', 'Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00062', '(95%-conf.int.', '0.00062', '-', '0.00062)']
['system', 'ROUGE-S*', 'Average_P:', '0.06667', '(95%-conf.int.', '0.06667', '-', '0.06667)']
['system', 'ROUGE-S*', 'Average_F:', '0.00123', '(95%-conf.int.', '0.00123', '-', '0.00123)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4851', 'P:45', 'F:3']
dict_values(['We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.', 'In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).', 'Compared to related work on the recovery of long-distance dependencies in constituency-based parsing, our approach is similar to that of Dienes and Dubey (2003) in that the processing of non-local dependencies is partly integrated in the parsing process, via an extension of the set of syntactic categories, whereas most other approaches rely on postprocessing only.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01457', '(95%-conf.int.', '0.01457', '-', '0.01457)']
['system', 'ROUGE-S*', 'Average_P:', '0.49524', '(95%-conf.int.', '0.49524', '-', '0.49524)']
['system', 'ROUGE-S*', 'Average_F:', '0.02830', '(95%-conf.int.', '0.02830', '-', '0.02830)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3570', 'P:105', 'F:52']
no Reference Text in gold P05-1013
no Reference Text in gold P05-1013
dict_values(['In the second scheme, Head+Path, we in addition modify the label of every arc along the lifting path from the syntactic to the linear head so that if the original label is p the new label is p&#8595;.'])
dict_values(['First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.', 'Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).', 'The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.', 'Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00692', '(95%-conf.int.', '0.00692', '-', '0.00692)']
['system', 'ROUGE-S*', 'Average_P:', '0.35833', '(95%-conf.int.', '0.35833', '-', '0.35833)']
['system', 'ROUGE-S*', 'Average_F:', '0.01357', '(95%-conf.int.', '0.01357', '-', '0.01357)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:6216', 'P:120', 'F:43']
dict_values(['This may seem surprising, given the experiments reported in section 4, but the explanation is probably that the non-projective dependencies that can be recovered at all are of the simple kind that only requires a single lift, where the encoding of path information is often redundant.'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.', 'First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00414', '(95%-conf.int.', '0.00414', '-', '0.00414)']
['system', 'ROUGE-S*', 'Average_P:', '0.06536', '(95%-conf.int.', '0.06536', '-', '0.06536)']
['system', 'ROUGE-S*', 'Average_F:', '0.00779', '(95%-conf.int.', '0.00779', '-', '0.00779)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:153', 'F:10']
dict_values(['From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.', 'In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.', 'However, since we want to preserve as much of the original structure as possible, we are interested in finding a transformation that involves a minimal number of lifts.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00435', '(95%-conf.int.', '0.00435', '-', '0.00435)']
['system', 'ROUGE-S*', 'Average_P:', '0.04412', '(95%-conf.int.', '0.04412', '-', '0.04412)']
['system', 'ROUGE-S*', 'Average_F:', '0.00793', '(95%-conf.int.', '0.00793', '-', '0.00793)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:136', 'F:6']
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'In section 2 we introduce the graph transformation techniques used to projectivize and deprojectivize dependency graphs, and in section 3 we describe the data-driven dependency parser that is the core of our system.', 'We then evaluate the approach in two steps.', 'Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00870', '(95%-conf.int.', '0.00870', '-', '0.00870)']
['system', 'ROUGE-S*', 'Average_P:', '0.16190', '(95%-conf.int.', '0.16190', '-', '0.16190)']
['system', 'ROUGE-S*', 'Average_F:', '0.01652', '(95%-conf.int.', '0.01652', '-', '0.01652)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:105', 'F:17']
0.31950922831146744 0.020616153687568046 0.03689538433157397





input/ref/Task1/P05-1013_vardha.csv
input/res/Task1/P05-1013.annv3.csv
parsing: input/ref/Task1/P05-1013_vardha.csv
 <S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
  <S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
    <S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
  <S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
    <S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'109'"]
'109'
['109']
parsed_discourse_facet ['method_citation']
 <S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



["'95'"]
'95'
['95']
parsed_discourse_facet ['method_citation']
    <S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'"]
'20'
['20']
parsed_discourse_facet ['method_citation']
    <S sid="36" ssid="7">As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
 <S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'62'"]
'62'
['62']
parsed_discourse_facet ['method_citation']
 <S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
    <S sid="23" ssid="19">By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'"]
'23'
['23']
parsed_discourse_facet ['method_citation']
 <S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
 <S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



["'95'"]
'95'
['95']
parsed_discourse_facet ['method_citation']
    <S sid="96" ssid="7">With respect to exact match, the improvement is even more noticeable, which shows quite clearly that even if non-projective dependencies are rare on the token level, they are nevertheless important for getting the global syntactic structure correct.</S>
original cit marker offset is 0
new cit marker offset is 0



["'96'"]
'96'
['96']
parsed_discourse_facet ['method_citation']
 <S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



["'95'"]
'95'
['95']
parsed_discourse_facet ['method_citation']
  <S sid="40" ssid="11">Even this may be nondeterministic, in case the graph contains several non-projective arcs whose lifts interact, but we use the following algorithm to construct a minimal projective transformation D0 = (W, A0) of a (nonprojective) dependency graph D = (W, A): The function SMALLEST-NONP-ARC returns the non-projective arc with the shortest distance from head to dependent (breaking ties from left to right).</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'"]
'40'
['40']
parsed_discourse_facet ['method_citation']
  <S sid="7" ssid="3">From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'"]
'7'
['7']
parsed_discourse_facet ['method_citation']
    <S sid="14" ssid="10">While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.</S>
original cit marker offset is 0
new cit marker offset is 0



["'14'"]
'14'
['14']
parsed_discourse_facet ['method_citation']
 <S sid="49" ssid="20">The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.</S>
original cit marker offset is 0
new cit marker offset is 0



["'49'"]
'49'
['49']
parsed_discourse_facet ['method_citation']
 <S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P05-1013.annv3.csv
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="61" ssid="32">Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'61'", "'62'", "'109'"]
'2'
'61'
'62'
'109'
['2', '61', '62', '109']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'62'", "'109'"]
'1'
'9'
'62'
'109'
['1', '9', '62', '109']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="3" ssid="3">Experiments using data from the Prague Dependency Treebank show that the combined system can handle nonprojective constructions with a precision sufficient to yield a significant improvement in overall parsing accuracy.</S><S sid="19" ssid="15">Finally, since non-projective constructions often involve long-distance dependencies, the problem is closely related to the recovery of empty categories and non-local dependencies in constituency-based parsing (Johnson, 2002; Dienes and Dubey, 2003; Jijkoun and de Rijke, 2004; Cahill et al., 2004; Levy and Manning, 2004; Campbell, 2004).</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'19'", "'20'"]
'2'
'3'
'19'
'20'
['2', '3', '19', '20']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'17'", "'21'"]
'1'
'2'
'17'
'21'
['1', '2', '17', '21']
parsed_discourse_facet ['results_citation']
<S sid="0">Pseudo-Projective Dependency Parsing</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'27'", "'109'"]
'0'
'2'
'27'
'109'
['0', '2', '27', '109']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'37'", "'50'", "'104'"]
'22'
'37'
'50'
'104'
['22', '37', '50', '104']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="40" ssid="11">Even this may be nondeterministic, in case the graph contains several non-projective arcs whose lifts interact, but we use the following algorithm to construct a minimal projective transformation D0 = (W, A0) of a (nonprojective) dependency graph D = (W, A): The function SMALLEST-NONP-ARC returns the non-projective arc with the shortest distance from head to dependent (breaking ties from left to right).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'40'"]
'2'
'20'
'21'
'40'
['2', '20', '21', '40']
parsed_discourse_facet ['hypothesis_citation']
<S sid="22" ssid="18">When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.</S><S sid="36" ssid="7">As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'", "'36'", "'37'", "'50'"]
'22'
'36'
'37'
'50'
['22', '36', '37', '50']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="107" ssid="18">Compared to related work on the recovery of long-distance dependencies in constituency-based parsing, our approach is similar to that of Dienes and Dubey (2003) in that the processing of non-local dependencies is partly integrated in the parsing process, via an extension of the set of syntactic categories, whereas most other approaches rely on postprocessing only.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'21'", "'62'", "'107'"]
'2'
'21'
'62'
'107'
['2', '21', '62', '107']
parsed_discourse_facet ['aim_citation']
<S sid="9" ssid="5">This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S><S sid="105" ssid="16">Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'17'", "'62'", "'105'"]
'9'
'17'
'62'
'105'
['9', '17', '62', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="7" ssid="3">From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.</S><S sid="12" ssid="8">Prague Dependency Treebank (Haji&#711;c et al., 2001b), Danish Dependency Treebank (Kromann, 2003), and the METU Treebank of Turkish (Oflazer et al., 2003), which generally allow annotations with nonprojective dependency structures.</S><S sid="95" ssid="6">The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'7'", "'12'", "'95'"]
'2'
'7'
'12'
'95'
['2', '7', '12', '95']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="23" ssid="19">By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.</S><S sid="61" ssid="32">Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.</S><S sid="94" ssid="5">The first thing to note is that projectivizing helps in itself, even if no encoding is used, as seen from the fact that the projective baseline outperforms the non-projective training condition by more than half a percentage point on attachment score, although the gain is much smaller with respect to exact match.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'23'", "'61'", "'94'"]
'1'
'23'
'61'
'94'
['1', '23', '61', '94']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">Pseudo-Projective Dependency Parsing</S><S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="8" ssid="4">Thus, most broad-coverage parsers based on dependency grammar have been restricted to projective structures.</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'8'", "'104'"]
'0'
'1'
'8'
'104'
['0', '1', '8', '104']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="13" ssid="9">The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="62" ssid="1">In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'21'", "'27'", "'62'"]
'13'
'21'
'27'
'62'
['13', '21', '27', '62']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="104" ssid="15">The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.</S><S sid="109" ssid="1">We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'104'", "'109'"]
'1'
'2'
'104'
'109'
['1', '2', '104', '109']
parsed_discourse_facet ['results_citation']
<S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S><S sid="37" ssid="8">Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).</S><S sid="49" ssid="20">The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.</S><S sid="50" ssid="21">Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'37'", "'49'", "'50'"]
'21'
'37'
'49'
'50'
['21', '37', '49', '50']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="17" ssid="13">There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.</S><S sid="21" ssid="17">First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'17'", "'21'"]
'1'
'2'
'17'
'21'
['1', '2', '17', '21']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.</S><S sid="13" ssid="9">The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.</S><S sid="20" ssid="16">In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.</S><S sid="39" ssid="10">However, since we want to preserve as much of the original structure as possible, we are interested in finding a transformation that involves a minimal number of lifts.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'13'", "'20'", "'39'"]
'2'
'13'
'20'
'39'
['2', '13', '20', '39']
parsed_discourse_facet ['hypothesis_citation']
<S sid="14" ssid="10">While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.</S><S sid="79" ssid="6">In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.</S><S sid="92" ssid="3">Evaluation metrics used are Attachment Score (AS), i.e. the proportion of tokens that are attached to the correct head, and Exact Match (EM), i.e. the proportion of sentences for which the dependency graph exactly matches the gold standard.</S><S sid="106" ssid="17">However, the accuracy is considerably higher than previously reported results for robust non-projective parsing of Czech, with a best performance of 73% UAS (Holan, 2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'14'", "'79'", "'92'", "'106'"]
'14'
'79'
'92'
'106'
['14', '79', '92', '106']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.</S><S sid="26" ssid="22">In section 2 we introduce the graph transformation techniques used to projectivize and deprojectivize dependency graphs, and in section 3 we describe the data-driven dependency parser that is the core of our system.</S><S sid="27" ssid="23">We then evaluate the approach in two steps.</S><S sid="105" ssid="16">Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'26'", "'27'", "'105'"]
'1'
'26'
'27'
'105'
['1', '26', '27', '105']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.', 'In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).', 'We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02732', '(95%-conf.int.', '0.02732', '-', '0.02732)']
['system', 'ROUGE-S*', 'Average_P:', '0.54945', '(95%-conf.int.', '0.54945', '-', '0.54945)']
['system', 'ROUGE-S*', 'Average_F:', '0.05206', '(95%-conf.int.', '0.05206', '-', '0.05206)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:91', 'F:50']
dict_values(['This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).', 'In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).', 'We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
['system', 'ROUGE-S*', 'Average_R:', '0.12587', '(95%-conf.int.', '0.12587', '-', '0.12587)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.22360', '(95%-conf.int.', '0.22360', '-', '0.22360)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:378', 'F:378']
dict_values(['The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'Experiments using data from the Prague Dependency Treebank show that the combined system can handle nonprojective constructions with a precision sufficient to yield a significant improvement in overall parsing accuracy.', 'Finally, since non-projective constructions often involve long-distance dependencies, the problem is closely related to the recovery of empty categories and non-local dependencies in constituency-based parsing (Johnson, 2002; Dienes and Dubey, 2003; Jijkoun and de Rijke, 2004; Cahill et al., 2004; Levy and Manning, 2004; Campbell, 2004).', 'In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00301', '(95%-conf.int.', '0.00301', '-', '0.00301)']
['system', 'ROUGE-S*', 'Average_P:', '0.27778', '(95%-conf.int.', '0.27778', '-', '0.27778)']
['system', 'ROUGE-S*', 'Average_F:', '0.00596', '(95%-conf.int.', '0.00596', '-', '0.00596)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3321', 'P:36', 'F:10']
dict_values(['The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.', 'First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00248', '(95%-conf.int.', '0.00248', '-', '0.00248)']
['system', 'ROUGE-S*', 'Average_P:', '0.16667', '(95%-conf.int.', '0.16667', '-', '0.16667)']
['system', 'ROUGE-S*', 'Average_F:', '0.00490', '(95%-conf.int.', '0.00490', '-', '0.00490)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:36', 'F:6']
dict_values(['We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
dict_values(['Pseudo-Projective Dependency Parsing', 'We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'We then evaluate the approach in two steps.', 'We have presented a new method for non-projective dependency parsing, based on a combination of data-driven projective dependency parsing and graph transformation techniques.'])
['system', 'ROUGE-S*', 'Average_R:', '0.15766', '(95%-conf.int.', '0.15766', '-', '0.15766)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.27237', '(95%-conf.int.', '0.27237', '-', '0.27237)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:666', 'P:105', 'F:105']
dict_values(['The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.'])
dict_values(['When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.', 'Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).', 'Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).', 'The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00222', '(95%-conf.int.', '0.00222', '-', '0.00222)']
['system', 'ROUGE-S*', 'Average_P:', '0.05147', '(95%-conf.int.', '0.05147', '-', '0.05147)']
['system', 'ROUGE-S*', 'Average_F:', '0.00425', '(95%-conf.int.', '0.00425', '-', '0.00425)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3160', 'P:136', 'F:7']
dict_values(['In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.', 'First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.', 'Even this may be nondeterministic, in case the graph contains several non-projective arcs whose lifts interact, but we use the following algorithm to construct a minimal projective transformation D0 = (W, A0) of a (nonprojective) dependency graph D = (W, A): The function SMALLEST-NONP-ARC returns the non-projective arc with the shortest distance from head to dependent (breaking ties from left to right).'])
['system', 'ROUGE-S*', 'Average_R:', '0.03030', '(95%-conf.int.', '0.03030', '-', '0.03030)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.05882', '(95%-conf.int.', '0.05882', '-', '0.05882)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:91', 'F:91']
dict_values(['As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.'])
dict_values(['When the parser is trained on the transformed data, it will ideally learn not only to construct projective dependency structures but also to assign arc labels that encode information about lifts.', 'As observed by Kahane et al. (1998), any (nonprojective) dependency graph can be transformed into a projective one by a lifting operation, which replaces each non-projective arc wj wk by a projective arc wi &#8212;* wk such that wi &#8212;*&#8727; wj holds in the original graph.', 'Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).', 'Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).'])
['system', 'ROUGE-S*', 'Average_R:', '0.07792', '(95%-conf.int.', '0.07792', '-', '0.07792)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.14458', '(95%-conf.int.', '0.14458', '-', '0.14458)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4851', 'P:378', 'F:378']
dict_values(['In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.', 'In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).', 'Compared to related work on the recovery of long-distance dependencies in constituency-based parsing, our approach is similar to that of Dienes and Dubey (2003) in that the processing of non-local dependencies is partly integrated in the parsing process, via an extension of the set of syntactic categories, whereas most other approaches rely on postprocessing only.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07087', '(95%-conf.int.', '0.07087', '-', '0.07087)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.13236', '(95%-conf.int.', '0.13236', '-', '0.13236)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3570', 'P:253', 'F:253']
dict_values(['The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.'])
dict_values(['This is true of the widely used link grammar parser for English (Sleator and Temperley, 1993), which uses a dependency grammar of sorts, the probabilistic dependency parser of Eisner (1996), and more recently proposed deterministic dependency parsers (Yamada and Matsumoto, 2003; Nivre et al., 2004).', 'There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.', 'In the experiments below, we employ a data-driven deterministic dependency parser producing labeled projective dependency graphs,3 previously tested on Swedish (Nivre et al., 2004) and English (Nivre and Scholz, 2004).', 'Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00055', '(95%-conf.int.', '0.00055', '-', '0.00055)']
['system', 'ROUGE-S*', 'Average_P:', '0.08333', '(95%-conf.int.', '0.08333', '-', '0.08333)']
['system', 'ROUGE-S*', 'Average_F:', '0.00109', '(95%-conf.int.', '0.00109', '-', '0.00109)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5460', 'P:36', 'F:3']
dict_values(['By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.', 'Prague Dependency Treebank (Haji&#711;c et al., 2001b), Danish Dependency Treebank (Kromann, 2003), and the METU Treebank of Turkish (Oflazer et al., 2003), which generally allow annotations with nonprojective dependency structures.', 'The second main result is that the pseudo-projective approach to parsing (using special arc labels to guide an inverse transformation) gives a further improvement of about one percentage point on attachment score.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02543', '(95%-conf.int.', '0.02543', '-', '0.02543)']
['system', 'ROUGE-S*', 'Average_P:', '0.13105', '(95%-conf.int.', '0.13105', '-', '0.13105)']
['system', 'ROUGE-S*', 'Average_F:', '0.04260', '(95%-conf.int.', '0.04260', '-', '0.04260)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2556', 'P:496', 'F:65']
dict_values(['The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'By applying an inverse transformation to the output of the parser, arcs with non-standard labels can be lowered to their proper place in the dependency graph, giving rise 1The dependency graph has been modified to make the final period a dependent of the main verb instead of being a dependent of a special root node for the sentence. to non-projective structures.', 'Before we turn to the evaluation, however, we need to introduce the data-driven dependency parser used in the latter experiments.', 'The first thing to note is that projectivizing helps in itself, even if no encoding is used, as seen from the fact that the projective baseline outperforms the non-projective training condition by more than half a percentage point on attachment score, although the gain is much smaller with respect to exact match.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00360', '(95%-conf.int.', '0.00360', '-', '0.00360)']
['system', 'ROUGE-S*', 'Average_P:', '0.27778', '(95%-conf.int.', '0.27778', '-', '0.27778)']
['system', 'ROUGE-S*', 'Average_F:', '0.00711', '(95%-conf.int.', '0.00711', '-', '0.00711)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:36', 'F:10']
dict_values(['Even this may be nondeterministic, in case the graph contains several non-projective arcs whose lifts interact, but we use the following algorithm to construct a minimal projective transformation D0 = (W, A0) of a (nonprojective) dependency graph D = (W, A): The function SMALLEST-NONP-ARC returns the non-projective arc with the shortest distance from head to dependent (breaking ties from left to right).'])
dict_values(['First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.', 'Here we use a slightly different notion of lift, applying to individual arcs and moving their head upwards one step at a time: Intuitively, lifting an arc makes the word wk dependent on the head wi of its original head wj (which is unique in a well-formed dependency graph), unless wj is a root in which case the operation is undefined (but then wj &#8212;* wk is necessarily projective if the dependency graph is well-formed).', 'The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.', 'Using this encoding scheme, the arc from je to Z in Figure 2 would be assigned the label AuxP&#8593;Sb (signifying an AuxP that has been lifted from a Sb).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01255', '(95%-conf.int.', '0.01255', '-', '0.01255)']
['system', 'ROUGE-S*', 'Average_P:', '0.16774', '(95%-conf.int.', '0.16774', '-', '0.16774)']
['system', 'ROUGE-S*', 'Average_F:', '0.02335', '(95%-conf.int.', '0.02335', '-', '0.02335)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:6216', 'P:465', 'F:78']
dict_values(['From the point of view of computational implementation this can be problematic, since the inclusion of non-projective structures makes the parsing problem more complex and therefore compromises efficiency and in practice also accuracy and robustness.'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'There exist a few robust broad-coverage parsers that produce non-projective dependency structures, notably Tapanainen and J&#168;arvinen (1997) and Wang and Harper (2004) for English, Foth et al. (2004) for German, and Holan (2004) for Czech.', 'First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al., 1998) and encoding information about these lifts in arc labels.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00166', '(95%-conf.int.', '0.00166', '-', '0.00166)']
['system', 'ROUGE-S*', 'Average_P:', '0.02941', '(95%-conf.int.', '0.02941', '-', '0.02941)']
['system', 'ROUGE-S*', 'Average_F:', '0.00314', '(95%-conf.int.', '0.00314', '-', '0.00314)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:136', 'F:4']
dict_values(['While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.'])
dict_values(['We show how a datadriven deterministic dependency parser, in itself restricted to projective structures, can be combined with graph transformation techniques to produce non-projective structures.', 'The fact that projective dependency parsers can never exactly reproduce the analyses found in non-projective treebanks is often neglected because of the relative scarcity of problematic constructions.', 'In this paper, we show how non-projective dependency parsing can be achieved by combining a datadriven projective parser with special graph transformation techniques.', 'However, since we want to preserve as much of the original structure as possible, we are interested in finding a transformation that involves a minimal number of lifts.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00218', '(95%-conf.int.', '0.00218', '-', '0.00218)']
['system', 'ROUGE-S*', 'Average_P:', '0.03297', '(95%-conf.int.', '0.03297', '-', '0.03297)']
['system', 'ROUGE-S*', 'Average_F:', '0.00408', '(95%-conf.int.', '0.00408', '-', '0.00408)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:91', 'F:3']
dict_values(['The baseline simply retains the original labels for all arcs, regardless of whether they have been lifted or not, and the number of distinct labels is therefore simply the number n of distinct dependency types.2 In the first encoding scheme, called Head, we use a new label d&#8593;h for each lifted arc, where d is the dependency relation between the syntactic head and the dependent in the non-projective representation, and h is the dependency relation that the syntactic head has to its own head in the underlying structure.'])
dict_values(['While the proportion of sentences containing non-projective dependencies is often 15&#8211;25%, the total proportion of non-projective arcs is normally only 1&#8211;2%.', 'In the first part of the experiment, dependency graphs from the treebanks were projectivized using the algorithm described in section 2.', 'Evaluation metrics used are Attachment Score (AS), i.e. the proportion of tokens that are attached to the correct head, and Exact Match (EM), i.e. the proportion of sentences for which the dependency graph exactly matches the gold standard.', 'However, the accuracy is considerably higher than previously reported results for robust non-projective parsing of Czech, with a best performance of 73% UAS (Holan, 2004).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01996', '(95%-conf.int.', '0.01996', '-', '0.01996)']
['system', 'ROUGE-S*', 'Average_P:', '0.04453', '(95%-conf.int.', '0.04453', '-', '0.04453)']
['system', 'ROUGE-S*', 'Average_F:', '0.02757', '(95%-conf.int.', '0.02757', '-', '0.02757)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:741', 'F:33']
dict_values(['The overall parsing accuracy obtained with the pseudo-projective approach is still lower than for the best projective parsers.'])
dict_values(['In order to realize the full potential of dependency-based syntactic parsing, it is desirable to allow non-projective dependency structures.', 'In section 2 we introduce the graph transformation techniques used to projectivize and deprojectivize dependency graphs, and in section 3 we describe the data-driven dependency parser that is the core of our system.', 'We then evaluate the approach in two steps.', 'Although the best published results for the Collins parser is 80% UAS (Collins, 1999), this parser reaches 82% when trained on the entire training data set, and an adapted version of Charniak&#8217;s parser (Charniak, 2000) performs at 84% (Jan Haji&#711;c, pers. comm.).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00358', '(95%-conf.int.', '0.00358', '-', '0.00358)']
['system', 'ROUGE-S*', 'Average_P:', '0.19444', '(95%-conf.int.', '0.19444', '-', '0.19444)']
['system', 'ROUGE-S*', 'Average_F:', '0.00704', '(95%-conf.int.', '0.00704', '-', '0.00704)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:36', 'F:7']
0.41215411522262285 0.03336235274492733 0.05969882317824221





input/ref/Task1/P08-1028_aakansha.csv
input/res/Task1/P08-1028.annv3.csv
parsing: input/ref/Task1/P08-1028_aakansha.csv
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'"]
'51'
['51']
parsed_discourse_facet ['method_citation']
<S sid="189" ssid="1">In this paper we presented a general framework for vector-based semantic composition.</S>
    <S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



["'189'", "'190'"]
'189'
'190'
['189', '190']
parsed_discourse_facet ['method_citation']
<S sid="185" ssid="19">The multiplicative model yields a better fit with the experimental data, &#961; = 0.17.</S>
    <S sid="186" ssid="20">The combined model is best overall with &#961; = 0.19.</S>
    <S sid="187" ssid="21">However, the difference between the two models is not statistically significant.</S>
original cit marker offset is 0
new cit marker offset is 0



["'185'", "'186'"]
'185'
'186'
['185', '186']
parsed_discourse_facet ['result_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'"]
'51'
['51']
parsed_discourse_facet ['method_citation']
<S sid="189" ssid="1">In this paper we presented a general framework for vector-based semantic composition.</S>
    <S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



["'189'", "'190'"]
'189'
'190'
['189', '190']
parsed_discourse_facet ['method_citation']
<S sid="48" ssid="21">The idea is to add not only the vectors representing the predicate and its argument but also the neighbors associated with both of them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'"]
'48'
['48']
parsed_discourse_facet ['method_citation']
<S sid="53" ssid="1">We formulate semantic composition as a function of two vectors, u and v. We assume that individual words are represented by vectors acquired from a corpus following any of the parametrisations that have been suggested in the literature.1 We briefly note here that a word&#8217;s vector typically represents its co-occurrence with neighboring words.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'53'", "'57'"]
'53'
'57'
['53', '57']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="16">Although the composition model in (5) is commonly used in the literature, from a linguistic perspective, the model in (6) is more appealing.</S>
    <S sid="69" ssid="17">Simply adding the vectors u and v lumps their contents together rather than allowing the content of one vector to pick out the relevant content of the other.</S>
    <S sid="70" ssid="18">Instead, it could be argued that the contribution of the ith component of u should be scaled according to its relevance to v, and vice versa.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'69'", "'70'"]
'68'
'69'
'70'
['68', '69', '70']
parsed_discourse_facet ['method_citation']
<S sid="189" ssid="1">In this paper we presented a general framework for vector-based semantic composition.</S>
    <S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



["'189'", "'190'"]
'189'
'190'
['189', '190']
parsed_discourse_facet ['method_citation']
<S sid="189" ssid="1">In this paper we presented a general framework for vector-based semantic composition.</S>
    <S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



["'189'", "'190'"]
'189'
'190'
['189', '190']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="20">In this paper we examine models of semantic composition that are empirically grounded and can represent similarity relations.</S>
    <S sid="25" ssid="21">We present a general framework for vector-based composition which allows us to consider different classes of models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'"]
'24'
'25'
['24', '25']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'"]
'64'
['64']
parsed_discourse_facet ['method_citation']
<S sid="176" ssid="10">The multiplicative and combined models yield means closer to the human ratings.</S>
    <S sid="177" ssid="11">The difference between High and Low similarity values estimated by these models are statistically significant (p &lt; 0.01 using the Wilcoxon rank sum test).</S>
original cit marker offset is 0
new cit marker offset is 0



["'176'", "'177'"]
'176'
'177'
['176', '177']
parsed_discourse_facet ['method_citation']
<S sid="191" ssid="3">Despite the popularity of additive models, our experimental results showed the superiority of models utilizing multiplicative combinations, at least for the sentence similarity task attempted here.</S>
original cit marker offset is 0
new cit marker offset is 0



["'191'"]
'191'
['191']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="20">In this paper we examine models of semantic composition that are empirically grounded and can represent similarity relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1028.annv3.csv
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S><S sid="194" ssid="6">Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'57'", "'194'"]
'51'
'52'
'57'
'194'
['51', '52', '57', '194']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">Moreover, the vector similarities within such semantic spaces have been shown to substantially correlate with human similarity judgments (McDonald, 2000) and word association norms (Denhire and Lemaire, 2004).</S><S sid="23" ssid="19">The downside of this approach is that differences in meaning are qualitative rather than quantitative, and degrees of similarity cannot be expressed easily.</S><S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S><S sid="87" ssid="35">Combining the multiplicative model with an additive model, which does not suffer from this problem, could mitigate this problem: pi = &#945;ui +&#946;vi +&#947;uivi (11) where &#945;, &#946;, and &#947; are weighting constants.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'23'", "'42'", "'87'"]
'10'
'23'
'42'
'87'
['10', '23', '42', '87']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">Central in these models is the notion of compositionality &#8212; the meaning of complex expressions is determined by the meanings of their constituent expressions and the rules used to combine them.</S><S sid="44" ssid="17">For example, assuming that individual words are represented by vectors, we can compute the meaning of a sentence by taking their mean (Foltz et al., 1998; Landauer and Dumais, 1997).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="138" ssid="51">Model Parameters Irrespectively of their form, all composition models discussed here are based on a semantic space for representing the meanings of individual words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'44'", "'51'", "'138'"]
'21'
'44'
'51'
'138'
['21', '44', '51', '138']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="26" ssid="22">Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.</S><S sid="27" ssid="23">Our results show that the multiplicative models are superior and correlate significantly with behavioral data.</S><S sid="90" ssid="3">He argues that the subjects of ran in The color ran and The horse ran select different senses of ran.</S><S sid="183" ssid="17">The weighted additive model (p = 0.09) is not significantly different from the baseline either or Kintsch (2001) (p = 0.09).</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'", "'90'", "'183'"]
'26'
'27'
'90'
'183'
['26', '27', '90', '183']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="50" ssid="23">The merits of different approaches are illustrated with a few hand picked examples and parameter values and large scale evaluations are uniformly absent (see Frank et al. (2007) for a criticism of Kintsch&#8217;s (2001) evaluation standards).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="75" ssid="23">An extreme form of this differential in the contribution of constituents is where one of the vectors, say u, contributes nothing at all to the combination: Admittedly the model in (8) is impoverished and rather simplistic, however it can serve as a simple baseline against which to compare more sophisticated models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'51'", "'52'", "'75'"]
'50'
'51'
'52'
'75'
['50', '51', '52', '75']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">In cognitive science vector-based models have been successful in simulating semantic priming (Lund and Burgess, 1996; Landauer and Dumais, 1997) and text comprehension (Landauer and Dumais, 1997; Foltz et al., 1998).</S><S sid="35" ssid="8">The tensor product u &#174; v is a matrix whose components are all the possible products uivj of the components of vectors u and v. A major difficulty with tensor products is their dimensionality which is higher than the dimensionality of the original vectors (precisely, the tensor product has dimensionality m x n).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'35'", "'52'", "'57'"]
'9'
'35'
'52'
'57'
['9', '35', '52', '57']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="1" ssid="1">This paper proposes a framework for representing the meaning of phrases and sentences in vector space.</S><S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S><S sid="43" ssid="16">Vector addition is by far the most common method for representing the meaning of linguistic sequences.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'42'", "'43'", "'57'"]
'1'
'42'
'43'
'57'
['1', '42', '43', '57']
parsed_discourse_facet ['hypothesis_citation']
<S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S><S sid="58" ssid="6">We define a general class of models for this process of composition as: The expression above allows us to derive models for which p is constructed in a distinct space from u and v, as is the case for tensor products.</S><S sid="59" ssid="7">It also allows us to derive models in which composition makes use of background knowledge K and models in which composition has a dependence, via the argument R, on syntax.</S><S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



["'57'", "'58'", "'59'", "'60'"]
'57'
'58'
'59'
'60'
['57', '58', '59', '60']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="74" ssid="22">As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'74'", "'168'"]
'51'
'52'
'74'
'168'
['51', '52', '74', '168']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">In cognitive science vector-based models have been successful in simulating semantic priming (Lund and Burgess, 1996; Landauer and Dumais, 1997) and text comprehension (Landauer and Dumais, 1997; Foltz et al., 1998).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'51'", "'52'", "'60'"]
'9'
'51'
'52'
'60'
['9', '51', '52', '60']
parsed_discourse_facet ['hypothesis_citation']
<S sid="38" ssid="11">The projection is defined in terms of circular convolution a mathematical function that compresses the tensor product of two vectors.</S><S sid="39" ssid="12">The compression is achieved by summing along the transdiagonal elements of the tensor product.</S><S sid="65" ssid="13">So, if we assume that only the ith components of u and v contribute to the ith component of p, that these components are not dependent on i, and that the function is symmetric with regard to the interchange of u and v, we obtain a simpler instantiation of an additive model: Analogously, under the same assumptions, we obtain the following simpler multiplicative model: only the ith components of u and v contribute to the ith component of p. Another class of models can be derived by relaxing this constraint.</S><S sid="194" ssid="6">Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'65'", "'194'"]
'38'
'39'
'65'
'194'
['38', '39', '65', '194']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">Central to our approach is vector composition which we operationalize in terms of additive and multiplicative functions.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S><S sid="174" ssid="8">The simple additive model fails to distinguish between High and Low Similarity items.</S><S sid="191" ssid="3">Despite the popularity of additive models, our experimental results showed the superiority of models utilizing multiplicative combinations, at least for the sentence similarity task attempted here.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'168'", "'174'", "'191'"]
'2'
'168'
'174'
'191'
['2', '168', '174', '191']
parsed_discourse_facet ['hypothesis_citation']
<S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S><S sid="156" ssid="69">This yielded a weighted sum consisting of 95% verb, 0% noun and 5% of their multiplicative combination.</S><S sid="174" ssid="8">The simple additive model fails to distinguish between High and Low Similarity items.</S><S sid="176" ssid="10">The multiplicative and combined models yield means closer to the human ratings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'156'", "'174'", "'176'"]
'64'
'156'
'174'
'176'
['64', '156', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="22">Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.</S><S sid="99" ssid="12">In order to establish an independent measure of sentence similarity, we assembled a set of experimental materials and elicited similarity ratings from human subjects.</S><S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S><S sid="172" ssid="6">Here, we are interested in relative differences, since the two types of ratings correspond to different scales.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'99'", "'163'", "'172'"]
'26'
'99'
'163'
'172'
['26', '99', '163', '172']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="7" ssid="3">A variety of NLP tasks have made good use of vector-based models.</S><S sid="14" ssid="10">This is illustrated in the example below taken from Landauer et al. (1997).</S><S sid="143" ssid="56">We used WordSim353, a benchmark dataset (Finkelstein et al., 2002), consisting of relatedness judgments (on a scale of 0 to 10) for 353 word pairs.</S><S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'14'", "'143'", "'163'"]
'7'
'14'
'143'
'163'
['7', '14', '143', '163']
parsed_discourse_facet ['aim_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S><S sid="164" ssid="77">A more scrupulous evaluation requires directly correlating all the individual participants&#8217; similarity judgments with those of the models.6 We used Spearman&#8217;s p for our correlation analyses.</S><S sid="182" ssid="16">The lowest correlation (p = 0.04) is observed for the simple additive model which is not significantly different from the non-compositional baseline model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'64'", "'164'", "'182'"]
'51'
'64'
'164'
'182'
['51', '64', '164', '182']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="74" ssid="22">As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'74'", "'168'"]
'51'
'52'
'74'
'168'
['51', '52', '74', '168']
parsed_discourse_facet ['method_citation']
dict_values(['Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).'])
dict_values(['Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).', 'Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.', 'Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.', 'Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.'])
['system', 'ROUGE-S*', 'Average_R:', '0.06352', '(95%-conf.int.', '0.06352', '-', '0.06352)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.11945', '(95%-conf.int.', '0.11945', '-', '0.11945)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:105', 'F:105']
dict_values(['The multiplicative model yields a better fit with the experimental data, &#961; = 0.17.', 'The combined model is best overall with &#961; = 0.19.', 'However, the difference between the two models is not statistically significant.'])
dict_values(['Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.', 'Our results show that the multiplicative models are superior and correlate significantly with behavioral data.', 'He argues that the subjects of ran in The color ran and The horse ran select different senses of ran.', 'The weighted additive model (p = 0.09) is not significantly different from the baseline either or Kintsch (2001) (p = 0.09).'])
['system', 'ROUGE-S*', 'Average_R:', '0.03212', '(95%-conf.int.', '0.03212', '-', '0.03212)']
['system', 'ROUGE-S*', 'Average_P:', '0.18954', '(95%-conf.int.', '0.18954', '-', '0.18954)']
['system', 'ROUGE-S*', 'Average_F:', '0.05492', '(95%-conf.int.', '0.05492', '-', '0.05492)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:903', 'P:153', 'F:29']
dict_values(['Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).'])
dict_values(['The merits of different approaches are illustrated with a few hand picked examples and parameter values and large scale evaluations are uniformly absent (see Frank et al. (2007) for a criticism of Kintsch&#8217;s (2001) evaluation standards).', 'Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).', 'Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.', 'An extreme form of this differential in the contribution of constituents is where one of the vectors, say u, contributes nothing at all to the combination: Admittedly the model in (8) is impoverished and rather simplistic, however it can serve as a simple baseline against which to compare more sophisticated models.'])
['system', 'ROUGE-S*', 'Average_R:', '0.04749', '(95%-conf.int.', '0.04749', '-', '0.04749)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.09067', '(95%-conf.int.', '0.09067', '-', '0.09067)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2211', 'P:105', 'F:105']
dict_values(['The idea is to add not only the vectors representing the predicate and its argument but also the neighbors associated with both of them.'])
dict_values(['This paper proposes a framework for representing the meaning of phrases and sentences in vector space.', 'This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.', 'Vector addition is by far the most common method for representing the meaning of linguistic sequences.', 'Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00106', '(95%-conf.int.', '0.00106', '-', '0.00106)']
['system', 'ROUGE-S*', 'Average_P:', '0.04762', '(95%-conf.int.', '0.04762', '-', '0.04762)']
['system', 'ROUGE-S*', 'Average_F:', '0.00207', '(95%-conf.int.', '0.00207', '-', '0.00207)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:946', 'P:21', 'F:1']
dict_values(['Although the composition model in (5) is commonly used in the literature, from a linguistic perspective, the model in (6) is more appealing.', 'Simply adding the vectors u and v lumps their contents together rather than allowing the content of one vector to pick out the relevant content of the other.', 'Instead, it could be argued that the contribution of the ith component of u should be scaled according to its relevance to v, and vice versa.'])
dict_values(['Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).', 'Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.', 'As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.', 'These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00215', '(95%-conf.int.', '0.00215', '-', '0.00215)']
['system', 'ROUGE-S*', 'Average_P:', '0.02463', '(95%-conf.int.', '0.02463', '-', '0.02463)']
['system', 'ROUGE-S*', 'Average_F:', '0.00395', '(95%-conf.int.', '0.00395', '-', '0.00395)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4656', 'P:406', 'F:10']
dict_values(['In this paper we presented a general framework for vector-based semantic composition.', 'We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.'])
dict_values(['The projection is defined in terms of circular convolution a mathematical function that compresses the tensor product of two vectors.', 'The compression is achieved by summing along the transdiagonal elements of the tensor product.', 'So, if we assume that only the ith components of u and v contribute to the ith component of p, that these components are not dependent on i, and that the function is symmetric with regard to the interchange of u and v, we obtain a simpler instantiation of an additive model: Analogously, under the same assumptions, we obtain the following simpler multiplicative model: only the ith components of u and v contribute to the ith component of p. Another class of models can be derived by relaxing this constraint.', 'Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00886', '(95%-conf.int.', '0.00886', '-', '0.00886)']
['system', 'ROUGE-S*', 'Average_P:', '0.13971', '(95%-conf.int.', '0.13971', '-', '0.13971)']
['system', 'ROUGE-S*', 'Average_F:', '0.01666', '(95%-conf.int.', '0.01666', '-', '0.01666)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:136', 'F:19']
dict_values(['The multiplicative and combined models yield means closer to the human ratings.', 'The difference between High and Low similarity values estimated by these models are statistically significant (p &lt; 0.01 using the Wilcoxon rank sum test).'])
dict_values(['Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.', 'In order to establish an independent measure of sentence similarity, we assembled a set of experimental materials and elicited similarity ratings from human subjects.', 'We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).', 'Here, we are interested in relative differences, since the two types of ratings correspond to different scales.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03092', '(95%-conf.int.', '0.03092', '-', '0.03092)']
['system', 'ROUGE-S*', 'Average_P:', '0.11594', '(95%-conf.int.', '0.11594', '-', '0.11594)']
['system', 'ROUGE-S*', 'Average_F:', '0.04882', '(95%-conf.int.', '0.04882', '-', '0.04882)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:276', 'F:32']
dict_values(['In this paper we examine models of semantic composition that are empirically grounded and can represent similarity relations.'])
dict_values(['Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).', 'Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.', 'As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.', 'These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00064', '(95%-conf.int.', '0.00064', '-', '0.00064)']
['system', 'ROUGE-S*', 'Average_P:', '0.06667', '(95%-conf.int.', '0.06667', '-', '0.06667)']
['system', 'ROUGE-S*', 'Average_F:', '0.00128', '(95%-conf.int.', '0.00128', '-', '0.00128)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4656', 'P:45', 'F:3']
0.32301374596232824 0.02334499970818751 0.04222749947215627





input/ref/Task1/P08-1028_swastika.csv
input/res/Task1/P08-1028.annv3.csv
parsing: input/ref/Task1/P08-1028_swastika.csv
<S sid="21" ssid="17">Central in these models is the notion of compositionality &#8212; the meaning of complex expressions is determined by the meanings of their constituent expressions and the rules used to combine them.</S>
original cit marker offset is 0
new cit marker offset is 0



['21']
21
['21']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="23">Our results show that the multiplicative models are superior and correlate significantly with behavioral data.</S>
original cit marker offset is 0
new cit marker offset is 0



['27']
27
['27']
parsed_discourse_facet ['result_citation']
<S sid="189" ssid="1">In this paper we presented a general framework for vector-based semantic composition.</S>
original cit marker offset is 0
new cit marker offset is 0



['189']
189
['189']
parsed_discourse_facet ['aim_citation']
<S sid="53" ssid="1">We formulate semantic composition as a function of two vectors, u and v. We assume that individual words are represented by vectors acquired from a corpus following any of the parametrisations that have been suggested in the literature.1 We briefly note here that a word&#8217;s vector typically represents its co-occurrence with neighboring words.</S>
original cit marker offset is 0
new cit marker offset is 0



['53']
53
['53']
parsed_discourse_facet ['method_citation']
<S sid="76" ssid="24">The models considered so far assume that components do not &#8216;interfere&#8217; with each other, i.e., that It is also possible to re-introduce the dependence on K into the model of vector composition.</S>
original cit marker offset is 0
new cit marker offset is 0



['76']
76
['76']
parsed_discourse_facet ['method_citation']
<S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



['57']
57
['57']
parsed_discourse_facet ['method_citation']
<S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



['57']
57
['57']
parsed_discourse_facet ['method_citation']
<S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



['190']
190
['190']
parsed_discourse_facet ['result_citation']
<S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



['60']
60
['60']
parsed_discourse_facet ['method_citation']
<S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



['190']
190
['190']
parsed_discourse_facet ['result_citation']
<S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



['190']
190
['190']
parsed_discourse_facet ['result_citation']
<S sid="73" ssid="21">Relaxing the assumption of symmetry in the case of the simple additive model produces a model which weighs the contribution of the two components differently: This allows additive models to become more syntax aware, since semantically important constituents can participate more actively in the composition.</S>
original cit marker offset is 0
new cit marker offset is 0



['73']
73
['73']
parsed_discourse_facet ['result_citation']
<S sid="99" ssid="12">In order to establish an independent measure of sentence similarity, we assembled a set of experimental materials and elicited similarity ratings from human subjects.</S>
original cit marker offset is 0
new cit marker offset is 0



['99']
99
['99']
parsed_discourse_facet ['method_citation']
<S sid="189" ssid="1">In this paper we presented a general framework for vector-based semantic composition.</S>
original cit marker offset is 0
new cit marker offset is 0



['189']
189
['189']
parsed_discourse_facet ['aim_citation']
<S sid="191" ssid="3">Despite the popularity of additive models, our experimental results showed the superiority of models utilizing multiplicative combinations, at least for the sentence similarity task attempted here.</S>
original cit marker offset is 0
new cit marker offset is 0



['191']
191
['191']
parsed_discourse_facet ['result_citation']
<S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



['190']
190
['190']
parsed_discourse_facet ['result_citation']
parsing: input/res/Task1/P08-1028.annv3.csv
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S><S sid="194" ssid="6">Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'57'", "'194'"]
'51'
'52'
'57'
'194'
['51', '52', '57', '194']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">Moreover, the vector similarities within such semantic spaces have been shown to substantially correlate with human similarity judgments (McDonald, 2000) and word association norms (Denhire and Lemaire, 2004).</S><S sid="23" ssid="19">The downside of this approach is that differences in meaning are qualitative rather than quantitative, and degrees of similarity cannot be expressed easily.</S><S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S><S sid="87" ssid="35">Combining the multiplicative model with an additive model, which does not suffer from this problem, could mitigate this problem: pi = &#945;ui +&#946;vi +&#947;uivi (11) where &#945;, &#946;, and &#947; are weighting constants.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'23'", "'42'", "'87'"]
'10'
'23'
'42'
'87'
['10', '23', '42', '87']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">Central in these models is the notion of compositionality &#8212; the meaning of complex expressions is determined by the meanings of their constituent expressions and the rules used to combine them.</S><S sid="44" ssid="17">For example, assuming that individual words are represented by vectors, we can compute the meaning of a sentence by taking their mean (Foltz et al., 1998; Landauer and Dumais, 1997).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="138" ssid="51">Model Parameters Irrespectively of their form, all composition models discussed here are based on a semantic space for representing the meanings of individual words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'44'", "'51'", "'138'"]
'21'
'44'
'51'
'138'
['21', '44', '51', '138']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="26" ssid="22">Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.</S><S sid="27" ssid="23">Our results show that the multiplicative models are superior and correlate significantly with behavioral data.</S><S sid="90" ssid="3">He argues that the subjects of ran in The color ran and The horse ran select different senses of ran.</S><S sid="183" ssid="17">The weighted additive model (p = 0.09) is not significantly different from the baseline either or Kintsch (2001) (p = 0.09).</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'", "'90'", "'183'"]
'26'
'27'
'90'
'183'
['26', '27', '90', '183']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="50" ssid="23">The merits of different approaches are illustrated with a few hand picked examples and parameter values and large scale evaluations are uniformly absent (see Frank et al. (2007) for a criticism of Kintsch&#8217;s (2001) evaluation standards).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="75" ssid="23">An extreme form of this differential in the contribution of constituents is where one of the vectors, say u, contributes nothing at all to the combination: Admittedly the model in (8) is impoverished and rather simplistic, however it can serve as a simple baseline against which to compare more sophisticated models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'51'", "'52'", "'75'"]
'50'
'51'
'52'
'75'
['50', '51', '52', '75']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">In cognitive science vector-based models have been successful in simulating semantic priming (Lund and Burgess, 1996; Landauer and Dumais, 1997) and text comprehension (Landauer and Dumais, 1997; Foltz et al., 1998).</S><S sid="35" ssid="8">The tensor product u &#174; v is a matrix whose components are all the possible products uivj of the components of vectors u and v. A major difficulty with tensor products is their dimensionality which is higher than the dimensionality of the original vectors (precisely, the tensor product has dimensionality m x n).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'35'", "'52'", "'57'"]
'9'
'35'
'52'
'57'
['9', '35', '52', '57']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="1" ssid="1">This paper proposes a framework for representing the meaning of phrases and sentences in vector space.</S><S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S><S sid="43" ssid="16">Vector addition is by far the most common method for representing the meaning of linguistic sequences.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'42'", "'43'", "'57'"]
'1'
'42'
'43'
'57'
['1', '42', '43', '57']
parsed_discourse_facet ['hypothesis_citation']
<S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S><S sid="58" ssid="6">We define a general class of models for this process of composition as: The expression above allows us to derive models for which p is constructed in a distinct space from u and v, as is the case for tensor products.</S><S sid="59" ssid="7">It also allows us to derive models in which composition makes use of background knowledge K and models in which composition has a dependence, via the argument R, on syntax.</S><S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



["'57'", "'58'", "'59'", "'60'"]
'57'
'58'
'59'
'60'
['57', '58', '59', '60']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="74" ssid="22">As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'74'", "'168'"]
'51'
'52'
'74'
'168'
['51', '52', '74', '168']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">In cognitive science vector-based models have been successful in simulating semantic priming (Lund and Burgess, 1996; Landauer and Dumais, 1997) and text comprehension (Landauer and Dumais, 1997; Foltz et al., 1998).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'51'", "'52'", "'60'"]
'9'
'51'
'52'
'60'
['9', '51', '52', '60']
parsed_discourse_facet ['hypothesis_citation']
<S sid="38" ssid="11">The projection is defined in terms of circular convolution a mathematical function that compresses the tensor product of two vectors.</S><S sid="39" ssid="12">The compression is achieved by summing along the transdiagonal elements of the tensor product.</S><S sid="65" ssid="13">So, if we assume that only the ith components of u and v contribute to the ith component of p, that these components are not dependent on i, and that the function is symmetric with regard to the interchange of u and v, we obtain a simpler instantiation of an additive model: Analogously, under the same assumptions, we obtain the following simpler multiplicative model: only the ith components of u and v contribute to the ith component of p. Another class of models can be derived by relaxing this constraint.</S><S sid="194" ssid="6">Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'65'", "'194'"]
'38'
'39'
'65'
'194'
['38', '39', '65', '194']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">Central to our approach is vector composition which we operationalize in terms of additive and multiplicative functions.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S><S sid="174" ssid="8">The simple additive model fails to distinguish between High and Low Similarity items.</S><S sid="191" ssid="3">Despite the popularity of additive models, our experimental results showed the superiority of models utilizing multiplicative combinations, at least for the sentence similarity task attempted here.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'168'", "'174'", "'191'"]
'2'
'168'
'174'
'191'
['2', '168', '174', '191']
parsed_discourse_facet ['hypothesis_citation']
<S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S><S sid="156" ssid="69">This yielded a weighted sum consisting of 95% verb, 0% noun and 5% of their multiplicative combination.</S><S sid="174" ssid="8">The simple additive model fails to distinguish between High and Low Similarity items.</S><S sid="176" ssid="10">The multiplicative and combined models yield means closer to the human ratings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'156'", "'174'", "'176'"]
'64'
'156'
'174'
'176'
['64', '156', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="22">Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.</S><S sid="99" ssid="12">In order to establish an independent measure of sentence similarity, we assembled a set of experimental materials and elicited similarity ratings from human subjects.</S><S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S><S sid="172" ssid="6">Here, we are interested in relative differences, since the two types of ratings correspond to different scales.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'99'", "'163'", "'172'"]
'26'
'99'
'163'
'172'
['26', '99', '163', '172']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="7" ssid="3">A variety of NLP tasks have made good use of vector-based models.</S><S sid="14" ssid="10">This is illustrated in the example below taken from Landauer et al. (1997).</S><S sid="143" ssid="56">We used WordSim353, a benchmark dataset (Finkelstein et al., 2002), consisting of relatedness judgments (on a scale of 0 to 10) for 353 word pairs.</S><S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'14'", "'143'", "'163'"]
'7'
'14'
'143'
'163'
['7', '14', '143', '163']
parsed_discourse_facet ['aim_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S><S sid="164" ssid="77">A more scrupulous evaluation requires directly correlating all the individual participants&#8217; similarity judgments with those of the models.6 We used Spearman&#8217;s p for our correlation analyses.</S><S sid="182" ssid="16">The lowest correlation (p = 0.04) is observed for the simple additive model which is not significantly different from the non-compositional baseline model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'64'", "'164'", "'182'"]
'51'
'64'
'164'
'182'
['51', '64', '164', '182']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="74" ssid="22">As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'74'", "'168'"]
'51'
'52'
'74'
'168'
['51', '52', '74', '168']
parsed_discourse_facet ['method_citation']
dict_values(['Our results show that the multiplicative models are superior and correlate significantly with behavioral data.'])
dict_values(['Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).', 'Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.', 'Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.', 'Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00060', '(95%-conf.int.', '0.00060', '-', '0.00060)']
['system', 'ROUGE-S*', 'Average_P:', '0.02778', '(95%-conf.int.', '0.02778', '-', '0.02778)']
['system', 'ROUGE-S*', 'Average_F:', '0.00118', '(95%-conf.int.', '0.00118', '-', '0.00118)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:36', 'F:1']
dict_values(['In this paper we presented a general framework for vector-based semantic composition.'])
dict_values(['Moreover, the vector similarities within such semantic spaces have been shown to substantially correlate with human similarity judgments (McDonald, 2000) and word association norms (Denhire and Lemaire, 2004).', 'The downside of this approach is that differences in meaning are qualitative rather than quantitative, and degrees of similarity cannot be expressed easily.', 'This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.', 'Combining the multiplicative model with an additive model, which does not suffer from this problem, could mitigate this problem: pi = &#945;ui +&#946;vi +&#947;uivi (11) where &#945;, &#946;, and &#947; are weighting constants.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00056', '(95%-conf.int.', '0.00056', '-', '0.00056)']
['system', 'ROUGE-S*', 'Average_P:', '0.03571', '(95%-conf.int.', '0.03571', '-', '0.03571)']
['system', 'ROUGE-S*', 'Average_F:', '0.00111', '(95%-conf.int.', '0.00111', '-', '0.00111)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:28', 'F:1']
dict_values(['We formulate semantic composition as a function of two vectors, u and v. We assume that individual words are represented by vectors acquired from a corpus following any of the parametrisations that have been suggested in the literature.1 We briefly note here that a word&#8217;s vector typically represents its co-occurrence with neighboring words.'])
dict_values(['Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.', 'Our results show that the multiplicative models are superior and correlate significantly with behavioral data.', 'He argues that the subjects of ran in The color ran and The horse ran select different senses of ran.', 'The weighted additive model (p = 0.09) is not significantly different from the baseline either or Kintsch (2001) (p = 0.09).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:903', 'P:325', 'F:0']
dict_values(['The models considered so far assume that components do not &#8216;interfere&#8217; with each other, i.e., that It is also possible to re-introduce the dependence on K into the model of vector composition.'])
dict_values(['The merits of different approaches are illustrated with a few hand picked examples and parameter values and large scale evaluations are uniformly absent (see Frank et al. (2007) for a criticism of Kintsch&#8217;s (2001) evaluation standards).', 'Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).', 'Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.', 'An extreme form of this differential in the contribution of constituents is where one of the vectors, say u, contributes nothing at all to the combination: Admittedly the model in (8) is impoverished and rather simplistic, however it can serve as a simple baseline against which to compare more sophisticated models.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00633', '(95%-conf.int.', '0.00633', '-', '0.00633)']
['system', 'ROUGE-S*', 'Average_P:', '0.21212', '(95%-conf.int.', '0.21212', '-', '0.21212)']
['system', 'ROUGE-S*', 'Average_F:', '0.01230', '(95%-conf.int.', '0.01230', '-', '0.01230)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2211', 'P:66', 'F:14']
dict_values(['Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.'])
dict_values(['This paper proposes a framework for representing the meaning of phrases and sentences in vector space.', 'This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.', 'Vector addition is by far the most common method for representing the meaning of linguistic sequences.', 'Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.'])
['system', 'ROUGE-S*', 'Average_R:', '0.14376', '(95%-conf.int.', '0.14376', '-', '0.14376)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.25139', '(95%-conf.int.', '0.25139', '-', '0.25139)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:946', 'P:136', 'F:136']
dict_values(['We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.'])
dict_values(['Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).', 'Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.', 'As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.', 'These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00301', '(95%-conf.int.', '0.00301', '-', '0.00301)']
['system', 'ROUGE-S*', 'Average_P:', '0.38889', '(95%-conf.int.', '0.38889', '-', '0.38889)']
['system', 'ROUGE-S*', 'Average_F:', '0.00597', '(95%-conf.int.', '0.00597', '-', '0.00597)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4656', 'P:36', 'F:14']
dict_values(['We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.'])
dict_values(['The projection is defined in terms of circular convolution a mathematical function that compresses the tensor product of two vectors.', 'The compression is achieved by summing along the transdiagonal elements of the tensor product.', 'So, if we assume that only the ith components of u and v contribute to the ith component of p, that these components are not dependent on i, and that the function is symmetric with regard to the interchange of u and v, we obtain a simpler instantiation of an additive model: Analogously, under the same assumptions, we obtain the following simpler multiplicative model: only the ith components of u and v contribute to the ith component of p. Another class of models can be derived by relaxing this constraint.', 'Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00606', '(95%-conf.int.', '0.00606', '-', '0.00606)']
['system', 'ROUGE-S*', 'Average_P:', '0.36111', '(95%-conf.int.', '0.36111', '-', '0.36111)']
['system', 'ROUGE-S*', 'Average_F:', '0.01192', '(95%-conf.int.', '0.01192', '-', '0.01192)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:36', 'F:13']
dict_values(['In order to establish an independent measure of sentence similarity, we assembled a set of experimental materials and elicited similarity ratings from human subjects.'])
dict_values(['Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.', 'In order to establish an independent measure of sentence similarity, we assembled a set of experimental materials and elicited similarity ratings from human subjects.', 'We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).', 'Here, we are interested in relative differences, since the two types of ratings correspond to different scales.'])
['system', 'ROUGE-S*', 'Average_R:', '0.10145', '(95%-conf.int.', '0.10145', '-', '0.10145)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.18421', '(95%-conf.int.', '0.18421', '-', '0.18421)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:105', 'F:105']
dict_values(['We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.'])
dict_values(['Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).', 'Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.', 'As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.', 'These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00301', '(95%-conf.int.', '0.00301', '-', '0.00301)']
['system', 'ROUGE-S*', 'Average_P:', '0.38889', '(95%-conf.int.', '0.38889', '-', '0.38889)']
['system', 'ROUGE-S*', 'Average_F:', '0.00597', '(95%-conf.int.', '0.00597', '-', '0.00597)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4656', 'P:36', 'F:14']
0.3793888846734568 0.029419999673111118 0.05267222163697531





input/ref/Task1/P08-1028_sweta.csv
input/res/Task1/P08-1028.annv3.csv
parsing: input/ref/Task1/P08-1028_sweta.csv
<S sid="65" ssid="13">So, if we assume that only the ith components of u and v contribute to the ith component of p, that these components are not dependent on i, and that the function is symmetric with regard to the interchange of u and v, we obtain a simpler instantiation of an additive model: Analogously, under the same assumptions, we obtain the following simpler multiplicative model: only the ith components of u and v contribute to the ith component of p. Another class of models can be derived by relaxing this constraint.</S>
original cit marker offset is 0
new cit marker offset is 0



["65'"]
65'
['65']
parsed_discourse_facet ['method_citation']
 <S sid="75" ssid="23">An extreme form of this differential in the contribution of constituents is where one of the vectors, say u, contributes nothing at all to the combination: Admittedly the model in (8) is impoverished and rather simplistic, however it can serve as a simple baseline against which to compare more sophisticated models.</S>
original cit marker offset is 0
new cit marker offset is 0



["75'"]
75'
['75']
parsed_discourse_facet ['method_citation']
<S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S>
original cit marker offset is 0
new cit marker offset is 0



["42'"]
42'
['42']
parsed_discourse_facet ['method_citation']
 <S sid="21" ssid="17">Central in these models is the notion of compositionality &#8212; the meaning of complex expressions is determined by the meanings of their constituent expressions and the rules used to combine them.</S>
original cit marker offset is 0
new cit marker offset is 0



["21'"]
21'
['21']
parsed_discourse_facet ['method_citation']
    <S sid="195" ssid="7">The resulting vector is sparser but expresses more succinctly the meaning of the predicate-argument structure, and thus allows semantic similarity to be modelled more accurately.</S>
original cit marker offset is 0
new cit marker offset is 0



["195'"]
195'
['195']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="21">We present a general framework for vector-based composition which allows us to consider different classes of models.</S>
original cit marker offset is 0
new cit marker offset is 0



["25'"]
25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="21">We present a general framework for vector-based composition which allows us to consider different classes of models.</S>
original cit marker offset is 0
new cit marker offset is 0



["25'"]
25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["57'"]
57'
['57']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S>
original cit marker offset is 0
new cit marker offset is 0



["51'"]
51'
['51']
parsed_discourse_facet ['method_citation']
<S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



["190'"]
190'
['190']
parsed_discourse_facet ['method_citation']
 <S sid="29" ssid="2">While neural networks can readily represent single distinct objects, in the case of multiple objects there are fundamental difficulties in keeping track of which features are bound to which objects.</S>
original cit marker offset is 0
new cit marker offset is 0



["29'"]
29'
['29']
parsed_discourse_facet ['method_citation']
    <S sid="38" ssid="11">The projection is defined in terms of circular convolution a mathematical function that compresses the tensor product of two vectors.</S>
original cit marker offset is 0
new cit marker offset is 0



["38'"]
38'
['38']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S>
original cit marker offset is 0
new cit marker offset is 0



["51'"]
51'
['51']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S>
original cit marker offset is 0
new cit marker offset is 0



["64'"]
64'
['64']
parsed_discourse_facet ['method_citation']
<S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["163'"]
163'
['163']
parsed_discourse_facet ['method_citation']
<S sid="185" ssid="19">The multiplicative model yields a better fit with the experimental data, &#961; = 0.17.</S>
original cit marker offset is 0
new cit marker offset is 0



["185'"]
185'
['185']
parsed_discourse_facet ['method_citation']
<S sid="190" ssid="2">We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.</S>
original cit marker offset is 0
new cit marker offset is 0



["190'"]
190'
['190']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1028.annv3.csv
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S><S sid="194" ssid="6">Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'57'", "'194'"]
'51'
'52'
'57'
'194'
['51', '52', '57', '194']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">Moreover, the vector similarities within such semantic spaces have been shown to substantially correlate with human similarity judgments (McDonald, 2000) and word association norms (Denhire and Lemaire, 2004).</S><S sid="23" ssid="19">The downside of this approach is that differences in meaning are qualitative rather than quantitative, and degrees of similarity cannot be expressed easily.</S><S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S><S sid="87" ssid="35">Combining the multiplicative model with an additive model, which does not suffer from this problem, could mitigate this problem: pi = &#945;ui +&#946;vi +&#947;uivi (11) where &#945;, &#946;, and &#947; are weighting constants.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'23'", "'42'", "'87'"]
'10'
'23'
'42'
'87'
['10', '23', '42', '87']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">Central in these models is the notion of compositionality &#8212; the meaning of complex expressions is determined by the meanings of their constituent expressions and the rules used to combine them.</S><S sid="44" ssid="17">For example, assuming that individual words are represented by vectors, we can compute the meaning of a sentence by taking their mean (Foltz et al., 1998; Landauer and Dumais, 1997).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="138" ssid="51">Model Parameters Irrespectively of their form, all composition models discussed here are based on a semantic space for representing the meanings of individual words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'44'", "'51'", "'138'"]
'21'
'44'
'51'
'138'
['21', '44', '51', '138']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="26" ssid="22">Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.</S><S sid="27" ssid="23">Our results show that the multiplicative models are superior and correlate significantly with behavioral data.</S><S sid="90" ssid="3">He argues that the subjects of ran in The color ran and The horse ran select different senses of ran.</S><S sid="183" ssid="17">The weighted additive model (p = 0.09) is not significantly different from the baseline either or Kintsch (2001) (p = 0.09).</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'", "'90'", "'183'"]
'26'
'27'
'90'
'183'
['26', '27', '90', '183']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="50" ssid="23">The merits of different approaches are illustrated with a few hand picked examples and parameter values and large scale evaluations are uniformly absent (see Frank et al. (2007) for a criticism of Kintsch&#8217;s (2001) evaluation standards).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="75" ssid="23">An extreme form of this differential in the contribution of constituents is where one of the vectors, say u, contributes nothing at all to the combination: Admittedly the model in (8) is impoverished and rather simplistic, however it can serve as a simple baseline against which to compare more sophisticated models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'50'", "'51'", "'52'", "'75'"]
'50'
'51'
'52'
'75'
['50', '51', '52', '75']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">In cognitive science vector-based models have been successful in simulating semantic priming (Lund and Burgess, 1996; Landauer and Dumais, 1997) and text comprehension (Landauer and Dumais, 1997; Foltz et al., 1998).</S><S sid="35" ssid="8">The tensor product u &#174; v is a matrix whose components are all the possible products uivj of the components of vectors u and v. A major difficulty with tensor products is their dimensionality which is higher than the dimensionality of the original vectors (precisely, the tensor product has dimensionality m x n).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'35'", "'52'", "'57'"]
'9'
'35'
'52'
'57'
['9', '35', '52', '57']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="1" ssid="1">This paper proposes a framework for representing the meaning of phrases and sentences in vector space.</S><S sid="42" ssid="15">This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.</S><S sid="43" ssid="16">Vector addition is by far the most common method for representing the meaning of linguistic sequences.</S><S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'42'", "'43'", "'57'"]
'1'
'42'
'43'
'57'
['1', '42', '43', '57']
parsed_discourse_facet ['hypothesis_citation']
<S sid="57" ssid="5">Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.</S><S sid="58" ssid="6">We define a general class of models for this process of composition as: The expression above allows us to derive models for which p is constructed in a distinct space from u and v, as is the case for tensor products.</S><S sid="59" ssid="7">It also allows us to derive models in which composition makes use of background knowledge K and models in which composition has a dependence, via the argument R, on syntax.</S><S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



["'57'", "'58'", "'59'", "'60'"]
'57'
'58'
'59'
'60'
['57', '58', '59', '60']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="74" ssid="22">As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'74'", "'168'"]
'51'
'52'
'74'
'168'
['51', '52', '74', '168']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">In cognitive science vector-based models have been successful in simulating semantic priming (Lund and Burgess, 1996; Landauer and Dumais, 1997) and text comprehension (Landauer and Dumais, 1997; Foltz et al., 1998).</S><S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="60" ssid="8">To derive specific models from this general framework requires the identification of appropriate constraints to narrow the space of functions being considered.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'51'", "'52'", "'60'"]
'9'
'51'
'52'
'60'
['9', '51', '52', '60']
parsed_discourse_facet ['hypothesis_citation']
<S sid="38" ssid="11">The projection is defined in terms of circular convolution a mathematical function that compresses the tensor product of two vectors.</S><S sid="39" ssid="12">The compression is achieved by summing along the transdiagonal elements of the tensor product.</S><S sid="65" ssid="13">So, if we assume that only the ith components of u and v contribute to the ith component of p, that these components are not dependent on i, and that the function is symmetric with regard to the interchange of u and v, we obtain a simpler instantiation of an additive model: Analogously, under the same assumptions, we obtain the following simpler multiplicative model: only the ith components of u and v contribute to the ith component of p. Another class of models can be derived by relaxing this constraint.</S><S sid="194" ssid="6">Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'65'", "'194'"]
'38'
'39'
'65'
'194'
['38', '39', '65', '194']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">Central to our approach is vector composition which we operationalize in terms of additive and multiplicative functions.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S><S sid="174" ssid="8">The simple additive model fails to distinguish between High and Low Similarity items.</S><S sid="191" ssid="3">Despite the popularity of additive models, our experimental results showed the superiority of models utilizing multiplicative combinations, at least for the sentence similarity task attempted here.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'168'", "'174'", "'191'"]
'2'
'168'
'174'
'191'
['2', '168', '174', '191']
parsed_discourse_facet ['hypothesis_citation']
<S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S><S sid="156" ssid="69">This yielded a weighted sum consisting of 95% verb, 0% noun and 5% of their multiplicative combination.</S><S sid="174" ssid="8">The simple additive model fails to distinguish between High and Low Similarity items.</S><S sid="176" ssid="10">The multiplicative and combined models yield means closer to the human ratings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'", "'156'", "'174'", "'176'"]
'64'
'156'
'174'
'176'
['64', '156', '174', '176']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="22">Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.</S><S sid="99" ssid="12">In order to establish an independent measure of sentence similarity, we assembled a set of experimental materials and elicited similarity ratings from human subjects.</S><S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S><S sid="172" ssid="6">Here, we are interested in relative differences, since the two types of ratings correspond to different scales.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'99'", "'163'", "'172'"]
'26'
'99'
'163'
'172'
['26', '99', '163', '172']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="7" ssid="3">A variety of NLP tasks have made good use of vector-based models.</S><S sid="14" ssid="10">This is illustrated in the example below taken from Landauer et al. (1997).</S><S sid="143" ssid="56">We used WordSim353, a benchmark dataset (Finkelstein et al., 2002), consisting of relatedness judgments (on a scale of 0 to 10) for 353 word pairs.</S><S sid="163" ssid="76">We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'14'", "'143'", "'163'"]
'7'
'14'
'143'
'163'
['7', '14', '143', '163']
parsed_discourse_facet ['aim_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="64" ssid="12">Now, if we assume that p lies in the same space as u and v, avoiding the issues of dimensionality associated with tensor products, and that f is a linear function, for simplicity, of the cartesian product of u and v, then we generate a class of additive models: where A and B are matrices which determine the contributions made by u and v to the product p. In contrast, if we assume that f is a linear function of the tensor product of u and v, then we obtain multiplicative models: where C is a tensor of rank 3, which projects the tensor product of u and v onto the space of p. Further constraints can be introduced to reduce the free parameters in these models.</S><S sid="164" ssid="77">A more scrupulous evaluation requires directly correlating all the individual participants&#8217; similarity judgments with those of the models.6 We used Spearman&#8217;s p for our correlation analyses.</S><S sid="182" ssid="16">The lowest correlation (p = 0.04) is observed for the simple additive model which is not significantly different from the non-compositional baseline model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'64'", "'164'", "'182'"]
'51'
'64'
'164'
'182'
['51', '64', '164', '182']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="24">Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).</S><S sid="52" ssid="25">Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.</S><S sid="74" ssid="22">As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.</S><S sid="168" ssid="2">These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'52'", "'74'", "'168'"]
'51'
'52'
'74'
'168'
['51', '52', '74', '168']
parsed_discourse_facet ['method_citation']
dict_values(['An extreme form of this differential in the contribution of constituents is where one of the vectors, say u, contributes nothing at all to the combination: Admittedly the model in (8) is impoverished and rather simplistic, however it can serve as a simple baseline against which to compare more sophisticated models.'])
dict_values(['Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).', 'Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.', 'Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.', 'Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00786', '(95%-conf.int.', '0.00786', '-', '0.00786)']
['system', 'ROUGE-S*', 'Average_P:', '0.07602', '(95%-conf.int.', '0.07602', '-', '0.07602)']
['system', 'ROUGE-S*', 'Average_F:', '0.01425', '(95%-conf.int.', '0.01425', '-', '0.01425)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:171', 'F:13']
dict_values(['This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.'])
dict_values(['Moreover, the vector similarities within such semantic spaces have been shown to substantially correlate with human similarity judgments (McDonald, 2000) and word association norms (Denhire and Lemaire, 2004).', 'The downside of this approach is that differences in meaning are qualitative rather than quantitative, and degrees of similarity cannot be expressed easily.', 'This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.', 'Combining the multiplicative model with an additive model, which does not suffer from this problem, could mitigate this problem: pi = &#945;ui +&#946;vi +&#947;uivi (11) where &#945;, &#946;, and &#947; are weighting constants.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02542', '(95%-conf.int.', '0.02542', '-', '0.02542)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.04959', '(95%-conf.int.', '0.04959', '-', '0.04959)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:45', 'F:45']
dict_values(['The resulting vector is sparser but expresses more succinctly the meaning of the predicate-argument structure, and thus allows semantic similarity to be modelled more accurately.'])
dict_values(['Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.', 'Our results show that the multiplicative models are superior and correlate significantly with behavioral data.', 'He argues that the subjects of ran in The color ran and The horse ran select different senses of ran.', 'The weighted additive model (p = 0.09) is not significantly different from the baseline either or Kintsch (2001) (p = 0.09).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00443', '(95%-conf.int.', '0.00443', '-', '0.00443)']
['system', 'ROUGE-S*', 'Average_P:', '0.05128', '(95%-conf.int.', '0.05128', '-', '0.05128)']
['system', 'ROUGE-S*', 'Average_F:', '0.00815', '(95%-conf.int.', '0.00815', '-', '0.00815)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:903', 'P:78', 'F:4']
dict_values(['We present a general framework for vector-based composition which allows us to consider different classes of models.'])
dict_values(['The merits of different approaches are illustrated with a few hand picked examples and parameter values and large scale evaluations are uniformly absent (see Frank et al. (2007) for a criticism of Kintsch&#8217;s (2001) evaluation standards).', 'Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).', 'Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.', 'An extreme form of this differential in the contribution of constituents is where one of the vectors, say u, contributes nothing at all to the combination: Admittedly the model in (8) is impoverished and rather simplistic, however it can serve as a simple baseline against which to compare more sophisticated models.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00271', '(95%-conf.int.', '0.00271', '-', '0.00271)']
['system', 'ROUGE-S*', 'Average_P:', '0.21429', '(95%-conf.int.', '0.21429', '-', '0.21429)']
['system', 'ROUGE-S*', 'Average_F:', '0.00536', '(95%-conf.int.', '0.00536', '-', '0.00536)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2211', 'P:28', 'F:6']
dict_values(['Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.'])
dict_values(['This paper proposes a framework for representing the meaning of phrases and sentences in vector space.', 'This poses problems for modeling linguistic data which is typically represented by vectors with non-random structure.', 'Vector addition is by far the most common method for representing the meaning of linguistic sequences.', 'Let p denote the composition of two vectors u and v, representing a pair of constituents which stand in some syntactic relation R. Let K stand for any additional knowledge or information which is needed to construct the semantics of their composition.'])
['system', 'ROUGE-S*', 'Average_R:', '0.14376', '(95%-conf.int.', '0.14376', '-', '0.14376)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.25139', '(95%-conf.int.', '0.25139', '-', '0.25139)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:946', 'P:136', 'F:136']
dict_values(['We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.'])
dict_values(['Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).', 'Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.', 'As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.', 'These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00301', '(95%-conf.int.', '0.00301', '-', '0.00301)']
['system', 'ROUGE-S*', 'Average_P:', '0.38889', '(95%-conf.int.', '0.38889', '-', '0.38889)']
['system', 'ROUGE-S*', 'Average_F:', '0.00597', '(95%-conf.int.', '0.00597', '-', '0.00597)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4656', 'P:36', 'F:14']
dict_values(['The projection is defined in terms of circular convolution a mathematical function that compresses the tensor product of two vectors.'])
dict_values(['The projection is defined in terms of circular convolution a mathematical function that compresses the tensor product of two vectors.', 'The compression is achieved by summing along the transdiagonal elements of the tensor product.', 'So, if we assume that only the ith components of u and v contribute to the ith component of p, that these components are not dependent on i, and that the function is symmetric with regard to the interchange of u and v, we obtain a simpler instantiation of an additive model: Analogously, under the same assumptions, we obtain the following simpler multiplicative model: only the ith components of u and v contribute to the ith component of p. Another class of models can be derived by relaxing this constraint.', 'Importantly, additive models capture composition by considering all vector components representing the meaning of the verb and its subject, whereas multiplicative models consider a subset, namely non-zero components.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02564', '(95%-conf.int.', '0.02564', '-', '0.02564)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.05000', '(95%-conf.int.', '0.05000', '-', '0.05000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:55', 'F:55']
dict_values(['We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).'])
dict_values(['Specifically, we present both additive and multiplicative models of vector combination and assess their performance on a sentence similarity rating experiment.', 'In order to establish an independent measure of sentence similarity, we assembled a set of experimental materials and elicited similarity ratings from human subjects.', 'We expect better models to yield a pattern of similarity scores like those observed in the human ratings (see Figure 2).', 'Here, we are interested in relative differences, since the two types of ratings correspond to different scales.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05314', '(95%-conf.int.', '0.05314', '-', '0.05314)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10092', '(95%-conf.int.', '0.10092', '-', '0.10092)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:55', 'F:55']
dict_values(['We formulated composition as a function of two vectors and introduced several models based on addition and multiplication.'])
dict_values(['Our work proposes a framework for vector composition which allows the derivation of different types of models and licenses two fundamental composition operations, multiplication and addition (and their combination).', 'Under this framework, we introduce novel composition models which we compare empirically against previous work using a rigorous evaluation methodology.', 'As an example if we set &#945; to 0.4 and &#946; to 0.6, then horse= 0 2.4 0.8 4 1.6 and run = 0.6 4.8 2.4 2.4 0, and their sum horse + run = 0.6 5.6 3.2 6.4 1.6.', 'These included three additive models, i.e., simple addition (equation (5), Add), weighted addition (equation (7), WeightAdd), and Kintsch&#8217;s (2001) model (equation (10), Kintsch), a multiplicative model (equation (6), Multiply), and also a model which combines multiplication with addition (equation (11), Combined).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00301', '(95%-conf.int.', '0.00301', '-', '0.00301)']
['system', 'ROUGE-S*', 'Average_P:', '0.38889', '(95%-conf.int.', '0.38889', '-', '0.38889)']
['system', 'ROUGE-S*', 'Average_F:', '0.00597', '(95%-conf.int.', '0.00597', '-', '0.00597)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4656', 'P:36', 'F:14']
0.5688188825686791 0.029886666334592603 0.05462222161530865





input/ref/Task1/P08-1043_aakansha.csv
input/res/Task1/P08-1043.annv3.csv
parsing: input/ref/Task1/P08-1043_aakansha.csv
<S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'94'"]
'94'
['94']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'"]
'4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'"]
'4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="69" ssid="1">We represent all morphological analyses of a given utterance using a lattice structure.</S>
    <S sid="70" ssid="2">Each lattice arc corresponds to a segment and its corresponding PoS tag, and a path through the lattice corresponds to a specific morphological segmentation of the utterance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'69'", "'70'"]
'69'
'70'
['69', '70']
parsed_discourse_facet ['method_citation']
<S sid="85" ssid="17">The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.</S>
original cit marker offset is 0
new cit marker offset is 0



["'85'"]
'85'
['85']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'94'"]
'94'
['94']
parsed_discourse_facet ['method_citation']
<S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S>
    <S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training 	similar to (Cohen and Smith, 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'", "'134'"]
'133'
'134'
['133', '134']
parsed_discourse_facet ['method_citation']
<S sid="85" ssid="17">The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.</S>
original cit marker offset is 0
new cit marker offset is 0



["'85'"]
'85'
['85']
parsed_discourse_facet ['method_citation']
<S sid="155" ssid="33">Evaluation We use 8 different measures to evaluate the performance of our system on the joint disambiguation task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'155'"]
'155'
['155']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1043.annv3.csv
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="35" ssid="14">The form fmnh, for example, can be understood as the verb &#8220;lubricated&#8221;, the possessed noun &#8220;her oil&#8221;, the adjective &#8220;fat&#8221; or the verb &#8220;got fat&#8221;.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="98" ssid="30">The Grammar Our parser looks for the most likely tree spanning a single path through the lattice of which the yield is a sequence of lexemes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'35'", "'49'", "'98'"]
'33'
'35'
'49'
'98'
['33', '35', '49', '98']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity.</S><S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S><S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'4'", "'18'", "'49'"]
'3'
'4'
'18'
'49'
['3', '4', '18', '49']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S><S sid="65" ssid="12">A possible probabilistic model for assigning probabilities to complex analyses of a surface form may be and indeed recent sequential disambiguation models for Hebrew (Adler and Elhadad, 2006) and Arabic (Smith et al., 2005) present similar models.</S><S sid="82" ssid="14">In sequential tagging models such as (Adler and Elhadad, 2006; Bar-Haim et al., 2007; Smith et al., 2005) weights are assigned according to a language model The input for the joint task is a sequence W = w1, ... , wn of space-delimited tokens.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'65'", "'82'"]
'20'
'21'
'65'
'82'
['20', '21', '65', '82']
parsed_discourse_facet ['aim_citation']
<S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="52" ssid="10">Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.</S><S sid="175" ssid="13">In our model there are no such hyper-parameters, and the performance is the result of truly joint disambiguation. sults.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'20'", "'52'", "'175'"]
'18'
'20'
'52'
'175'
['18', '20', '52', '175']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S><S sid="47" ssid="5">Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'47'", "'48'", "'49'"]
'4'
'47'
'48'
'49'
['4', '47', '48', '49']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="47" ssid="5">Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'47'", "'48'", "'49'"]
'33'
'47'
'48'
'49'
['33', '47', '48', '49']
parsed_discourse_facet ['aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S><S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S><S sid="106" ssid="38">Handling Unknown tokens When handling unknown tokens in a language such as Hebrew various important aspects have to be borne in mind.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'86'", "'94'", "'106'"]
'33'
'86'
'94'
'106'
['33', '86', '94', '106']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="85" ssid="17">The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.</S><S sid="192" ssid="6">Using a wide-coverage morphological analyzer based on (Itai et al., 2006) should cater for a better coverage, and incorporating lexical probabilities learned from a big (unannotated) corpus (cf.</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'85'", "'192'", "'193'"]
'33'
'85'
'192'
'193'
['33', '85', '192', '193']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="0">A Single Generative Model for Joint Morphological Segmentation and Syntactic Parsing</S><S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S><S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'18'", "'19'", "'20'"]
'0'
'18'
'19'
'20'
['0', '18', '19', '20']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="71" ssid="3">This is by now a fairly standard representation for multiple morphological segmentation of Hebrew utterances (Adler, 2001; Bar-Haim et al., 2005; Smith et al., 2005; Cohen and Smith, 2007; Adler, 2007).</S><S sid="141" ssid="19">This analyzer setting is similar to that of (Cohen and Smith, 2007), and models using it are denoted nohsp, Parser and Grammar We used BitPar (Schmid, 2004), an efficient general purpose parser,10 together with various treebank grammars to parse the input sentences and propose compatible morphological segmentation and syntactic analysis.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'49'", "'71'", "'141'"]
'21'
'49'
'71'
'141'
['21', '49', '71', '141']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="159" ssid="37">Our parsing performance measures (SY N) thus report the PARSEVAL extension proposed in Tsarfaty (2006).</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'49'", "'159'", "'193'"]
'33'
'49'
'159'
'193'
['33', '49', '159', '193']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="151" ssid="29">In our third model GTppp we also add the distinction between general PPs and possessive PPs following Goldberg and Elhadad (2007).</S><S sid="152" ssid="30">In our forth model GTnph we add the definiteness status of constituents following Tsarfaty and Sima&#8217;an (2007).</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'151'", "'152'", "'193'"]
'33'
'151'
'152'
'193'
['33', '151', '152', '193']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="52" ssid="10">Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.</S><S sid="158" ssid="36">Evaluating parsing results in our joint framework, as argued by Tsarfaty (2006), is not trivial under the joint disambiguation task, as the hypothesized yield need not coincide with the correct one.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'48'", "'52'", "'158'"]
'20'
'48'
'52'
'158'
['20', '48', '52', '158']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="51" ssid="9">Tsarfaty (2006) used a morphological analyzer (Segal, 2000), a PoS tagger (Bar-Haim et al., 2005), and a general purpose parser (Schmid, 2000) in an integrated framework in which morphological and syntactic components interact to share information, leading to improved performance on the joint task.</S><S sid="132" ssid="10">(we ignored the 419 trees in their development set.)</S><S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S><S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'132'", "'133'", "'134'"]
'51'
'132'
'133'
'134'
['51', '132', '133', '134']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S><S sid="112" ssid="44">We first make use of our morphological analyzer to find all segmentation possibilities by chopping off all prefix sequence possibilities (including the empty prefix) and construct a lattice off of them.</S><S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S><S sid="140" ssid="18">For these models we limit the options provided for OOV words by not considering the entire token as a valid segmentation in case at least some prefix segmentation exists.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'", "'112'", "'133'", "'140'"]
'86'
'112'
'133'
'140'
['86', '112', '133', '140']
parsed_discourse_facet ['method_citation']
<S sid="123" ssid="1">Previous work on morphological and syntactic disambiguation in Hebrew used different sets of data, different splits, differing annotation schemes, and different evaluation measures.</S><S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S><S sid="154" ssid="32">For all grammars, we use fine-grained PoS tags indicating various morphological features annotated therein.</S><S sid="155" ssid="33">Evaluation We use 8 different measures to evaluate the performance of our system on the joint disambiguation task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'123'", "'134'", "'154'", "'155'"]
'123'
'134'
'154'
'155'
['123', '134', '154', '155']
parsed_discourse_facet ['results_citation']
dict_values(['Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.'])
dict_values(['The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).', 'The form fmnh, for example, can be understood as the verb &#8220;lubricated&#8221;, the possessed noun &#8220;her oil&#8221;, the adjective &#8220;fat&#8221; or the verb &#8220;got fat&#8221;.', 'Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.', 'The Grammar Our parser looks for the most likely tree spanning a single path through the lattice of which the yield is a sequence of lexemes.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00043', '(95%-conf.int.', '0.00043', '-', '0.00043)']
['system', 'ROUGE-S*', 'Average_P:', '0.00654', '(95%-conf.int.', '0.00654', '-', '0.00654)']
['system', 'ROUGE-S*', 'Average_F:', '0.00080', '(95%-conf.int.', '0.00080', '-', '0.00080)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:153', 'F:1']
dict_values(['Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.'])
dict_values(['Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity.', 'Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.', 'Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.', 'Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.14789', '(95%-conf.int.', '0.14789', '-', '0.14789)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.25767', '(95%-conf.int.', '0.25767', '-', '0.25767)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2556', 'P:378', 'F:378']
dict_values(['Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.'])
dict_values(['We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.', 'Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2', 'A possible probabilistic model for assigning probabilities to complex analyses of a surface form may be and indeed recent sequential disambiguation models for Hebrew (Adler and Elhadad, 2006) and Arabic (Smith et al., 2005) present similar models.', 'In sequential tagging models such as (Adler and Elhadad, 2006; Bar-Haim et al., 2007; Smith et al., 2005) weights are assigned according to a language model The input for the joint task is a sequence W = w1, ... , wn of space-delimited tokens.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00149', '(95%-conf.int.', '0.00149', '-', '0.00149)']
['system', 'ROUGE-S*', 'Average_P:', '0.06667', '(95%-conf.int.', '0.06667', '-', '0.06667)']
['system', 'ROUGE-S*', 'Average_F:', '0.00292', '(95%-conf.int.', '0.00292', '-', '0.00292)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5356', 'P:120', 'F:8']
dict_values(['Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.'])
dict_values(['Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.', 'We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.', 'Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.', 'In our model there are no such hyper-parameters, and the performance is the result of truly joint disambiguation. sults.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00752', '(95%-conf.int.', '0.00752', '-', '0.00752)']
['system', 'ROUGE-S*', 'Average_P:', '0.10000', '(95%-conf.int.', '0.10000', '-', '0.10000)']
['system', 'ROUGE-S*', 'Average_F:', '0.01399', '(95%-conf.int.', '0.01399', '-', '0.01399)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:120', 'F:12']
dict_values(['Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.'])
dict_values(['Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.', 'Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.', 'Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.', 'Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.12587', '(95%-conf.int.', '0.12587', '-', '0.12587)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.22360', '(95%-conf.int.', '0.22360', '-', '0.22360)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:378', 'F:378']
dict_values(['We represent all morphological analyses of a given utterance using a lattice structure.', 'Each lattice arc corresponds to a segment and its corresponding PoS tag, and a path through the lattice corresponds to a specific morphological segmentation of the utterance.'])
dict_values(['The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).', 'A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).', 'Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.', 'Handling Unknown tokens When handling unknown tokens in a language such as Hebrew various important aspects have to be borne in mind.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00877', '(95%-conf.int.', '0.00877', '-', '0.00877)']
['system', 'ROUGE-S*', 'Average_P:', '0.08772', '(95%-conf.int.', '0.08772', '-', '0.08772)']
['system', 'ROUGE-S*', 'Average_F:', '0.01594', '(95%-conf.int.', '0.01594', '-', '0.01594)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:171', 'F:15']
dict_values(['The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.'])
dict_values(['The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).', 'The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.', 'Using a wide-coverage morphological analyzer based on (Itai et al., 2006) should cater for a better coverage, and incorporating lexical probabilities learned from a big (unannotated) corpus (cf.', '(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03636', '(95%-conf.int.', '0.03636', '-', '0.03636)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.07018', '(95%-conf.int.', '0.07018', '-', '0.07018)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:78', 'F:78']
dict_values(['Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.'])
dict_values(['A Single Generative Model for Joint Morphological Segmentation and Syntactic Parsing', 'Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.', 'Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.', 'We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.'])
['system', 'ROUGE-S*', 'Average_R:', '0.08081', '(95%-conf.int.', '0.08081', '-', '0.08081)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.14953', '(95%-conf.int.', '0.14953', '-', '0.14953)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:120', 'F:120']
dict_values(['Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.'])
dict_values(['Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2', 'Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.', 'This is by now a fairly standard representation for multiple morphological segmentation of Hebrew utterances (Adler, 2001; Bar-Haim et al., 2005; Smith et al., 2005; Cohen and Smith, 2007; Adler, 2007).', 'This analyzer setting is similar to that of (Cohen and Smith, 2007), and models using it are denoted nohsp, Parser and Grammar We used BitPar (Schmid, 2004), an efficient general purpose parser,10 together with various treebank grammars to parse the input sentences and propose compatible morphological segmentation and syntactic analysis.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00153', '(95%-conf.int.', '0.00153', '-', '0.00153)']
['system', 'ROUGE-S*', 'Average_P:', '0.07500', '(95%-conf.int.', '0.07500', '-', '0.07500)']
['system', 'ROUGE-S*', 'Average_F:', '0.00300', '(95%-conf.int.', '0.00300', '-', '0.00300)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5886', 'P:120', 'F:9']
dict_values(['Evaluation We use 8 different measures to evaluate the performance of our system on the joint disambiguation task.'])
dict_values(['Previous work on morphological and syntactic disambiguation in Hebrew used different sets of data, different splits, differing annotation schemes, and different evaluation measures.', 'Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).', 'For all grammars, we use fine-grained PoS tags indicating various morphological features annotated therein.', 'Evaluation We use 8 different measures to evaluate the performance of our system on the joint disambiguation task.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02424', '(95%-conf.int.', '0.02424', '-', '0.02424)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.04734', '(95%-conf.int.', '0.04734', '-', '0.04734)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:36', 'F:36']
0.5335929946640701 0.043490999565090005 0.07849699921503





input/ref/Task1/P08-1043_swastika.csv
input/res/Task1/P08-1043.annv3.csv
parsing: input/ref/Task1/P08-1043_swastika.csv
    <S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S>
original cit marker offset is 0
new cit marker offset is 0



['94']
94
['94']
parsed_discourse_facet ['aim_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S>
original cit marker offset is 0
new cit marker offset is 0



['4']
4
['4']
parsed_discourse_facet ['result_citation']
    <S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S>
original cit marker offset is 0
new cit marker offset is 0



['94']
94
['94']
parsed_discourse_facet ['method_citation']
    <S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



['19']
19
['19']
parsed_discourse_facet ['method_citation']
    <S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



['19']
19
['19']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S>
original cit marker offset is 0
new cit marker offset is 0



['4']
4
['4']
parsed_discourse_facet ['result_citation']
<S sid="105" ssid="37">3An English sentence with ambiguous PoS assignment can be trivially represented as a lattice similar to our own, where every pair of consecutive nodes correspond to a word, and every possible PoS assignment for this word is a connecting arc.</S>
original cit marker offset is 0
new cit marker offset is 0



['105']
105
['105']
parsed_discourse_facet ['method_citation']
    <S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



['19']
19
['19']
parsed_discourse_facet ['method_citation']
    <S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S>
original cit marker offset is 0
new cit marker offset is 0



['19']
19
['19']
parsed_discourse_facet ['method_citation']
<S sid="163" ssid="1">The accuracy results for segmentation, tagging and parsing using our different models and our standard data split are summarized in Table 1.</S>
original cit marker offset is 0
new cit marker offset is 0



['163']
163
['163']
parsed_discourse_facet ['result_citation']
    <S sid="100" ssid="32">This means that the rules in our grammar are of two kinds: (a) syntactic rules relating nonterminals to a sequence of non-terminals and/or PoS tags, and (b) lexical rules relating PoS tags to lattice arcs (lexemes).</S>
original cit marker offset is 0
new cit marker offset is 0



['100']
100
['100']
parsed_discourse_facet ['method_citation']
    <S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S>
original cit marker offset is 0
new cit marker offset is 0



['94']
94
['94']
parsed_discourse_facet ['result_citation']
<S sid="188" ssid="2">The overall performance of our joint framework demonstrates that a probability distribution obtained over mere syntactic contexts using a Treebank grammar and a data-driven lexicon outperforms upper bounds proposed by previous joint disambiguation systems and achieves segmentation and parsing results on a par with state-of-the-art standalone applications results.</S>
original cit marker offset is 0
new cit marker offset is 0



['188']
188
['188']
parsed_discourse_facet ['result_citation']
<S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S>
original cit marker offset is 0
new cit marker offset is 0



['86']
86
['86']
parsed_discourse_facet ['result_citation']
<S sid="97" ssid="29">Thus our proposed model is a proper model assigning probability mass to all (7r, L) pairs, where 7r is a parse tree and L is the one and only lattice that a sequence of characters (and spaces) W over our alpha-beth gives rise to.</S>
original cit marker offset is 0
new cit marker offset is 0



['97']
97
['97']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1043.annv3.csv
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="35" ssid="14">The form fmnh, for example, can be understood as the verb &#8220;lubricated&#8221;, the possessed noun &#8220;her oil&#8221;, the adjective &#8220;fat&#8221; or the verb &#8220;got fat&#8221;.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="98" ssid="30">The Grammar Our parser looks for the most likely tree spanning a single path through the lattice of which the yield is a sequence of lexemes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'35'", "'49'", "'98'"]
'33'
'35'
'49'
'98'
['33', '35', '49', '98']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity.</S><S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S><S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'4'", "'18'", "'49'"]
'3'
'4'
'18'
'49'
['3', '4', '18', '49']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S><S sid="65" ssid="12">A possible probabilistic model for assigning probabilities to complex analyses of a surface form may be and indeed recent sequential disambiguation models for Hebrew (Adler and Elhadad, 2006) and Arabic (Smith et al., 2005) present similar models.</S><S sid="82" ssid="14">In sequential tagging models such as (Adler and Elhadad, 2006; Bar-Haim et al., 2007; Smith et al., 2005) weights are assigned according to a language model The input for the joint task is a sequence W = w1, ... , wn of space-delimited tokens.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'65'", "'82'"]
'20'
'21'
'65'
'82'
['20', '21', '65', '82']
parsed_discourse_facet ['aim_citation']
<S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="52" ssid="10">Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.</S><S sid="175" ssid="13">In our model there are no such hyper-parameters, and the performance is the result of truly joint disambiguation. sults.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'20'", "'52'", "'175'"]
'18'
'20'
'52'
'175'
['18', '20', '52', '175']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S><S sid="47" ssid="5">Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'47'", "'48'", "'49'"]
'4'
'47'
'48'
'49'
['4', '47', '48', '49']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="47" ssid="5">Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'47'", "'48'", "'49'"]
'33'
'47'
'48'
'49'
['33', '47', '48', '49']
parsed_discourse_facet ['aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S><S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S><S sid="106" ssid="38">Handling Unknown tokens When handling unknown tokens in a language such as Hebrew various important aspects have to be borne in mind.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'86'", "'94'", "'106'"]
'33'
'86'
'94'
'106'
['33', '86', '94', '106']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="85" ssid="17">The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.</S><S sid="192" ssid="6">Using a wide-coverage morphological analyzer based on (Itai et al., 2006) should cater for a better coverage, and incorporating lexical probabilities learned from a big (unannotated) corpus (cf.</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'85'", "'192'", "'193'"]
'33'
'85'
'192'
'193'
['33', '85', '192', '193']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="0">A Single Generative Model for Joint Morphological Segmentation and Syntactic Parsing</S><S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S><S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'18'", "'19'", "'20'"]
'0'
'18'
'19'
'20'
['0', '18', '19', '20']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="71" ssid="3">This is by now a fairly standard representation for multiple morphological segmentation of Hebrew utterances (Adler, 2001; Bar-Haim et al., 2005; Smith et al., 2005; Cohen and Smith, 2007; Adler, 2007).</S><S sid="141" ssid="19">This analyzer setting is similar to that of (Cohen and Smith, 2007), and models using it are denoted nohsp, Parser and Grammar We used BitPar (Schmid, 2004), an efficient general purpose parser,10 together with various treebank grammars to parse the input sentences and propose compatible morphological segmentation and syntactic analysis.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'49'", "'71'", "'141'"]
'21'
'49'
'71'
'141'
['21', '49', '71', '141']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="159" ssid="37">Our parsing performance measures (SY N) thus report the PARSEVAL extension proposed in Tsarfaty (2006).</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'49'", "'159'", "'193'"]
'33'
'49'
'159'
'193'
['33', '49', '159', '193']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="151" ssid="29">In our third model GTppp we also add the distinction between general PPs and possessive PPs following Goldberg and Elhadad (2007).</S><S sid="152" ssid="30">In our forth model GTnph we add the definiteness status of constituents following Tsarfaty and Sima&#8217;an (2007).</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'151'", "'152'", "'193'"]
'33'
'151'
'152'
'193'
['33', '151', '152', '193']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="52" ssid="10">Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.</S><S sid="158" ssid="36">Evaluating parsing results in our joint framework, as argued by Tsarfaty (2006), is not trivial under the joint disambiguation task, as the hypothesized yield need not coincide with the correct one.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'48'", "'52'", "'158'"]
'20'
'48'
'52'
'158'
['20', '48', '52', '158']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="51" ssid="9">Tsarfaty (2006) used a morphological analyzer (Segal, 2000), a PoS tagger (Bar-Haim et al., 2005), and a general purpose parser (Schmid, 2000) in an integrated framework in which morphological and syntactic components interact to share information, leading to improved performance on the joint task.</S><S sid="132" ssid="10">(we ignored the 419 trees in their development set.)</S><S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S><S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'132'", "'133'", "'134'"]
'51'
'132'
'133'
'134'
['51', '132', '133', '134']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S><S sid="112" ssid="44">We first make use of our morphological analyzer to find all segmentation possibilities by chopping off all prefix sequence possibilities (including the empty prefix) and construct a lattice off of them.</S><S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S><S sid="140" ssid="18">For these models we limit the options provided for OOV words by not considering the entire token as a valid segmentation in case at least some prefix segmentation exists.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'", "'112'", "'133'", "'140'"]
'86'
'112'
'133'
'140'
['86', '112', '133', '140']
parsed_discourse_facet ['method_citation']
<S sid="123" ssid="1">Previous work on morphological and syntactic disambiguation in Hebrew used different sets of data, different splits, differing annotation schemes, and different evaluation measures.</S><S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S><S sid="154" ssid="32">For all grammars, we use fine-grained PoS tags indicating various morphological features annotated therein.</S><S sid="155" ssid="33">Evaluation We use 8 different measures to evaluate the performance of our system on the joint disambiguation task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'123'", "'134'", "'154'", "'155'"]
'123'
'134'
'154'
'155'
['123', '134', '154', '155']
parsed_discourse_facet ['results_citation']
dict_values(['Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.'])
dict_values(['The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).', 'The form fmnh, for example, can be understood as the verb &#8220;lubricated&#8221;, the possessed noun &#8220;her oil&#8221;, the adjective &#8220;fat&#8221; or the verb &#8220;got fat&#8221;.', 'Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.', 'The Grammar Our parser looks for the most likely tree spanning a single path through the lattice of which the yield is a sequence of lexemes.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00043', '(95%-conf.int.', '0.00043', '-', '0.00043)']
['system', 'ROUGE-S*', 'Average_P:', '0.00654', '(95%-conf.int.', '0.00654', '-', '0.00654)']
['system', 'ROUGE-S*', 'Average_F:', '0.00080', '(95%-conf.int.', '0.00080', '-', '0.00080)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:153', 'F:1']
dict_values(['Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.'])
dict_values(['Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity.', 'Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.', 'Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.', 'Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.14789', '(95%-conf.int.', '0.14789', '-', '0.14789)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.25767', '(95%-conf.int.', '0.25767', '-', '0.25767)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2556', 'P:378', 'F:378']
dict_values(['Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.'])
dict_values(['We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.', 'Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2', 'A possible probabilistic model for assigning probabilities to complex analyses of a surface form may be and indeed recent sequential disambiguation models for Hebrew (Adler and Elhadad, 2006) and Arabic (Smith et al., 2005) present similar models.', 'In sequential tagging models such as (Adler and Elhadad, 2006; Bar-Haim et al., 2007; Smith et al., 2005) weights are assigned according to a language model The input for the joint task is a sequence W = w1, ... , wn of space-delimited tokens.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00280', '(95%-conf.int.', '0.00280', '-', '0.00280)']
['system', 'ROUGE-S*', 'Average_P:', '0.09804', '(95%-conf.int.', '0.09804', '-', '0.09804)']
['system', 'ROUGE-S*', 'Average_F:', '0.00545', '(95%-conf.int.', '0.00545', '-', '0.00545)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5356', 'P:153', 'F:15']
dict_values(['Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.'])
dict_values(['Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.', 'We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.', 'Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.', 'In our model there are no such hyper-parameters, and the performance is the result of truly joint disambiguation. sults.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00752', '(95%-conf.int.', '0.00752', '-', '0.00752)']
['system', 'ROUGE-S*', 'Average_P:', '0.10000', '(95%-conf.int.', '0.10000', '-', '0.10000)']
['system', 'ROUGE-S*', 'Average_F:', '0.01399', '(95%-conf.int.', '0.01399', '-', '0.01399)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:120', 'F:12']
dict_values(['Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.'])
dict_values(['Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.', 'Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.', 'Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.', 'Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00566', '(95%-conf.int.', '0.00566', '-', '0.00566)']
['system', 'ROUGE-S*', 'Average_P:', '0.14167', '(95%-conf.int.', '0.14167', '-', '0.14167)']
['system', 'ROUGE-S*', 'Average_F:', '0.01089', '(95%-conf.int.', '0.01089', '-', '0.01089)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:120', 'F:17']
dict_values(['3An English sentence with ambiguous PoS assignment can be trivially represented as a lattice similar to our own, where every pair of consecutive nodes correspond to a word, and every possible PoS assignment for this word is a connecting arc.'])
dict_values(['The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).', 'A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).', 'Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.', 'Handling Unknown tokens When handling unknown tokens in a language such as Hebrew various important aspects have to be borne in mind.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00058', '(95%-conf.int.', '0.00058', '-', '0.00058)']
['system', 'ROUGE-S*', 'Average_P:', '0.00526', '(95%-conf.int.', '0.00526', '-', '0.00526)']
['system', 'ROUGE-S*', 'Average_F:', '0.00105', '(95%-conf.int.', '0.00105', '-', '0.00105)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:190', 'F:1']
dict_values(['Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.'])
dict_values(['A Single Generative Model for Joint Morphological Segmentation and Syntactic Parsing', 'Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.', 'Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.', 'We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.'])
['system', 'ROUGE-S*', 'Average_R:', '0.08081', '(95%-conf.int.', '0.08081', '-', '0.08081)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.14953', '(95%-conf.int.', '0.14953', '-', '0.14953)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:120', 'F:120']
dict_values(['Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.'])
dict_values(['Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2', 'Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.', 'This is by now a fairly standard representation for multiple morphological segmentation of Hebrew utterances (Adler, 2001; Bar-Haim et al., 2005; Smith et al., 2005; Cohen and Smith, 2007; Adler, 2007).', 'This analyzer setting is similar to that of (Cohen and Smith, 2007), and models using it are denoted nohsp, Parser and Grammar We used BitPar (Schmid, 2004), an efficient general purpose parser,10 together with various treebank grammars to parse the input sentences and propose compatible morphological segmentation and syntactic analysis.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00153', '(95%-conf.int.', '0.00153', '-', '0.00153)']
['system', 'ROUGE-S*', 'Average_P:', '0.07500', '(95%-conf.int.', '0.07500', '-', '0.07500)']
['system', 'ROUGE-S*', 'Average_F:', '0.00300', '(95%-conf.int.', '0.00300', '-', '0.00300)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5886', 'P:120', 'F:9']
dict_values(['Thus our proposed model is a proper model assigning probability mass to all (7r, L) pairs, where 7r is a parse tree and L is the one and only lattice that a sequence of characters (and spaces) W over our alpha-beth gives rise to.'])
dict_values(['Previous work on morphological and syntactic disambiguation in Hebrew used different sets of data, different splits, differing annotation schemes, and different evaluation measures.', 'Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).', 'For all grammars, we use fine-grained PoS tags indicating various morphological features annotated therein.', 'Evaluation We use 8 different measures to evaluate the performance of our system on the joint disambiguation task.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:171', 'F:0']
0.26961221922653095 0.02746888858367902 0.0491533327871852





input/ref/Task1/P08-1043_sweta.csv
input/res/Task1/P08-1043.annv3.csv
parsing: input/ref/Task1/P08-1043_sweta.csv
<S sid="156" ssid="34">To evaluate the performance on the segmentation task, we report SEG, the standard harmonic means for segmentation Precision and Recall F1 (as defined in Bar-Haim et al. (2005); Tsarfaty (2006)) as well as the segmentation accuracy SEGTok measure indicating the percentage of input tokens assigned the correct exact segmentation (as reported by Cohen and Smith (2007)).</S>
original cit marker offset is 0
new cit marker offset is 0



["156'"]
156'
['156']
parsed_discourse_facet ['method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S>
original cit marker offset is 0
new cit marker offset is 0



["4'"]
4'
['4']
parsed_discourse_facet ['method_citation']
<S sid="70" ssid="2">Each lattice arc corresponds to a segment and its corresponding PoS tag, and a path through the lattice corresponds to a specific morphological segmentation of the utterance.</S>
original cit marker offset is 0
new cit marker offset is 0



["70'"]
70'
['70']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity.</S>
original cit marker offset is 0
new cit marker offset is 0



["3'"]
3'
['3']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="9">Tsarfaty (2006) used a morphological analyzer (Segal, 2000), a PoS tagger (Bar-Haim et al., 2005), and a general purpose parser (Schmid, 2000) in an integrated framework in which morphological and syntactic components interact to share information, leading to improved performance on the joint task.</S>
original cit marker offset is 0
new cit marker offset is 0



["51'"]
51'
['51']
parsed_discourse_facet ['method_citation']
<S sid="107" ssid="39">Firstly, Hebrew unknown tokens are doubly unknown: each unknown token may correspond to several segmentation possibilities, and each segment in such sequences may be able to admit multiple PoS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["107'"]
107'
['107']
parsed_discourse_facet ['method_citation']
<S sid="14" ssid="10">The input for the segmentation task is however highly ambiguous for Semitic languages, and surface forms (tokens) may admit multiple possible analyses as in (BarHaim et al., 2007; Adler and Elhadad, 2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["14'"]
14'
['14']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S>
original cit marker offset is 0
new cit marker offset is 0



["33'"]
33'
['33']
parsed_discourse_facet ['method_citation']
<S sid="53" ssid="11">Both (Tsarfaty, 2006; Cohen and Smith, 2007) have shown that a single integrated framework outperforms a completely streamlined implementation, yet neither has shown a single generative model which handles both tasks.</S>
original cit marker offset is 0
new cit marker offset is 0



["53'"]
53'
['53']
parsed_discourse_facet ['method_citation']
 <S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S>
original cit marker offset is 0
new cit marker offset is 0



["48'"]
48'
['48']
parsed_discourse_facet ['method_citation']
<S sid="141" ssid="19">This analyzer setting is similar to that of (Cohen and Smith, 2007), and models using it are denoted nohsp, Parser and Grammar We used BitPar (Schmid, 2004), an efficient general purpose parser,10 together with various treebank grammars to parse the input sentences and propose compatible morphological segmentation and syntactic analysis.</S>
original cit marker offset is 0
new cit marker offset is 0



["141'"]
141'
['141']
parsed_discourse_facet ['method_citation']
<S sid="188" ssid="2">The overall performance of our joint framework demonstrates that a probability distribution obtained over mere syntactic contexts using a Treebank grammar and a data-driven lexicon outperforms upper bounds proposed by previous joint disambiguation systems and achieves segmentation and parsing results on a par with state-of-the-art standalone applications results.</S>
original cit marker offset is 0
new cit marker offset is 0



["188'"]
188'
['188']
parsed_discourse_facet ['method_citation']
<S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S>
original cit marker offset is 0
new cit marker offset is 0



["94'"]
94'
['94']
parsed_discourse_facet ['method_citation']
<S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["134'"]
134'
['134']
parsed_discourse_facet ['method_citation']
    <S sid="156" ssid="34">To evaluate the performance on the segmentation task, we report SEG, the standard harmonic means for segmentation Precision and Recall F1 (as defined in Bar-Haim et al. (2005); Tsarfaty (2006)) as well as the segmentation accuracy SEGTok measure indicating the percentage of input tokens assigned the correct exact segmentation (as reported by Cohen and Smith (2007)).</S>
original cit marker offset is 0
new cit marker offset is 0



["156'"]
156'
['156']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="1">Current state-of-the-art broad-coverage parsers assume a direct correspondence between the lexical items ingrained in the proposed syntactic analyses (the yields of syntactic parse-trees) and the spacedelimited tokens (henceforth, &#8216;tokens&#8217;) that constitute the unanalyzed surface forms (utterances).</S>
original cit marker offset is 0
new cit marker offset is 0



["5'"]
5'
['5']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1043.annv3.csv
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="35" ssid="14">The form fmnh, for example, can be understood as the verb &#8220;lubricated&#8221;, the possessed noun &#8220;her oil&#8221;, the adjective &#8220;fat&#8221; or the verb &#8220;got fat&#8221;.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="98" ssid="30">The Grammar Our parser looks for the most likely tree spanning a single path through the lattice of which the yield is a sequence of lexemes.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'35'", "'49'", "'98'"]
'33'
'35'
'49'
'98'
['33', '35', '49', '98']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity.</S><S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S><S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'4'", "'18'", "'49'"]
'3'
'4'
'18'
'49'
['3', '4', '18', '49']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S><S sid="65" ssid="12">A possible probabilistic model for assigning probabilities to complex analyses of a surface form may be and indeed recent sequential disambiguation models for Hebrew (Adler and Elhadad, 2006) and Arabic (Smith et al., 2005) present similar models.</S><S sid="82" ssid="14">In sequential tagging models such as (Adler and Elhadad, 2006; Bar-Haim et al., 2007; Smith et al., 2005) weights are assigned according to a language model The input for the joint task is a sequence W = w1, ... , wn of space-delimited tokens.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'21'", "'65'", "'82'"]
'20'
'21'
'65'
'82'
['20', '21', '65', '82']
parsed_discourse_facet ['aim_citation']
<S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="52" ssid="10">Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.</S><S sid="175" ssid="13">In our model there are no such hyper-parameters, and the performance is the result of truly joint disambiguation. sults.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'20'", "'52'", "'175'"]
'18'
'20'
'52'
'175'
['18', '20', '52', '175']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="4" ssid="4">Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.</S><S sid="47" ssid="5">Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'47'", "'48'", "'49'"]
'4'
'47'
'48'
'49'
['4', '47', '48', '49']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="47" ssid="5">Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'47'", "'48'", "'49'"]
'33'
'47'
'48'
'49'
['33', '47', '48', '49']
parsed_discourse_facet ['aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S><S sid="94" ssid="26">Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.</S><S sid="106" ssid="38">Handling Unknown tokens When handling unknown tokens in a language such as Hebrew various important aspects have to be borne in mind.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'86'", "'94'", "'106'"]
'33'
'86'
'94'
'106'
['33', '86', '94', '106']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="85" ssid="17">The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.</S><S sid="192" ssid="6">Using a wide-coverage morphological analyzer based on (Itai et al., 2006) should cater for a better coverage, and incorporating lexical probabilities learned from a big (unannotated) corpus (cf.</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'85'", "'192'", "'193'"]
'33'
'85'
'192'
'193'
['33', '85', '192', '193']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="0">A Single Generative Model for Joint Morphological Segmentation and Syntactic Parsing</S><S sid="18" ssid="14">Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.</S><S sid="19" ssid="15">Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.</S><S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'18'", "'19'", "'20'"]
'0'
'18'
'19'
'20'
['0', '18', '19', '20']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="71" ssid="3">This is by now a fairly standard representation for multiple morphological segmentation of Hebrew utterances (Adler, 2001; Bar-Haim et al., 2005; Smith et al., 2005; Cohen and Smith, 2007; Adler, 2007).</S><S sid="141" ssid="19">This analyzer setting is similar to that of (Cohen and Smith, 2007), and models using it are denoted nohsp, Parser and Grammar We used BitPar (Schmid, 2004), an efficient general purpose parser,10 together with various treebank grammars to parse the input sentences and propose compatible morphological segmentation and syntactic analysis.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'49'", "'71'", "'141'"]
'21'
'49'
'71'
'141'
['21', '49', '71', '141']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="49" ssid="7">Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.</S><S sid="159" ssid="37">Our parsing performance measures (SY N) thus report the PARSEVAL extension proposed in Tsarfaty (2006).</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'49'", "'159'", "'193'"]
'33'
'49'
'159'
'193'
['33', '49', '159', '193']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="33" ssid="12">The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).</S><S sid="151" ssid="29">In our third model GTppp we also add the distinction between general PPs and possessive PPs following Goldberg and Elhadad (2007).</S><S sid="152" ssid="30">In our forth model GTnph we add the definiteness status of constituents following Tsarfaty and Sima&#8217;an (2007).</S><S sid="193" ssid="7">(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'151'", "'152'", "'193'"]
'33'
'151'
'152'
'193'
['33', '151', '152', '193']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="20" ssid="16">We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.</S><S sid="48" ssid="6">Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.</S><S sid="52" ssid="10">Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.</S><S sid="158" ssid="36">Evaluating parsing results in our joint framework, as argued by Tsarfaty (2006), is not trivial under the joint disambiguation task, as the hypothesized yield need not coincide with the correct one.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'48'", "'52'", "'158'"]
'20'
'48'
'52'
'158'
['20', '48', '52', '158']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="51" ssid="9">Tsarfaty (2006) used a morphological analyzer (Segal, 2000), a PoS tagger (Bar-Haim et al., 2005), and a general purpose parser (Schmid, 2000) in an integrated framework in which morphological and syntactic components interact to share information, leading to improved performance on the joint task.</S><S sid="132" ssid="10">(we ignored the 419 trees in their development set.)</S><S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S><S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'132'", "'133'", "'134'"]
'51'
'132'
'133'
'134'
['51', '132', '133', '134']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="18">A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).</S><S sid="112" ssid="44">We first make use of our morphological analyzer to find all segmentation possibilities by chopping off all prefix sequence possibilities (including the empty prefix) and construct a lattice off of them.</S><S sid="133" ssid="11">Morphological Analyzer Ideally, we would use an of-the-shelf morphological analyzer for mapping each input token to its possible analyses.</S><S sid="140" ssid="18">For these models we limit the options provided for OOV words by not considering the entire token as a valid segmentation in case at least some prefix segmentation exists.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'", "'112'", "'133'", "'140'"]
'86'
'112'
'133'
'140'
['86', '112', '133', '140']
parsed_discourse_facet ['method_citation']
<S sid="123" ssid="1">Previous work on morphological and syntactic disambiguation in Hebrew used different sets of data, different splits, differing annotation schemes, and different evaluation measures.</S><S sid="134" ssid="12">Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).</S><S sid="154" ssid="32">For all grammars, we use fine-grained PoS tags indicating various morphological features annotated therein.</S><S sid="155" ssid="33">Evaluation We use 8 different measures to evaluate the performance of our system on the joint disambiguation task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'123'", "'134'", "'154'", "'155'"]
'123'
'134'
'154'
'155'
['123', '134', '154', '155']
parsed_discourse_facet ['results_citation']
dict_values(['To evaluate the performance on the segmentation task, we report SEG, the standard harmonic means for segmentation Precision and Recall F1 (as defined in Bar-Haim et al. (2005); Tsarfaty (2006)) as well as the segmentation accuracy SEGTok measure indicating the percentage of input tokens assigned the correct exact segmentation (as reported by Cohen and Smith (2007)).'])
dict_values(['The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).', 'The form fmnh, for example, can be understood as the verb &#8220;lubricated&#8221;, the possessed noun &#8220;her oil&#8221;, the adjective &#8220;fat&#8221; or the verb &#8220;got fat&#8221;.', 'Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.', 'The Grammar Our parser looks for the most likely tree spanning a single path through the lattice of which the yield is a sequence of lexemes.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00597', '(95%-conf.int.', '0.00597', '-', '0.00597)']
['system', 'ROUGE-S*', 'Average_P:', '0.02222', '(95%-conf.int.', '0.02222', '-', '0.02222)']
['system', 'ROUGE-S*', 'Average_F:', '0.00941', '(95%-conf.int.', '0.00941', '-', '0.00941)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:630', 'F:14']
dict_values(['Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.'])
dict_values(['Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity.', 'Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.', 'Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.', 'Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.14789', '(95%-conf.int.', '0.14789', '-', '0.14789)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.25767', '(95%-conf.int.', '0.25767', '-', '0.25767)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2556', 'P:378', 'F:378']
dict_values(['Each lattice arc corresponds to a segment and its corresponding PoS tag, and a path through the lattice corresponds to a specific morphological segmentation of the utterance.'])
dict_values(['We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.', 'Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2', 'A possible probabilistic model for assigning probabilities to complex analyses of a surface form may be and indeed recent sequential disambiguation models for Hebrew (Adler and Elhadad, 2006) and Arabic (Smith et al., 2005) present similar models.', 'In sequential tagging models such as (Adler and Elhadad, 2006; Bar-Haim et al., 2007; Smith et al., 2005) weights are assigned according to a language model The input for the joint task is a sequence W = w1, ... , wn of space-delimited tokens.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00075', '(95%-conf.int.', '0.00075', '-', '0.00075)']
['system', 'ROUGE-S*', 'Average_P:', '0.05128', '(95%-conf.int.', '0.05128', '-', '0.05128)']
['system', 'ROUGE-S*', 'Average_F:', '0.00147', '(95%-conf.int.', '0.00147', '-', '0.00147)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5356', 'P:78', 'F:4']
dict_values(['Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity.'])
dict_values(['Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.', 'We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.', 'Cohen and Smith (2007) later on based a system for joint inference on factored, independent, morphological and syntactic components of which scores are combined to cater for the joint inference task.', 'In our model there are no such hyper-parameters, and the performance is the result of truly joint disambiguation. sults.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01566', '(95%-conf.int.', '0.01566', '-', '0.01566)']
['system', 'ROUGE-S*', 'Average_P:', '0.45455', '(95%-conf.int.', '0.45455', '-', '0.45455)']
['system', 'ROUGE-S*', 'Average_F:', '0.03028', '(95%-conf.int.', '0.03028', '-', '0.03028)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:55', 'F:25']
dict_values(['Tsarfaty (2006) used a morphological analyzer (Segal, 2000), a PoS tagger (Bar-Haim et al., 2005), and a general purpose parser (Schmid, 2000) in an integrated framework in which morphological and syntactic components interact to share information, leading to improved performance on the joint task.'])
dict_values(['Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far.', 'Sima&#8217;an et al. (2001) presented parsing results for a DOP tree-gram model using a small data set (500 sentences) and semiautomatic morphological disambiguation.', 'Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.', 'Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00333', '(95%-conf.int.', '0.00333', '-', '0.00333)']
['system', 'ROUGE-S*', 'Average_P:', '0.02299', '(95%-conf.int.', '0.02299', '-', '0.02299)']
['system', 'ROUGE-S*', 'Average_F:', '0.00582', '(95%-conf.int.', '0.00582', '-', '0.00582)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:435', 'F:10']
dict_values(['The input for the segmentation task is however highly ambiguous for Semitic languages, and surface forms (tokens) may admit multiple possible analyses as in (BarHaim et al., 2007; Adler and Elhadad, 2006).'])
dict_values(['The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).', 'A morphological analyzer M : W&#8212;* L is a function mapping sentences in Hebrew (W E W) to their corresponding lattices (M(W) = L E L).', 'Our use of an unweighted lattice reflects our belief that all the segmentations of the given input sentence are a-priori equally likely; the only reason to prefer one segmentation over the another is due to the overall syntactic context which is modeled via the PCFG derivations.', 'Handling Unknown tokens When handling unknown tokens in a language such as Hebrew various important aspects have to be borne in mind.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00292', '(95%-conf.int.', '0.00292', '-', '0.00292)']
['system', 'ROUGE-S*', 'Average_P:', '0.02924', '(95%-conf.int.', '0.02924', '-', '0.02924)']
['system', 'ROUGE-S*', 'Average_F:', '0.00531', '(95%-conf.int.', '0.00531', '-', '0.00531)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:171', 'F:5']
dict_values(['The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).'])
dict_values(['The current work treats both segmental and super-segmental phenomena, yet we note that there may be more adequate ways to treat supersegmental phenomena assuming Word-Based morphology as we explore in (Tsarfaty and Goldberg, 2008).', 'The Input The set of analyses for a token is thus represented as a lattice in which every arc corresponds to a specific lexeme l, as shown in Figure 1.', 'Using a wide-coverage morphological analyzer based on (Itai et al., 2006) should cater for a better coverage, and incorporating lexical probabilities learned from a big (unannotated) corpus (cf.', '(Levinger et al., 1995; Goldberg et al., ; Adler et al., 2008)) will make the parser more robust and suitable for use in more realistic scenarios.'])
['system', 'ROUGE-S*', 'Average_R:', '0.09790', '(95%-conf.int.', '0.09790', '-', '0.09790)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.17834', '(95%-conf.int.', '0.17834', '-', '0.17834)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:210', 'F:210']
dict_values(['Both (Tsarfaty, 2006; Cohen and Smith, 2007) have shown that a single integrated framework outperforms a completely streamlined implementation, yet neither has shown a single generative model which handles both tasks.'])
dict_values(['A Single Generative Model for Joint Morphological Segmentation and Syntactic Parsing', 'Cohen and Smith (2007) followed up on these results and proposed a system for joint inference of morphological and syntactic structures using factored models each designed and trained on its own.', 'Here we push the single-framework conjecture across the board and present a single model that performs morphological segmentation and syntactic disambiguation in a fully generative framework.', 'We claim that no particular morphological segmentation is a-priory more likely for surface forms before exploring the compositional nature of syntactic structures, including manifestations of various long-distance dependencies.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01886', '(95%-conf.int.', '0.01886', '-', '0.01886)']
['system', 'ROUGE-S*', 'Average_P:', '0.16374', '(95%-conf.int.', '0.16374', '-', '0.16374)']
['system', 'ROUGE-S*', 'Average_F:', '0.03382', '(95%-conf.int.', '0.03382', '-', '0.03382)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:171', 'F:28']
dict_values(['Tsarfaty (2006) was the first to demonstrate that fully automatic Hebrew parsing is feasible using the newly available 5000 sentences treebank.'])
dict_values(['Morphological segmentation decisions in our model are delegated to a lexeme-based PCFG and we show that using a simple treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling our model outperforms (Tsarfaty, 2006) and (Cohen and Smith, 2007) on the joint task and achieves state-of-the-art results on a par with current respective standalone models.2', 'Tsarfaty and Sima&#8217;an (2007) have reported state-of-the-art results on Hebrew unlexicalized parsing (74.41%) albeit assuming oracle morphological segmentation.', 'This is by now a fairly standard representation for multiple morphological segmentation of Hebrew utterances (Adler, 2001; Bar-Haim et al., 2005; Smith et al., 2005; Cohen and Smith, 2007; Adler, 2007).', 'This analyzer setting is similar to that of (Cohen and Smith, 2007), and models using it are denoted nohsp, Parser and Grammar We used BitPar (Schmid, 2004), an efficient general purpose parser,10 together with various treebank grammars to parse the input sentences and propose compatible morphological segmentation and syntactic analysis.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00238', '(95%-conf.int.', '0.00238', '-', '0.00238)']
['system', 'ROUGE-S*', 'Average_P:', '0.17949', '(95%-conf.int.', '0.17949', '-', '0.17949)']
['system', 'ROUGE-S*', 'Average_F:', '0.00469', '(95%-conf.int.', '0.00469', '-', '0.00469)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5886', 'P:78', 'F:14']
dict_values(['Current state-of-the-art broad-coverage parsers assume a direct correspondence between the lexical items ingrained in the proposed syntactic analyses (the yields of syntactic parse-trees) and the spacedelimited tokens (henceforth, &#8216;tokens&#8217;) that constitute the unanalyzed surface forms (utterances).'])
dict_values(['Previous work on morphological and syntactic disambiguation in Hebrew used different sets of data, different splits, differing annotation schemes, and different evaluation measures.', 'Such resources exist for Hebrew (Itai et al., 2006), but unfortunately use a tagging scheme which is incompatible with the one of the Hebrew Treebank.s For this reason, we use a data-driven morphological analyzer derived from the training data similar to (Cohen and Smith, 2007).', 'For all grammars, we use fine-grained PoS tags indicating various morphological features annotated therein.', 'Evaluation We use 8 different measures to evaluate the performance of our system on the joint disambiguation task.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:435', 'F:0']
0.29235099707649004 0.029565999704340002 0.05268099947319001





input/ref/Task1/P08-1102_aakansha.csv
input/res/Task1/P08-1102.annv3.csv
parsing: input/ref/Task1/P08-1102_aakansha.csv
<S sid="130" ssid="1">We proposed a cascaded linear model for Chinese Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'130'"]
'130'
['130']
parsed_discourse_facet ['method_citation']
<S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S>
original cit marker offset is 0
new cit marker offset is 0



["'42'"]
'42'
['42']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="21">According to Ng and Low (2004), the segmentation task can be transformed to a tagging problem by assigning each character a boundary tag of the following four types: We can extract segmentation result by splitting the labelled result into subsequences of pattern s or bm*e which denote single-character word and multicharacter word respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'"]
'25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="130" ssid="1">We proposed a cascaded linear model for Chinese Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'130'"]
'130'
['130']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["'34'"]
'34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'"]
'12'
['12']
parsed_discourse_facet ['method_citation']
<S sid="130" ssid="1">We proposed a cascaded linear model for Chinese Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'130'"]
'130'
['130']
parsed_discourse_facet ['method_citation']
<S sid="130" ssid="1">We proposed a cascaded linear model for Chinese Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'130'"]
'130'
['130']
parsed_discourse_facet ['method_citation']
<S sid="121" ssid="32">Among other features, the 4-gram POS LM plays the most important role, removing this feature causes F-measure decrement of 0.33 points on segmentation and 0.71 points on Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'121'"]
'121'
['121']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="9">C represents a Chinese character while the subscript of C indicates its position in the sentence relative to the current character (it has the subscript 0).</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'"]
'37'
['37']
parsed_discourse_facet ['method_citation']
<S sid="73" ssid="24">For instance, if the word w appears N times in training corpus and is labelled as POS t for n times, the probability Pr(t|w) can be estimated by the formula below: The probability Pr(w|t) could be estimated through the same approach.</S>
original cit marker offset is 0
new cit marker offset is 0



["'73'"]
'73'
['73']
parsed_discourse_facet ['method_citation']
<S sid="46" ssid="18">Following Collins, we use a function GEN(x) generating all candidate results of an input x , a representation 4) mapping each training example (x, y) &#8712; X &#215; Y to a feature vector 4)(x, y) &#8712; Rd, and a parameter vector &#945;&#65533; &#8712; Rd corresponding to the feature vector. d means the dimension of the vector space, it equals to the amount of features in the model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'46'"]
'46'
['46']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'"]
'12'
['12']
parsed_discourse_facet ['method_citation']
<S sid="130" ssid="1">We proposed a cascaded linear model for Chinese Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'130'"]
'130'
['130']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1102.annv3.csv
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="22" ssid="18">2 Segmentation and POS Tagging Given a Chinese character sequence: while the segmentation and POS tagging result can be depicted as: Here, Ci (i = L.n) denotes Chinese character, ti (i = L.m) denotes POS tag, and Cl:r (l &lt; r) denotes character sequence ranges from Cl to Cr.</S><S sid="77" ssid="2">In Chinese Joint S&amp;T, the mission of the decoder is to find the boundary-POS labelled sequence with the highest score.</S><S sid="78" ssid="3">Given a Chinese character sequence C1:n, the decoding procedure can proceed in a left-right fashion with a dynamic programming approach.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'22'", "'77'", "'78'"]
'10'
'22'
'77'
'78'
['10', '22', '77', '78']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="24" ssid="20">It is a better idea to perform segmentation and POS tagging jointly in a uniform framework.</S><S sid="25" ssid="21">According to Ng and Low (2004), the segmentation task can be transformed to a tagging problem by assigning each character a boundary tag of the following four types: We can extract segmentation result by splitting the labelled result into subsequences of pattern s or bm*e which denote single-character word and multicharacter word respectively.</S><S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S><S sid="32" ssid="4">We trained a character-based perceptron for Chinese Joint S&amp;T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'31'", "'32'"]
'24'
'25'
'31'
'32'
['24', '25', '31', '32']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S><S sid="39" ssid="11">We called them non-lexical-target because predications derived from them can predicate without considering the current character C0.</S><S sid="40" ssid="12">Templates in the column below are expanded from the upper ones.</S><S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'40'", "'42'"]
'38'
'39'
'40'
'42'
['38', '39', '40', '42']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S><S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S><S sid="101" ssid="12">On the three corpora, it also outperformed the word-based perceptron model of Zhang and Clark (2007).</S><S sid="119" ssid="30">We also find that the perceptron model functions as the kernel of the outside-layer linear model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'31'", "'38'", "'101'", "'119'"]
'31'
'38'
'101'
'119'
['31', '38', '101', '119']
parsed_discourse_facet ['method_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S><S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="4" ssid="4">On the Penn Chinese Treebank 5.0, we obtain an error reduction of segmentation and joint segmentation and part-of-speech tagging over the perceptron-only baseline.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'4'"]
'0'
'1'
'2'
'4'
['0', '1', '2', '4']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S><S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S><S sid="51" ssid="2">Additional features most widely used are related to word or POS ngrams.</S><S sid="113" ssid="24">Besides this perceptron, other sub-models are trained and used as additional features of the outside-layer linear model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'51'", "'113'"]
'33'
'34'
'51'
'113'
['33', '34', '51', '113']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">Compared to performing segmentation and POS tagging one at a time, Joint S&amp;T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).</S><S sid="12" ssid="8">Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.</S><S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S><S sid="86" ssid="11">Line 4 scans words of all possible lengths l (l = 1.. min(i, K), where i points to the current considering character).</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'42'", "'86'"]
'11'
'12'
'42'
'86'
['11', '12', '42', '86']
parsed_discourse_facet ['hypothesis_citation']
<S sid="88" ssid="13">Line 8 considers each candidate result in N-best list at prior position of the current word.</S><S sid="100" ssid="11">Test results listed in Table 2 shows that this model obtains higher accuracy than the best of SIGHAN Bakeoff 2 in three corpora (AS, CityU and MSR).</S><S sid="107" ssid="18">The evaluation results are shown in Table 3.</S><S sid="129" ssid="40">Experimental results show that, it achieves obvious improvement over the perceptron-only model, about from 0.973 to 0.978 on segmentation, and from 0.925 to 0.934 on Joint S&amp;T, with error reductions of 18.5% and 12% respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'88'", "'100'", "'107'", "'129'"]
'88'
'100'
'107'
'129'
['88', '100', '107', '129']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="22" ssid="18">2 Segmentation and POS Tagging Given a Chinese character sequence: while the segmentation and POS tagging result can be depicted as: Here, Ci (i = L.n) denotes Chinese character, ti (i = L.m) denotes POS tag, and Cl:r (l &lt; r) denotes character sequence ranges from Cl to Cr.</S><S sid="23" ssid="19">We can see that segmentation and POS tagging task is to divide a character sequence into several subsequences and label each of them a POS tag.</S><S sid="105" ssid="16">At the first step, we conducted a group of contrasting experiments on the core perceptron, the first concentrated on the segmentation regardless of the POS information and reported the F-measure on segmentation only, while the second performed Joint S&amp;T using POS information and reported the F-measure both on segmentation and on Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'22'", "'23'", "'105'"]
'10'
'22'
'23'
'105'
['10', '22', '23', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="58" ssid="9">Instead of incorporating all features into the perceptron directly, we first trained the perceptron using character-based features, and several other sub-models using additional ones such as word or POS n-grams, then trained the outside-layer linear model using the outputs of these sub-models, including the perceptron.</S><S sid="71" ssid="22">Using W = w1:m to denote the word sequence, T = t1:m to denote the corresponding POS sequence, P (T |W) to denote the probability that W is labelled as T, and P(W|T) to denote the probability that T generates W, we can define the cooccurrence model as follows: &#955;wt and &#955;tw denote the corresponding weights of the two components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'10'", "'58'", "'71'"]
'0'
'10'
'58'
'71'
['0', '10', '58', '71']
parsed_discourse_facet ['hypothesis_citation']
<S sid="13" ssid="9">However, as such features are generated dynamically during the decoding procedure, two limitation arise: on the one hand, the amount of parameters increases rapidly, which is apt to overfit on training corpus; on the other hand, exact inference by dynamic programming is intractable because the current predication relies on the results of prior predications.</S><S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S><S sid="133" ssid="4">However, can the perceptron incorporate all the knowledge used in the outside-layer linear model?</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'33'", "'35'", "'133'"]
'13'
'33'
'35'
'133'
['13', '33', '35', '133']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="13" ssid="9">However, as such features are generated dynamically during the decoding procedure, two limitation arise: on the one hand, the amount of parameters increases rapidly, which is apt to overfit on training corpus; on the other hand, exact inference by dynamic programming is intractable because the current predication relies on the results of prior predications.</S><S sid="14" ssid="10">As a result, many theoretically useful features such as higherorder word or POS n-grams are difficult to be incorporated in the model efficiently.</S><S sid="41" ssid="13">We add a field C0 to each template in the upper column, so that it can carry out predication according to not only the context but also the current character itself.</S><S sid="91" ssid="2">The first was conducted to test the performance of the perceptron on segmentation on the corpus from SIGHAN Bakeoff 2, including the Academia Sinica Corpus (AS), the Hong Kong City University Corpus (CityU), the Peking University Corpus (PKU) and the Microsoft Research Corpus (MSR).</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'14'", "'41'", "'91'"]
'13'
'14'
'41'
'91'
['13', '14', '41', '91']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="15" ssid="11">To cope with this problem, we propose a cascaded linear model inspired by the log-linear model (Och and Ney, 2004) widely used in statistical machine translation to incorporate different kinds of knowledge sources.</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S><S sid="50" ssid="1">In theory, any useful knowledge can be incorporated into the perceptron directly, besides the characterbased features already adopted.</S><S sid="51" ssid="2">Additional features most widely used are related to word or POS ngrams.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'35'", "'50'", "'51'"]
'15'
'35'
'50'
'51'
['15', '35', '50', '51']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="16" ssid="12">Shown in Figure 1, the cascaded model has a two-layer architecture, with a characterbased perceptron as the core combined with other real-valued features such as language models.</S><S sid="57" ssid="8">It has a two-layer architecture, with a perceptron as the core and another linear model as the outside-layer.</S><S sid="65" ssid="16">As shown in Figure 1, the character-based perceptron is used as the inside-layer linear model and sends its output to the outside-layer.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'16'", "'57'", "'65'"]
'2'
'16'
'57'
'65'
['2', '16', '57', '65']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="11" ssid="7">Compared to performing segmentation and POS tagging one at a time, Joint S&amp;T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).</S><S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'11'", "'34'", "'35'"]
'10'
'11'
'34'
'35'
['10', '11', '34', '35']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S><S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'31'"]
'0'
'1'
'2'
'31'
['0', '1', '2', '31']
parsed_discourse_facet ['hypothesis_citation']
Length 0 input/ref/Task1/P08-1102_aakansha.csv
0.0 0.0 0.0





input/ref/Task1/P08-1102_swastika.csv
input/res/Task1/P08-1102.annv3.csv
parsing: input/ref/Task1/P08-1102_swastika.csv
    <S sid="32" ssid="4">We trained a character-based perceptron for Chinese Joint S&amp;T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['32']
32
['32']
parsed_discourse_facet ['method_citation']
    <S sid="32" ssid="4">We trained a character-based perceptron for Chinese Joint S&amp;T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['32']
32
['32']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S>
original cit marker offset is 0
new cit marker offset is 0



['38']
38
['38']
parsed_discourse_facet ['method_citation']
    <S sid="92" ssid="3">The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['92']
92
['92']
parsed_discourse_facet ['method_citation']
    <S sid="36" ssid="8">All feature templates and their instances are shown in Table 1.</S>
original cit marker offset is 0
new cit marker offset is 0



['36']
36
['36']
parsed_discourse_facet ['method_citation']
    <S sid="32" ssid="4">We trained a character-based perceptron for Chinese Joint S&amp;T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['32']
32
['32']
parsed_discourse_facet ['method_citation']
    <S sid="92" ssid="3">The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['92']
92
['92']
parsed_discourse_facet ['method_citation']
    <S sid="92" ssid="3">The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['92']
92
['92']
parsed_discourse_facet ['method_citation']
<S sid="97" ssid="8">Figure 3 shows their learning curves depicting the F-measure on the development set after 1 to 10 training iterations.</S>
original cit marker offset is 0
new cit marker offset is 0



['97']
97
['97']
parsed_discourse_facet ['result_citation']
<S sid="91" ssid="2">The first was conducted to test the performance of the perceptron on segmentation on the corpus from SIGHAN Bakeoff 2, including the Academia Sinica Corpus (AS), the Hong Kong City University Corpus (CityU), the Peking University Corpus (PKU) and the Microsoft Research Corpus (MSR).</S>
original cit marker offset is 0
new cit marker offset is 0



['91']
91
['91']
parsed_discourse_facet ['aim_citation']
<S sid="16" ssid="12">Shown in Figure 1, the cascaded model has a two-layer architecture, with a characterbased perceptron as the core combined with other real-valued features such as language models.</S>
original cit marker offset is 0
new cit marker offset is 0



['16']
16
['16']
parsed_discourse_facet ['method_citation']
    <S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S>
original cit marker offset is 0
new cit marker offset is 0



['34']
34
['34']
parsed_discourse_facet ['method_citation']
    <S sid="92" ssid="3">The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



['92']
92
['92']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1102.annv3.csv
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="22" ssid="18">2 Segmentation and POS Tagging Given a Chinese character sequence: while the segmentation and POS tagging result can be depicted as: Here, Ci (i = L.n) denotes Chinese character, ti (i = L.m) denotes POS tag, and Cl:r (l &lt; r) denotes character sequence ranges from Cl to Cr.</S><S sid="77" ssid="2">In Chinese Joint S&amp;T, the mission of the decoder is to find the boundary-POS labelled sequence with the highest score.</S><S sid="78" ssid="3">Given a Chinese character sequence C1:n, the decoding procedure can proceed in a left-right fashion with a dynamic programming approach.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'22'", "'77'", "'78'"]
'10'
'22'
'77'
'78'
['10', '22', '77', '78']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="24" ssid="20">It is a better idea to perform segmentation and POS tagging jointly in a uniform framework.</S><S sid="25" ssid="21">According to Ng and Low (2004), the segmentation task can be transformed to a tagging problem by assigning each character a boundary tag of the following four types: We can extract segmentation result by splitting the labelled result into subsequences of pattern s or bm*e which denote single-character word and multicharacter word respectively.</S><S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S><S sid="32" ssid="4">We trained a character-based perceptron for Chinese Joint S&amp;T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'31'", "'32'"]
'24'
'25'
'31'
'32'
['24', '25', '31', '32']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S><S sid="39" ssid="11">We called them non-lexical-target because predications derived from them can predicate without considering the current character C0.</S><S sid="40" ssid="12">Templates in the column below are expanded from the upper ones.</S><S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'40'", "'42'"]
'38'
'39'
'40'
'42'
['38', '39', '40', '42']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S><S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S><S sid="101" ssid="12">On the three corpora, it also outperformed the word-based perceptron model of Zhang and Clark (2007).</S><S sid="119" ssid="30">We also find that the perceptron model functions as the kernel of the outside-layer linear model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'31'", "'38'", "'101'", "'119'"]
'31'
'38'
'101'
'119'
['31', '38', '101', '119']
parsed_discourse_facet ['method_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S><S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="4" ssid="4">On the Penn Chinese Treebank 5.0, we obtain an error reduction of segmentation and joint segmentation and part-of-speech tagging over the perceptron-only baseline.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'4'"]
'0'
'1'
'2'
'4'
['0', '1', '2', '4']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S><S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S><S sid="51" ssid="2">Additional features most widely used are related to word or POS ngrams.</S><S sid="113" ssid="24">Besides this perceptron, other sub-models are trained and used as additional features of the outside-layer linear model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'51'", "'113'"]
'33'
'34'
'51'
'113'
['33', '34', '51', '113']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">Compared to performing segmentation and POS tagging one at a time, Joint S&amp;T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).</S><S sid="12" ssid="8">Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.</S><S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S><S sid="86" ssid="11">Line 4 scans words of all possible lengths l (l = 1.. min(i, K), where i points to the current considering character).</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'42'", "'86'"]
'11'
'12'
'42'
'86'
['11', '12', '42', '86']
parsed_discourse_facet ['hypothesis_citation']
<S sid="88" ssid="13">Line 8 considers each candidate result in N-best list at prior position of the current word.</S><S sid="100" ssid="11">Test results listed in Table 2 shows that this model obtains higher accuracy than the best of SIGHAN Bakeoff 2 in three corpora (AS, CityU and MSR).</S><S sid="107" ssid="18">The evaluation results are shown in Table 3.</S><S sid="129" ssid="40">Experimental results show that, it achieves obvious improvement over the perceptron-only model, about from 0.973 to 0.978 on segmentation, and from 0.925 to 0.934 on Joint S&amp;T, with error reductions of 18.5% and 12% respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'88'", "'100'", "'107'", "'129'"]
'88'
'100'
'107'
'129'
['88', '100', '107', '129']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="22" ssid="18">2 Segmentation and POS Tagging Given a Chinese character sequence: while the segmentation and POS tagging result can be depicted as: Here, Ci (i = L.n) denotes Chinese character, ti (i = L.m) denotes POS tag, and Cl:r (l &lt; r) denotes character sequence ranges from Cl to Cr.</S><S sid="23" ssid="19">We can see that segmentation and POS tagging task is to divide a character sequence into several subsequences and label each of them a POS tag.</S><S sid="105" ssid="16">At the first step, we conducted a group of contrasting experiments on the core perceptron, the first concentrated on the segmentation regardless of the POS information and reported the F-measure on segmentation only, while the second performed Joint S&amp;T using POS information and reported the F-measure both on segmentation and on Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'22'", "'23'", "'105'"]
'10'
'22'
'23'
'105'
['10', '22', '23', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="58" ssid="9">Instead of incorporating all features into the perceptron directly, we first trained the perceptron using character-based features, and several other sub-models using additional ones such as word or POS n-grams, then trained the outside-layer linear model using the outputs of these sub-models, including the perceptron.</S><S sid="71" ssid="22">Using W = w1:m to denote the word sequence, T = t1:m to denote the corresponding POS sequence, P (T |W) to denote the probability that W is labelled as T, and P(W|T) to denote the probability that T generates W, we can define the cooccurrence model as follows: &#955;wt and &#955;tw denote the corresponding weights of the two components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'10'", "'58'", "'71'"]
'0'
'10'
'58'
'71'
['0', '10', '58', '71']
parsed_discourse_facet ['hypothesis_citation']
<S sid="13" ssid="9">However, as such features are generated dynamically during the decoding procedure, two limitation arise: on the one hand, the amount of parameters increases rapidly, which is apt to overfit on training corpus; on the other hand, exact inference by dynamic programming is intractable because the current predication relies on the results of prior predications.</S><S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S><S sid="133" ssid="4">However, can the perceptron incorporate all the knowledge used in the outside-layer linear model?</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'33'", "'35'", "'133'"]
'13'
'33'
'35'
'133'
['13', '33', '35', '133']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="13" ssid="9">However, as such features are generated dynamically during the decoding procedure, two limitation arise: on the one hand, the amount of parameters increases rapidly, which is apt to overfit on training corpus; on the other hand, exact inference by dynamic programming is intractable because the current predication relies on the results of prior predications.</S><S sid="14" ssid="10">As a result, many theoretically useful features such as higherorder word or POS n-grams are difficult to be incorporated in the model efficiently.</S><S sid="41" ssid="13">We add a field C0 to each template in the upper column, so that it can carry out predication according to not only the context but also the current character itself.</S><S sid="91" ssid="2">The first was conducted to test the performance of the perceptron on segmentation on the corpus from SIGHAN Bakeoff 2, including the Academia Sinica Corpus (AS), the Hong Kong City University Corpus (CityU), the Peking University Corpus (PKU) and the Microsoft Research Corpus (MSR).</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'14'", "'41'", "'91'"]
'13'
'14'
'41'
'91'
['13', '14', '41', '91']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="15" ssid="11">To cope with this problem, we propose a cascaded linear model inspired by the log-linear model (Och and Ney, 2004) widely used in statistical machine translation to incorporate different kinds of knowledge sources.</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S><S sid="50" ssid="1">In theory, any useful knowledge can be incorporated into the perceptron directly, besides the characterbased features already adopted.</S><S sid="51" ssid="2">Additional features most widely used are related to word or POS ngrams.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'35'", "'50'", "'51'"]
'15'
'35'
'50'
'51'
['15', '35', '50', '51']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="16" ssid="12">Shown in Figure 1, the cascaded model has a two-layer architecture, with a characterbased perceptron as the core combined with other real-valued features such as language models.</S><S sid="57" ssid="8">It has a two-layer architecture, with a perceptron as the core and another linear model as the outside-layer.</S><S sid="65" ssid="16">As shown in Figure 1, the character-based perceptron is used as the inside-layer linear model and sends its output to the outside-layer.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'16'", "'57'", "'65'"]
'2'
'16'
'57'
'65'
['2', '16', '57', '65']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="11" ssid="7">Compared to performing segmentation and POS tagging one at a time, Joint S&amp;T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).</S><S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'11'", "'34'", "'35'"]
'10'
'11'
'34'
'35'
['10', '11', '34', '35']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S><S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'31'"]
'0'
'1'
'2'
'31'
['0', '1', '2', '31']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.'])
dict_values(['Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.', 'We called them non-lexical-target because predications derived from them can predicate without considering the current character C0.', 'Templates in the column below are expanded from the upper ones.', 'As predications generated from such templates depend on the current character, we name these templates lexical-target.'])
['system', 'ROUGE-S*', 'Average_R:', '0.11092', '(95%-conf.int.', '0.11092', '-', '0.11092)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.19970', '(95%-conf.int.', '0.19970', '-', '0.19970)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:595', 'P:66', 'F:66']
dict_values(['The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&T.'])
dict_values(['A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging', 'We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.', 'With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.', 'On the Penn Chinese Treebank 5.0, we obtain an error reduction of segmentation and joint segmentation and part-of-speech tagging over the perceptron-only baseline.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01948', '(95%-conf.int.', '0.01948', '-', '0.01948)']
['system', 'ROUGE-S*', 'Average_P:', '0.32967', '(95%-conf.int.', '0.32967', '-', '0.32967)']
['system', 'ROUGE-S*', 'Average_F:', '0.03679', '(95%-conf.int.', '0.03679', '-', '0.03679)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1540', 'P:91', 'F:30']
dict_values(['All feature templates and their instances are shown in Table 1.'])
dict_values(['In following subsections, we describe the feature templates and the perceptron training algorithm.', 'The feature templates we adopted are selected from those of Ng and Low (2004).', 'Additional features most widely used are related to word or POS ngrams.', 'Besides this perceptron, other sub-models are trained and used as additional features of the outside-layer linear model.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00246', '(95%-conf.int.', '0.00246', '-', '0.00246)']
['system', 'ROUGE-S*', 'Average_P:', '0.06667', '(95%-conf.int.', '0.06667', '-', '0.06667)']
['system', 'ROUGE-S*', 'Average_F:', '0.00475', '(95%-conf.int.', '0.00475', '-', '0.00475)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:406', 'P:15', 'F:1']
dict_values(['We trained a character-based perceptron for Chinese Joint S&T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&T.'])
dict_values(['Compared to performing segmentation and POS tagging one at a time, Joint S&T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).', 'Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.', 'As predications generated from such templates depend on the current character, we name these templates lexical-target.', 'Line 4 scans words of all possible lengths l (l = 1.. min(i, K), where i points to the current considering character).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00680', '(95%-conf.int.', '0.00680', '-', '0.00680)']
['system', 'ROUGE-S*', 'Average_P:', '0.08791', '(95%-conf.int.', '0.08791', '-', '0.08791)']
['system', 'ROUGE-S*', 'Average_F:', '0.01263', '(95%-conf.int.', '0.01263', '-', '0.01263)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:91', 'F:8']
dict_values(['The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&T.'])
dict_values(['A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging', 'Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).', 'Instead of incorporating all features into the perceptron directly, we first trained the perceptron using character-based features, and several other sub-models using additional ones such as word or POS n-grams, then trained the outside-layer linear model using the outputs of these sub-models, including the perceptron.', 'Using W = w1:m to denote the word sequence, T = t1:m to denote the corresponding POS sequence, P (T |W) to denote the probability that W is labelled as T, and P(W|T) to denote the probability that T generates W, we can define the cooccurrence model as follows: &#955;wt and &#955;tw denote the corresponding weights of the two components.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00280', '(95%-conf.int.', '0.00280', '-', '0.00280)']
['system', 'ROUGE-S*', 'Average_P:', '0.10989', '(95%-conf.int.', '0.10989', '-', '0.10989)']
['system', 'ROUGE-S*', 'Average_F:', '0.00546', '(95%-conf.int.', '0.00546', '-', '0.00546)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3570', 'P:91', 'F:10']
dict_values(['The feature templates we adopted are selected from those of Ng and Low (2004).'])
dict_values(['Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).', 'Compared to performing segmentation and POS tagging one at a time, Joint S&T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).', 'The feature templates we adopted are selected from those of Ng and Low (2004).', 'To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01010', '(95%-conf.int.', '0.01010', '-', '0.01010)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.01999', '(95%-conf.int.', '0.01999', '-', '0.01999)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2080', 'P:21', 'F:21']
dict_values(['The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&T.'])
dict_values(['A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging', 'We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.', 'With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.', 'The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00649', '(95%-conf.int.', '0.00649', '-', '0.00649)']
['system', 'ROUGE-S*', 'Average_P:', '0.10989', '(95%-conf.int.', '0.10989', '-', '0.10989)']
['system', 'ROUGE-S*', 'Average_F:', '0.01226', '(95%-conf.int.', '0.01226', '-', '0.01226)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1540', 'P:91', 'F:10']
0.38628999448157153 0.022721428246836737 0.0416542851192245





input/ref/Task1/P08-1102_sweta.csv
input/res/Task1/P08-1102.annv3.csv
parsing: input/ref/Task1/P08-1102_sweta.csv
<S sid="21" ssid="17">Experiments show that our cascaded model can utilize different knowledge sources effectively and obtain accuracy improvements on both segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["21'"]
21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="28" ssid="24">A subsequence of boundary-POS labelling result indicates a word with POS t only if the boundary tag sequence composed of its boundary part conforms to s or bm*e style, and all POS tags in its POS part equal to t. For example, a tag sequence b NN m NN e NN represents a threecharacter word with POS tag NN.</S>
original cit marker offset is 0
new cit marker offset is 0



["28'"]
28'
['28']
parsed_discourse_facet ['method_citation']
<S sid="43" ssid="15">Note that the templates of Ng and Low (2004) have already contained some lexical-target ones.</S>
original cit marker offset is 0
new cit marker offset is 0



["43'"]
43'
['43']
parsed_discourse_facet ['method_citation']
<S sid="92" ssid="3">The second was conducted on the Penn Chinese Treebank 5.0 (CTB5.0) to test the performance of the cascaded model on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["92'"]
92'
['92']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">To segment and tag a character sequence, there are two strategies to choose: performing POS tagging following segmentation; or joint segmentation and POS tagging (Joint S&amp;T).</S>
original cit marker offset is 0
new cit marker offset is 0



["9'"]
9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S>
    <S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S>
original cit marker offset is 0
new cit marker offset is 0



["33'", "'34'"]
33'
'34'
['33', '34']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["12'"]
12'
['12']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="15">In our experiments we trained a 3-gram word language model measuring the fluency of the segmentation result, a 4-gram POS language model functioning as the product of statetransition probabilities in HMM, and a word-POS co-occurrence model describing how much probably a word sequence coexists with a POS sequence.</S>
original cit marker offset is 0
new cit marker offset is 0



["64'"]
64'
['64']
parsed_discourse_facet ['method_citation']
<S sid="79" ssid="4">By maintaining a stack of size N at each position i of the sequence, we can preserve the top N best candidate labelled results of subsequence C1:i during decoding.</S>
original cit marker offset is 0
new cit marker offset is 0



["79'"]
79'
['79']
parsed_discourse_facet ['method_citation']
<S sid="96" ssid="7">In order to test the performance of the lexical-target templates and meanwhile determine the best iterations over the training corpus, we randomly chosen 2, 000 shorter sentences (less than 50 words) as the development set and the rest as the training set (84, 294 sentences), then trained a perceptron model named NON-LEX using only nonlexical-target features and another named LEX using both the two kinds of features.</S>
original cit marker offset is 0
new cit marker offset is 0



["96'"]
96'
['96']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="2">The first was conducted to test the performance of the perceptron on segmentation on the corpus from SIGHAN Bakeoff 2, including the Academia Sinica Corpus (AS), the Hong Kong City University Corpus (CityU), the Peking University Corpus (PKU) and the Microsoft Research Corpus (MSR).</S>
original cit marker offset is 0
new cit marker offset is 0



["91'"]
91'
['91']
parsed_discourse_facet ['method_citation']
 <S sid="16" ssid="12">Shown in Figure 1, the cascaded model has a two-layer architecture, with a characterbased perceptron as the core combined with other real-valued features such as language models.</S>
original cit marker offset is 0
new cit marker offset is 0



["16'"]
16'
['16']
parsed_discourse_facet ['method_citation']
<S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S>
original cit marker offset is 0
new cit marker offset is 0



["35'"]
35'
['35']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S>
original cit marker offset is 0
new cit marker offset is 0



["91'"]
91'
['91']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P08-1102.annv3.csv
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="22" ssid="18">2 Segmentation and POS Tagging Given a Chinese character sequence: while the segmentation and POS tagging result can be depicted as: Here, Ci (i = L.n) denotes Chinese character, ti (i = L.m) denotes POS tag, and Cl:r (l &lt; r) denotes character sequence ranges from Cl to Cr.</S><S sid="77" ssid="2">In Chinese Joint S&amp;T, the mission of the decoder is to find the boundary-POS labelled sequence with the highest score.</S><S sid="78" ssid="3">Given a Chinese character sequence C1:n, the decoding procedure can proceed in a left-right fashion with a dynamic programming approach.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'22'", "'77'", "'78'"]
'10'
'22'
'77'
'78'
['10', '22', '77', '78']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="24" ssid="20">It is a better idea to perform segmentation and POS tagging jointly in a uniform framework.</S><S sid="25" ssid="21">According to Ng and Low (2004), the segmentation task can be transformed to a tagging problem by assigning each character a boundary tag of the following four types: We can extract segmentation result by splitting the labelled result into subsequences of pattern s or bm*e which denote single-character word and multicharacter word respectively.</S><S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S><S sid="32" ssid="4">We trained a character-based perceptron for Chinese Joint S&amp;T, and found that the perceptron itself could achieve considerably high accuracy on segmentation and Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'", "'25'", "'31'", "'32'"]
'24'
'25'
'31'
'32'
['24', '25', '31', '32']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S><S sid="39" ssid="11">We called them non-lexical-target because predications derived from them can predicate without considering the current character C0.</S><S sid="40" ssid="12">Templates in the column below are expanded from the upper ones.</S><S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'39'", "'40'", "'42'"]
'38'
'39'
'40'
'42'
['38', '39', '40', '42']
parsed_discourse_facet ['method_citation']
<S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S><S sid="38" ssid="10">Templates immediately borrowed from Ng and Low (2004) are listed in the upper column named non-lexical-target.</S><S sid="101" ssid="12">On the three corpora, it also outperformed the word-based perceptron model of Zhang and Clark (2007).</S><S sid="119" ssid="30">We also find that the perceptron model functions as the kernel of the outside-layer linear model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'31'", "'38'", "'101'", "'119'"]
'31'
'38'
'101'
'119'
['31', '38', '101', '119']
parsed_discourse_facet ['method_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S><S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="4" ssid="4">On the Penn Chinese Treebank 5.0, we obtain an error reduction of segmentation and joint segmentation and part-of-speech tagging over the perceptron-only baseline.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'4'"]
'0'
'1'
'2'
'4'
['0', '1', '2', '4']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S><S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S><S sid="51" ssid="2">Additional features most widely used are related to word or POS ngrams.</S><S sid="113" ssid="24">Besides this perceptron, other sub-models are trained and used as additional features of the outside-layer linear model.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'51'", "'113'"]
'33'
'34'
'51'
'113'
['33', '34', '51', '113']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">Compared to performing segmentation and POS tagging one at a time, Joint S&amp;T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).</S><S sid="12" ssid="8">Besides the usual character-based features, additional features dependent on POS&#8217;s or words can also be employed to improve the performance.</S><S sid="42" ssid="14">As predications generated from such templates depend on the current character, we name these templates lexical-target.</S><S sid="86" ssid="11">Line 4 scans words of all possible lengths l (l = 1.. min(i, K), where i points to the current considering character).</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'42'", "'86'"]
'11'
'12'
'42'
'86'
['11', '12', '42', '86']
parsed_discourse_facet ['hypothesis_citation']
<S sid="88" ssid="13">Line 8 considers each candidate result in N-best list at prior position of the current word.</S><S sid="100" ssid="11">Test results listed in Table 2 shows that this model obtains higher accuracy than the best of SIGHAN Bakeoff 2 in three corpora (AS, CityU and MSR).</S><S sid="107" ssid="18">The evaluation results are shown in Table 3.</S><S sid="129" ssid="40">Experimental results show that, it achieves obvious improvement over the perceptron-only model, about from 0.973 to 0.978 on segmentation, and from 0.925 to 0.934 on Joint S&amp;T, with error reductions of 18.5% and 12% respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'88'", "'100'", "'107'", "'129'"]
'88'
'100'
'107'
'129'
['88', '100', '107', '129']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="22" ssid="18">2 Segmentation and POS Tagging Given a Chinese character sequence: while the segmentation and POS tagging result can be depicted as: Here, Ci (i = L.n) denotes Chinese character, ti (i = L.m) denotes POS tag, and Cl:r (l &lt; r) denotes character sequence ranges from Cl to Cr.</S><S sid="23" ssid="19">We can see that segmentation and POS tagging task is to divide a character sequence into several subsequences and label each of them a POS tag.</S><S sid="105" ssid="16">At the first step, we conducted a group of contrasting experiments on the core perceptron, the first concentrated on the segmentation regardless of the POS information and reported the F-measure on segmentation only, while the second performed Joint S&amp;T using POS information and reported the F-measure both on segmentation and on Joint S&amp;T.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'22'", "'23'", "'105'"]
'10'
'22'
'23'
'105'
['10', '22', '23', '105']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="58" ssid="9">Instead of incorporating all features into the perceptron directly, we first trained the perceptron using character-based features, and several other sub-models using additional ones such as word or POS n-grams, then trained the outside-layer linear model using the outputs of these sub-models, including the perceptron.</S><S sid="71" ssid="22">Using W = w1:m to denote the word sequence, T = t1:m to denote the corresponding POS sequence, P (T |W) to denote the probability that W is labelled as T, and P(W|T) to denote the probability that T generates W, we can define the cooccurrence model as follows: &#955;wt and &#955;tw denote the corresponding weights of the two components.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'10'", "'58'", "'71'"]
'0'
'10'
'58'
'71'
['0', '10', '58', '71']
parsed_discourse_facet ['hypothesis_citation']
<S sid="13" ssid="9">However, as such features are generated dynamically during the decoding procedure, two limitation arise: on the one hand, the amount of parameters increases rapidly, which is apt to overfit on training corpus; on the other hand, exact inference by dynamic programming is intractable because the current predication relies on the results of prior predications.</S><S sid="33" ssid="5">In following subsections, we describe the feature templates and the perceptron training algorithm.</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S><S sid="133" ssid="4">However, can the perceptron incorporate all the knowledge used in the outside-layer linear model?</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'33'", "'35'", "'133'"]
'13'
'33'
'35'
'133'
['13', '33', '35', '133']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="13" ssid="9">However, as such features are generated dynamically during the decoding procedure, two limitation arise: on the one hand, the amount of parameters increases rapidly, which is apt to overfit on training corpus; on the other hand, exact inference by dynamic programming is intractable because the current predication relies on the results of prior predications.</S><S sid="14" ssid="10">As a result, many theoretically useful features such as higherorder word or POS n-grams are difficult to be incorporated in the model efficiently.</S><S sid="41" ssid="13">We add a field C0 to each template in the upper column, so that it can carry out predication according to not only the context but also the current character itself.</S><S sid="91" ssid="2">The first was conducted to test the performance of the perceptron on segmentation on the corpus from SIGHAN Bakeoff 2, including the Academia Sinica Corpus (AS), the Hong Kong City University Corpus (CityU), the Peking University Corpus (PKU) and the Microsoft Research Corpus (MSR).</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'14'", "'41'", "'91'"]
'13'
'14'
'41'
'91'
['13', '14', '41', '91']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="15" ssid="11">To cope with this problem, we propose a cascaded linear model inspired by the log-linear model (Och and Ney, 2004) widely used in statistical machine translation to incorporate different kinds of knowledge sources.</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S><S sid="50" ssid="1">In theory, any useful knowledge can be incorporated into the perceptron directly, besides the characterbased features already adopted.</S><S sid="51" ssid="2">Additional features most widely used are related to word or POS ngrams.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'", "'35'", "'50'", "'51'"]
'15'
'35'
'50'
'51'
['15', '35', '50', '51']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="16" ssid="12">Shown in Figure 1, the cascaded model has a two-layer architecture, with a characterbased perceptron as the core combined with other real-valued features such as language models.</S><S sid="57" ssid="8">It has a two-layer architecture, with a perceptron as the core and another linear model as the outside-layer.</S><S sid="65" ssid="16">As shown in Figure 1, the character-based perceptron is used as the inside-layer linear model and sends its output to the outside-layer.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'16'", "'57'", "'65'"]
'2'
'16'
'57'
'65'
['2', '16', '57', '65']
parsed_discourse_facet ['results_citation']
<S sid="10" ssid="6">Since the typical approach of discriminative models treats segmentation as a labelling problem by assigning each character a boundary tag (Xue and Shen, 2003), Joint S&amp;T can be conducted in a labelling fashion by expanding boundary tags to include POS information (Ng and Low, 2004).</S><S sid="11" ssid="7">Compared to performing segmentation and POS tagging one at a time, Joint S&amp;T can achieve higher accuracy not only on segmentation but also on POS tagging (Ng and Low, 2004).</S><S sid="34" ssid="6">The feature templates we adopted are selected from those of Ng and Low (2004).</S><S sid="35" ssid="7">To compare with others conveniently, we excluded the ones forbidden by the close test regulation of SIGHAN, for example, Pu(C0), indicating whether character C0 is a punctuation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'11'", "'34'", "'35'"]
'10'
'11'
'34'
'35'
['10', '11', '34', '35']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="0">A Cascaded Linear Model for Joint Chinese Word Segmentation and Part-of-Speech Tagging</S><S sid="1" ssid="1">We propose a cascaded linear model for joint Chinese word segmentation and partof-speech tagging.</S><S sid="2" ssid="2">With a character-based perceptron as the core, combined with realvalued features such as language models, the cascaded model is able to efficiently utilize knowledge sources that are inconvenient to incorporate into the perceptron directly.</S><S sid="31" ssid="3">The perceptron has been used in many NLP tasks, such as POS tagging (Collins, 2002), Chinese word segmentation (Ng and Low, 2004; Zhang and Clark, 2007) and so on.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'2'", "'31'"]
'0'
'1'
'2'
'31'
['0', '1', '2', '31']
parsed_discourse_facet ['hypothesis_citation']
Length 0 input/ref/Task1/P08-1102_sweta.csv
0.0 0.0 0.0





input/ref/Task1/P11-1060_aakansha.csv
input/res/Task1/P11-1060.annv3.csv
parsing: input/ref/Task1/P11-1060_aakansha.csv
<S sid="11" ssid="7">Figure 1 shows our probabilistic model: with respect to a world w (database of facts), producing an answer y.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'"]
'11'
['11']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'"]
'2'
['2']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="112" ssid="88">Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.</S>
original cit marker offset is 0
new cit marker offset is 0



["'112'"]
'112'
['112']
parsed_discourse_facet ['method_citation']
<S sid="35" ssid="11">Although a DCS tree is a logical form, note that it looks like a syntactic dependency tree with predicates in place of words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'"]
'11'
['11']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="42" ssid="18">The denotation JzKw (z evaluated on w) is the set of consistent values of the root node (see Figure 2 for an example).</S>
original cit marker offset is 0
new cit marker offset is 0



["'42'"]
'42'
['42']
parsed_discourse_facet ['method_citation']
<S sid="106" ssid="82">Learning Given a training dataset D containing (x, y) pairs, we define the regularized marginal log-likelihood objective O(&#952;) = E(x,y)ED log p&#952;(JzKw = y  |x, z &#8712; ZL(x)) &#8722; &#955;k&#952;k22, which sums over all DCS trees z that evaluate to the target answer y.</S>
original cit marker offset is 0
new cit marker offset is 0



["'106'"]
'106'
['106']
parsed_discourse_facet ['method_citation']
<S sid="45" ssid="21">The logical forms in DCS are called DCS trees, where nodes are labeled with predicates, and edges are labeled with relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'45'"]
'45'
['45']
parsed_discourse_facet ['method_citation']
<S sid="88" ssid="64">Generalized Quantification (d.ri = Q) Generalized quantifiers are predicates on two sets, a restrictor A and a nuclear scope B.</S>
original cit marker offset is 0
new cit marker offset is 0



["'88'"]
'88'
['88']
parsed_discourse_facet ['method_citation']
<S sid="171" ssid="56">This yields a more system is based on a new semantic representation, factorized and flexible representation that is easier DCS, which offers a simple and expressive alterto search through and parametrize using features. native to lambda calculus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'171'"]
'171'
['171']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P11-1060.annv3.csv
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'7'", "'9'"]
'1'
'2'
'7'
'9'
['1', '2', '7', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="6" ssid="2">Answering these types of complex questions compositionally involves first mapping the questions into logical forms (semantic parsing).</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'6'", "'9'", "'10'"]
'2'
'6'
'9'
'10'
['2', '6', '9', '10']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="3" ssid="3">In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'8'", "'9'"]
'2'
'3'
'8'
'9'
['2', '3', '8', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="46" ssid="22">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).</S><S sid="48" ssid="24">In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.</S><S sid="49" ssid="25">Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compositional structures, but they cannot capture higherorder phenomena in language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'", "'46'", "'48'", "'49'"]
'25'
'46'
'48'
'49'
['25', '46', '48', '49']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.</S><S sid="34" ssid="10">Figure 2(a) shows an example of a DCS tree.</S><S sid="38" ssid="14">Let us start by considering a DCS tree z with only join relations.</S><S sid="107" ssid="83">Our model is arc-factored, so we can sum over all DCS trees in ZL(x) using dynamic programming.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'34'", "'38'", "'107'"]
'12'
'34'
'38'
'107'
['12', '34', '38', '107']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="164" ssid="49">Past work has also fofor the second.</S><S sid="165" ssid="50">These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'164'", "'165'", "'166'"]
'7'
'164'
'165'
'166'
['7', '164', '165', '166']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="156" ssid="41">There has been a fair amount of past work on no predicates), confusion of Washington state with this topic: Liang et al. (2010) induces combinatory Washington D.C., learning the wrong lexical asso- logic programs in a non-linguistic setting.</S><S sid="165" ssid="50">These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'8'", "'156'", "'165'"]
'7'
'8'
'156'
'165'
['7', '8', '156', '165']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S><S sid="135" ssid="20">SEMRESP requires a lexicon of 1.42 words per non-value predicate, WordNet features, and syntactic parse trees; DCS requires only words for the domain-independent predicates (overall, around 0.5 words per non-value predicate), POS tags, and very simple indicator features.</S><S sid="136" ssid="21">In fact, DCS performs comparably to even the version of SEMRESP trained using logical forms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'10'", "'135'", "'136'"]
'9'
'10'
'135'
'136'
['9', '10', '135', '136']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="3" ssid="3">In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid="5" ssid="1">What is the total population of the ten largest capitals in the US?</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'5'", "'22'"]
'2'
'3'
'5'
'22'
['2', '3', '5', '22']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="132" ssid="17">Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'9'", "'132'"]
'1'
'2'
'9'
'132'
['1', '2', '9', '132']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'22'", "'25'", "'36'"]
'21'
'22'
'25'
'36'
['21', '22', '25', '36']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="47" ssid="23">This algorithm is linear in the number of nodes times the size of the denotations.1 Now the dual importance of trees in DCS is clear: We have seen that trees parallel syntactic dependency structure, which will facilitate parsing.</S><S sid="48" ssid="24">In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.</S><S sid="49" ssid="25">Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compositional structures, but they cannot capture higherorder phenomena in language.</S><S sid="94" ssid="70">We now turn to the task of mapping natural language For the example in Figure 4(b), the de- utterances to DCS trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'47'", "'48'", "'49'", "'94'"]
'47'
'48'
'49'
'94'
['47', '48', '49', '94']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.</S><S sid="33" ssid="9">As another example, w(average) = {(S, &#175;x) : We write a DCS tree z as hp; r1 : c1; ... ; rm : cmi.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S><S sid="167" ssid="52">In DCS, we start with lexical triggers, which are 6 Conclusion more basic than CCG lexical entries.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'33'", "'166'", "'167'"]
'12'
'33'
'166'
'167'
['12', '33', '166', '167']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="43" ssid="19">Computation We can compute the denotation JzKw of a DCS tree z by exploiting dynamic programming on trees (Dechter, 2003).</S><S sid="46" ssid="22">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).</S><S sid="50" ssid="26">For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.</S><S sid="86" ssid="62">Formally, extraction simply moves the i-th column to the front: Xi(d) = di, &#8722;(i, &#248;){&#945;1 = &#248;}.</S>
original cit marker offset is 0
new cit marker offset is 0



["'43'", "'46'", "'50'", "'86'"]
'43'
'46'
'50'
'86'
['43', '46', '50', '86']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'9'"]
'1'
'2'
'8'
'9'
['1', '2', '8', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="133" ssid="18">Table 2 shows that our system using lexical triggers L (henceforth, DCS) outperforms SEMRESP (78.9% over 73.2%).</S><S sid="140" ssid="25">Table 3 shows that even DCS, which does not use prototypes, is comparable to the best previous system (Kwiatkowski et al., 2010), and by adding a few prototypes, DCS+ offers a decisive edge (91.1% over 88.9% on GEO).</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'133'", "'140'", "'166'"]
'7'
'133'
'140'
'166'
['7', '133', '140', '166']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="162" ssid="47">The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.</S><S sid="164" ssid="49">Past work has also fofor the second.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'9'", "'162'", "'164'"]
'7'
'9'
'162'
'164'
['7', '9', '162', '164']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="17" ssid="13">The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'22'", "'25'", "'36'"]
'17'
'22'
'25'
'36'
['17', '22', '25', '36']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="13">The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.</S><S sid="50" ssid="26">For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.</S><S sid="150" ssid="35">For example, area (by virtue which results in programs (DCS trees) which are of being a noun) triggers many predicates: city, much simpler than the logically-equivalent lambda state, area, etc.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'50'", "'150'", "'166'"]
'17'
'50'
'150'
'166'
['17', '50', '150', '166']
parsed_discourse_facet ['method_citation']
dict_values(['Figure 1 shows our probabilistic model: with respect to a world w (database of facts), producing an answer y.'])
dict_values(['Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.', 'In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.', 'Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.', 'As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3081', 'P:55', 'F:0']
dict_values(['The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).'])
dict_values(['We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.', 'Figure 2(a) shows an example of a DCS tree.', 'Let us start by considering a DCS tree z with only join relations.', 'Our model is arc-factored, so we can sum over all DCS trees in ZL(x) using dynamic programming.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00570', '(95%-conf.int.', '0.00570', '-', '0.00570)']
['system', 'ROUGE-S*', 'Average_P:', '0.01905', '(95%-conf.int.', '0.01905', '-', '0.01905)']
['system', 'ROUGE-S*', 'Average_F:', '0.00877', '(95%-conf.int.', '0.00877', '-', '0.00877)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:351', 'P:105', 'F:2']
dict_values(['Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.'])
dict_values(['As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.', 'However, we still model the logical form (now as a latent variable) to capture the complexities of language.', 'SEMRESP requires a lexicon of 1.42 words per non-value predicate, WordNet features, and syntactic parse trees; DCS requires only words for the domain-independent predicates (overall, around 0.5 words per non-value predicate), POS tags, and very simple indicator features.', 'In fact, DCS performs comparably to even the version of SEMRESP trained using logical forms.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:300', 'F:0']
dict_values(['Although a DCS tree is a logical form, note that it looks like a syntactic dependency tree with predicates in place of words.'])
dict_values(['In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.', 'In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.', 'What is the total population of the ten largest capitals in the US?', 'The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00980', '(95%-conf.int.', '0.00980', '-', '0.00980)']
['system', 'ROUGE-S*', 'Average_P:', '0.23636', '(95%-conf.int.', '0.23636', '-', '0.23636)']
['system', 'ROUGE-S*', 'Average_F:', '0.01883', '(95%-conf.int.', '0.01883', '-', '0.01883)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1326', 'P:55', 'F:13']
dict_values(['The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).'])
dict_values(['Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.', 'In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.', 'As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.', 'Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00109', '(95%-conf.int.', '0.00109', '-', '0.00109)']
['system', 'ROUGE-S*', 'Average_P:', '0.01905', '(95%-conf.int.', '0.01905', '-', '0.01905)']
['system', 'ROUGE-S*', 'Average_F:', '0.00207', '(95%-conf.int.', '0.00207', '-', '0.00207)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:105', 'F:2']
dict_values(['The denotation JzKw (z evaluated on w) is the set of consistent values of the root node (see Figure 2 for an example).'])
dict_values(['Computation We can compute the denotation JzKw of a DCS tree z by exploiting dynamic programming on trees (Dechter, 2003).', 'Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).', 'For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.', 'Formally, extraction simply moves the i-th column to the front: Xi(d) = di, &#8722;(i, &#248;){&#945;1 = &#248;}.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00404', '(95%-conf.int.', '0.00404', '-', '0.00404)']
['system', 'ROUGE-S*', 'Average_P:', '0.13333', '(95%-conf.int.', '0.13333', '-', '0.13333)']
['system', 'ROUGE-S*', 'Average_F:', '0.00784', '(95%-conf.int.', '0.00784', '-', '0.00784)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:45', 'F:6']
dict_values(['The logical forms in DCS are called DCS trees, where nodes are labeled with predicates, and edges are labeled with relations.'])
dict_values(['Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.', 'Table 2 shows that our system using lexical triggers L (henceforth, DCS) outperforms SEMRESP (78.9% over 73.2%).', 'Table 3 shows that even DCS, which does not use prototypes, is comparable to the best previous system (Kwiatkowski et al., 2010), and by adding a few prototypes, DCS+ offers a decisive edge (91.1% over 88.9% on GEO).', 'Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00239', '(95%-conf.int.', '0.00239', '-', '0.00239)']
['system', 'ROUGE-S*', 'Average_P:', '0.15152', '(95%-conf.int.', '0.15152', '-', '0.15152)']
['system', 'ROUGE-S*', 'Average_F:', '0.00470', '(95%-conf.int.', '0.00470', '-', '0.00470)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4186', 'P:66', 'F:10']
dict_values(['Generalized Quantification (d.ri = Q) Generalized quantifiers are predicates on two sets, a restrictor A and a nuclear scope B.'])
dict_values(['Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.', 'As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.', 'The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.', 'Past work has also fofor the second.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:45', 'F:0']
dict_values(['This yields a more system is based on a new semantic representation, factorized and flexible representation that is easier DCS, which offers a simple and expressive alterto search through and parametrize using features. native to lambda calculus.'])
dict_values(['The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.', 'For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.', 'For example, area (by virtue which results in programs (DCS trees) which are of being a noun) triggers many predicates: city, much simpler than the logically-equivalent lambda state, area, etc.', 'Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00395', '(95%-conf.int.', '0.00395', '-', '0.00395)']
['system', 'ROUGE-S*', 'Average_P:', '0.03684', '(95%-conf.int.', '0.03684', '-', '0.03684)']
['system', 'ROUGE-S*', 'Average_F:', '0.00714', '(95%-conf.int.', '0.00714', '-', '0.00714)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:190', 'F:7']
0.06623888815290124 0.002996666633370371 0.005483333272407409





input/ref/Task1/P11-1060_swastika.csv
input/res/Task1/P11-1060.annv3.csv
parsing: input/ref/Task1/P11-1060_swastika.csv
<S sid="112" ssid="88">Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.</S>
original cit marker offset is 0
new cit marker offset is 0



['112']
112
['112']
parsed_discourse_facet ['method_citation']
<S sid="112" ssid="88">Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.</S>
original cit marker offset is 0
new cit marker offset is 0



['112']
112
['112']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



['25']
25
['25']
parsed_discourse_facet ['aim_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



['21']
21
['21']
parsed_discourse_facet ['aim_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



['25']
25
['25']
parsed_discourse_facet ['aim_citation']
    <S sid="148" ssid="33">This bootstrapping behavior occurs naturally: The &#8220;easy&#8221; examples are processed first, where easy is defined by the ability of the current model to generate the correct answer using any tree. with scope variation.</S>
original cit marker offset is 0
new cit marker offset is 0



['148']
148
['148']
parsed_discourse_facet ['method_citation']
    <S sid="13" ssid="9">We want to induce latent logical forms z (and parameters 0) given only question-answer pairs (x, y), which is much cheaper to obtain than (x, z) pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



['13']
13
['13']
parsed_discourse_facet ['result_citation']
<S sid="112" ssid="88">Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.</S>
original cit marker offset is 0
new cit marker offset is 0



['112']
112
['112']
parsed_discourse_facet ['result_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



['21']
21
['21']
parsed_discourse_facet ['aim_citation']
<S sid="47" ssid="23">This algorithm is linear in the number of nodes times the size of the denotations.1 Now the dual importance of trees in DCS is clear: We have seen that trees parallel syntactic dependency structure, which will facilitate parsing.</S>
original cit marker offset is 0
new cit marker offset is 0



['47']
47
['47']
parsed_discourse_facet ['method_citation']
<S sid="112" ssid="88">Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.</S>
original cit marker offset is 0
new cit marker offset is 0



['112']
112
['112']
parsed_discourse_facet ['method_citation']
S sid="44" ssid="20">The recurrence is as follows: At each node, we compute the set of tuples v consistent with the predicate at that node (v &#8712; w(p)), and S(x)}, where a set of pairs S is treated as a set-valued function S(x) = {y : (x, y) &#8712; S} with domain S1 = {x : (x, y) &#8712; S}.</S>
original cit marker offset is 0
new cit marker offset is 0



['44']
44
['44']
Error in Reference Offset
<S sid="106" ssid="82">Learning Given a training dataset D containing (x, y) pairs, we define the regularized marginal log-likelihood objective O(&#952;) = E(x,y)ED log p&#952;(JzKw = y  |x, z &#8712; ZL(x)) &#8722; &#955;k&#952;k22, which sums over all DCS trees z that evaluate to the target answer y.</S>
original cit marker offset is 0
new cit marker offset is 0



['106']
106
['106']
parsed_discourse_facet ['aim_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



['21']
21
['21']
parsed_discourse_facet ['aim_citation']
    <S sid="172" ssid="57">Free from the burden It also allows us to easily add new lexical triggers of annotating logical forms, we hope to use our without becoming mired in the semantic formalism. techniques in developing even more accurate and Quantifiers and superlatives significantly compli- broader-coverage language understanding systems. cate scoping in lambda calculus, and often type rais- Acknowledgments We thank Luke Zettlemoyer ing needs to be employed.</S>
original cit marker offset is 0
new cit marker offset is 0



['172']
172
['172']
parsed_discourse_facet ['result_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S>
original cit marker offset is 0
new cit marker offset is 0



['21']
21
['21']
parsed_discourse_facet ['aim_citation']
<S sid="171" ssid="56">This yields a more system is based on a new semantic representation, factorized and flexible representation that is easier DCS, which offers a simple and expressive alterto search through and parametrize using features. native to lambda calculus.</S>
original cit marker offset is 0
new cit marker offset is 0



['171']
171
['171']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P11-1060.annv3.csv
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'7'", "'9'"]
'1'
'2'
'7'
'9'
['1', '2', '7', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="6" ssid="2">Answering these types of complex questions compositionally involves first mapping the questions into logical forms (semantic parsing).</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'6'", "'9'", "'10'"]
'2'
'6'
'9'
'10'
['2', '6', '9', '10']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="3" ssid="3">In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'8'", "'9'"]
'2'
'3'
'8'
'9'
['2', '3', '8', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="46" ssid="22">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).</S><S sid="48" ssid="24">In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.</S><S sid="49" ssid="25">Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compositional structures, but they cannot capture higherorder phenomena in language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'", "'46'", "'48'", "'49'"]
'25'
'46'
'48'
'49'
['25', '46', '48', '49']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.</S><S sid="34" ssid="10">Figure 2(a) shows an example of a DCS tree.</S><S sid="38" ssid="14">Let us start by considering a DCS tree z with only join relations.</S><S sid="107" ssid="83">Our model is arc-factored, so we can sum over all DCS trees in ZL(x) using dynamic programming.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'34'", "'38'", "'107'"]
'12'
'34'
'38'
'107'
['12', '34', '38', '107']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="164" ssid="49">Past work has also fofor the second.</S><S sid="165" ssid="50">These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'164'", "'165'", "'166'"]
'7'
'164'
'165'
'166'
['7', '164', '165', '166']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="156" ssid="41">There has been a fair amount of past work on no predicates), confusion of Washington state with this topic: Liang et al. (2010) induces combinatory Washington D.C., learning the wrong lexical asso- logic programs in a non-linguistic setting.</S><S sid="165" ssid="50">These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'8'", "'156'", "'165'"]
'7'
'8'
'156'
'165'
['7', '8', '156', '165']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S><S sid="135" ssid="20">SEMRESP requires a lexicon of 1.42 words per non-value predicate, WordNet features, and syntactic parse trees; DCS requires only words for the domain-independent predicates (overall, around 0.5 words per non-value predicate), POS tags, and very simple indicator features.</S><S sid="136" ssid="21">In fact, DCS performs comparably to even the version of SEMRESP trained using logical forms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'10'", "'135'", "'136'"]
'9'
'10'
'135'
'136'
['9', '10', '135', '136']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="3" ssid="3">In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid="5" ssid="1">What is the total population of the ten largest capitals in the US?</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'5'", "'22'"]
'2'
'3'
'5'
'22'
['2', '3', '5', '22']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="132" ssid="17">Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'9'", "'132'"]
'1'
'2'
'9'
'132'
['1', '2', '9', '132']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'22'", "'25'", "'36'"]
'21'
'22'
'25'
'36'
['21', '22', '25', '36']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="47" ssid="23">This algorithm is linear in the number of nodes times the size of the denotations.1 Now the dual importance of trees in DCS is clear: We have seen that trees parallel syntactic dependency structure, which will facilitate parsing.</S><S sid="48" ssid="24">In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.</S><S sid="49" ssid="25">Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compositional structures, but they cannot capture higherorder phenomena in language.</S><S sid="94" ssid="70">We now turn to the task of mapping natural language For the example in Figure 4(b), the de- utterances to DCS trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'47'", "'48'", "'49'", "'94'"]
'47'
'48'
'49'
'94'
['47', '48', '49', '94']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.</S><S sid="33" ssid="9">As another example, w(average) = {(S, &#175;x) : We write a DCS tree z as hp; r1 : c1; ... ; rm : cmi.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S><S sid="167" ssid="52">In DCS, we start with lexical triggers, which are 6 Conclusion more basic than CCG lexical entries.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'33'", "'166'", "'167'"]
'12'
'33'
'166'
'167'
['12', '33', '166', '167']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="43" ssid="19">Computation We can compute the denotation JzKw of a DCS tree z by exploiting dynamic programming on trees (Dechter, 2003).</S><S sid="46" ssid="22">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).</S><S sid="50" ssid="26">For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.</S><S sid="86" ssid="62">Formally, extraction simply moves the i-th column to the front: Xi(d) = di, &#8722;(i, &#248;){&#945;1 = &#248;}.</S>
original cit marker offset is 0
new cit marker offset is 0



["'43'", "'46'", "'50'", "'86'"]
'43'
'46'
'50'
'86'
['43', '46', '50', '86']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'9'"]
'1'
'2'
'8'
'9'
['1', '2', '8', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="133" ssid="18">Table 2 shows that our system using lexical triggers L (henceforth, DCS) outperforms SEMRESP (78.9% over 73.2%).</S><S sid="140" ssid="25">Table 3 shows that even DCS, which does not use prototypes, is comparable to the best previous system (Kwiatkowski et al., 2010), and by adding a few prototypes, DCS+ offers a decisive edge (91.1% over 88.9% on GEO).</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'133'", "'140'", "'166'"]
'7'
'133'
'140'
'166'
['7', '133', '140', '166']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="162" ssid="47">The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.</S><S sid="164" ssid="49">Past work has also fofor the second.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'9'", "'162'", "'164'"]
'7'
'9'
'162'
'164'
['7', '9', '162', '164']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="17" ssid="13">The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'22'", "'25'", "'36'"]
'17'
'22'
'25'
'36'
['17', '22', '25', '36']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="13">The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.</S><S sid="50" ssid="26">For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.</S><S sid="150" ssid="35">For example, area (by virtue which results in programs (DCS trees) which are of being a noun) triggers many predicates: city, much simpler than the logically-equivalent lambda state, area, etc.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'50'", "'150'", "'166'"]
'17'
'50'
'150'
'166'
['17', '50', '150', '166']
parsed_discourse_facet ['method_citation']
dict_values(['Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.'])
dict_values(['Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.', 'In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.', 'Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.', 'As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00065', '(95%-conf.int.', '0.00065', '-', '0.00065)']
['system', 'ROUGE-S*', 'Average_P:', '0.00667', '(95%-conf.int.', '0.00667', '-', '0.00667)']
['system', 'ROUGE-S*', 'Average_F:', '0.00118', '(95%-conf.int.', '0.00118', '-', '0.00118)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3081', 'P:300', 'F:2']
dict_values(['The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).'])
dict_values(['We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.', 'Figure 2(a) shows an example of a DCS tree.', 'Let us start by considering a DCS tree z with only join relations.', 'Our model is arc-factored, so we can sum over all DCS trees in ZL(x) using dynamic programming.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00570', '(95%-conf.int.', '0.00570', '-', '0.00570)']
['system', 'ROUGE-S*', 'Average_P:', '0.01905', '(95%-conf.int.', '0.01905', '-', '0.01905)']
['system', 'ROUGE-S*', 'Average_F:', '0.00877', '(95%-conf.int.', '0.00877', '-', '0.00877)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:351', 'P:105', 'F:2']
dict_values(['We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.'])
dict_values(['Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.', 'Past work has also fofor the second.', 'These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.', 'Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00112', '(95%-conf.int.', '0.00112', '-', '0.00112)']
['system', 'ROUGE-S*', 'Average_P:', '0.02339', '(95%-conf.int.', '0.02339', '-', '0.02339)']
['system', 'ROUGE-S*', 'Average_F:', '0.00214', '(95%-conf.int.', '0.00214', '-', '0.00214)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3570', 'P:171', 'F:4']
dict_values(['This bootstrapping behavior occurs naturally: The &#8220;easy&#8221; examples are processed first, where easy is defined by the ability of the current model to generate the correct answer using any tree. with scope variation.'])
dict_values(['As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.', 'However, we still model the logical form (now as a latent variable) to capture the complexities of language.', 'SEMRESP requires a lexicon of 1.42 words per non-value predicate, WordNet features, and syntactic parse trees; DCS requires only words for the domain-independent predicates (overall, around 0.5 words per non-value predicate), POS tags, and very simple indicator features.', 'In fact, DCS performs comparably to even the version of SEMRESP trained using logical forms.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00125', '(95%-conf.int.', '0.00125', '-', '0.00125)']
['system', 'ROUGE-S*', 'Average_P:', '0.00952', '(95%-conf.int.', '0.00952', '-', '0.00952)']
['system', 'ROUGE-S*', 'Average_F:', '0.00221', '(95%-conf.int.', '0.00221', '-', '0.00221)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:210', 'F:2']
dict_values(['We want to induce latent logical forms z (and parameters 0) given only question-answer pairs (x, y), which is much cheaper to obtain than (x, z) pairs.'])
dict_values(['In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.', 'In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.', 'What is the total population of the ten largest capitals in the US?', 'The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02187', '(95%-conf.int.', '0.02187', '-', '0.02187)']
['system', 'ROUGE-S*', 'Average_P:', '0.43939', '(95%-conf.int.', '0.43939', '-', '0.43939)']
['system', 'ROUGE-S*', 'Average_F:', '0.04167', '(95%-conf.int.', '0.04167', '-', '0.04167)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1326', 'P:66', 'F:29']
dict_values(['Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.'])
dict_values(['Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.', 'In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.', 'As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.', 'Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00109', '(95%-conf.int.', '0.00109', '-', '0.00109)']
['system', 'ROUGE-S*', 'Average_P:', '0.00667', '(95%-conf.int.', '0.00667', '-', '0.00667)']
['system', 'ROUGE-S*', 'Average_F:', '0.00188', '(95%-conf.int.', '0.00188', '-', '0.00188)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:300', 'F:2']
dict_values(['Our learning algorithm alternates between (i) using the current parameters &#952; to generate the K-best set &#732;ZL,&#952;(x) for each training example x, and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.'])
dict_values(['Computation We can compute the denotation JzKw of a DCS tree z by exploiting dynamic programming on trees (Dechter, 2003).', 'Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).', 'For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.', 'Formally, extraction simply moves the i-th column to the front: Xi(d) = di, &#8722;(i, &#248;){&#945;1 = &#248;}.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00202', '(95%-conf.int.', '0.00202', '-', '0.00202)']
['system', 'ROUGE-S*', 'Average_P:', '0.01000', '(95%-conf.int.', '0.01000', '-', '0.01000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00336', '(95%-conf.int.', '0.00336', '-', '0.00336)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:300', 'F:3']
dict_values(['The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).'])
dict_values(['Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.', 'Table 2 shows that our system using lexical triggers L (henceforth, DCS) outperforms SEMRESP (78.9% over 73.2%).', 'Table 3 shows that even DCS, which does not use prototypes, is comparable to the best previous system (Kwiatkowski et al., 2010), and by adding a few prototypes, DCS+ offers a decisive edge (91.1% over 88.9% on GEO).', 'Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00334', '(95%-conf.int.', '0.00334', '-', '0.00334)']
['system', 'ROUGE-S*', 'Average_P:', '0.13333', '(95%-conf.int.', '0.13333', '-', '0.13333)']
['system', 'ROUGE-S*', 'Average_F:', '0.00653', '(95%-conf.int.', '0.00653', '-', '0.00653)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4186', 'P:105', 'F:14']
dict_values(['Free from the burden It also allows us to easily add new lexical triggers of annotating logical forms, we hope to use our without becoming mired in the semantic formalism. techniques in developing even more accurate and Quantifiers and superlatives significantly compli- broader-coverage language understanding systems. cate scoping in lambda calculus, and often type rais- Acknowledgments We thank Luke Zettlemoyer ing needs to be employed.'])
dict_values(['Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.', 'As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.', 'The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.', 'Past work has also fofor the second.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00219', '(95%-conf.int.', '0.00219', '-', '0.00219)']
['system', 'ROUGE-S*', 'Average_P:', '0.00635', '(95%-conf.int.', '0.00635', '-', '0.00635)']
['system', 'ROUGE-S*', 'Average_F:', '0.00325', '(95%-conf.int.', '0.00325', '-', '0.00325)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:630', 'F:4']
dict_values(['The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).'])
dict_values(['The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.', 'The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.', 'We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.', 'It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01792', '(95%-conf.int.', '0.01792', '-', '0.01792)']
['system', 'ROUGE-S*', 'Average_P:', '0.33333', '(95%-conf.int.', '0.33333', '-', '0.33333)']
['system', 'ROUGE-S*', 'Average_F:', '0.03401', '(95%-conf.int.', '0.03401', '-', '0.03401)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:105', 'F:35']
dict_values(['This yields a more system is based on a new semantic representation, factorized and flexible representation that is easier DCS, which offers a simple and expressive alterto search through and parametrize using features. native to lambda calculus.'])
dict_values(['The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.', 'For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.', 'For example, area (by virtue which results in programs (DCS trees) which are of being a noun) triggers many predicates: city, much simpler than the logically-equivalent lambda state, area, etc.', 'Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00395', '(95%-conf.int.', '0.00395', '-', '0.00395)']
['system', 'ROUGE-S*', 'Average_P:', '0.03684', '(95%-conf.int.', '0.03684', '-', '0.03684)']
['system', 'ROUGE-S*', 'Average_F:', '0.00714', '(95%-conf.int.', '0.00714', '-', '0.00714)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:190', 'F:7']
0.09313999915327274 0.005554545404049587 0.01019454536186777





input/ref/Task1/P11-1060_sweta.csv
input/res/Task1/P11-1060.annv3.csv
parsing: input/ref/Task1/P11-1060_sweta.csv
<S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S>
original cit marker offset is 0
new cit marker offset is 0



["8'"]
8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="132" ssid="17">Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["132'"]
132'
['132']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["25'"]
25'
['25']
parsed_discourse_facet ['method_citation']
 <S sid="45" ssid="21">The logical forms in DCS are called DCS trees, where nodes are labeled with predicates, and edges are labeled with relations.</S>
original cit marker offset is 0
new cit marker offset is 0



["45'"]
45'
['45']
parsed_discourse_facet ['method_citation']
<S sid="51" ssid="27">It is impossible to represent the semantics of this phrase with just a CSP, so we introduce a new aggregate relation, notated E. Consider a tree hE:ci, whose root is connected to a child c via E. If the denotation of c is a set of values s, the parent&#8217;s denotation is then a singleton set containing s. Formally: Figure 3(a) shows the DCS tree for our running example.</S>
original cit marker offset is 0
new cit marker offset is 0



["51'"]
51'
['51']
parsed_discourse_facet ['method_citation']
 <S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["166'"]
166'
['166']
parsed_discourse_facet ['method_citation']
 <S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S>
original cit marker offset is 0
new cit marker offset is 0



["8'"]
8'
['8']
parsed_discourse_facet ['method_citation']
 <S sid="11" ssid="7">Figure 1 shows our probabilistic model: with respect to a world w (database of facts), producing an answer y.</S>
original cit marker offset is 0
new cit marker offset is 0



["11'"]
11'
['11']
parsed_discourse_facet ['method_citation']
  <S sid="115" ssid="91">After training, given a new utterance x, our system outputs the most likely y, summing out the latent logical form z: argmaxy p&#952;(T)(y  |x, z &#8712; &#732;ZL,&#952;(T)).</S>
original cit marker offset is 0
new cit marker offset is 0



["115'"]
115'
['115']
parsed_discourse_facet ['method_citation']
<S sid="132" ssid="17">Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["132'"]
132'
['132']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["25'"]
25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="94" ssid="70">We now turn to the task of mapping natural language For the example in Figure 4(b), the de- utterances to DCS trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["94'"]
94'
['94']
parsed_discourse_facet ['method_citation']
<S sid="132" ssid="17">Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["132'"]
132'
['132']
parsed_discourse_facet ['method_citation']
<S sid="157" ssid="42">Eisenciations due to data sparsity, and having an insuffi- stein et al. (2009) induces conjunctive formulae and ciently large K. uses them as features in another learning problem.</S>
original cit marker offset is 0
new cit marker offset is 0



["157'"]
157'
['157']
parsed_discourse_facet ['method_citation']
<S sid="106" ssid="82">Learning Given a training dataset D containing (x, y) pairs, we define the regularized marginal log-likelihood objective O(&#952;) = E(x,y)ED log p&#952;(JzKw = y  |x, z &#8712; ZL(x)) &#8722; &#955;k&#952;k22, which sums over all DCS trees z that evaluate to the target answer y.</S>
original cit marker offset is 0
new cit marker offset is 0



["106'"]
106'
['106']
parsed_discourse_facet ['method_citation']
<S sid="167" ssid="52">In DCS, we start with lexical triggers, which are 6 Conclusion more basic than CCG lexical entries.</S>
original cit marker offset is 0
new cit marker offset is 0



["167'"]
167'
['167']
parsed_discourse_facet ['method_citation']
<S sid="138" ssid="23">Next, we compared our systems (DCS and DCS+) with the state-of-the-art semantic parsers on the full dataset for both GEO and JOBS (see Table 3).</S>
original cit marker offset is 0
new cit marker offset is 0



["138'"]
138'
['138']
parsed_discourse_facet ['method_citation']
<S sid="40" ssid="16">The CSP has two types of constraints: (i) x &#8712; w(p) for each node x labeled with predicate p &#8712; P; and (ii) xj = yj0 (the j-th component of x must equal the j'-th component of y) for each edge (x, y) labeled with j0j &#8712; R. A solution to the CSP is an assignment of nodes to values that satisfies all the constraints.</S>
original cit marker offset is 0
new cit marker offset is 0



["40'"]
40'
['40']
parsed_discourse_facet ['method_citation']
<S sid="171" ssid="56">This yields a more system is based on a new semantic representation, factorized and flexible representation that is easier DCS, which offers a simple and expressive alterto search through and parametrize using features. native to lambda calculus.</S>
original cit marker offset is 0
new cit marker offset is 0



["171'"]
171'
['171']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P11-1060.annv3.csv
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'7'", "'9'"]
'1'
'2'
'7'
'9'
['1', '2', '7', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="6" ssid="2">Answering these types of complex questions compositionally involves first mapping the questions into logical forms (semantic parsing).</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'6'", "'9'", "'10'"]
'2'
'6'
'9'
'10'
['2', '6', '9', '10']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="3" ssid="3">In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'8'", "'9'"]
'2'
'3'
'8'
'9'
['2', '3', '8', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="46" ssid="22">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).</S><S sid="48" ssid="24">In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.</S><S sid="49" ssid="25">Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compositional structures, but they cannot capture higherorder phenomena in language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'", "'46'", "'48'", "'49'"]
'25'
'46'
'48'
'49'
['25', '46', '48', '49']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.</S><S sid="34" ssid="10">Figure 2(a) shows an example of a DCS tree.</S><S sid="38" ssid="14">Let us start by considering a DCS tree z with only join relations.</S><S sid="107" ssid="83">Our model is arc-factored, so we can sum over all DCS trees in ZL(x) using dynamic programming.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'34'", "'38'", "'107'"]
'12'
'34'
'38'
'107'
['12', '34', '38', '107']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="164" ssid="49">Past work has also fofor the second.</S><S sid="165" ssid="50">These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'164'", "'165'", "'166'"]
'7'
'164'
'165'
'166'
['7', '164', '165', '166']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="156" ssid="41">There has been a fair amount of past work on no predicates), confusion of Washington state with this topic: Liang et al. (2010) induces combinatory Washington D.C., learning the wrong lexical asso- logic programs in a non-linguistic setting.</S><S sid="165" ssid="50">These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'8'", "'156'", "'165'"]
'7'
'8'
'156'
'165'
['7', '8', '156', '165']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="10" ssid="6">However, we still model the logical form (now as a latent variable) to capture the complexities of language.</S><S sid="135" ssid="20">SEMRESP requires a lexicon of 1.42 words per non-value predicate, WordNet features, and syntactic parse trees; DCS requires only words for the domain-independent predicates (overall, around 0.5 words per non-value predicate), POS tags, and very simple indicator features.</S><S sid="136" ssid="21">In fact, DCS performs comparably to even the version of SEMRESP trained using logical forms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'10'", "'135'", "'136'"]
'9'
'10'
'135'
'136'
['9', '10', '135', '136']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="3" ssid="3">In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid="5" ssid="1">What is the total population of the ten largest capitals in the US?</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'5'", "'22'"]
'2'
'3'
'5'
'22'
['2', '3', '5', '22']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="132" ssid="17">Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'9'", "'132'"]
'1'
'2'
'9'
'132'
['1', '2', '9', '132']
parsed_discourse_facet ['hypothesis_citation']
<S sid="21" ssid="17">The main technical contribution of this work is a new semantic representation, dependency-based compositional semantics (DCS), which is both simple and expressive (Section 2).</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'22'", "'25'", "'36'"]
'21'
'22'
'25'
'36'
['21', '22', '25', '36']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="47" ssid="23">This algorithm is linear in the number of nodes times the size of the denotations.1 Now the dual importance of trees in DCS is clear: We have seen that trees parallel syntactic dependency structure, which will facilitate parsing.</S><S sid="48" ssid="24">In addition, trees enable efficient computation, thereby establishing a new connection between dependency syntax and efficient semantic evaluation.</S><S sid="49" ssid="25">Aggregate relation DCS trees that only use join relations can represent arbitrarily complex compositional structures, but they cannot capture higherorder phenomena in language.</S><S sid="94" ssid="70">We now turn to the task of mapping natural language For the example in Figure 4(b), the de- utterances to DCS trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'47'", "'48'", "'49'", "'94'"]
'47'
'48'
'49'
'94'
['47', '48', '49', '94']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.</S><S sid="33" ssid="9">As another example, w(average) = {(S, &#175;x) : We write a DCS tree z as hp; r1 : c1; ... ; rm : cmi.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S><S sid="167" ssid="52">In DCS, we start with lexical triggers, which are 6 Conclusion more basic than CCG lexical entries.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'33'", "'166'", "'167'"]
'12'
'33'
'166'
'167'
['12', '33', '166', '167']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="43" ssid="19">Computation We can compute the denotation JzKw of a DCS tree z by exploiting dynamic programming on trees (Dechter, 2003).</S><S sid="46" ssid="22">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).</S><S sid="50" ssid="26">For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.</S><S sid="86" ssid="62">Formally, extraction simply moves the i-th column to the front: Xi(d) = di, &#8722;(i, &#248;){&#945;1 = &#248;}.</S>
original cit marker offset is 0
new cit marker offset is 0



["'43'", "'46'", "'50'", "'86'"]
'43'
'46'
'50'
'86'
['43', '46', '50', '86']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.</S><S sid="2" ssid="2">In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.</S><S sid="8" ssid="4">On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'9'"]
'1'
'2'
'8'
'9'
['1', '2', '8', '9']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="133" ssid="18">Table 2 shows that our system using lexical triggers L (henceforth, DCS) outperforms SEMRESP (78.9% over 73.2%).</S><S sid="140" ssid="25">Table 3 shows that even DCS, which does not use prototypes, is comparable to the best previous system (Kwiatkowski et al., 2010), and by adding a few prototypes, DCS+ offers a decisive edge (91.1% over 88.9% on GEO).</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'133'", "'140'", "'166'"]
'7'
'133'
'140'
'166'
['7', '133', '140', '166']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="7" ssid="3">Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.</S><S sid="9" ssid="5">As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid="162" ssid="47">The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.</S><S sid="164" ssid="49">Past work has also fofor the second.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'9'", "'162'", "'164'"]
'7'
'9'
'162'
'164'
['7', '9', '162', '164']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="17" ssid="13">The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.</S><S sid="22" ssid="18">The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid="25" ssid="1">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.</S><S sid="36" ssid="12">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'22'", "'25'", "'36'"]
'17'
'22'
'25'
'36'
['17', '22', '25', '36']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="13">The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.</S><S sid="50" ssid="26">For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.</S><S sid="150" ssid="35">For example, area (by virtue which results in programs (DCS trees) which are of being a noun) triggers many predicates: city, much simpler than the logically-equivalent lambda state, area, etc.</S><S sid="166" ssid="51">Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'50'", "'150'", "'166'"]
'17'
'50'
'150'
'166'
['17', '50', '150', '166']
parsed_discourse_facet ['method_citation']
dict_values(['On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.'])
dict_values(['Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.', 'In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.', 'Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.', 'As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00032', '(95%-conf.int.', '0.00032', '-', '0.00032)']
['system', 'ROUGE-S*', 'Average_P:', '0.00952', '(95%-conf.int.', '0.00952', '-', '0.00952)']
['system', 'ROUGE-S*', 'Average_F:', '0.00063', '(95%-conf.int.', '0.00063', '-', '0.00063)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3081', 'P:105', 'F:1']
dict_values(['It is impossible to represent the semantics of this phrase with just a CSP, so we introduce a new aggregate relation, notated E. Consider a tree hE:ci, whose root is connected to a child c via E. If the denotation of c is a set of values s, the parent&#8217;s denotation is then a singleton set containing s. Formally: Figure 3(a) shows the DCS tree for our running example.'])
dict_values(['We represent logical forms z as labeled trees, induced automatically from (x, y) pairs.', 'Figure 2(a) shows an example of a DCS tree.', 'Let us start by considering a DCS tree z with only join relations.', 'Our model is arc-factored, so we can sum over all DCS trees in ZL(x) using dynamic programming.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05128', '(95%-conf.int.', '0.05128', '-', '0.05128)']
['system', 'ROUGE-S*', 'Average_P:', '0.04433', '(95%-conf.int.', '0.04433', '-', '0.04433)']
['system', 'ROUGE-S*', 'Average_F:', '0.04756', '(95%-conf.int.', '0.04756', '-', '0.04756)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:351', 'P:406', 'F:18']
dict_values(['Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.'])
dict_values(['Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.', 'Past work has also fofor the second.', 'These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.', 'Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07087', '(95%-conf.int.', '0.07087', '-', '0.07087)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.13236', '(95%-conf.int.', '0.13236', '-', '0.13236)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3570', 'P:253', 'F:253']
dict_values(['On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.'])
dict_values(['Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.', 'On the other hand, existing unsupervised semantic parsers (Poon and Domingos, 2009) do not handle deeper linguistic phenomena such as quantification, negation, and superlatives.', 'There has been a fair amount of past work on no predicates), confusion of Washington state with this topic: Liang et al. (2010) induces combinatory Washington D.C., learning the wrong lexical asso- logic programs in a non-linguistic setting.', 'These rules are often too stringent, cused on aligning text to a world (Liang et al., 2009), and for complex utterances, especially in free word- using text in reinforcement learning (Branavan et al., order languages, either disharmonic combinators are 2009; Branavan et al., 2010), and many others.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02255', '(95%-conf.int.', '0.02255', '-', '0.02255)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.04411', '(95%-conf.int.', '0.04411', '-', '0.04411)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4656', 'P:105', 'F:105']
dict_values(['Figure 1 shows our probabilistic model: with respect to a world w (database of facts), producing an answer y.'])
dict_values(['As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.', 'However, we still model the logical form (now as a latent variable) to capture the complexities of language.', 'SEMRESP requires a lexicon of 1.42 words per non-value predicate, WordNet features, and syntactic parse trees; DCS requires only words for the domain-independent predicates (overall, around 0.5 words per non-value predicate), POS tags, and very simple indicator features.', 'In fact, DCS performs comparably to even the version of SEMRESP trained using logical forms.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00125', '(95%-conf.int.', '0.00125', '-', '0.00125)']
['system', 'ROUGE-S*', 'Average_P:', '0.03636', '(95%-conf.int.', '0.03636', '-', '0.03636)']
['system', 'ROUGE-S*', 'Average_F:', '0.00242', '(95%-conf.int.', '0.00242', '-', '0.00242)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:55', 'F:2']
dict_values(['After training, given a new utterance x, our system outputs the most likely y, summing out the latent logical form z: argmaxy p&#952;(T)(y  |x, z &#8712; &#732;ZL,&#952;(T)).'])
dict_values(['In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.', 'In tackling this challenging learning problem, we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.', 'What is the total population of the ten largest capitals in the US?', 'The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00226', '(95%-conf.int.', '0.00226', '-', '0.00226)']
['system', 'ROUGE-S*', 'Average_P:', '0.03297', '(95%-conf.int.', '0.03297', '-', '0.03297)']
['system', 'ROUGE-S*', 'Average_F:', '0.00423', '(95%-conf.int.', '0.00423', '-', '0.00423)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1326', 'P:91', 'F:3']
dict_values(['Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.'])
dict_values(['Compositional question answering begins by mapping questions to logical forms, but training a semantic parser to perform this mapping typically requires the costly annotation of the target logical forms.', 'In this paper, we learn to map questions to answers via latent logical forms, which are induced automatically from question-answer pairs.', 'As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.', 'Results We first compare our system with Clarke et al. (2010) (henceforth, SEMRESP), which also learns a semantic parser from question-answer pairs.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05738', '(95%-conf.int.', '0.05738', '-', '0.05738)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10853', '(95%-conf.int.', '0.10853', '-', '0.10853)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:105', 'F:105']
dict_values(['Eisenciations due to data sparsity, and having an insuffi- stein et al. (2009) induces conjunctive formulae and ciently large K. uses them as features in another learning problem.'])
dict_values(['Computation We can compute the denotation JzKw of a DCS tree z by exploiting dynamic programming on trees (Dechter, 2003).', 'Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees, where each z &#8712; Z consists of (i) a predicate for each child i, the ji-th component of v must equal the j\\i-th component of some t in the child&#8217;s denotation (t &#8712; JciKw).', 'For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.', 'Formally, extraction simply moves the i-th column to the front: Xi(d) = di, &#8722;(i, &#248;){&#945;1 = &#248;}.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:120', 'F:0']
dict_values(['In DCS, we start with lexical triggers, which are 6 Conclusion more basic than CCG lexical entries.'])
dict_values(['Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.', 'Table 2 shows that our system using lexical triggers L (henceforth, DCS) outperforms SEMRESP (78.9% over 73.2%).', 'Table 3 shows that even DCS, which does not use prototypes, is comparable to the best previous system (Kwiatkowski et al., 2010), and by adding a few prototypes, DCS+ offers a decisive edge (91.1% over 88.9% on GEO).', 'Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00215', '(95%-conf.int.', '0.00215', '-', '0.00215)']
['system', 'ROUGE-S*', 'Average_P:', '0.20000', '(95%-conf.int.', '0.20000', '-', '0.20000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00425', '(95%-conf.int.', '0.00425', '-', '0.00425)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4186', 'P:45', 'F:9']
dict_values(['Next, we compared our systems (DCS and DCS+) with the state-of-the-art semantic parsers on the full dataset for both GEO and JOBS (see Table 3).'])
dict_values(['Supervised semantic parsers (Zelle and Mooney, 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010) rely on manual annotation of logical forms, which is expensive.', 'As in Clarke et al. (2010), we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.', 'The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.', 'Past work has also fofor the second.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00055', '(95%-conf.int.', '0.00055', '-', '0.00055)']
['system', 'ROUGE-S*', 'Average_P:', '0.01099', '(95%-conf.int.', '0.01099', '-', '0.01099)']
['system', 'ROUGE-S*', 'Average_F:', '0.00104', '(95%-conf.int.', '0.00104', '-', '0.00104)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:91', 'F:1']
dict_values(["The CSP has two types of constraints: (i) x &#8712; w(p) for each node x labeled with predicate p &#8712; P; and (ii) xj = yj0 (the j-th component of x must equal the j'-th component of y) for each edge (x, y) labeled with j0j &#8712; R. A solution to the CSP is an assignment of nodes to values that satisfies all the constraints."])
dict_values(['The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.', 'The logical forms in this framework are trees, which is desirable for two reasons: (i) they parallel syntactic dependency trees, which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.', 'We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS), which captures the core idea of using trees to represent formal semantics.', 'It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1953', 'P:300', 'F:0']
dict_values(['This yields a more system is based on a new semantic representation, factorized and flexible representation that is easier DCS, which offers a simple and expressive alterto search through and parametrize using features. native to lambda calculus.'])
dict_values(['The dominant paradigm in compositional semantics is Montague semantics, which constructs lambda calculus forms in a bottom-up manner.', 'For example, consider the phrase number of major cities, and suppose that number corresponds to the count predicate.', 'For example, area (by virtue which results in programs (DCS trees) which are of being a noun) triggers many predicates: city, much simpler than the logically-equivalent lambda state, area, etc.', 'Our employed (Zettlemoyer and Collins, 2007) or words work pushes the grounded language agenda towards are given multiple lexical entries (Kwiatkowski et deeper representations of language&#8212;think grounded al., 2010). compositional semantics.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00395', '(95%-conf.int.', '0.00395', '-', '0.00395)']
['system', 'ROUGE-S*', 'Average_P:', '0.03684', '(95%-conf.int.', '0.03684', '-', '0.03684)']
['system', 'ROUGE-S*', 'Average_F:', '0.00714', '(95%-conf.int.', '0.00714', '-', '0.00714)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:190', 'F:7']
0.2809174976590209 0.017713333185722224 0.02935583308870139





input/ref/Task1/P11-1061_aakansha.csv
input/res/Task1/P11-1061.annv3.csv
parsing: input/ref/Task1/P11-1061_aakansha.csv
<S sid="40" ssid="6">We extend Subramanya et al.&#8217;s intuitions to our bilingual setup.</S>
original cit marker offset is 0
new cit marker offset is 0



["'40'"]
'40'
['40']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="11">First, we use a novel graph-based framework for projecting syntactic information across language boundaries.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'"]
'15'
['15']
parsed_discourse_facet ['method_citation']
<S sid="25" ssid="2">Central to our approach (see Algorithm 1) is a bilingual similarity graph built from a sentence-aligned parallel corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'"]
'25'
['25']
parsed_discourse_facet ['method_citation']
<S sid="29" ssid="6">To establish a soft correspondence between the two languages, we use a second similarity function, which leverages standard unsupervised word alignment statistics (&#167;3.3).3 Since we have no labeled foreign data, our goal is to project syntactic information from the English side to the foreign side.</S>
original cit marker offset is 0
new cit marker offset is 0



["'29'"]
'29'
['29']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'"]
'18'
['18']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'"]
'18'
['18']
parsed_discourse_facet ['method_citation']
<S sid="158" ssid="1">We have shown the efficacy of graph-based label propagation for projecting part-of-speech information across languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'158'"]
'158'
['158']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">These universal POS categories not only facilitate the transfer of POS information from one language to another, but also relieve us from using controversial evaluation metrics,2 by establishing a direct correspondence between the induced hidden states in the foreign language and the observed English labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="158" ssid="1">We have shown the efficacy of graph-based label propagation for projecting part-of-speech information across languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'158'"]
'158'
['158']
parsed_discourse_facet ['method_citation']
<S sid="21" ssid="17">These universal POS categories not only facilitate the transfer of POS information from one language to another, but also relieve us from using controversial evaluation metrics,2 by establishing a direct correspondence between the induced hidden states in the foreign language and the observed English labels.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'24'"]
'24'
['24']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'"]
'17'
['17']
parsed_discourse_facet ['method_citation']
<S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S>
original cit marker offset is 0
new cit marker offset is 0



["'111'"]
'111'
['111']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="29" ssid="6">To establish a soft correspondence between the two languages, we use a second similarity function, which leverages standard unsupervised word alignment statistics (&#167;3.3).3 Since we have no labeled foreign data, our goal is to project syntactic information from the English side to the foreign side.</S>
original cit marker offset is 0
new cit marker offset is 0



["'29'"]
'29'
['29']
parsed_discourse_facet ['method_citation']
<S sid="161" ssid="4">Our results outperform strong unsupervised baselines as well as approaches that rely on direct projections, and bridge the gap between purely supervised and unsupervised POS tagging models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'161'"]
'161'
['161']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P11-1061.annv3.csv
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="7" ssid="3">However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.</S><S sid="8" ssid="4">Unsupervised learning approaches appear to be a natural solution to this problem, as they require only unannotated text for training models.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'7'", "'8'", "'18'"]
'1'
'7'
'8'
'18'
['1', '7', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="6" ssid="2">Supervised part-of-speech (POS) taggers, for example, approach the level of inter-annotator agreement (Shen et al., 2007, 97.3% accuracy for English).</S><S sid="7" ssid="3">However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.</S><S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'6'", "'7'", "'9'"]
'1'
'6'
'7'
'9'
['1', '6', '7', '9']
parsed_discourse_facet ['hypothesis_citation', 'results_citation']
<S sid="0">Unsupervised Part-of-Speech Tagging with Bilingual Graph-Based Projections</S><S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'112'", "'113'"]
'0'
'2'
'112'
'113'
['0', '2', '112', '113']
parsed_discourse_facet ['aim_citation']
<S sid="27" ssid="4">Graph construction does not require any labeled data, but makes use of two similarity functions.</S><S sid="47" ssid="13">Our monolingual similarity function (for connecting pairs of foreign trigram types) is the same as the one used by Subramanya et al. (2010).</S><S sid="48" ssid="14">We briefly review it here for completeness.</S><S sid="51" ssid="17">For each trigram type x2 x3 x4 in a sequence x1 x2 x3 x4 x5, we count how many times that trigram type co-occurs with the different instantiations of each concept, and compute the point-wise mutual information (PMI) between the two.5 The similarity between two trigram types is given by summing over the PMI values over feature instantiations that they have in common.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'47'", "'48'", "'51'"]
'27'
'47'
'48'
'51'
['27', '47', '48', '51']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="4">Graph construction does not require any labeled data, but makes use of two similarity functions.</S><S sid="57" ssid="23">Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.</S><S sid="69" ssid="35">Label propagation is used to propagate these tags inwards and results in tag distributions for the middle word of each Italian trigram.</S><S sid="97" ssid="28">This formulation of the constraint feature is equivalent to the use of a tagging dictionary extracted from the graph using a threshold T on the posterior distribution of tags for a given word type (Eq.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'57'", "'69'", "'97'"]
'27'
'57'
'69'
'97'
['27', '57', '69', '97']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S><S sid="96" ssid="27">The function A : F &#8212;* C maps from the language specific fine-grained tagset F to the coarser universal tagset C and is described in detail in &#167;6.2: Note that when tx(y) = 1 the feature value is 0 and has no effect on the model, while its value is &#8722;oc when tx(y) = 0 and constrains the HMM&#8217;s state space.</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'96'", "'111'", "'113'"]
'19'
'96'
'111'
'113'
['19', '96', '111', '113']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S><S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'17'", "'18'", "'113'"]
'3'
'17'
'18'
'113'
['3', '17', '18', '113']
parsed_discourse_facet ['results_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'111'", "'112'", "'113'"]
'18'
'111'
'112'
'113'
['18', '111', '112', '113']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'24'", "'112'", "'113'"]
'1'
'24'
'112'
'113'
['1', '24', '112', '113']
parsed_discourse_facet ['aim_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S><S sid="16" ssid="12">To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).</S><S sid="70" ssid="1">Given the bilingual graph described in the previous section, we can use label propagation to project the English POS labels to the foreign language.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'16'", "'70'", "'113'"]
'3'
'16'
'70'
'113'
['3', '16', '70', '113']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="29" ssid="6">To establish a soft correspondence between the two languages, we use a second similarity function, which leverages standard unsupervised word alignment statistics (&#167;3.3).3 Since we have no labeled foreign data, our goal is to project syntactic information from the English side to the foreign side.</S><S sid="57" ssid="23">Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'24'", "'29'", "'57'"]
'1'
'24'
'29'
'57'
['1', '24', '29', '57']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S><S sid="71" ssid="2">We use label propagation in two stages to generate soft labels on all the vertices in the graph.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'10'", "'71'", "'113'"]
'1'
'10'
'71'
'113'
['1', '10', '71', '113']
parsed_discourse_facet ['results_citation']
<S sid="4" ssid="4">Across eight European languages, our approach results in an average absolute improvement of 10.4% over a state-of-the-art baseline, and 16.7% over vanilla hidden Markov models induced with the Expectation Maximization algorithm.</S><S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S><S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'9'", "'19'", "'112'"]
'4'
'9'
'19'
'112'
['4', '9', '19', '112']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S><S sid="114" ssid="14">The supervised POS tagging accuracies (on this tagset) are shown in the last row of Table 2.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'18'", "'113'", "'114'"]
'17'
'18'
'113'
'114'
['17', '18', '113', '114']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'17'", "'112'", "'113'"]
'1'
'17'
'112'
'113'
['1', '17', '112', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'24'", "'113'"]
'1'
'2'
'24'
'113'
['1', '2', '24', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'18'", "'111'", "'113'"]
'1'
'18'
'111'
'113'
['1', '18', '111', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="93" ssid="24">For English POS tagging, BergKirkpatrick et al. (2010) found that this direct gradient method performed better (&gt;7% absolute accuracy) than using a feature-enhanced modification of the Expectation-Maximization (EM) algorithm (Dempster et al., 1977).8 Moreover, this route of optimization outperformed a vanilla HMM trained with EM by 12%.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S><S sid="117" ssid="17">In other words, the set of hidden states F was chosen to be the fine set of treebank tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'93'", "'112'", "'113'", "'117'"]
'93'
'112'
'113'
'117'
['93', '112', '113', '117']
parsed_discourse_facet ['method_citation']
dict_values(['We extend Subramanya et al.&#8217;s intuitions to our bilingual setup.'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.', 'Unsupervised learning approaches appear to be a natural solution to this problem, as they require only unannotated text for training models.', 'To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:21', 'F:0']
dict_values(['To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'Supervised part-of-speech (POS) taggers, for example, approach the level of inter-annotator agreement (Shen et al., 2007, 97.3% accuracy for English).', 'However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.', 'Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02433', '(95%-conf.int.', '0.02433', '-', '0.02433)']
['system', 'ROUGE-S*', 'Average_P:', '0.08712', '(95%-conf.int.', '0.08712', '-', '0.08712)']
['system', 'ROUGE-S*', 'Average_F:', '0.03803', '(95%-conf.int.', '0.03803', '-', '0.03803)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:528', 'F:46']
dict_values(['To establish a soft correspondence between the two languages, we use a second similarity function, which leverages standard unsupervised word alignment statistics (&#167;3.3).3 Since we have no labeled foreign data, our goal is to project syntactic information from the English side to the foreign side.'])
dict_values(['Graph construction does not require any labeled data, but makes use of two similarity functions.', 'Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.', 'Label propagation is used to propagate these tags inwards and results in tag distributions for the middle word of each Italian trigram.', 'This formulation of the constraint feature is equivalent to the use of a tagging dictionary extracted from the graph using a threshold T on the posterior distribution of tags for a given word type (Eq.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01058', '(95%-conf.int.', '0.01058', '-', '0.01058)']
['system', 'ROUGE-S*', 'Average_P:', '0.10256', '(95%-conf.int.', '0.10256', '-', '0.10256)']
['system', 'ROUGE-S*', 'Average_F:', '0.01918', '(95%-conf.int.', '0.01918', '-', '0.01918)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3403', 'P:351', 'F:36']
dict_values(['To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).'])
dict_values(['We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).', 'Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.', 'To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03993', '(95%-conf.int.', '0.03993', '-', '0.03993)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.07679', '(95%-conf.int.', '0.07679', '-', '0.07679)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:66', 'F:66']
dict_values(['We have shown the efficacy of graph-based label propagation for projecting part-of-speech information across languages.'])
dict_values(['To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).', 'We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00160', '(95%-conf.int.', '0.00160', '-', '0.00160)']
['system', 'ROUGE-S*', 'Average_P:', '0.10909', '(95%-conf.int.', '0.10909', '-', '0.10909)']
['system', 'ROUGE-S*', 'Average_F:', '0.00316', '(95%-conf.int.', '0.00316', '-', '0.00316)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3741', 'P:55', 'F:6']
dict_values(['These universal POS categories not only facilitate the transfer of POS information from one language to another, but also relieve us from using controversial evaluation metrics,2 by establishing a direct correspondence between the induced hidden states in the foreign language and the observed English labels.'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01586', '(95%-conf.int.', '0.01586', '-', '0.01586)']
['system', 'ROUGE-S*', 'Average_P:', '0.10870', '(95%-conf.int.', '0.10870', '-', '0.10870)']
['system', 'ROUGE-S*', 'Average_F:', '0.02769', '(95%-conf.int.', '0.02769', '-', '0.02769)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:276', 'F:30']
dict_values(['We have shown the efficacy of graph-based label propagation for projecting part-of-speech information across languages.'])
dict_values(['We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).', 'To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).', 'Given the bilingual graph described in the previous section, we can use label propagation to project the English POS labels to the foreign language.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00895', '(95%-conf.int.', '0.00895', '-', '0.00895)']
['system', 'ROUGE-S*', 'Average_P:', '0.38182', '(95%-conf.int.', '0.38182', '-', '0.38182)']
['system', 'ROUGE-S*', 'Average_F:', '0.01749', '(95%-conf.int.', '0.01749', '-', '0.01749)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:55', 'F:21']
dict_values(['To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.', 'We use label propagation in two stages to generate soft labels on all the vertices in the graph.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.19027', '(95%-conf.int.', '0.19027', '-', '0.19027)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.31971', '(95%-conf.int.', '0.31971', '-', '0.31971)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:528', 'F:528']
dict_values(['The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.'])
dict_values(['Across eight European languages, our approach results in an average absolute improvement of 10.4% over a state-of-the-art baseline, and 16.7% over vanilla hidden Markov models induced with the Expectation Maximization algorithm.', 'Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.', 'Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00381', '(95%-conf.int.', '0.00381', '-', '0.00381)']
['system', 'ROUGE-S*', 'Average_P:', '0.10989', '(95%-conf.int.', '0.10989', '-', '0.10989)']
['system', 'ROUGE-S*', 'Average_F:', '0.00736', '(95%-conf.int.', '0.00736', '-', '0.00736)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2628', 'P:91', 'F:10']
dict_values(['We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01870', '(95%-conf.int.', '0.01870', '-', '0.01870)']
['system', 'ROUGE-S*', 'Average_P:', '0.03544', '(95%-conf.int.', '0.03544', '-', '0.03544)']
['system', 'ROUGE-S*', 'Average_F:', '0.02448', '(95%-conf.int.', '0.02448', '-', '0.02448)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:903', 'F:32']
dict_values(['Our results outperform strong unsupervised baselines as well as approaches that rely on direct projections, and bridge the gap between purely supervised and unsupervised POS tagging models.'])
dict_values(['For English POS tagging, BergKirkpatrick et al. (2010) found that this direct gradient method performed better (&gt;7% absolute accuracy) than using a feature-enhanced modification of the Expectation-Maximization (EM) algorithm (Dempster et al., 1977).8 Moreover, this route of optimization outperformed a vanilla HMM trained with EM by 12%.', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.', 'In other words, the set of hidden states F was chosen to be the fine set of treebank tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00180', '(95%-conf.int.', '0.00180', '-', '0.00180)']
['system', 'ROUGE-S*', 'Average_P:', '0.03676', '(95%-conf.int.', '0.03676', '-', '0.03676)']
['system', 'ROUGE-S*', 'Average_F:', '0.00344', '(95%-conf.int.', '0.00344', '-', '0.00344)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:136', 'F:5']
0.2701254520897687 0.028711817920801658 0.048848181374107444





input/ref/Task1/P11-1061_swastika.csv
input/res/Task1/P11-1061.annv3.csv
parsing: input/ref/Task1/P11-1061_swastika.csv
    <S sid="144" ssid="7">For comparison, the completely unsupervised feature-HMM baseline accuracy on the universal POS tags for English is 79.4%, and goes up to 88.7% with a treebank dictionary.</S>
original cit marker offset is 0
new cit marker offset is 0



['144']
144
['144']
parsed_discourse_facet ['result_citation']
    <S sid="44" ssid="10">Because all English vertices are going to be labeled, we do not need to disambiguate them by embedding them in trigrams.</S
original cit marker offset is 0
new cit marker offset is 0



['44']
44
['44']
parsed_discourse_facet ['method_citation']
    <S sid="16" ssid="12">To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).</S>
original cit marker offset is 0
new cit marker offset is 0



['16']
16
['16']
parsed_discourse_facet ['method_citation']
    <S sid="44" ssid="10">Because all English vertices are going to be labeled, we do not need to disambiguate them by embedding them in trigrams.</S
original cit marker offset is 0
new cit marker offset is 0



['44']
44
['44']
parsed_discourse_facet ['method_citation']
<S sid="110" ssid="10">We hope that this will allow practitioners to apply our approach directly to languages for which no resources are available.</S>
original cit marker offset is 0
new cit marker offset is 0



['110']
110
['110']
parsed_discourse_facet ['aim_citation']
    <S sid="115" ssid="15">The taggers were trained on datasets labeled with the universal tags.</S>
original cit marker offset is 0
new cit marker offset is 0



['115']
115
['115']
parsed_discourse_facet ['method_citation']
    <S sid="115" ssid="15">The taggers were trained on datasets labeled with the universal tags.</S>
original cit marker offset is 0
new cit marker offset is 0



['115']
115
['115']
parsed_discourse_facet ['method_citation']
<S sid="158" ssid="1">We have shown the efficacy of graph-based label propagation for projecting part-of-speech information across languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['158']
158
['158']
parsed_discourse_facet ['result_citation']
<S sid="23" ssid="19">Our final average POS tagging accuracy of 83.4% compares very favorably to the average accuracy of Berg-Kirkpatrick et al.&#8217;s monolingual unsupervised state-of-the-art model (73.0%), and considerably bridges the gap to fully supervised POS tagging performance (96.6%).</S>
original cit marker offset is 0
new cit marker offset is 0



['23']
23
['23']
parsed_discourse_facet ['result_citation']
<S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['24']
24
['24']
parsed_discourse_facet ['aim_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



['10']
10
['10']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



['???']
???
['???']
parsed_discourse_facet ['method_citation']
    <S sid="16" ssid="12">To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).</S>
original cit marker offset is 0
new cit marker offset is 0



['16']
16
['16']
parsed_discourse_facet ['method_citation']
    <S sid="23" ssid="19">Our final average POS tagging accuracy of 83.4% compares very favorably to the average accuracy of Berg-Kirkpatrick et al.&#8217;s monolingual unsupervised state-of-the-art model (73.0%), and considerably bridges the gap to fully supervised POS tagging performance (96.6%).</S>
original cit marker offset is 0
new cit marker offset is 0



['23']
23
['23']
parsed_discourse_facet ['result_citation']
<S sid="158" ssid="1">We have shown the efficacy of graph-based label propagation for projecting part-of-speech information across languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['158']
158
['158']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



['10']
10
['10']
parsed_discourse_facet ['method_citation']
<S sid="56" ssid="22">To define a similarity function between the English and the foreign vertices, we rely on high-confidence word alignments.</S>
original cit marker offset is 0
new cit marker offset is 0



['56']
56
['56']
parsed_discourse_facet ['method_citation']
<S sid="161" ssid="4">Our results outperform strong unsupervised baselines as well as approaches that rely on direct projections, and bridge the gap between purely supervised and unsupervised POS tagging models.</S>
original cit marker offset is 0
new cit marker offset is 0



['161']
161
['161']
parsed_discourse_facet ['result_citation']
parsing: input/res/Task1/P11-1061.annv3.csv
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="7" ssid="3">However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.</S><S sid="8" ssid="4">Unsupervised learning approaches appear to be a natural solution to this problem, as they require only unannotated text for training models.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'7'", "'8'", "'18'"]
'1'
'7'
'8'
'18'
['1', '7', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="6" ssid="2">Supervised part-of-speech (POS) taggers, for example, approach the level of inter-annotator agreement (Shen et al., 2007, 97.3% accuracy for English).</S><S sid="7" ssid="3">However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.</S><S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'6'", "'7'", "'9'"]
'1'
'6'
'7'
'9'
['1', '6', '7', '9']
parsed_discourse_facet ['hypothesis_citation', 'results_citation']
<S sid="0">Unsupervised Part-of-Speech Tagging with Bilingual Graph-Based Projections</S><S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'112'", "'113'"]
'0'
'2'
'112'
'113'
['0', '2', '112', '113']
parsed_discourse_facet ['aim_citation']
<S sid="27" ssid="4">Graph construction does not require any labeled data, but makes use of two similarity functions.</S><S sid="47" ssid="13">Our monolingual similarity function (for connecting pairs of foreign trigram types) is the same as the one used by Subramanya et al. (2010).</S><S sid="48" ssid="14">We briefly review it here for completeness.</S><S sid="51" ssid="17">For each trigram type x2 x3 x4 in a sequence x1 x2 x3 x4 x5, we count how many times that trigram type co-occurs with the different instantiations of each concept, and compute the point-wise mutual information (PMI) between the two.5 The similarity between two trigram types is given by summing over the PMI values over feature instantiations that they have in common.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'47'", "'48'", "'51'"]
'27'
'47'
'48'
'51'
['27', '47', '48', '51']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="4">Graph construction does not require any labeled data, but makes use of two similarity functions.</S><S sid="57" ssid="23">Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.</S><S sid="69" ssid="35">Label propagation is used to propagate these tags inwards and results in tag distributions for the middle word of each Italian trigram.</S><S sid="97" ssid="28">This formulation of the constraint feature is equivalent to the use of a tagging dictionary extracted from the graph using a threshold T on the posterior distribution of tags for a given word type (Eq.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'57'", "'69'", "'97'"]
'27'
'57'
'69'
'97'
['27', '57', '69', '97']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S><S sid="96" ssid="27">The function A : F &#8212;* C maps from the language specific fine-grained tagset F to the coarser universal tagset C and is described in detail in &#167;6.2: Note that when tx(y) = 1 the feature value is 0 and has no effect on the model, while its value is &#8722;oc when tx(y) = 0 and constrains the HMM&#8217;s state space.</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'96'", "'111'", "'113'"]
'19'
'96'
'111'
'113'
['19', '96', '111', '113']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S><S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'17'", "'18'", "'113'"]
'3'
'17'
'18'
'113'
['3', '17', '18', '113']
parsed_discourse_facet ['results_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'111'", "'112'", "'113'"]
'18'
'111'
'112'
'113'
['18', '111', '112', '113']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'24'", "'112'", "'113'"]
'1'
'24'
'112'
'113'
['1', '24', '112', '113']
parsed_discourse_facet ['aim_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S><S sid="16" ssid="12">To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).</S><S sid="70" ssid="1">Given the bilingual graph described in the previous section, we can use label propagation to project the English POS labels to the foreign language.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'16'", "'70'", "'113'"]
'3'
'16'
'70'
'113'
['3', '16', '70', '113']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="29" ssid="6">To establish a soft correspondence between the two languages, we use a second similarity function, which leverages standard unsupervised word alignment statistics (&#167;3.3).3 Since we have no labeled foreign data, our goal is to project syntactic information from the English side to the foreign side.</S><S sid="57" ssid="23">Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'24'", "'29'", "'57'"]
'1'
'24'
'29'
'57'
['1', '24', '29', '57']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S><S sid="71" ssid="2">We use label propagation in two stages to generate soft labels on all the vertices in the graph.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'10'", "'71'", "'113'"]
'1'
'10'
'71'
'113'
['1', '10', '71', '113']
parsed_discourse_facet ['results_citation']
<S sid="4" ssid="4">Across eight European languages, our approach results in an average absolute improvement of 10.4% over a state-of-the-art baseline, and 16.7% over vanilla hidden Markov models induced with the Expectation Maximization algorithm.</S><S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S><S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'9'", "'19'", "'112'"]
'4'
'9'
'19'
'112'
['4', '9', '19', '112']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S><S sid="114" ssid="14">The supervised POS tagging accuracies (on this tagset) are shown in the last row of Table 2.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'18'", "'113'", "'114'"]
'17'
'18'
'113'
'114'
['17', '18', '113', '114']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'17'", "'112'", "'113'"]
'1'
'17'
'112'
'113'
['1', '17', '112', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'24'", "'113'"]
'1'
'2'
'24'
'113'
['1', '2', '24', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'18'", "'111'", "'113'"]
'1'
'18'
'111'
'113'
['1', '18', '111', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="93" ssid="24">For English POS tagging, BergKirkpatrick et al. (2010) found that this direct gradient method performed better (&gt;7% absolute accuracy) than using a feature-enhanced modification of the Expectation-Maximization (EM) algorithm (Dempster et al., 1977).8 Moreover, this route of optimization outperformed a vanilla HMM trained with EM by 12%.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S><S sid="117" ssid="17">In other words, the set of hidden states F was chosen to be the fine set of treebank tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'93'", "'112'", "'113'", "'117'"]
'93'
'112'
'113'
'117'
['93', '112', '113', '117']
parsed_discourse_facet ['method_citation']
dict_values(['For comparison, the completely unsupervised feature-HMM baseline accuracy on the universal POS tags for English is 79.4%, and goes up to 88.7% with a treebank dictionary.'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.', 'Unsupervised learning approaches appear to be a natural solution to this problem, as they require only unannotated text for training models.', 'To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00255', '(95%-conf.int.', '0.00255', '-', '0.00255)']
['system', 'ROUGE-S*', 'Average_P:', '0.02206', '(95%-conf.int.', '0.02206', '-', '0.02206)']
['system', 'ROUGE-S*', 'Average_F:', '0.00457', '(95%-conf.int.', '0.00457', '-', '0.00457)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:136', 'F:3']
dict_values(['Because all English vertices are going to be labeled, we do not need to disambiguate them by embedding them in trigrams.'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'Supervised part-of-speech (POS) taggers, for example, approach the level of inter-annotator agreement (Shen et al., 2007, 97.3% accuracy for English).', 'However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.', 'Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00053', '(95%-conf.int.', '0.00053', '-', '0.00053)']
['system', 'ROUGE-S*', 'Average_P:', '0.06667', '(95%-conf.int.', '0.06667', '-', '0.06667)']
['system', 'ROUGE-S*', 'Average_F:', '0.00105', '(95%-conf.int.', '0.00105', '-', '0.00105)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:15', 'F:1']
dict_values(['We hope that this will allow practitioners to apply our approach directly to languages for which no resources are available.'])
dict_values(['Graph construction does not require any labeled data, but makes use of two similarity functions.', 'Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.', 'Label propagation is used to propagate these tags inwards and results in tag distributions for the middle word of each Italian trigram.', 'This formulation of the constraint feature is equivalent to the use of a tagging dictionary extracted from the graph using a threshold T on the posterior distribution of tags for a given word type (Eq.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3403', 'P:21', 'F:0']
dict_values(['The taggers were trained on datasets labeled with the universal tags.'])
dict_values(['We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).', 'Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.', 'To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00302', '(95%-conf.int.', '0.00302', '-', '0.00302)']
['system', 'ROUGE-S*', 'Average_P:', '0.33333', '(95%-conf.int.', '0.33333', '-', '0.33333)']
['system', 'ROUGE-S*', 'Average_F:', '0.00600', '(95%-conf.int.', '0.00600', '-', '0.00600)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:15', 'F:5']
dict_values(['We have shown the efficacy of graph-based label propagation for projecting part-of-speech information across languages.'])
dict_values(['To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).', 'We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00160', '(95%-conf.int.', '0.00160', '-', '0.00160)']
['system', 'ROUGE-S*', 'Average_P:', '0.10909', '(95%-conf.int.', '0.10909', '-', '0.10909)']
['system', 'ROUGE-S*', 'Average_F:', '0.00316', '(95%-conf.int.', '0.00316', '-', '0.00316)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3741', 'P:55', 'F:6']
dict_values(['Our final average POS tagging accuracy of 83.4% compares very favorably to the average accuracy of Berg-Kirkpatrick et al.&#8217;s monolingual unsupervised state-of-the-art model (73.0%), and considerably bridges the gap to fully supervised POS tagging performance (96.6%).'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00793', '(95%-conf.int.', '0.00793', '-', '0.00793)']
['system', 'ROUGE-S*', 'Average_P:', '0.03024', '(95%-conf.int.', '0.03024', '-', '0.03024)']
['system', 'ROUGE-S*', 'Average_F:', '0.01257', '(95%-conf.int.', '0.01257', '-', '0.01257)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:496', 'F:15']
dict_values(['The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.'])
dict_values(['We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).', 'To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).', 'Given the bilingual graph described in the previous section, we can use label propagation to project the English POS labels to the foreign language.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00597', '(95%-conf.int.', '0.00597', '-', '0.00597)']
['system', 'ROUGE-S*', 'Average_P:', '0.15385', '(95%-conf.int.', '0.15385', '-', '0.15385)']
['system', 'ROUGE-S*', 'Average_F:', '0.01149', '(95%-conf.int.', '0.01149', '-', '0.01149)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:91', 'F:14']
dict_values(['To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.', 'We use label propagation in two stages to generate soft labels on all the vertices in the graph.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.19027', '(95%-conf.int.', '0.19027', '-', '0.19027)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.31971', '(95%-conf.int.', '0.31971', '-', '0.31971)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:528', 'F:528']
dict_values(['To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).'])
dict_values(['Across eight European languages, our approach results in an average absolute improvement of 10.4% over a state-of-the-art baseline, and 16.7% over vanilla hidden Markov models induced with the Expectation Maximization algorithm.', 'Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.', 'Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00228', '(95%-conf.int.', '0.00228', '-', '0.00228)']
['system', 'ROUGE-S*', 'Average_P:', '0.02597', '(95%-conf.int.', '0.02597', '-', '0.02597)']
['system', 'ROUGE-S*', 'Average_F:', '0.00420', '(95%-conf.int.', '0.00420', '-', '0.00420)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2628', 'P:231', 'F:6']
dict_values(['We have shown the efficacy of graph-based label propagation for projecting part-of-speech information across languages.'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00584', '(95%-conf.int.', '0.00584', '-', '0.00584)']
['system', 'ROUGE-S*', 'Average_P:', '0.18182', '(95%-conf.int.', '0.18182', '-', '0.18182)']
['system', 'ROUGE-S*', 'Average_F:', '0.01133', '(95%-conf.int.', '0.01133', '-', '0.01133)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:55', 'F:10']
dict_values(['Our results outperform strong unsupervised baselines as well as approaches that rely on direct projections, and bridge the gap between purely supervised and unsupervised POS tagging models.'])
dict_values(['For English POS tagging, BergKirkpatrick et al. (2010) found that this direct gradient method performed better (&gt;7% absolute accuracy) than using a feature-enhanced modification of the Expectation-Maximization (EM) algorithm (Dempster et al., 1977).8 Moreover, this route of optimization outperformed a vanilla HMM trained with EM by 12%.', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.', 'In other words, the set of hidden states F was chosen to be the fine set of treebank tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00180', '(95%-conf.int.', '0.00180', '-', '0.00180)']
['system', 'ROUGE-S*', 'Average_P:', '0.03676', '(95%-conf.int.', '0.03676', '-', '0.03676)']
['system', 'ROUGE-S*', 'Average_F:', '0.00344', '(95%-conf.int.', '0.00344', '-', '0.00344)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:136', 'F:5']
0.17816272565306615 0.020162727089429757 0.034319999688





input/ref/Task1/P11-1061_sweta.csv
input/res/Task1/P11-1061.annv3.csv
parsing: input/ref/Task1/P11-1061_sweta.csv
 <S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S>
original cit marker offset is 0
new cit marker offset is 0



["9'"]
9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="47" ssid="13">Our monolingual similarity function (for connecting pairs of foreign trigram types) is the same as the one used by Subramanya et al. (2010).</S>
original cit marker offset is 0
new cit marker offset is 0



["47'"]
47'
['47']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S>
original cit marker offset is 0
new cit marker offset is 0



["10'"]
10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="70" ssid="1">Given the bilingual graph described in the previous section, we can use label propagation to project the English POS labels to the foreign language.</S>
original cit marker offset is 0
new cit marker offset is 0



["70'"]
70'
['70']
parsed_discourse_facet ['method_citation']
<S sid="52" ssid="18">This is similar to stacking the different feature instantiations into long (sparse) vectors and computing the cosine similarity between them.</S>
original cit marker offset is 0
new cit marker offset is 0



["52'"]
52'
['52']
parsed_discourse_facet ['method_citation']
 <S sid="83" ssid="14">We then extract a set of possible tags tx(y) by eliminating labels whose probability is below a threshold value &#964;: We describe how we choose &#964; in &#167;6.4.</S>
original cit marker offset is 0
new cit marker offset is 0



["83'"]
83'
['83']
parsed_discourse_facet ['method_citation']
<S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["113'"]
113'
['113']
parsed_discourse_facet ['method_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S>
original cit marker offset is 0
new cit marker offset is 0



["3'"]
3'
['3']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["18'"]
18'
['18']
parsed_discourse_facet ['method_citation']
 <S sid="13" ssid="9">(2009) study related but different multilingual grammar and tagger induction tasks, where it is assumed that no labeled data at all is available.</S>
original cit marker offset is 0
new cit marker offset is 0



["13'"]
13'
['13']
parsed_discourse_facet ['method_citation']
 <S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S>
original cit marker offset is 0
new cit marker offset is 0



["3'"]
3'
['3']
parsed_discourse_facet ['method_citation']
<S sid="120" ssid="20">We were intentionally lenient with our baselines: bilingual information by projecting POS tags directly across alignments in the parallel data.</S>
original cit marker offset is 0
new cit marker offset is 0



["120'"]
120'
['120']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["2'"]
2'
['2']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S>
original cit marker offset is 0
new cit marker offset is 0



["19'"]
19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="153" ssid="16">Figure 2 shows an excerpt of a sentence from the Italian test set and the tags assigned by four different models, as well as the gold tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["153'"]
153'
['153']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["18'"]
18'
['18']
parsed_discourse_facet ['method_citation']
<S sid="161" ssid="4">Our results outperform strong unsupervised baselines as well as approaches that rely on direct projections, and bridge the gap between purely supervised and unsupervised POS tagging models.</S>
original cit marker offset is 0
new cit marker offset is 0



["161'"]
161'
['161']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="19">Our final average POS tagging accuracy of 83.4% compares very favorably to the average accuracy of Berg-Kirkpatrick et al.&#8217;s monolingual unsupervised state-of-the-art model (73.0%), and considerably bridges the gap to fully supervised POS tagging performance (96.6%).</S>
original cit marker offset is 0
new cit marker offset is 0



["23'"]
23'
['23']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="19">Our final average POS tagging accuracy of 83.4% compares very favorably to the average accuracy of Berg-Kirkpatrick et al.&#8217;s monolingual unsupervised state-of-the-art model (73.0%), and considerably bridges the gap to fully supervised POS tagging performance (96.6%).</S>
original cit marker offset is 0
new cit marker offset is 0



["23'"]
23'
['23']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P11-1061.annv3.csv
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="7" ssid="3">However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.</S><S sid="8" ssid="4">Unsupervised learning approaches appear to be a natural solution to this problem, as they require only unannotated text for training models.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'7'", "'8'", "'18'"]
'1'
'7'
'8'
'18'
['1', '7', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="6" ssid="2">Supervised part-of-speech (POS) taggers, for example, approach the level of inter-annotator agreement (Shen et al., 2007, 97.3% accuracy for English).</S><S sid="7" ssid="3">However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.</S><S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'6'", "'7'", "'9'"]
'1'
'6'
'7'
'9'
['1', '6', '7', '9']
parsed_discourse_facet ['hypothesis_citation', 'results_citation']
<S sid="0">Unsupervised Part-of-Speech Tagging with Bilingual Graph-Based Projections</S><S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'112'", "'113'"]
'0'
'2'
'112'
'113'
['0', '2', '112', '113']
parsed_discourse_facet ['aim_citation']
<S sid="27" ssid="4">Graph construction does not require any labeled data, but makes use of two similarity functions.</S><S sid="47" ssid="13">Our monolingual similarity function (for connecting pairs of foreign trigram types) is the same as the one used by Subramanya et al. (2010).</S><S sid="48" ssid="14">We briefly review it here for completeness.</S><S sid="51" ssid="17">For each trigram type x2 x3 x4 in a sequence x1 x2 x3 x4 x5, we count how many times that trigram type co-occurs with the different instantiations of each concept, and compute the point-wise mutual information (PMI) between the two.5 The similarity between two trigram types is given by summing over the PMI values over feature instantiations that they have in common.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'47'", "'48'", "'51'"]
'27'
'47'
'48'
'51'
['27', '47', '48', '51']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="4">Graph construction does not require any labeled data, but makes use of two similarity functions.</S><S sid="57" ssid="23">Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.</S><S sid="69" ssid="35">Label propagation is used to propagate these tags inwards and results in tag distributions for the middle word of each Italian trigram.</S><S sid="97" ssid="28">This formulation of the constraint feature is equivalent to the use of a tagging dictionary extracted from the graph using a threshold T on the posterior distribution of tags for a given word type (Eq.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'57'", "'69'", "'97'"]
'27'
'57'
'69'
'97'
['27', '57', '69', '97']
parsed_discourse_facet ['method_citation']
<S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S><S sid="96" ssid="27">The function A : F &#8212;* C maps from the language specific fine-grained tagset F to the coarser universal tagset C and is described in detail in &#167;6.2: Note that when tx(y) = 1 the feature value is 0 and has no effect on the model, while its value is &#8722;oc when tx(y) = 0 and constrains the HMM&#8217;s state space.</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'96'", "'111'", "'113'"]
'19'
'96'
'111'
'113'
['19', '96', '111', '113']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S><S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'17'", "'18'", "'113'"]
'3'
'17'
'18'
'113'
['3', '17', '18', '113']
parsed_discourse_facet ['results_citation']
<S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'", "'111'", "'112'", "'113'"]
'18'
'111'
'112'
'113'
['18', '111', '112', '113']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'24'", "'112'", "'113'"]
'1'
'24'
'112'
'113'
['1', '24', '112', '113']
parsed_discourse_facet ['aim_citation']
<S sid="3" ssid="3">We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).</S><S sid="16" ssid="12">To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).</S><S sid="70" ssid="1">Given the bilingual graph described in the previous section, we can use label propagation to project the English POS labels to the foreign language.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'", "'16'", "'70'", "'113'"]
'3'
'16'
'70'
'113'
['3', '16', '70', '113']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="29" ssid="6">To establish a soft correspondence between the two languages, we use a second similarity function, which leverages standard unsupervised word alignment statistics (&#167;3.3).3 Since we have no labeled foreign data, our goal is to project syntactic information from the English side to the foreign side.</S><S sid="57" ssid="23">Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'24'", "'29'", "'57'"]
'1'
'24'
'29'
'57'
['1', '24', '29', '57']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="10" ssid="6">To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.</S><S sid="71" ssid="2">We use label propagation in two stages to generate soft labels on all the vertices in the graph.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'10'", "'71'", "'113'"]
'1'
'10'
'71'
'113'
['1', '10', '71', '113']
parsed_discourse_facet ['results_citation']
<S sid="4" ssid="4">Across eight European languages, our approach results in an average absolute improvement of 10.4% over a state-of-the-art baseline, and 16.7% over vanilla hidden Markov models induced with the Expectation Maximization algorithm.</S><S sid="9" ssid="5">Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.</S><S sid="19" ssid="15">Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S>
original cit marker offset is 0
new cit marker offset is 0



["'4'", "'9'", "'19'", "'112'"]
'4'
'9'
'19'
'112'
['4', '9', '19', '112']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S><S sid="114" ssid="14">The supervised POS tagging accuracies (on this tagset) are shown in the last row of Table 2.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'18'", "'113'", "'114'"]
'17'
'18'
'113'
'114'
['17', '18', '113', '114']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="17" ssid="13">Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'17'", "'112'", "'113'"]
'1'
'17'
'112'
'113'
['1', '17', '112', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="2" ssid="2">Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.</S><S sid="24" ssid="1">The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'24'", "'113'"]
'1'
'2'
'24'
'113'
['1', '2', '24', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.</S><S sid="18" ssid="14">To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).</S><S sid="111" ssid="11">We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'18'", "'111'", "'113'"]
'1'
'18'
'111'
'113'
['1', '18', '111', '113']
parsed_discourse_facet ['hypothesis_citation']
<S sid="93" ssid="24">For English POS tagging, BergKirkpatrick et al. (2010) found that this direct gradient method performed better (&gt;7% absolute accuracy) than using a feature-enhanced modification of the Expectation-Maximization (EM) algorithm (Dempster et al., 1977).8 Moreover, this route of optimization outperformed a vanilla HMM trained with EM by 12%.</S><S sid="112" ssid="12">While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.</S><S sid="113" ssid="13">For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.</S><S sid="117" ssid="17">In other words, the set of hidden states F was chosen to be the fine set of treebank tags.</S>
original cit marker offset is 0
new cit marker offset is 0



["'93'", "'112'", "'113'", "'117'"]
'93'
'112'
'113'
'117'
['93', '112', '113', '117']
parsed_discourse_facet ['method_citation']
dict_values(['Our monolingual similarity function (for connecting pairs of foreign trigram types) is the same as the one used by Subramanya et al. (2010).'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.', 'Unsupervised learning approaches appear to be a natural solution to this problem, as they require only unannotated text for training models.', 'To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:55', 'F:0']
dict_values(['To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'Supervised part-of-speech (POS) taggers, for example, approach the level of inter-annotator agreement (Shen et al., 2007, 97.3% accuracy for English).', 'However, supervised methods rely on labeled training data, which is time-consuming and expensive to generate.', 'Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02433', '(95%-conf.int.', '0.02433', '-', '0.02433)']
['system', 'ROUGE-S*', 'Average_P:', '0.08712', '(95%-conf.int.', '0.08712', '-', '0.08712)']
['system', 'ROUGE-S*', 'Average_F:', '0.03803', '(95%-conf.int.', '0.03803', '-', '0.03803)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:528', 'F:46']
dict_values(['We then extract a set of possible tags tx(y) by eliminating labels whose probability is below a threshold value &#964;: We describe how we choose &#964; in &#167;6.4.'])
dict_values(['Graph construction does not require any labeled data, but makes use of two similarity functions.', 'Since our graph is built from a parallel corpus, we can use standard word alignment techniques to align the English sentences De 5Note that many combinations are impossible giving a PMI value of 0; e.g., when the trigram type and the feature instantiation don&#8217;t have words in common. and their foreign language translations Df.6 Label propagation in the graph will provide coverage and high recall, and we therefore extract only intersected high-confidence (&gt; 0.9) alignments De&#65533;f.', 'Label propagation is used to propagate these tags inwards and results in tag distributions for the middle word of each Italian trigram.', 'This formulation of the constraint feature is equivalent to the use of a tagging dictionary extracted from the graph using a threshold T on the posterior distribution of tags for a given word type (Eq.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00176', '(95%-conf.int.', '0.00176', '-', '0.00176)']
['system', 'ROUGE-S*', 'Average_P:', '0.05714', '(95%-conf.int.', '0.05714', '-', '0.05714)']
['system', 'ROUGE-S*', 'Average_F:', '0.00342', '(95%-conf.int.', '0.00342', '-', '0.00342)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3403', 'P:105', 'F:6']
dict_values(['We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).'])
dict_values(['We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).', 'Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.', 'To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.08227', '(95%-conf.int.', '0.08227', '-', '0.08227)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.15204', '(95%-conf.int.', '0.15204', '-', '0.15204)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:136', 'F:136']
dict_values(['To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).'])
dict_values(['To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).', 'We use the universal POS tagset of Petrov et al. (2011) in our experiments.10 This set C consists of the following 12 coarse-grained tags: NOUN (nouns), VERB (verbs), ADJ (adjectives), ADV (adverbs), PRON (pronouns), DET (determiners), ADP (prepositions or postpositions), NUM (numerals), CONJ (conjunctions), PRT (particles), PUNC (punctuation marks) and X (a catch-all for other categories such as abbreviations or foreign words).', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01764', '(95%-conf.int.', '0.01764', '-', '0.01764)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.03467', '(95%-conf.int.', '0.03467', '-', '0.03467)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3741', 'P:66', 'F:66']
dict_values(['(2009) study related but different multilingual grammar and tagger induction tasks, where it is assumed that no labeled data at all is available.'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'The focus of this work is on building POS taggers for foreign languages, assuming that we have an English POS tagger and some parallel text between the two languages.', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00212', '(95%-conf.int.', '0.00212', '-', '0.00212)']
['system', 'ROUGE-S*', 'Average_P:', '0.07273', '(95%-conf.int.', '0.07273', '-', '0.07273)']
['system', 'ROUGE-S*', 'Average_F:', '0.00411', '(95%-conf.int.', '0.00411', '-', '0.00411)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:55', 'F:4']
dict_values(['We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).'])
dict_values(['We use graph-based label propagation for cross-lingual knowledge transfer and use the projected labels as features in an unsupervised model (Berg- Kirkpatrick et al., 2010).', 'To this end, we construct a bilingual graph over word types to establish a connection between the two languages (&#167;3), and then use graph label propagation to project syntactic information from English to the foreign language (&#167;4).', 'Given the bilingual graph described in the previous section, we can use label propagation to project the English POS labels to the foreign language.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05797', '(95%-conf.int.', '0.05797', '-', '0.05797)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10959', '(95%-conf.int.', '0.10959', '-', '0.10959)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:136', 'F:136']
dict_values(['Our method does not assume any knowledge about the target language (in particular no tagging dictionary is assumed), making it applicable to a wide array of resource-poor languages.'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'To bridge this gap, we consider a practically motivated scenario, in which we want to leverage existing resources from a resource-rich language (like English) when building tools for resource-poor foreign languages.1 We assume that absolutely no labeled training data is available for the foreign language of interest, but that we have access to parallel data with a resource-rich language.', 'We use label propagation in two stages to generate soft labels on all the vertices in the graph.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00468', '(95%-conf.int.', '0.00468', '-', '0.00468)']
['system', 'ROUGE-S*', 'Average_P:', '0.12381', '(95%-conf.int.', '0.12381', '-', '0.12381)']
['system', 'ROUGE-S*', 'Average_F:', '0.00903', '(95%-conf.int.', '0.00903', '-', '0.00903)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:105', 'F:13']
dict_values(['Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.'])
dict_values(['Across eight European languages, our approach results in an average absolute improvement of 10.4% over a state-of-the-art baseline, and 16.7% over vanilla hidden Markov models induced with the Expectation Maximization algorithm.', 'Unfortunately, the best completely unsupervised English POS tagger (that does not make use of a tagging dictionary) reaches only 76.1% accuracy (Christodoulopoulos et al., 2010), making its practical usability questionable at best.', 'Syntactic universals are a well studied concept in linguistics (Carnie, 2002; Newmeyer, 2005), and were recently used in similar form by Naseem et al. (2010) for multilingual grammar induction.', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05822', '(95%-conf.int.', '0.05822', '-', '0.05822)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.11003', '(95%-conf.int.', '0.11003', '-', '0.11003)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2628', 'P:153', 'F:153']
dict_values(['To make the projection practical, we rely on the twelve universal part-of-speech tags of Petrov et al. (2011).'])
dict_values(['We describe a novel approach for inducing unsupervised part-of-speech taggers for languages that have no labeled training data, but have translated text in a resource-rich language.', 'Second, we treat the projected labels as features in an unsupervised model (&#167;5), rather than using them directly for supervised training.', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01169', '(95%-conf.int.', '0.01169', '-', '0.01169)']
['system', 'ROUGE-S*', 'Average_P:', '0.30303', '(95%-conf.int.', '0.30303', '-', '0.30303)']
['system', 'ROUGE-S*', 'Average_F:', '0.02251', '(95%-conf.int.', '0.02251', '-', '0.02251)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1711', 'P:66', 'F:20']
dict_values(['Our final average POS tagging accuracy of 83.4% compares very favorably to the average accuracy of Berg-Kirkpatrick et al.&#8217;s monolingual unsupervised state-of-the-art model (73.0%), and considerably bridges the gap to fully supervised POS tagging performance (96.6%).'])
dict_values(['For English POS tagging, BergKirkpatrick et al. (2010) found that this direct gradient method performed better (&gt;7% absolute accuracy) than using a feature-enhanced modification of the Expectation-Maximization (EM) algorithm (Dempster et al., 1977).8 Moreover, this route of optimization outperformed a vanilla HMM trained with EM by 12%.', 'While there might be some controversy about the exact definition of such a tagset, these 12 categories cover the most frequent part-of-speech and exist in one form or another in all of the languages that we studied.', 'For each language under consideration, Petrov et al. (2011) provide a mapping A from the fine-grained language specific POS tags in the foreign treebank to the universal POS tags.', 'In other words, the set of hidden states F was chosen to be the fine set of treebank tags.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01153', '(95%-conf.int.', '0.01153', '-', '0.01153)']
['system', 'ROUGE-S*', 'Average_P:', '0.06452', '(95%-conf.int.', '0.06452', '-', '0.06452)']
['system', 'ROUGE-S*', 'Average_F:', '0.01957', '(95%-conf.int.', '0.01957', '-', '0.01957)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:496', 'F:32']
0.4280318142906198 0.024746363411396695 0.045727272311570255





input/ref/Task1/P87-1015_swastika.csv
input/res/Task1/P87-1015.annv3.csv
parsing: input/ref/Task1/P87-1015_swastika.csv
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['118']
118
['118']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['118']
118
['118']
parsed_discourse_facet ['aim_citation']
<S sid="149" ssid="34">We can obtain a letter equivalent CFL defined by a CFG in which the for each rule as above, we have the production A &#8212;* A1 Anup where tk (up) = cp.</S>
original cit marker offset is 0
new cit marker offset is 0



['149']
149
['149']
parsed_discourse_facet ['method_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['118']
118
['118']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['118']
118
['118']
parsed_discourse_facet ['aim_citation']
    <S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S>
original cit marker offset is 0
new cit marker offset is 0



['2']
2
['2']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['118']
118
['118']
parsed_discourse_facet ['aim_citation']
<S sid="222" ssid="28">However, in order to capture the properties of various grammatical systems under consideration, our notation is more restrictive that ILFP, which was designed as a general logical notation to characterize the complete class of languages that are recognizable in polynomial time.</S>
original cit marker offset is 0
new cit marker offset is 0



['222']
222
['222']
parsed_discourse_facet ['method_citation']
<S sid="119" ssid="4">In defining LCFRS's, we hope to generalize the definition of CFG's to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S>
original cit marker offset is 0
new cit marker offset is 0



['119']
119
['119']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['???']
???
['???']
parsed_discourse_facet ['aim_citation']
<S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



['207']
207
['207']
parsed_discourse_facet ['result_citation']
<S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



['207']
207
['207']
parsed_discourse_facet ['result_citation']
<S sid="19" ssid="4">It can be easily shown from Thatcher's result that the path set of every local set is a regular set.</S>
original cit marker offset is 0
new cit marker offset is 0



['19']
19
['19']
parsed_discourse_facet ['method_citation']
<S sid="119" ssid="4">In defining LCFRS's, we hope to generalize the definition of CFG's to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S>
original cit marker offset is 0
new cit marker offset is 0



['119']
119
['119']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



['118']
118
['118']
parsed_discourse_facet ['aim_citation']
parsing: input/res/Task1/P87-1015.annv3.csv
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="232" ssid="38">In considering this aspect of a formalism, we hope to better understand the relationship between the structural descriptions generated by the grammars of a formalism, and the properties of semilinearity and polynomial recognizability.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'118'", "'232'"]
'2'
'3'
'118'
'232'
['2', '3', '118', '232']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="180" ssid="65">The rewrite rules and the definition of the composition operations may be stored in the finite state control since G uses a finite number of them.</S><S sid="230" ssid="36">LCFRS\s have only been loosely defined in this paper; we have yet to provide a complete set of formal properties associated with members of this class.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'", "'151'", "'180'", "'230'"]
'118'
'151'
'180'
'230'
['118', '151', '180', '230']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We consider the structural descriptions produced by various grammatical formalisms in terms of the complexity of the paths and the relationship between paths in the sets of structural descriptions that each system can generate.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="214" ssid="20">LCFRS\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'3'", "'119'", "'214'"]
'1'
'3'
'119'
'214'
['1', '3', '119', '214']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="92" ssid="77">We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S><S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'92'", "'118'", "'134'", "'207'"]
'92'
'118'
'134'
'207'
['92', '118', '134', '207']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'74'", "'207'"]
'2'
'3'
'74'
'207'
['2', '3', '74', '207']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\s insists that the composition operations are linear and nonerasing.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="229" ssid="35">In addition, the restricted version of CG\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\s containing formalisms whose tree sets have path sets that are themselves LCFRL\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'146'", "'151'", "'229'"]
'119'
'146'
'151'
'229'
['119', '146', '151', '229']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="92" ssid="77">We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="164" ssid="49">Although embedding this version of LCFRS\s in the framework of ILFP developed by Rounds (1985) is straightforward, our motivation was to capture properties shared by a family of grammatical systems and generalize them defining a class of related formalisms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'92'", "'118'", "'164'"]
'2'
'92'
'118'
'164'
['2', '92', '118', '164']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="117" ssid="2">Our goal is to define a class of formal systems, and show that any member of this class will possess certain attractive properties.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'117'", "'118'"]
'2'
'3'
'117'
'118'
['2', '3', '117', '118']
parsed_discourse_facet ['aim_citation']
<S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\s insists that the composition operations are linear and nonerasing.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="229" ssid="35">In addition, the restricted version of CG\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\s containing formalisms whose tree sets have path sets that are themselves LCFRL\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'146'", "'151'", "'229'"]
'119'
'146'
'151'
'229'
['119', '146', '151', '229']
parsed_discourse_facet ['method_citation']
<S sid="42" ssid="27">Suppose -y results from the adjunction of 71, ,-y, at the k distinct tree addresses 141, , nk in some elementary tree 7\, respectively.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="75" ssid="60">A multicomponent Tree Adjoining Grammar (MCTAG) consists of a finite set of finite elementary tree sets.</S><S sid="158" ssid="43">We can represent any derived tree of a TAG by the two substrings that appear in its frontier, and then define how the adjunction operation concatenates the substrings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'42'", "'74'", "'75'", "'158'"]
'42'
'74'
'75'
'158'
['42', '74', '75', '158']
parsed_discourse_facet ['method_citation']
<S sid="89" ssid="74">Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\s, MCTAG\s, and HG\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.</S><S sid="90" ssid="75">Thus, as in CFG\s, at any point in the derivation, the set of structures that can be applied is determined only by a finite set of rules encapsulated by the grammar.</S><S sid="128" ssid="13">As in the case of the derivation trees of CFG\s, nodes are labeled by a member of some finite set of symbols (perhaps only implicit in the grammar as in TAG\s) used to denote derived structures.</S><S sid="141" ssid="26">Thus, the length of any string in L is a linear combination of the length of strings in some fixed finite subset of L, and thus L is said to have the constant growth property.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'", "'90'", "'128'", "'141'"]
'89'
'90'
'128'
'141'
['89', '90', '128', '141']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S><S sid="135" ssid="20">Unlike GCFG\s, however, the composition operations of LCFRS\s are restricted to be linear (do not duplicate unboundedly large structures) and nonerasing (do not erase unbounded structures, a restriction made in most modern transformational grammars).</S><S sid="228" ssid="34">Since these path sets are semilinear, the property of independent paths in their tree sets is sufficient to cause semilinearity of the languages generated by them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'134'", "'135'", "'228'"]
'2'
'134'
'135'
'228'
['2', '134', '135', '228']
parsed_discourse_facet ['aim_citation']
<S sid="73" ssid="58">The equivalence of CC\s with this restriction to TAG\s and HG\s is, however, still an open problem.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="89" ssid="74">Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\s, MCTAG\s, and HG\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.</S><S sid="228" ssid="34">Since these path sets are semilinear, the property of independent paths in their tree sets is sufficient to cause semilinearity of the languages generated by them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'73'", "'74'", "'89'", "'228'"]
'73'
'74'
'89'
'228'
['73', '74', '89', '228']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="71">MCTAG\s are able to generate tee sets having dependent paths.</S><S sid="93" ssid="78">As is described in Section 4, the property of having a derivation tree set that is a local set appears to be useful in showing important properties of the languages generated by the formalisms.</S><S sid="109" ssid="15">A geometrical progression of language families defined by Weir (1987) involves tree sets with increasingly complex path sets.</S><S sid="111" ssid="17">.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'", "'93'", "'109'", "'111'"]
'86'
'93'
'109'
'111'
['86', '93', '109', '111']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="27" ssid="12">Thus, the tree sets generated by HG\s are similar to those of CFG\s, with each node annotated by the operation (concatenation or wrapping) used to combine the headed strings derived by the daughters of Tree Adjoining Grammars, a tree rewriting formalism, was introduced by Joshi, Levy and Takahashi (1975) and Joshi (1983/85).</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="214" ssid="20">LCFRS\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'27'", "'74'", "'214'"]
'2'
'27'
'74'
'214'
['2', '27', '74', '214']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="91" ssid="76">We characterize a class of formalisms that have this property in Section 4.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'91'", "'118'", "'134'"]
'2'
'91'
'118'
'134'
['2', '91', '118', '134']
parsed_discourse_facet ['aim_citation']
dict_values(["In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows."])
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.', 'Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.', 'In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'In considering this aspect of a formalism, we hope to better understand the relationship between the structural descriptions generated by the grammars of a formalism, and the properties of semilinearity and polynomial recognizability.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03361', '(95%-conf.int.', '0.03361', '-', '0.03361)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.06504', '(95%-conf.int.', '0.06504', '-', '0.06504)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3570', 'P:120', 'F:120']
dict_values(["In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows."])
dict_values(['In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\\s).', 'The rewrite rules and the definition of the composition operations may be stored in the finite state control since G uses a finite number of them.', 'LCFRS\\s have only been loosely defined in this paper; we have yet to provide a complete set of formal properties associated with members of this class.'])
['system', 'ROUGE-S*', 'Average_R:', '0.11594', '(95%-conf.int.', '0.11594', '-', '0.11594)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.20779', '(95%-conf.int.', '0.20779', '-', '0.20779)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:120', 'F:120']
dict_values(['We can obtain a letter equivalent CFL defined by a CFG in which the for each rule as above, we have the production A &#8212;* A1 Anup where tk (up) = cp.'])
dict_values(['We consider the structural descriptions produced by various grammatical formalisms in terms of the complexity of the paths and the relationship between paths in the sets of structural descriptions that each system can generate.', 'Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.', 'In defining LCFRS\\s, we hope to generalize the definition of CFG\\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.', 'LCFRS\\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00078', '(95%-conf.int.', '0.00078', '-', '0.00078)']
['system', 'ROUGE-S*', 'Average_P:', '0.01282', '(95%-conf.int.', '0.01282', '-', '0.01282)']
['system', 'ROUGE-S*', 'Average_F:', '0.00148', '(95%-conf.int.', '0.00148', '-', '0.00148)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1275', 'P:78', 'F:1']
dict_values(["In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows."])
dict_values(['In defining LCFRS\\s, we hope to generalize the definition of CFG\\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.', 'Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\\s insists that the composition operations are linear and nonerasing.', 'We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\\s).', 'In addition, the restricted version of CG\\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\\s containing formalisms whose tree sets have path sets that are themselves LCFRL\\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00373', '(95%-conf.int.', '0.00373', '-', '0.00373)']
['system', 'ROUGE-S*', 'Average_P:', '0.07500', '(95%-conf.int.', '0.07500', '-', '0.07500)']
['system', 'ROUGE-S*', 'Average_F:', '0.00710', '(95%-conf.int.', '0.00710', '-', '0.00710)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:120', 'F:9']
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.'])
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.', 'We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.', 'In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'Although embedding this version of LCFRS\\s in the framework of ILFP developed by Rounds (1985) is straightforward, our motivation was to capture properties shared by a family of grammatical systems and generalize them defining a class of related formalisms.'])
['system', 'ROUGE-S*', 'Average_R:', '0.23620', '(95%-conf.int.', '0.23620', '-', '0.23620)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.38215', '(95%-conf.int.', '0.38215', '-', '0.38215)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4005', 'P:946', 'F:946']
dict_values(['However, in order to capture the properties of various grammatical systems under consideration, our notation is more restrictive that ILFP, which was designed as a general logical notation to characterize the complete class of languages that are recognizable in polynomial time.'])
dict_values(['In defining LCFRS\\s, we hope to generalize the definition of CFG\\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.', 'Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\\s insists that the composition operations are linear and nonerasing.', 'We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\\s).', 'In addition, the restricted version of CG\\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\\s containing formalisms whose tree sets have path sets that are themselves LCFRL\\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00207', '(95%-conf.int.', '0.00207', '-', '0.00207)']
['system', 'ROUGE-S*', 'Average_P:', '0.02632', '(95%-conf.int.', '0.02632', '-', '0.02632)']
['system', 'ROUGE-S*', 'Average_F:', '0.00384', '(95%-conf.int.', '0.00384', '-', '0.00384)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:190', 'F:5']
dict_values(["In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows."])
dict_values(['Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\\s, MCTAG\\s, and HG\\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.', 'Thus, as in CFG\\s, at any point in the derivation, the set of structures that can be applied is determined only by a finite set of rules encapsulated by the grammar.', 'As in the case of the derivation trees of CFG\\s, nodes are labeled by a member of some finite set of symbols (perhaps only implicit in the grammar as in TAG\\s) used to denote derived structures.', 'Thus, the length of any string in L is a linear combination of the length of strings in some fixed finite subset of L, and thus L is said to have the constant growth property.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:120', 'F:0']
dict_values(["It can be easily shown from Thatcher's result that the path set of every local set is a regular set."])
dict_values(['MCTAG\\s are able to generate tee sets having dependent paths.', 'As is described in Section 4, the property of having a derivation tree set that is a local set appears to be useful in showing important properties of the languages generated by the formalisms.', 'A geometrical progression of language families defined by Weir (1987) involves tree sets with increasingly complex path sets.', '.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01681', '(95%-conf.int.', '0.01681', '-', '0.01681)']
['system', 'ROUGE-S*', 'Average_P:', '0.22222', '(95%-conf.int.', '0.22222', '-', '0.22222)']
['system', 'ROUGE-S*', 'Average_F:', '0.03125', '(95%-conf.int.', '0.03125', '-', '0.03125)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:595', 'P:45', 'F:10']
dict_values(["In defining LCFRS's, we hope to generalize the definition of CFG's to formalisms manipulating any structure, e.g. strings, trees, or graphs."])
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.', 'Thus, the tree sets generated by HG\\s are similar to those of CFG\\s, with each node annotated by the operation (concatenation or wrapping) used to combine the headed strings derived by the daughters of Tree Adjoining Grammars, a tree rewriting formalism, was introduced by Joshi, Levy and Takahashi (1975) and Joshi (1983/85).', 'An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.', 'LCFRS\\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00311', '(95%-conf.int.', '0.00311', '-', '0.00311)']
['system', 'ROUGE-S*', 'Average_P:', '0.25758', '(95%-conf.int.', '0.25758', '-', '0.25758)']
['system', 'ROUGE-S*', 'Average_F:', '0.00615', '(95%-conf.int.', '0.00615', '-', '0.00615)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5460', 'P:66', 'F:17']
dict_values(["In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows."])
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.', 'We characterize a class of formalisms that have this property in Section 4.', 'In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\\s).'])
['system', 'ROUGE-S*', 'Average_R:', '0.04324', '(95%-conf.int.', '0.04324', '-', '0.04324)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.08290', '(95%-conf.int.', '0.08290', '-', '0.08290)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:120', 'F:120']
0.4593939954060601 0.04554899954451001 0.07876999921229999





input/ref/Task1/P87-1015_sweta.csv
input/res/Task1/P87-1015.annv3.csv
parsing: input/ref/Task1/P87-1015_sweta.csv
<S sid="205" ssid="11">Independence of paths at this level reflects context freeness of rewriting and suggests why they can be recognized efficiently.</S>
original cit marker offset is 0
new cit marker offset is 0



["205'"]
205'
['205']
parsed_discourse_facet ['method_citation']
<S sid="229" ssid="35">In addition, the restricted version of CG's (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS's containing formalisms whose tree sets have path sets that are themselves LCFRL's (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["229'"]
229'
['229']
parsed_discourse_facet ['method_citation']
<S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS's insists that the composition operations are linear and nonerasing.</S>
original cit marker offset is 0
new cit marker offset is 0



["146'"]
146'
['146']
parsed_discourse_facet ['method_citation']
<S sid="201" ssid="7">It is interesting to note, however, that the ability to produce a bounded number of dependent paths (where two dependent paths can share an unbounded amount of information) does not require machinery as powerful as that used in LFG, FUG and IG's.</S>
original cit marker offset is 0
new cit marker offset is 0



["201'"]
201'
['201']
parsed_discourse_facet ['method_citation']
 <S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL's).</S>
original cit marker offset is 0
new cit marker offset is 0



["151'"]
151'
['151']
parsed_discourse_facet ['method_citation']
 <S sid="222" ssid="28">However, in order to capture the properties of various grammatical systems under consideration, our notation is more restrictive that ILFP, which was designed as a general logical notation to characterize the complete class of languages that are recognizable in polynomial time.</S>
original cit marker offset is 0
new cit marker offset is 0



["222'"]
222'
['222']
parsed_discourse_facet ['method_citation']
<S sid="22" ssid="7">Gazdar (1985) argues this is the appropriate analysis of unbounded dependencies in the hypothetical Scandinavian language Norwedish.</S>
    <S sid="23" ssid="8">He also argues that paired English complementizers may also require structural descriptions whose path sets have nested dependencies.</S>
original cit marker offset is 0
new cit marker offset is 0



["22'", "'23'"]
22'
'23'
['22', '23']
parsed_discourse_facet ['method_citation']
 <S sid="156" ssid="41">Giving a recognition algorithm for LCFRL's involves describing the substrings of the input that are spanned by the structures derived by the LCFRS's and how the composition operation combines these substrings.</S>
original cit marker offset is 0
new cit marker offset is 0



["156'"]
156'
['156']
parsed_discourse_facet ['method_citation']
<S sid="221" ssid="27">Members of LCFRS whose operations have this property can be translated into the ILFP notation (Rounds, 1985).</S>
original cit marker offset is 0
new cit marker offset is 0



["221'"]
221'
['221']
parsed_discourse_facet ['method_citation']
<S sid="54" ssid="39">An IG can be viewed as a CFG in which each nonterminal is associated with a stack.</S>
original cit marker offset is 0
new cit marker offset is 0



["54'"]
54'
['54']
parsed_discourse_facet ['method_citation']
<S sid="128" ssid="13">As in the case of the derivation trees of CFG's, nodes are labeled by a member of some finite set of symbols (perhaps only implicit in the grammar as in TAG's) used to denote derived structures.</S>
original cit marker offset is 0
new cit marker offset is 0



["128'"]
128'
['128']
parsed_discourse_facet ['method_citation']
<S sid="217" ssid="23">In considering the recognition of these languages, we were forced to be more specific regarding the relationship between the structures derived by these formalisms and the substrings they span.</S>
original cit marker offset is 0
new cit marker offset is 0



[";217'"]
;217'
[';217']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="1">From Thatcher's (1973) work, it is obvious that the complexity of the set of paths from root to frontier of trees in a local set (the tree set of a CFG) is regular'.</S>
original cit marker offset is 0
new cit marker offset is 0



["16'"]
16'
['16']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="1">From Thatcher's (1973) work, it is obvious that the complexity of the set of paths from root to frontier of trees in a local set (the tree set of a CFG) is regular'.</S>
original cit marker offset is 0
new cit marker offset is 0



["16'"]
16'
['16']
parsed_discourse_facet ['method_citation']
<S sid="214" ssid="20">LCFRS's share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["214'"]
214'
['214']
parsed_discourse_facet ['method_citation']
<S sid="35" ssid="20">TAG's can be used to give the structural descriptions discussed by Gazdar (1985) for the unbounded nested dependencies in Norwedish, for cross serial dependencies in Dutch subordinate clauses, and for the nestings of paired English complementizers.</S>
original cit marker offset is 0
new cit marker offset is 0



["35'"]
35'
['35']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P87-1015.annv3.csv
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="232" ssid="38">In considering this aspect of a formalism, we hope to better understand the relationship between the structural descriptions generated by the grammars of a formalism, and the properties of semilinearity and polynomial recognizability.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'118'", "'232'"]
'2'
'3'
'118'
'232'
['2', '3', '118', '232']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="180" ssid="65">The rewrite rules and the definition of the composition operations may be stored in the finite state control since G uses a finite number of them.</S><S sid="230" ssid="36">LCFRS\s have only been loosely defined in this paper; we have yet to provide a complete set of formal properties associated with members of this class.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'", "'151'", "'180'", "'230'"]
'118'
'151'
'180'
'230'
['118', '151', '180', '230']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We consider the structural descriptions produced by various grammatical formalisms in terms of the complexity of the paths and the relationship between paths in the sets of structural descriptions that each system can generate.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="214" ssid="20">LCFRS\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'3'", "'119'", "'214'"]
'1'
'3'
'119'
'214'
['1', '3', '119', '214']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="92" ssid="77">We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S><S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'92'", "'118'", "'134'", "'207'"]
'92'
'118'
'134'
'207'
['92', '118', '134', '207']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'74'", "'207'"]
'2'
'3'
'74'
'207'
['2', '3', '74', '207']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\s insists that the composition operations are linear and nonerasing.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="229" ssid="35">In addition, the restricted version of CG\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\s containing formalisms whose tree sets have path sets that are themselves LCFRL\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'146'", "'151'", "'229'"]
'119'
'146'
'151'
'229'
['119', '146', '151', '229']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="92" ssid="77">We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="164" ssid="49">Although embedding this version of LCFRS\s in the framework of ILFP developed by Rounds (1985) is straightforward, our motivation was to capture properties shared by a family of grammatical systems and generalize them defining a class of related formalisms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'92'", "'118'", "'164'"]
'2'
'92'
'118'
'164'
['2', '92', '118', '164']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="117" ssid="2">Our goal is to define a class of formal systems, and show that any member of this class will possess certain attractive properties.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'117'", "'118'"]
'2'
'3'
'117'
'118'
['2', '3', '117', '118']
parsed_discourse_facet ['aim_citation']
<S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\s insists that the composition operations are linear and nonerasing.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="229" ssid="35">In addition, the restricted version of CG\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\s containing formalisms whose tree sets have path sets that are themselves LCFRL\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'146'", "'151'", "'229'"]
'119'
'146'
'151'
'229'
['119', '146', '151', '229']
parsed_discourse_facet ['method_citation']
<S sid="42" ssid="27">Suppose -y results from the adjunction of 71, ,-y, at the k distinct tree addresses 141, , nk in some elementary tree 7\, respectively.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="75" ssid="60">A multicomponent Tree Adjoining Grammar (MCTAG) consists of a finite set of finite elementary tree sets.</S><S sid="158" ssid="43">We can represent any derived tree of a TAG by the two substrings that appear in its frontier, and then define how the adjunction operation concatenates the substrings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'42'", "'74'", "'75'", "'158'"]
'42'
'74'
'75'
'158'
['42', '74', '75', '158']
parsed_discourse_facet ['method_citation']
<S sid="89" ssid="74">Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\s, MCTAG\s, and HG\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.</S><S sid="90" ssid="75">Thus, as in CFG\s, at any point in the derivation, the set of structures that can be applied is determined only by a finite set of rules encapsulated by the grammar.</S><S sid="128" ssid="13">As in the case of the derivation trees of CFG\s, nodes are labeled by a member of some finite set of symbols (perhaps only implicit in the grammar as in TAG\s) used to denote derived structures.</S><S sid="141" ssid="26">Thus, the length of any string in L is a linear combination of the length of strings in some fixed finite subset of L, and thus L is said to have the constant growth property.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'", "'90'", "'128'", "'141'"]
'89'
'90'
'128'
'141'
['89', '90', '128', '141']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S><S sid="135" ssid="20">Unlike GCFG\s, however, the composition operations of LCFRS\s are restricted to be linear (do not duplicate unboundedly large structures) and nonerasing (do not erase unbounded structures, a restriction made in most modern transformational grammars).</S><S sid="228" ssid="34">Since these path sets are semilinear, the property of independent paths in their tree sets is sufficient to cause semilinearity of the languages generated by them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'134'", "'135'", "'228'"]
'2'
'134'
'135'
'228'
['2', '134', '135', '228']
parsed_discourse_facet ['aim_citation']
<S sid="73" ssid="58">The equivalence of CC\s with this restriction to TAG\s and HG\s is, however, still an open problem.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="89" ssid="74">Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\s, MCTAG\s, and HG\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.</S><S sid="228" ssid="34">Since these path sets are semilinear, the property of independent paths in their tree sets is sufficient to cause semilinearity of the languages generated by them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'73'", "'74'", "'89'", "'228'"]
'73'
'74'
'89'
'228'
['73', '74', '89', '228']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="71">MCTAG\s are able to generate tee sets having dependent paths.</S><S sid="93" ssid="78">As is described in Section 4, the property of having a derivation tree set that is a local set appears to be useful in showing important properties of the languages generated by the formalisms.</S><S sid="109" ssid="15">A geometrical progression of language families defined by Weir (1987) involves tree sets with increasingly complex path sets.</S><S sid="111" ssid="17">.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'", "'93'", "'109'", "'111'"]
'86'
'93'
'109'
'111'
['86', '93', '109', '111']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="27" ssid="12">Thus, the tree sets generated by HG\s are similar to those of CFG\s, with each node annotated by the operation (concatenation or wrapping) used to combine the headed strings derived by the daughters of Tree Adjoining Grammars, a tree rewriting formalism, was introduced by Joshi, Levy and Takahashi (1975) and Joshi (1983/85).</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="214" ssid="20">LCFRS\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'27'", "'74'", "'214'"]
'2'
'27'
'74'
'214'
['2', '27', '74', '214']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="91" ssid="76">We characterize a class of formalisms that have this property in Section 4.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'91'", "'118'", "'134'"]
'2'
'91'
'118'
'134'
['2', '91', '118', '134']
parsed_discourse_facet ['aim_citation']
dict_values(['Independence of paths at this level reflects context freeness of rewriting and suggests why they can be recognized efficiently.'])
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.', 'Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.', 'In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'In considering this aspect of a formalism, we hope to better understand the relationship between the structural descriptions generated by the grammars of a formalism, and the properties of semilinearity and polynomial recognizability.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00084', '(95%-conf.int.', '0.00084', '-', '0.00084)']
['system', 'ROUGE-S*', 'Average_P:', '0.06667', '(95%-conf.int.', '0.06667', '-', '0.06667)']
['system', 'ROUGE-S*', 'Average_F:', '0.00166', '(95%-conf.int.', '0.00166', '-', '0.00166)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3570', 'P:45', 'F:3']
dict_values(["In addition, the restricted version of CG's (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS's containing formalisms whose tree sets have path sets that are themselves LCFRL's (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir)."])
dict_values(['In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\\s).', 'The rewrite rules and the definition of the composition operations may be stored in the finite state control since G uses a finite number of them.', 'LCFRS\\s have only been loosely defined in this paper; we have yet to provide a complete set of formal properties associated with members of this class.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02029', '(95%-conf.int.', '0.02029', '-', '0.02029)']
['system', 'ROUGE-S*', 'Average_P:', '0.04828', '(95%-conf.int.', '0.04828', '-', '0.04828)']
['system', 'ROUGE-S*', 'Average_F:', '0.02857', '(95%-conf.int.', '0.02857', '-', '0.02857)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:435', 'F:21']
dict_values(["Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS's insists that the composition operations are linear and nonerasing."])
dict_values(['We consider the structural descriptions produced by various grammatical formalisms in terms of the complexity of the paths and the relationship between paths in the sets of structural descriptions that each system can generate.', 'Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.', 'In defining LCFRS\\s, we hope to generalize the definition of CFG\\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.', 'LCFRS\\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00078', '(95%-conf.int.', '0.00078', '-', '0.00078)']
['system', 'ROUGE-S*', 'Average_P:', '0.00526', '(95%-conf.int.', '0.00526', '-', '0.00526)']
['system', 'ROUGE-S*', 'Average_F:', '0.00137', '(95%-conf.int.', '0.00137', '-', '0.00137)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1275', 'P:190', 'F:1']
dict_values(["It is interesting to note, however, that the ability to produce a bounded number of dependent paths (where two dependent paths can share an unbounded amount of information) does not require machinery as powerful as that used in LFG, FUG and IG's."])
dict_values(['We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.', 'In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\\s).', 'We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:190', 'F:0']
dict_values(['However, in order to capture the properties of various grammatical systems under consideration, our notation is more restrictive that ILFP, which was designed as a general logical notation to characterize the complete class of languages that are recognizable in polynomial time.'])
dict_values(['In defining LCFRS\\s, we hope to generalize the definition of CFG\\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.', 'Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\\s insists that the composition operations are linear and nonerasing.', 'We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\\s).', 'In addition, the restricted version of CG\\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\\s containing formalisms whose tree sets have path sets that are themselves LCFRL\\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00207', '(95%-conf.int.', '0.00207', '-', '0.00207)']
['system', 'ROUGE-S*', 'Average_P:', '0.02632', '(95%-conf.int.', '0.02632', '-', '0.02632)']
['system', 'ROUGE-S*', 'Average_F:', '0.00384', '(95%-conf.int.', '0.00384', '-', '0.00384)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:190', 'F:5']
dict_values(['Gazdar (1985) argues this is the appropriate analysis of unbounded dependencies in the hypothetical Scandinavian language Norwedish.', 'He also argues that paired English complementizers may also require structural descriptions whose path sets have nested dependencies.'])
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.', 'We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.', 'In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'Although embedding this version of LCFRS\\s in the framework of ILFP developed by Rounds (1985) is straightforward, our motivation was to capture properties shared by a family of grammatical systems and generalize them defining a class of related formalisms.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4005', 'P:210', 'F:0']
dict_values(['Members of LCFRS whose operations have this property can be translated into the ILFP notation (Rounds, 1985).'])
dict_values(['In defining LCFRS\\s, we hope to generalize the definition of CFG\\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.', 'Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\\s insists that the composition operations are linear and nonerasing.', 'We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\\s).', 'In addition, the restricted version of CG\\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\\s containing formalisms whose tree sets have path sets that are themselves LCFRL\\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00041', '(95%-conf.int.', '0.00041', '-', '0.00041)']
['system', 'ROUGE-S*', 'Average_P:', '0.02778', '(95%-conf.int.', '0.02778', '-', '0.02778)']
['system', 'ROUGE-S*', 'Average_F:', '0.00082', '(95%-conf.int.', '0.00082', '-', '0.00082)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:36', 'F:1']
dict_values(["As in the case of the derivation trees of CFG's, nodes are labeled by a member of some finite set of symbols (perhaps only implicit in the grammar as in TAG's) used to denote derived structures."])
dict_values(['Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\\s, MCTAG\\s, and HG\\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.', 'Thus, as in CFG\\s, at any point in the derivation, the set of structures that can be applied is determined only by a finite set of rules encapsulated by the grammar.', 'As in the case of the derivation trees of CFG\\s, nodes are labeled by a member of some finite set of symbols (perhaps only implicit in the grammar as in TAG\\s) used to denote derived structures.', 'Thus, the length of any string in L is a linear combination of the length of strings in some fixed finite subset of L, and thus L is said to have the constant growth property.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05115', '(95%-conf.int.', '0.05115', '-', '0.05115)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.09732', '(95%-conf.int.', '0.09732', '-', '0.09732)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:120', 'F:120']
dict_values(["From Thatcher's (1973) work, it is obvious that the complexity of the set of paths from root to frontier of trees in a local set (the tree set of a CFG) is regular'."])
dict_values(['MCTAG\\s are able to generate tee sets having dependent paths.', 'As is described in Section 4, the property of having a derivation tree set that is a local set appears to be useful in showing important properties of the languages generated by the formalisms.', 'A geometrical progression of language families defined by Weir (1987) involves tree sets with increasingly complex path sets.', '.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03866', '(95%-conf.int.', '0.03866', '-', '0.03866)']
['system', 'ROUGE-S*', 'Average_P:', '0.19167', '(95%-conf.int.', '0.19167', '-', '0.19167)']
['system', 'ROUGE-S*', 'Average_F:', '0.06434', '(95%-conf.int.', '0.06434', '-', '0.06434)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:595', 'P:120', 'F:23']
dict_values(["LCFRS's share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85)."])
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.', 'Thus, the tree sets generated by HG\\s are similar to those of CFG\\s, with each node annotated by the operation (concatenation or wrapping) used to combine the headed strings derived by the daughters of Tree Adjoining Grammars, a tree rewriting formalism, was introduced by Joshi, Levy and Takahashi (1975) and Joshi (1983/85).', 'An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.', 'LCFRS\\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01429', '(95%-conf.int.', '0.01429', '-', '0.01429)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.02817', '(95%-conf.int.', '0.02817', '-', '0.02817)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5460', 'P:78', 'F:78']
dict_values(["TAG's can be used to give the structural descriptions discussed by Gazdar (1985) for the unbounded nested dependencies in Norwedish, for cross serial dependencies in Dutch subordinate clauses, and for the nestings of paired English complementizers."])
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.', 'We characterize a class of formalisms that have this property in Section 4.', 'In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\\s).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:210', 'F:0']
0.21508908895373557 0.01168090898471901 0.020553636176785125





input/ref/Task1/P87-1015_vardha.csv
input/res/Task1/P87-1015.annv3.csv
parsing: input/ref/Task1/P87-1015_vardha.csv
<S sid="165" ssid="50">This class of formalisms have the properties that their derivation trees are local sets, and manipulate objects, using a finite number of composition operations that use a finite number of symbols.</S>
original cit marker offset is 0
new cit marker offset is 0



["'165'"]
'165'
['165']
parsed_discourse_facet ['method_citation']
 <S sid="119" ssid="4">In defining LCFRS's, we hope to generalize the definition of CFG's to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'"]
'119'
['119']
parsed_discourse_facet ['method_citation']
    <S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S>
original cit marker offset is 0
new cit marker offset is 0



["'3'"]
'3'
['3']
parsed_discourse_facet ['method_citation']
    <S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'"]
'118'
['118']
parsed_discourse_facet ['method_citation']
    <S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'"]
'118'
['118']
parsed_discourse_facet ['method_citation']
    <S sid="133" ssid="18">To show that the derivation trees of any grammar in LCFRS is a local set, we can rewrite the annotated derivation trees such that every node is labelled by a pair to include the composition operations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'"]
'133'
['133']
parsed_discourse_facet ['method_citation']
 <S sid="138" ssid="23">We can show that languages generated by LCFRS's are semilinear as long as the composition operation does not remove any terminal symbols from its arguments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'"]
'138'
['138']
parsed_discourse_facet ['method_citation']
    <S sid="156" ssid="41">Giving a recognition algorithm for LCFRL's involves describing the substrings of the input that are spanned by the structures derived by the LCFRS's and how the composition operation combines these substrings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'156'"]
'156'
['156']
parsed_discourse_facet ['method_citation']
 <S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'"]
'118'
['118']
parsed_discourse_facet ['method_citation']
 <S sid="119" ssid="4">In defining LCFRS's, we hope to generalize the definition of CFG's to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'"]
'119'
['119']
parsed_discourse_facet ['method_citation']
  <S sid="133" ssid="18">To show that the derivation trees of any grammar in LCFRS is a local set, we can rewrite the annotated derivation trees such that every node is labelled by a pair to include the composition operations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'133'"]
'133'
['133']
parsed_discourse_facet ['method_citation']
 <S sid="164" ssid="49">Although embedding this version of LCFRS's in the framework of ILFP developed by Rounds (1985) is straightforward, our motivation was to capture properties shared by a family of grammatical systems and generalize them defining a class of related formalisms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'164'"]
'164'
['164']
parsed_discourse_facet ['method_citation']
 <S sid="204" ssid="10">The similarities become apparent when they are studied at the level of derivation structures: derivation nee sets of CFG's, HG's, TAG's, and MCTAG's are all local sets.</S>
original cit marker offset is 0
new cit marker offset is 0



["'204'"]
'204'
['204']
parsed_discourse_facet ['method_citation']
    <S sid="9" ssid="7">We examine both the complexity of the paths of trees in the tree sets, and the kinds of dependencies that the formalisms can impose between paths.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
    <S sid="28" ssid="13">A TAG consists of a finite set of elementary trees that are either initial trees or auxiliary trees.</S>
original cit marker offset is 0
new cit marker offset is 0



["'28'"]
'28'
['28']
parsed_discourse_facet ['method_citation']
 <S sid="138" ssid="23">We can show that languages generated by LCFRS's are semilinear as long as the composition operation does not remove any terminal symbols from its arguments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'"]
'138'
['138']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/P87-1015.annv3.csv
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="232" ssid="38">In considering this aspect of a formalism, we hope to better understand the relationship between the structural descriptions generated by the grammars of a formalism, and the properties of semilinearity and polynomial recognizability.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'118'", "'232'"]
'2'
'3'
'118'
'232'
['2', '3', '118', '232']
parsed_discourse_facet ['aim_citation']
<S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="180" ssid="65">The rewrite rules and the definition of the composition operations may be stored in the finite state control since G uses a finite number of them.</S><S sid="230" ssid="36">LCFRS\s have only been loosely defined in this paper; we have yet to provide a complete set of formal properties associated with members of this class.</S>
original cit marker offset is 0
new cit marker offset is 0



["'118'", "'151'", "'180'", "'230'"]
'118'
'151'
'180'
'230'
['118', '151', '180', '230']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We consider the structural descriptions produced by various grammatical formalisms in terms of the complexity of the paths and the relationship between paths in the sets of structural descriptions that each system can generate.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="214" ssid="20">LCFRS\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'3'", "'119'", "'214'"]
'1'
'3'
'119'
'214'
['1', '3', '119', '214']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="92" ssid="77">We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S><S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'92'", "'118'", "'134'", "'207'"]
'92'
'118'
'134'
'207'
['92', '118', '134', '207']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="207" ssid="13">We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'74'", "'207'"]
'2'
'3'
'74'
'207'
['2', '3', '74', '207']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\s insists that the composition operations are linear and nonerasing.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="229" ssid="35">In addition, the restricted version of CG\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\s containing formalisms whose tree sets have path sets that are themselves LCFRL\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'146'", "'151'", "'229'"]
'119'
'146'
'151'
'229'
['119', '146', '151', '229']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="92" ssid="77">We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="164" ssid="49">Although embedding this version of LCFRS\s in the framework of ILFP developed by Rounds (1985) is straightforward, our motivation was to capture properties shared by a family of grammatical systems and generalize them defining a class of related formalisms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'92'", "'118'", "'164'"]
'2'
'92'
'118'
'164'
['2', '92', '118', '164']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="3" ssid="1">Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.</S><S sid="117" ssid="2">Our goal is to define a class of formal systems, and show that any member of this class will possess certain attractive properties.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'117'", "'118'"]
'2'
'3'
'117'
'118'
['2', '3', '117', '118']
parsed_discourse_facet ['aim_citation']
<S sid="119" ssid="4">In defining LCFRS\s, we hope to generalize the definition of CFG\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.</S><S sid="146" ssid="31">Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\s insists that the composition operations are linear and nonerasing.</S><S sid="151" ssid="36">We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\s).</S><S sid="229" ssid="35">In addition, the restricted version of CG\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\s containing formalisms whose tree sets have path sets that are themselves LCFRL\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).</S>
original cit marker offset is 0
new cit marker offset is 0



["'119'", "'146'", "'151'", "'229'"]
'119'
'146'
'151'
'229'
['119', '146', '151', '229']
parsed_discourse_facet ['method_citation']
<S sid="42" ssid="27">Suppose -y results from the adjunction of 71, ,-y, at the k distinct tree addresses 141, , nk in some elementary tree 7\, respectively.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="75" ssid="60">A multicomponent Tree Adjoining Grammar (MCTAG) consists of a finite set of finite elementary tree sets.</S><S sid="158" ssid="43">We can represent any derived tree of a TAG by the two substrings that appear in its frontier, and then define how the adjunction operation concatenates the substrings.</S>
original cit marker offset is 0
new cit marker offset is 0



["'42'", "'74'", "'75'", "'158'"]
'42'
'74'
'75'
'158'
['42', '74', '75', '158']
parsed_discourse_facet ['method_citation']
<S sid="89" ssid="74">Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\s, MCTAG\s, and HG\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.</S><S sid="90" ssid="75">Thus, as in CFG\s, at any point in the derivation, the set of structures that can be applied is determined only by a finite set of rules encapsulated by the grammar.</S><S sid="128" ssid="13">As in the case of the derivation trees of CFG\s, nodes are labeled by a member of some finite set of symbols (perhaps only implicit in the grammar as in TAG\s) used to denote derived structures.</S><S sid="141" ssid="26">Thus, the length of any string in L is a linear combination of the length of strings in some fixed finite subset of L, and thus L is said to have the constant growth property.</S>
original cit marker offset is 0
new cit marker offset is 0



["'89'", "'90'", "'128'", "'141'"]
'89'
'90'
'128'
'141'
['89', '90', '128', '141']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S><S sid="135" ssid="20">Unlike GCFG\s, however, the composition operations of LCFRS\s are restricted to be linear (do not duplicate unboundedly large structures) and nonerasing (do not erase unbounded structures, a restriction made in most modern transformational grammars).</S><S sid="228" ssid="34">Since these path sets are semilinear, the property of independent paths in their tree sets is sufficient to cause semilinearity of the languages generated by them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'134'", "'135'", "'228'"]
'2'
'134'
'135'
'228'
['2', '134', '135', '228']
parsed_discourse_facet ['aim_citation']
<S sid="73" ssid="58">The equivalence of CC\s with this restriction to TAG\s and HG\s is, however, still an open problem.</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="89" ssid="74">Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\s, MCTAG\s, and HG\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.</S><S sid="228" ssid="34">Since these path sets are semilinear, the property of independent paths in their tree sets is sufficient to cause semilinearity of the languages generated by them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'73'", "'74'", "'89'", "'228'"]
'73'
'74'
'89'
'228'
['73', '74', '89', '228']
parsed_discourse_facet ['method_citation']
<S sid="86" ssid="71">MCTAG\s are able to generate tee sets having dependent paths.</S><S sid="93" ssid="78">As is described in Section 4, the property of having a derivation tree set that is a local set appears to be useful in showing important properties of the languages generated by the formalisms.</S><S sid="109" ssid="15">A geometrical progression of language families defined by Weir (1987) involves tree sets with increasingly complex path sets.</S><S sid="111" ssid="17">.</S>
original cit marker offset is 0
new cit marker offset is 0



["'86'", "'93'", "'109'", "'111'"]
'86'
'93'
'109'
'111'
['86', '93', '109', '111']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="27" ssid="12">Thus, the tree sets generated by HG\s are similar to those of CFG\s, with each node annotated by the operation (concatenation or wrapping) used to combine the headed strings derived by the daughters of Tree Adjoining Grammars, a tree rewriting formalism, was introduced by Joshi, Levy and Takahashi (1975) and Joshi (1983/85).</S><S sid="74" ssid="59">An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.</S><S sid="214" ssid="20">LCFRS\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'27'", "'74'", "'214'"]
'2'
'27'
'74'
'214'
['2', '27', '74', '214']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="2" ssid="2">In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.</S><S sid="91" ssid="76">We characterize a class of formalisms that have this property in Section 4.</S><S sid="118" ssid="3">In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.</S><S sid="134" ssid="19">These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\s).</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'91'", "'118'", "'134'"]
'2'
'91'
'118'
'134'
['2', '91', '118', '134']
parsed_discourse_facet ['aim_citation']
dict_values(['This class of formalisms have the properties that their derivation trees are local sets, and manipulate objects, using a finite number of composition operations that use a finite number of symbols.'])
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.', 'Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.', 'In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'In considering this aspect of a formalism, we hope to better understand the relationship between the structural descriptions generated by the grammars of a formalism, and the properties of semilinearity and polynomial recognizability.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00336', '(95%-conf.int.', '0.00336', '-', '0.00336)']
['system', 'ROUGE-S*', 'Average_P:', '0.10000', '(95%-conf.int.', '0.10000', '-', '0.10000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00650', '(95%-conf.int.', '0.00650', '-', '0.00650)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3570', 'P:120', 'F:12']
dict_values(["In defining LCFRS's, we hope to generalize the definition of CFG's to formalisms manipulating any structure, e.g. strings, trees, or graphs."])
dict_values(['In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\\s).', 'The rewrite rules and the definition of the composition operations may be stored in the finite state control since G uses a finite number of them.', 'LCFRS\\s have only been loosely defined in this paper; we have yet to provide a complete set of formal properties associated with members of this class.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01159', '(95%-conf.int.', '0.01159', '-', '0.01159)']
['system', 'ROUGE-S*', 'Average_P:', '0.18182', '(95%-conf.int.', '0.18182', '-', '0.18182)']
['system', 'ROUGE-S*', 'Average_F:', '0.02180', '(95%-conf.int.', '0.02180', '-', '0.02180)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:66', 'F:12']
dict_values(['Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.'])
dict_values(['We consider the structural descriptions produced by various grammatical formalisms in terms of the complexity of the paths and the relationship between paths in the sets of structural descriptions that each system can generate.', 'Much of the study of grammatical systems in computational linguistics has been focused on the weak generative capacity of grammatical formalism.', 'In defining LCFRS\\s, we hope to generalize the definition of CFG\\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.', 'LCFRS\\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).'])
['system', 'ROUGE-S*', 'Average_R:', '0.04314', '(95%-conf.int.', '0.04314', '-', '0.04314)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.08271', '(95%-conf.int.', '0.08271', '-', '0.08271)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1275', 'P:55', 'F:55']
dict_values(["In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows."])
dict_values(['We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.', 'In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\\s).', 'We outlined the definition of a family of constrained grammatical formalisms, called Linear Context-Free Rewriting Systems.'])
['system', 'ROUGE-S*', 'Average_R:', '0.11594', '(95%-conf.int.', '0.11594', '-', '0.11594)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.20779', '(95%-conf.int.', '0.20779', '-', '0.20779)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:120', 'F:120']
dict_values(['To show that the derivation trees of any grammar in LCFRS is a local set, we can rewrite the annotated derivation trees such that every node is labelled by a pair to include the composition operations.'])
dict_values(['In defining LCFRS\\s, we hope to generalize the definition of CFG\\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.', 'Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\\s insists that the composition operations are linear and nonerasing.', 'We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\\s).', 'In addition, the restricted version of CG\\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\\s containing formalisms whose tree sets have path sets that are themselves LCFRL\\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00994', '(95%-conf.int.', '0.00994', '-', '0.00994)']
['system', 'ROUGE-S*', 'Average_P:', '0.17647', '(95%-conf.int.', '0.17647', '-', '0.17647)']
['system', 'ROUGE-S*', 'Average_F:', '0.01882', '(95%-conf.int.', '0.01882', '-', '0.01882)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:136', 'F:24']
dict_values(["We can show that languages generated by LCFRS's are semilinear as long as the composition operation does not remove any terminal symbols from its arguments."])
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.', 'We loosely describe the class of all such systems as Linear Context-Free Rewriting Formalisms.', 'In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'Although embedding this version of LCFRS\\s in the framework of ILFP developed by Rounds (1985) is straightforward, our motivation was to capture properties shared by a family of grammatical systems and generalize them defining a class of related formalisms.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00250', '(95%-conf.int.', '0.00250', '-', '0.00250)']
['system', 'ROUGE-S*', 'Average_P:', '0.15152', '(95%-conf.int.', '0.15152', '-', '0.15152)']
['system', 'ROUGE-S*', 'Average_F:', '0.00491', '(95%-conf.int.', '0.00491', '-', '0.00491)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:4005', 'P:66', 'F:10']
dict_values(["In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS's) may be defined and sketch how semilinearity and polynomial recognition of these systems follows."])
dict_values(['In defining LCFRS\\s, we hope to generalize the definition of CFG\\s to formalisms manipulating any structure, e.g. strings, trees, or graphs.', 'Since every CFL is known to be semilinear (Parikh, 1966), in order to show semilinearity of some language, we need only show the existence of a letter equivalent CFL Our definition of LCFRS\\s insists that the composition operations are linear and nonerasing.', 'We now turn our attention to the recognition of string languages generated by these formalisms (LCFRL\\s).', 'In addition, the restricted version of CG\\s (discussed in Section 6) generates tree sets with independent paths and we hope that it can be included in a more general definition of LCFRS\\s containing formalisms whose tree sets have path sets that are themselves LCFRL\\s (as in the case of the restricted indexed grammars, and the hierarchy defined by Weir).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00373', '(95%-conf.int.', '0.00373', '-', '0.00373)']
['system', 'ROUGE-S*', 'Average_P:', '0.07500', '(95%-conf.int.', '0.07500', '-', '0.07500)']
['system', 'ROUGE-S*', 'Average_F:', '0.00710', '(95%-conf.int.', '0.00710', '-', '0.00710)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2415', 'P:120', 'F:9']
dict_values(['To show that the derivation trees of any grammar in LCFRS is a local set, we can rewrite the annotated derivation trees such that every node is labelled by a pair to include the composition operations.'])
dict_values(['Hence, trees shown in Figure 8 can not be generated by any MCTAG (but can be generated by an IG) because the number of pairs of dependent paths grows with n. Since the derivation tees of TAG\\s, MCTAG\\s, and HG\\s are local sets, the choice of the structure used at each point in a derivation in these systems does not depend on the context at that point within the derivation.', 'Thus, as in CFG\\s, at any point in the derivation, the set of structures that can be applied is determined only by a finite set of rules encapsulated by the grammar.', 'As in the case of the derivation trees of CFG\\s, nodes are labeled by a member of some finite set of symbols (perhaps only implicit in the grammar as in TAG\\s) used to denote derived structures.', 'Thus, the length of any string in L is a linear combination of the length of strings in some fixed finite subset of L, and thus L is said to have the constant growth property.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01535', '(95%-conf.int.', '0.01535', '-', '0.01535)']
['system', 'ROUGE-S*', 'Average_P:', '0.26471', '(95%-conf.int.', '0.26471', '-', '0.26471)']
['system', 'ROUGE-S*', 'Average_F:', '0.02901', '(95%-conf.int.', '0.02901', '-', '0.02901)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:136', 'F:36']
dict_values(['We examine both the complexity of the paths of trees in the tree sets, and the kinds of dependencies that the formalisms can impose between paths.'])
dict_values(['MCTAG\\s are able to generate tee sets having dependent paths.', 'As is described in Section 4, the property of having a derivation tree set that is a local set appears to be useful in showing important properties of the languages generated by the formalisms.', 'A geometrical progression of language families defined by Weir (1987) involves tree sets with increasingly complex path sets.', '.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03193', '(95%-conf.int.', '0.03193', '-', '0.03193)']
['system', 'ROUGE-S*', 'Average_P:', '0.34545', '(95%-conf.int.', '0.34545', '-', '0.34545)']
['system', 'ROUGE-S*', 'Average_F:', '0.05846', '(95%-conf.int.', '0.05846', '-', '0.05846)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:595', 'P:55', 'F:19']
dict_values(['A TAG consists of a finite set of elementary trees that are either initial trees or auxiliary trees.'])
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.', 'Thus, the tree sets generated by HG\\s are similar to those of CFG\\s, with each node annotated by the operation (concatenation or wrapping) used to combine the headed strings derived by the daughters of Tree Adjoining Grammars, a tree rewriting formalism, was introduced by Joshi, Levy and Takahashi (1975) and Joshi (1983/85).', 'An extension of the TAG system was introduced by Joshi et al. (1975) and later redefined by Joshi (1987) in which the adjunction operation is defined on sets of elementary trees rather than single trees.', 'LCFRS\\s share several properties possessed by the class of mildly context-sensitive formalisms discussed by Joshi (1983/85).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00238', '(95%-conf.int.', '0.00238', '-', '0.00238)']
['system', 'ROUGE-S*', 'Average_P:', '0.28889', '(95%-conf.int.', '0.28889', '-', '0.28889)']
['system', 'ROUGE-S*', 'Average_F:', '0.00472', '(95%-conf.int.', '0.00472', '-', '0.00472)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5460', 'P:45', 'F:13']
dict_values(["We can show that languages generated by LCFRS's are semilinear as long as the composition operation does not remove any terminal symbols from its arguments."])
dict_values(['In considering the relationship between formalisms, we show that it is useful to abstract away from the details of the formalism, and examine the nature of their derivation process as reflected by properties their trees. find that several of the formalisms considered can be seen as being closely related since they have derivation tree sets with the same structure as those produced by Context-Free Grammars On the basis of this observation, we describe a class of formalisms which we call Linear Context- Free Rewriting Systems, and show they are recognizable in polynomial time and generate only semilinear languages.', 'We characterize a class of formalisms that have this property in Section 4.', 'In the remainder of the paper, we outline how a class of Linear Context-Free Rewriting Systems (LCFRS\\s) may be defined and sketch how semilinearity and polynomial recognition of these systems follows.', 'These systems are similar to those described by Pollard (1984) as Generalized Context-Free Grammars (GCFG\\s).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00360', '(95%-conf.int.', '0.00360', '-', '0.00360)']
['system', 'ROUGE-S*', 'Average_P:', '0.15152', '(95%-conf.int.', '0.15152', '-', '0.15152)']
['system', 'ROUGE-S*', 'Average_F:', '0.00704', '(95%-conf.int.', '0.00704', '-', '0.00704)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2775', 'P:66', 'F:10']
0.33957999691290913 0.022132727071520666 0.040805454174495874





input/ref/Task1/W06-2932_swastika.csv
input/res/Task1/W06-2932.annv3.csv
parsing: input/ref/Task1/W06-2932_swastika.csv
<S sid="86" ssid="8">Unlabeled accuracy for all verbs increases from 71% to 73% and for all conjunctions from 71% to 74%.</S>
original cit marker offset is 
new cit marker offset is 0



['86']
86
['86']
parsed_discourse_facet ['result_citation']
<S sid="79" ssid="1">Although overall unlabeled accuracy is 86%, most verbs and some conjunctions attach to their head words with much lower accuracy: 69% for main verbs, 75% for the verb ser, and 65% for coordinating conjunctions.</S>
original cit marker offset is 0
new cit marker offset is 0



['79']
79
['79']
parsed_discourse_facet ['result_citation']
<S sid="79" ssid="1">Although overall unlabeled accuracy is 86%, most verbs and some conjunctions attach to their head words with much lower accuracy: 69% for main verbs, 75% for the verb ser, and 65% for coordinating conjunctions.</S>
original cit marker offset is 0
new cit marker offset is 0



['79']
79
['79']
parsed_discourse_facet ['result_citation']
<S sid="79" ssid="1">Although overall unlabeled accuracy is 86%, most verbs and some conjunctions attach to their head words with much lower accuracy: 69% for main verbs, 75% for the verb ser, and 65% for coordinating conjunctions.</S>
original cit marker offset is 0
new cit marker offset is 0



['79']
79
['79']
parsed_discourse_facet ['result_citation']
<S sid="22" ssid="4">An exact projective and an approximate non-projective parsing algorithm are presented, since it is shown that nonprojective dependency parsing becomes NP-hard when features are extended beyond a single edge.</S>
original cit marker offset is 0
new cit marker offset is 0



['22']
22
['22']
parsed_discourse_facet ['method_citation']
<S sid="54" ssid="2">Based on performance from a held-out section of the training data, we used non-projective parsing algorithms for Czech, Danish, Dutch, German, Japanese, Portuguese and Slovene, and projective parsing algorithms for Arabic, Bulgarian, Chinese, Spanish, Swedish and Turkish.</S>
original cit marker offset is 0
new cit marker offset is 0



['54']
54
['54']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S>
original cit marker offset is 0
new cit marker offset is 0



['12']
12
['12']
parsed_discourse_facet ['method_citation']
    <S sid="22" ssid="4">An exact projective and an approximate non-projective parsing algorithm are presented, since it is shown that nonprojective dependency parsing becomes NP-hard when features are extended beyond a single edge.</S>
original cit marker offset is 0
new cit marker offset is 0



['22']
22
['22']
parsed_discourse_facet ['method_citation']
<S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



['41']
41
['41']
parsed_discourse_facet ['method_citation']
<S sid="24" ssid="6">Its power lies in the ability to define a rich set of features over parsing decisions, as well as surface level features relative to these decisions.</S>
original cit marker offset is 0
new cit marker offset is 0



['24']
24
['24']
parsed_discourse_facet ['method_citation']
<S sid="79" ssid="1">Although overall unlabeled accuracy is 86%, most verbs and some conjunctions attach to their head words with much lower accuracy: 69% for main verbs, 75% for the verb ser, and 65% for coordinating conjunctions.</S>
original cit marker offset is 0
new cit marker offset is 0



['79']
79
['79']
parsed_discourse_facet ['result_citation']
<S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S>
original cit marker offset is 0
new cit marker offset is 0



['12']
12
['12']
parsed_discourse_facet ['method_citation']
<S sid="43" ssid="12">For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.</S>
original cit marker offset is 0
new cit marker offset is 0



['43']
43
['43']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W06-2932.annv3.csv
<S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'20'", "'21'", "'104'"]
'19'
'20'
'21'
'104'
['19', '20', '21', '104']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'45'", "'58'", "'104'"]
'11'
'45'
'58'
'104'
['11', '45', '58', '104']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="10" ssid="6">Dependency graphs also encode much of the deep syntactic information needed for further processing.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="59" ssid="7">Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.</S><S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'58'", "'59'", "'61'"]
'10'
'58'
'59'
'61'
['10', '58', '59', '61']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="13" ssid="9">We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="31" ssid="13">Not all data sets in our experiments include morphological features, so we use them only when available.</S><S sid="64" ssid="2">N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'19'", "'31'", "'64'"]
'13'
'19'
'31'
'64'
['13', '19', '31', '64']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="43" ssid="12">For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.</S><S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'19'", "'43'", "'44'"]
'11'
'19'
'43'
'44'
['11', '19', '43', '44']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'21'", "'58'", "'104'"]
'13'
'21'
'58'
'104'
['13', '21', '58', '104']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S><S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'44'", "'58'"]
'11'
'12'
'44'
'58'
['11', '12', '44', '58']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="18" ssid="14">We Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X), pages 216&#8211;220, New York City, June 2006. c&#65533;2006 Association for Computational Linguistics assume that all dependency graphs are trees but may be non-projective, both of which are true in the data sets we use.</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'11'", "'18'", "'19'"]
'2'
'11'
'18'
'19'
['2', '11', '18', '19']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="3" ssid="3">The second stage takes the output from the first and labels all the edges in the dependency graph with appropriate syntactic categories using a globally trained sequence classifier over components of the graph.</S><S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'41'", "'104'"]
'2'
'3'
'41'
'104'
['2', '3', '41', '104']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="24" ssid="6">Its power lies in the ability to define a rich set of features over parsing decisions, as well as surface level features relative to these decisions.</S><S sid="31" ssid="13">Not all data sets in our experiments include morphological features, so we use them only when available.</S><S sid="46" ssid="15">Of course, we have to define a set of suitable features.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'24'", "'31'", "'46'"]
'2'
'24'
'31'
'46'
['2', '24', '31', '46']
parsed_discourse_facet ['results_citation']
<S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S><S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S><S sid="59" ssid="7">Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.</S><S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'45'", "'59'", "'61'"]
'44'
'45'
'59'
'61'
['44', '45', '59', '61']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'41'"]
'2'
'20'
'21'
'41'
['2', '20', '21', '41']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'104'"]
'2'
'20'
'21'
'104'
['2', '20', '21', '104']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['Although overall unlabeled accuracy is 86%, most verbs and some conjunctions attach to their head words with much lower accuracy: 69% for main verbs, 75% for the verb ser, and 65% for coordinating conjunctions.'])
dict_values(['Dependency graphs also encode much of the deep syntactic information needed for further processing.', 'These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.', 'Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.', 'In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00073', '(95%-conf.int.', '0.00073', '-', '0.00073)']
['system', 'ROUGE-S*', 'Average_P:', '0.00585', '(95%-conf.int.', '0.00585', '-', '0.00585)']
['system', 'ROUGE-S*', 'Average_F:', '0.00129', '(95%-conf.int.', '0.00129', '-', '0.00129)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:171', 'F:1']
dict_values(['Although overall unlabeled accuracy is 86%, most verbs and some conjunctions attach to their head words with much lower accuracy: 69% for main verbs, 75% for the verb ser, and 65% for coordinating conjunctions.'])
dict_values(['We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).', 'The first stage of our system creates an unlabeled parse y for an input sentence x.', 'Not all data sets in our experiments include morphological features, so we use them only when available.', 'N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5253', 'P:171', 'F:0']
dict_values(['An exact projective and an approximate non-projective parsing algorithm are presented, since it is shown that nonprojective dependency parsing becomes NP-hard when features are extended beyond a single edge.'])
dict_values(['This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).', 'The first stage of our system creates an unlabeled parse y for an input sentence x.', 'For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.', 'We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00213', '(95%-conf.int.', '0.00213', '-', '0.00213)']
['system', 'ROUGE-S*', 'Average_P:', '0.03676', '(95%-conf.int.', '0.03676', '-', '0.03676)']
['system', 'ROUGE-S*', 'Average_F:', '0.00403', '(95%-conf.int.', '0.00403', '-', '0.00403)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:136', 'F:5']
dict_values(['Based on performance from a held-out section of the training data, we used non-projective parsing algorithms for Czech, Danish, Dutch, German, Japanese, Portuguese and Slovene, and projective parsing algorithms for Arabic, Bulgarian, Chinese, Spanish, Swedish and Turkish.'])
dict_values(['We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).', 'That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.', 'These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.', 'We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00041', '(95%-conf.int.', '0.00041', '-', '0.00041)']
['system', 'ROUGE-S*', 'Average_P:', '0.01000', '(95%-conf.int.', '0.01000', '-', '0.01000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00079', '(95%-conf.int.', '0.00079', '-', '0.00079)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:7260', 'P:300', 'F:3']
dict_values(['In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.'])
dict_values(['This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).', 'In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.', 'We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.', 'These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02985', '(95%-conf.int.', '0.02985', '-', '0.02985)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.05797', '(95%-conf.int.', '0.05797', '-', '0.05797)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2211', 'P:66', 'F:66']
dict_values(['An exact projective and an approximate non-projective parsing algorithm are presented, since it is shown that nonprojective dependency parsing becomes NP-hard when features are extended beyond a single edge.'])
dict_values(['The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.', 'This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).', 'We Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X), pages 216&#8211;220, New York City, June 2006. c&#65533;2006 Association for Computational Linguistics assume that all dependency graphs are trees but may be non-projective, both of which are true in the data sets we use.', 'The first stage of our system creates an unlabeled parse y for an input sentence x.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00333', '(95%-conf.int.', '0.00333', '-', '0.00333)']
['system', 'ROUGE-S*', 'Average_P:', '0.06618', '(95%-conf.int.', '0.06618', '-', '0.06618)']
['system', 'ROUGE-S*', 'Average_F:', '0.00634', '(95%-conf.int.', '0.00634', '-', '0.00634)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2701', 'P:136', 'F:9']
dict_values(['To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.'])
dict_values(['The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.', 'The second stage takes the output from the first and labels all the edges in the dependency graph with appropriate syntactic categories using a globally trained sequence classifier over components of the graph.', 'To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.', 'We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.'])
['system', 'ROUGE-S*', 'Average_R:', '0.12587', '(95%-conf.int.', '0.12587', '-', '0.12587)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.22360', '(95%-conf.int.', '0.22360', '-', '0.22360)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:378', 'F:378']
dict_values(['Its power lies in the ability to define a rich set of features over parsing decisions, as well as surface level features relative to these decisions.'])
dict_values(['The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.', 'Its power lies in the ability to define a rich set of features over parsing decisions, as well as surface level features relative to these decisions.', 'Not all data sets in our experiments include morphological features, so we use them only when available.', 'Of course, we have to define a set of suitable features.'])
['system', 'ROUGE-S*', 'Average_R:', '0.12281', '(95%-conf.int.', '0.12281', '-', '0.12281)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.21875', '(95%-conf.int.', '0.21875', '-', '0.21875)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:741', 'P:91', 'F:91']
dict_values(['Although overall unlabeled accuracy is 86%, most verbs and some conjunctions attach to their head words with much lower accuracy: 69% for main verbs, 75% for the verb ser, and 65% for coordinating conjunctions.'])
dict_values(['We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.', 'Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).', 'Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.', 'In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00181', '(95%-conf.int.', '0.00181', '-', '0.00181)']
['system', 'ROUGE-S*', 'Average_P:', '0.01754', '(95%-conf.int.', '0.01754', '-', '0.01754)']
['system', 'ROUGE-S*', 'Average_F:', '0.00329', '(95%-conf.int.', '0.00329', '-', '0.00329)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:171', 'F:3']
dict_values(['For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.'])
dict_values(['The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.', 'This system is primarily based on the parsing models described by McDonald and Pereira (2006).', 'That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.', 'We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00053', '(95%-conf.int.', '0.00053', '-', '0.00053)']
['system', 'ROUGE-S*', 'Average_P:', '0.00433', '(95%-conf.int.', '0.00433', '-', '0.00433)']
['system', 'ROUGE-S*', 'Average_F:', '0.00094', '(95%-conf.int.', '0.00094', '-', '0.00094)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:231', 'F:1']
0.31406599685934 0.02874699971253 0.05169999948300001





input/ref/Task1/W06-2932_sweta.csv
input/res/Task1/W06-2932.annv3.csv
parsing: input/ref/Task1/W06-2932_sweta.csv
 <S sid="5" ssid="1">Often in language processing we require a deep syntactic representation of a sentence in order to assist further processing.</S>
original cit marker offset is 0
new cit marker offset is 0



["5'"]
5'
['5']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="5">However, in a two stage system we can incorporate features over the entire output of the unlabeled parser since that structure is fixed as input.</S>
original cit marker offset is 0
new cit marker offset is 0



["36'"]
36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["61'"]
61'
['61']
parsed_discourse_facet ['method_citation']
<S sid="76" ssid="14">For instance, sequential labeling improves the labeling of 2This difference was much larger for experiments in which gold standard unlabeled dependencies are used. objects from 81.7%/75.6% to 84.2%/81.3% (labeled precision/recall) and the labeling of subjects from 86.8%/88.2% to 90.5%/90.4% for Swedish.</S>
original cit marker offset is 0
new cit marker offset is 0



["76'"]
76'
['76']
parsed_discourse_facet ['method_citation']
 <S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["45'"]
45'
['45']
parsed_discourse_facet ['method_citation']
<S sid="106" ssid="3">First, we plan on examining the performance difference between two-staged dependency parsing (as presented here) and joint parsing plus labeling.</S>
original cit marker offset is 0
new cit marker offset is 0



["106'"]
106'
['106']
parsed_discourse_facet ['method_citation']
<S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S>
original cit marker offset is 0
new cit marker offset is 0



["12'"]
12'
['12']
parsed_discourse_facet ['method_citation']
<S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["104'"]
104'
['104']
parsed_discourse_facet ['method_citation']
<S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["58'"]
58'
['58']
parsed_discourse_facet ['method_citation']
<S sid="64" ssid="2">N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.</S>
original cit marker offset is 0
new cit marker offset is 0



["64'"]
64'
['64']
parsed_discourse_facet ['method_citation']
<S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



["41'"]
41'
['41']
parsed_discourse_facet ['method_citation']
 <S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["21'"]
21'
['21']
parsed_discourse_facet ['method_citation']
 <S sid="64" ssid="2">N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.</S>
original cit marker offset is 0
new cit marker offset is 0



["64'"]
64'
['64']
parsed_discourse_facet ['method_citation']
 <S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["104'"]
104'
['104']
parsed_discourse_facet ['method_citation']
<S sid="33" ssid="2">Ideally one would like to make all parsing and labeling decisions jointly so that the shared knowledge of both decisions will help resolve any ambiguities.</S>
original cit marker offset is 0
new cit marker offset is 0



["33'"]
33'
['33']
parsed_discourse_facet ['method_citation']
<S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



["41'"]
41'
['41']
parsed_discourse_facet ['method_citation']
 <S sid="43" ssid="12">For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.</S>
original cit marker offset is 0
new cit marker offset is 0



["43'"]
43'
['43']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W06-2932.annv3.csv
<S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'20'", "'21'", "'104'"]
'19'
'20'
'21'
'104'
['19', '20', '21', '104']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'45'", "'58'", "'104'"]
'11'
'45'
'58'
'104'
['11', '45', '58', '104']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="10" ssid="6">Dependency graphs also encode much of the deep syntactic information needed for further processing.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="59" ssid="7">Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.</S><S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'58'", "'59'", "'61'"]
'10'
'58'
'59'
'61'
['10', '58', '59', '61']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="13" ssid="9">We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="31" ssid="13">Not all data sets in our experiments include morphological features, so we use them only when available.</S><S sid="64" ssid="2">N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'19'", "'31'", "'64'"]
'13'
'19'
'31'
'64'
['13', '19', '31', '64']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="43" ssid="12">For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.</S><S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'19'", "'43'", "'44'"]
'11'
'19'
'43'
'44'
['11', '19', '43', '44']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'21'", "'58'", "'104'"]
'13'
'21'
'58'
'104'
['13', '21', '58', '104']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S><S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'44'", "'58'"]
'11'
'12'
'44'
'58'
['11', '12', '44', '58']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="18" ssid="14">We Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X), pages 216&#8211;220, New York City, June 2006. c&#65533;2006 Association for Computational Linguistics assume that all dependency graphs are trees but may be non-projective, both of which are true in the data sets we use.</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'11'", "'18'", "'19'"]
'2'
'11'
'18'
'19'
['2', '11', '18', '19']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="3" ssid="3">The second stage takes the output from the first and labels all the edges in the dependency graph with appropriate syntactic categories using a globally trained sequence classifier over components of the graph.</S><S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'41'", "'104'"]
'2'
'3'
'41'
'104'
['2', '3', '41', '104']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="24" ssid="6">Its power lies in the ability to define a rich set of features over parsing decisions, as well as surface level features relative to these decisions.</S><S sid="31" ssid="13">Not all data sets in our experiments include morphological features, so we use them only when available.</S><S sid="46" ssid="15">Of course, we have to define a set of suitable features.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'24'", "'31'", "'46'"]
'2'
'24'
'31'
'46'
['2', '24', '31', '46']
parsed_discourse_facet ['results_citation']
<S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S><S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S><S sid="59" ssid="7">Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.</S><S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'45'", "'59'", "'61'"]
'44'
'45'
'59'
'61'
['44', '45', '59', '61']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'41'"]
'2'
'20'
'21'
'41'
['2', '20', '21', '41']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'104'"]
'2'
'20'
'21'
'104'
['2', '20', '21', '104']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).'])
dict_values(['Dependency graphs also encode much of the deep syntactic information needed for further processing.', 'These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.', 'Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.', 'In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).'])
['system', 'ROUGE-S*', 'Average_R:', '0.05660', '(95%-conf.int.', '0.05660', '-', '0.05660)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10714', '(95%-conf.int.', '0.10714', '-', '0.10714)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:78', 'F:78']
dict_values(['For instance, sequential labeling improves the labeling of 2This difference was much larger for experiments in which gold standard unlabeled dependencies are used. objects from 81.7%/75.6% to 84.2%/81.3% (labeled precision/recall) and the labeling of subjects from 86.8%/88.2% to 90.5%/90.4% for Swedish.'])
dict_values(['We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).', 'The first stage of our system creates an unlabeled parse y for an input sentence x.', 'Not all data sets in our experiments include morphological features, so we use them only when available.', 'N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00190', '(95%-conf.int.', '0.00190', '-', '0.00190)']
['system', 'ROUGE-S*', 'Average_P:', '0.01587', '(95%-conf.int.', '0.01587', '-', '0.01587)']
['system', 'ROUGE-S*', 'Average_F:', '0.00340', '(95%-conf.int.', '0.00340', '-', '0.00340)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5253', 'P:630', 'F:10']
dict_values(['Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).'])
dict_values(['This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).', 'The first stage of our system creates an unlabeled parse y for an input sentence x.', 'For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.', 'We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00341', '(95%-conf.int.', '0.00341', '-', '0.00341)']
['system', 'ROUGE-S*', 'Average_P:', '0.12121', '(95%-conf.int.', '0.12121', '-', '0.12121)']
['system', 'ROUGE-S*', 'Average_F:', '0.00663', '(95%-conf.int.', '0.00663', '-', '0.00663)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:66', 'F:8']
dict_values(['First, we plan on examining the performance difference between two-staged dependency parsing (as presented here) and joint parsing plus labeling.'])
dict_values(['We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).', 'That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.', 'These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.', 'We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00083', '(95%-conf.int.', '0.00083', '-', '0.00083)']
['system', 'ROUGE-S*', 'Average_P:', '0.09091', '(95%-conf.int.', '0.09091', '-', '0.09091)']
['system', 'ROUGE-S*', 'Average_F:', '0.00164', '(95%-conf.int.', '0.00164', '-', '0.00164)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:7260', 'P:66', 'F:6']
dict_values(['In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.'])
dict_values(['This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).', 'In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.', 'We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.', 'These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02985', '(95%-conf.int.', '0.02985', '-', '0.02985)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.05797', '(95%-conf.int.', '0.05797', '-', '0.05797)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2211', 'P:66', 'F:66']
dict_values(['N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.'])
dict_values(['The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.', 'This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).', 'We Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X), pages 216&#8211;220, New York City, June 2006. c&#65533;2006 Association for Computational Linguistics assume that all dependency graphs are trees but may be non-projective, both of which are true in the data sets we use.', 'The first stage of our system creates an unlabeled parse y for an input sentence x.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00185', '(95%-conf.int.', '0.00185', '-', '0.00185)']
['system', 'ROUGE-S*', 'Average_P:', '0.01976', '(95%-conf.int.', '0.01976', '-', '0.01976)']
['system', 'ROUGE-S*', 'Average_F:', '0.00339', '(95%-conf.int.', '0.00339', '-', '0.00339)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2701', 'P:253', 'F:5']
dict_values(['To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.'])
dict_values(['The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.', 'The second stage takes the output from the first and labels all the edges in the dependency graph with appropriate syntactic categories using a globally trained sequence classifier over components of the graph.', 'To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.', 'We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.'])
['system', 'ROUGE-S*', 'Average_R:', '0.12587', '(95%-conf.int.', '0.12587', '-', '0.12587)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.22360', '(95%-conf.int.', '0.22360', '-', '0.22360)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:378', 'F:378']
dict_values(['N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.'])
dict_values(['The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.', 'Its power lies in the ability to define a rich set of features over parsing decisions, as well as surface level features relative to these decisions.', 'Not all data sets in our experiments include morphological features, so we use them only when available.', 'Of course, we have to define a set of suitable features.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03644', '(95%-conf.int.', '0.03644', '-', '0.03644)']
['system', 'ROUGE-S*', 'Average_P:', '0.10672', '(95%-conf.int.', '0.10672', '-', '0.10672)']
['system', 'ROUGE-S*', 'Average_F:', '0.05433', '(95%-conf.int.', '0.05433', '-', '0.05433)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:741', 'P:253', 'F:27']
dict_values(['Ideally one would like to make all parsing and labeling decisions jointly so that the shared knowledge of both decisions will help resolve any ambiguities.'])
dict_values(['We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.', 'Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).', 'Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.', 'In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:55', 'F:0']
dict_values(['For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.'])
dict_values(['The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.', 'This system is primarily based on the parsing models described by McDonald and Pereira (2006).', 'That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.', 'We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00053', '(95%-conf.int.', '0.00053', '-', '0.00053)']
['system', 'ROUGE-S*', 'Average_P:', '0.00433', '(95%-conf.int.', '0.00433', '-', '0.00433)']
['system', 'ROUGE-S*', 'Average_F:', '0.00094', '(95%-conf.int.', '0.00094', '-', '0.00094)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:231', 'F:1']
0.33587999664120005 0.025727999742720005 0.04590399954096





input/ref/Task1/W06-2932_vardha.csv
input/res/Task1/W06-2932.annv3.csv
parsing: input/ref/Task1/W06-2932_vardha.csv
    <S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'"]
'19'
['19']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="5">However, in a two stage system we can incorporate features over the entire output of the unlabeled parser since that structure is fixed as input.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
    <S sid="57" ssid="5">Performance is measured through unlabeled accuracy, which is the percentage of words that modify the correct head in the dependency graph, and labeled accuracy, which is the percentage of words that modify the correct head and label the dependency edge correctly in the graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'57'"]
'57'
['57']
parsed_discourse_facet ['method_citation']
    <S sid="76" ssid="14">For instance, sequential labeling improves the labeling of 2This difference was much larger for experiments in which gold standard unlabeled dependencies are used. objects from 81.7%/75.6% to 84.2%/81.3% (labeled precision/recall) and the labeling of subjects from 86.8%/88.2% to 90.5%/90.4% for Swedish.</S>
original cit marker offset is 0
new cit marker offset is 0



["'76'"]
'76'
['76']
parsed_discourse_facet ['method_citation']
 <S sid="54" ssid="2">Based on performance from a held-out section of the training data, we used non-projective parsing algorithms for Czech, Danish, Dutch, German, Japanese, Portuguese and Slovene, and projective parsing algorithms for Arabic, Bulgarian, Chinese, Spanish, Swedish and Turkish.</S>
original cit marker offset is 0
new cit marker offset is 0



["'54'"]
'54'
['54']
parsed_discourse_facet ['method_citation']
    <S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'104'"]
'104'
['104']
parsed_discourse_facet ['method_citation']
    <S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'"]
'12'
['12']
parsed_discourse_facet ['method_citation']
    <S sid="57" ssid="5">Performance is measured through unlabeled accuracy, which is the percentage of words that modify the correct head in the dependency graph, and labeled accuracy, which is the percentage of words that modify the correct head and label the dependency edge correctly in the graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'57'"]
'57'
['57']
parsed_discourse_facet ['method_citation']
    <S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'58'"]
'58'
['58']
parsed_discourse_facet ['method_citation']
    <S sid="22" ssid="4">An exact projective and an approximate non-projective parsing algorithm are presented, since it is shown that nonprojective dependency parsing becomes NP-hard when features are extended beyond a single edge.</S>
original cit marker offset is 0
new cit marker offset is 0



["'22'"]
'22'
['22']
parsed_discourse_facet ['method_citation']
    <S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



["'41'"]
'41'
['41']
parsed_discourse_facet ['method_citation']
    <S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
    <S sid="64" ssid="2">N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'64'"]
'64'
['64']
parsed_discourse_facet ['method_citation']
    <S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
    <S sid="57" ssid="5">Performance is measured through unlabeled accuracy, which is the percentage of words that modify the correct head in the dependency graph, and labeled accuracy, which is the percentage of words that modify the correct head and label the edge correctly in the graph.</S>
original cit marker offset is 0
new cit marker offset is 0



["'57'"]
'57'
['57']
parsed_discourse_facet ['method_citation']
    <S sid="43" ssid="12">For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.</S>
original cit marker offset is 0
new cit marker offset is 0



["'43'"]
'43'
['43']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W06-2932.annv3.csv
<S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'19'", "'20'", "'21'", "'104'"]
'19'
'20'
'21'
'104'
['19', '20', '21', '104']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'45'", "'58'", "'104'"]
'11'
'45'
'58'
'104'
['11', '45', '58', '104']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="10" ssid="6">Dependency graphs also encode much of the deep syntactic information needed for further processing.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="59" ssid="7">Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.</S><S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'58'", "'59'", "'61'"]
'10'
'58'
'59'
'61'
['10', '58', '59', '61']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="13" ssid="9">We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="31" ssid="13">Not all data sets in our experiments include morphological features, so we use them only when available.</S><S sid="64" ssid="2">N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'19'", "'31'", "'64'"]
'13'
'19'
'31'
'64'
['13', '19', '31', '64']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S><S sid="43" ssid="12">For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.</S><S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'19'", "'43'", "'44'"]
'11'
'19'
'43'
'44'
['11', '19', '43', '44']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'21'", "'58'", "'104'"]
'13'
'21'
'58'
'104'
['13', '21', '58', '104']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="12" ssid="8">In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.</S><S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S><S sid="58" ssid="6">These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'", "'12'", "'44'", "'58'"]
'11'
'12'
'44'
'58'
['11', '12', '44', '58']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="11" ssid="7">This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).</S><S sid="18" ssid="14">We Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X), pages 216&#8211;220, New York City, June 2006. c&#65533;2006 Association for Computational Linguistics assume that all dependency graphs are trees but may be non-projective, both of which are true in the data sets we use.</S><S sid="19" ssid="1">The first stage of our system creates an unlabeled parse y for an input sentence x.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'11'", "'18'", "'19'"]
'2'
'11'
'18'
'19'
['2', '11', '18', '19']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="3" ssid="3">The second stage takes the output from the first and labels all the edges in the dependency graph with appropriate syntactic categories using a globally trained sequence classifier over components of the graph.</S><S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'3'", "'41'", "'104'"]
'2'
'3'
'41'
'104'
['2', '3', '41', '104']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="24" ssid="6">Its power lies in the ability to define a rich set of features over parsing decisions, as well as surface level features relative to these decisions.</S><S sid="31" ssid="13">Not all data sets in our experiments include morphological features, so we use them only when available.</S><S sid="46" ssid="15">Of course, we have to define a set of suitable features.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'24'", "'31'", "'46'"]
'2'
'24'
'31'
'46'
['2', '24', '31', '46']
parsed_discourse_facet ['results_citation']
<S sid="44" ssid="13">We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.</S><S sid="45" ssid="14">Furthermore, it made the system homogeneous in terms of learning algorithms since that is what is used to train our unlabeled parser (McDonald and Pereira, 2006).</S><S sid="59" ssid="7">Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.</S><S sid="61" ssid="9">In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'45'", "'59'", "'61'"]
'44'
'45'
'59'
'61'
['44', '45', '59', '61']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="41" ssid="10">To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'41'"]
'2'
'20'
'21'
'41'
['2', '20', '21', '41']
parsed_discourse_facet ['hypothesis_citation']
<S sid="2" ssid="2">The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.</S><S sid="20" ssid="2">This system is primarily based on the parsing models described by McDonald and Pereira (2006).</S><S sid="21" ssid="3">That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.</S><S sid="104" ssid="1">We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'20'", "'21'", "'104'"]
'2'
'20'
'21'
'104'
['2', '20', '21', '104']
parsed_discourse_facet ['hypothesis_citation']
dict_values(['Performance is measured through unlabeled accuracy, which is the percentage of words that modify the correct head in the dependency graph, and labeled accuracy, which is the percentage of words that modify the correct head and label the dependency edge correctly in the graph.'])
dict_values(['Dependency graphs also encode much of the deep syntactic information needed for further processing.', 'These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.', 'Only Arabic, Turkish and Slovene have parsing accuracies significantly below 80%, and these languages have relatively small training sets and/or are highly inflected with little to no word order constraints.', 'In fact, for every language our models perform significantly higher than the average performance for all the systems reported in Buchholz et al. (2006).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00435', '(95%-conf.int.', '0.00435', '-', '0.00435)']
['system', 'ROUGE-S*', 'Average_P:', '0.02372', '(95%-conf.int.', '0.02372', '-', '0.02372)']
['system', 'ROUGE-S*', 'Average_F:', '0.00736', '(95%-conf.int.', '0.00736', '-', '0.00736)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:253', 'F:6']
dict_values(['For instance, sequential labeling improves the labeling of 2This difference was much larger for experiments in which gold standard unlabeled dependencies are used. objects from 81.7%/75.6% to 84.2%/81.3% (labeled precision/recall) and the labeling of subjects from 86.8%/88.2% to 90.5%/90.4% for Swedish.'])
dict_values(['We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).', 'The first stage of our system creates an unlabeled parse y for an input sentence x.', 'Not all data sets in our experiments include morphological features, so we use them only when available.', 'N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00190', '(95%-conf.int.', '0.00190', '-', '0.00190)']
['system', 'ROUGE-S*', 'Average_P:', '0.01587', '(95%-conf.int.', '0.01587', '-', '0.01587)']
['system', 'ROUGE-S*', 'Average_F:', '0.00340', '(95%-conf.int.', '0.00340', '-', '0.00340)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:5253', 'P:630', 'F:10']
dict_values(['Based on performance from a held-out section of the training data, we used non-projective parsing algorithms for Czech, Danish, Dutch, German, Japanese, Portuguese and Slovene, and projective parsing algorithms for Arabic, Bulgarian, Chinese, Spanish, Swedish and Turkish.'])
dict_values(['This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).', 'The first stage of our system creates an unlabeled parse y for an input sentence x.', 'For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.', 'We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00043', '(95%-conf.int.', '0.00043', '-', '0.00043)']
['system', 'ROUGE-S*', 'Average_P:', '0.00333', '(95%-conf.int.', '0.00333', '-', '0.00333)']
['system', 'ROUGE-S*', 'Average_F:', '0.00076', '(95%-conf.int.', '0.00076', '-', '0.00076)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:300', 'F:1']
dict_values(['We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.'])
dict_values(['We evaluate this parser on a diverse set of 13 languages using data provided by the CoNLL-X shared-task organizers (Buchholz et al., 2006; Haji&#711;c et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B&#168;ohmov&#180;a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; D&#711;zeroski et al., 2006; Civit Torruella and MartiAntonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).', 'That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.', 'These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.', 'We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02355', '(95%-conf.int.', '0.02355', '-', '0.02355)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.04602', '(95%-conf.int.', '0.04602', '-', '0.04602)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:7260', 'P:171', 'F:171']
dict_values(['In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.'])
dict_values(['This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).', 'In this paper we describe a two-stage discriminative parsing approach consisting of an unlabeled parser and a subsequent edge labeler.', 'We use the MIRA online learner to set the weights (Crammer and Singer, 2003; McDonald et al., 2005a) since we found it trained quickly and provide good performance.', 'These results show that the discriminative spanning tree parsing framework (McDonald et al., 2005b; McDonald and Pereira, 2006) is easily adapted across all these languages.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02985', '(95%-conf.int.', '0.02985', '-', '0.02985)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.05797', '(95%-conf.int.', '0.05797', '-', '0.05797)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2211', 'P:66', 'F:66']
dict_values(['An exact projective and an approximate non-projective parsing algorithm are presented, since it is shown that nonprojective dependency parsing becomes NP-hard when features are extended beyond a single edge.'])
dict_values(['The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.', 'This has been shown through their successful use in many standard natural language processing tasks, including machine translation (Ding and Palmer, 2005), sentence compression (McDonald, 2006), and textual inference (Haghighi et al., 2005).', 'We Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X), pages 216&#8211;220, New York City, June 2006. c&#65533;2006 Association for Computational Linguistics assume that all dependency graphs are trees but may be non-projective, both of which are true in the data sets we use.', 'The first stage of our system creates an unlabeled parse y for an input sentence x.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00333', '(95%-conf.int.', '0.00333', '-', '0.00333)']
['system', 'ROUGE-S*', 'Average_P:', '0.06618', '(95%-conf.int.', '0.06618', '-', '0.06618)']
['system', 'ROUGE-S*', 'Average_F:', '0.00634', '(95%-conf.int.', '0.00634', '-', '0.00634)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2701', 'P:136', 'F:9']
dict_values(['To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.'])
dict_values(['The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.', 'The second stage takes the output from the first and labels all the edges in the dependency graph with appropriate syntactic categories using a globally trained sequence classifier over components of the graph.', 'To model this we treat the labeling of the edges (i, j1), ... , (i, jM) as a sequence labeling problem, We use a first-order Markov factorization of the score s(l(i,jm), l(i,jm&#65533;1), i, y, x) in which each factor is the score of labeling the adjacent edges (i, jm) and (i, jm&#8722;1) in the tree y.', 'We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.'])
['system', 'ROUGE-S*', 'Average_R:', '0.12587', '(95%-conf.int.', '0.12587', '-', '0.12587)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.22360', '(95%-conf.int.', '0.22360', '-', '0.22360)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3003', 'P:378', 'F:378']
dict_values(['N/P: Allow non-projective/Force projective, S/A: Sequential labeling/Atomic labeling, M/B: Include morphology features/No morphology features. assignment of edge labels instead of individual assignment, and a rich feature set that incorporates morphological properties when available.'])
dict_values(['The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.', 'Its power lies in the ability to define a rich set of features over parsing decisions, as well as surface level features relative to these decisions.', 'Not all data sets in our experiments include morphological features, so we use them only when available.', 'Of course, we have to define a set of suitable features.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03644', '(95%-conf.int.', '0.03644', '-', '0.03644)']
['system', 'ROUGE-S*', 'Average_P:', '0.10672', '(95%-conf.int.', '0.10672', '-', '0.10672)']
['system', 'ROUGE-S*', 'Average_F:', '0.05433', '(95%-conf.int.', '0.05433', '-', '0.05433)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:741', 'P:253', 'F:27']
dict_values(['For score functions, we use simple dot products between high dimensional feature representations and a weight vector Assuming we have an appropriate feature representation, we can find the highest scoring label sequence with Viterbi&#8217;s algorithm.'])
dict_values(['The first stage based on the unlabeled dependency parsing models described by McDonald and Pereira (2006) augmented with morphological features for a subset of the languages.', 'This system is primarily based on the parsing models described by McDonald and Pereira (2006).', 'That work extends the maximum spanning tree dependency parsing framework (McDonald et al., 2005a; McDonald et al., 2005b) to incorporate features over multiple edges in the dependency graph.', 'We have presented results showing that the spanning tree dependency parsing framework of McDonald et al. (McDonald et al., 2005b; McDonald and Pereira, 2006) generalizes well to languages other than English.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00053', '(95%-conf.int.', '0.00053', '-', '0.00053)']
['system', 'ROUGE-S*', 'Average_P:', '0.00433', '(95%-conf.int.', '0.00433', '-', '0.00433)']
['system', 'ROUGE-S*', 'Average_F:', '0.00094', '(95%-conf.int.', '0.00094', '-', '0.00094)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1891', 'P:231', 'F:1']
0.3577944404689507 0.025138888609567908 0.0445244439497284





input/ref/Task1/W06-3114_aakansha.csv
input/res/Task1/W06-3114.annv3.csv
parsing: input/ref/Task1/W06-3114_aakansha.csv
<S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'170'"]
'170'
['170']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="1">The evaluation framework for the shared task is similar to the one used in last year&#8217;s shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="2">The BLEU metric, as all currently proposed automatic metrics, is occasionally suspected to be biased towards statistical systems, especially the phrase-based systems currently in use.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="2">The BLEU metric, as all currently proposed automatic metrics, is occasionally suspected to be biased towards statistical systems, especially the phrase-based systems currently in use.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['method_citation']
<S sid="102" ssid="18">Confidence Interval: To estimate confidence intervals for the average mean scores for the systems, we use standard significance testing.</S>
original cit marker offset is 0
new cit marker offset is 0



["'102'"]
'102'
['102']
parsed_discourse_facet ['method_citation']
<S sid="84" ssid="23">The human judges were presented with the following definition of adequacy and fluency, but no additional instructions:</S>
original cit marker offset is 0
new cit marker offset is 0



["'84'"]
'84'
['84']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="4">To lower the barrier of entrance to the competition, we provided a complete baseline MT system, along with data resources.</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'"]
'11'
['11']
parsed_discourse_facet ['method_citation']
<S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'126'"]
'126'
['126']
parsed_discourse_facet ['method_citation']
<S sid="15" ssid="8">Out-of-domain test data is from the Project Syndicate web site, a compendium of political commentary.</S>
original cit marker offset is 0
new cit marker offset is 0



["'15'"]
'15'
['15']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="1">The evaluation framework for the shared task is similar to the one used in last year&#8217;s shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="90" ssid="6">Another way to view the judgements is that they are less quality judgements of machine translation systems per se, but rankings of machine translation systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'90'"]
'90'
['90']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="3">&#8226; We evaluated translation from English, in addition to into English.</S>
    <S sid="6" ssid="4">English was again paired with German, French, and Spanish.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'6'"]
'5'
'6'
['5', '6']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W06-3114.annv3.csv
<S sid="48" ssid="14">Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="56" ssid="22">The bootstrap method has been critized by Riezler and Maxwell (2005) and Collins et al. (2005), as being too optimistic in deciding for statistical significant difference between systems.</S><S sid="57" ssid="23">We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'56'", "'57'"]
'48'
'49'
'56'
'57'
['48', '49', '56', '57']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="5">We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.</S><S sid="26" ssid="19">Most of these groups follow a phrase-based statistical approach to machine translation.</S><S sid="30" ssid="23">The other half was replaced by other participants, so we ended up with roughly the same number.</S><S sid="65" ssid="4">The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'26'", "'30'", "'65'"]
'7'
'26'
'30'
'65'
['7', '26', '30', '65']
parsed_discourse_facet ['hypothesis_citation']
<S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S><S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="15" ssid="8">Out-of-domain test data is from the Project Syndicate web site, a compendium of political commentary.</S><S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'13'", "'15'", "'18'"]
'9'
'13'
'15'
'18'
['9', '13', '15', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S><S sid="90" ssid="6">Another way to view the judgements is that they are less quality judgements of machine translation systems per se, but rankings of machine translation systems.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'62'", "'90'", "'140'"]
'38'
'62'
'90'
'140'
['38', '62', '90', '140']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .</S><S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S><S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="165" ssid="58">However, ince we extracted the test corpus automatically from web sources, the reference translation was not always accurate &#8212; due to sentence alignment errors, or because translators did not adhere to a strict sentence-by-sentence translation (say, using pronouns when referring to entities mentioned in the previous sentence).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'17'", "'165'"]
'1'
'9'
'17'
'165'
['1', '9', '17', '165']
parsed_discourse_facet ['results_citation']
<S sid="37" ssid="3">It rewards matches of n-gram sequences, but measures only at most indirectly overall grammatical coherence.</S><S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'64'", "'140'"]
'37'
'39'
'64'
'140'
['37', '39', '64', '140']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="3">It rewards matches of n-gram sequences, but measures only at most indirectly overall grammatical coherence.</S><S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="139" ssid="32">Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'139'", "'140'"]
'37'
'39'
'139'
'140'
['37', '39', '139', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="47" ssid="13">Because of this, we retokenized and lowercased submitted output with our own tokenizer, which was also used to prepare the training and test data.</S><S sid="83" ssid="22">The number of judgements is additionally fragmented by our breakup of sentences into in-domain and out-of-domain.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'47'", "'83'", "'140'"]
'39'
'47'
'83'
'140'
['39', '47', '83', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S><S sid="167" ssid="60">One annotator suggested that this was the case for as much as 10% of our test sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'49'", "'140'", "'167'"]
'39'
'49'
'140'
'167'
['39', '49', '140', '167']
parsed_discourse_facet ['method_citation']
<S sid="48" ssid="14">Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="57" ssid="23">We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.</S><S sid="58" ssid="24">We divide up each test set into blocks of 20 sentences (100 blocks for the in-domain test set, 53 blocks for the out-of-domain test set), check for each block, if one system has a higher BLEU score than the other, and then use the sign test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'57'", "'58'"]
'48'
'49'
'57'
'58'
['48', '49', '57', '58']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S><S sid="122" ssid="15">While the Bootstrap method is slightly more sensitive, it is very much in line with the sign test on text blocks.</S><S sid="123" ssid="16">For the manual scoring, we can distinguish only half of the systems, both in terms of fluency and adequacy.</S><S sid="124" ssid="17">More judgements would have enabled us to make better distinctions, but it is not clear what the upper limit is.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'122'", "'123'", "'124'"]
'68'
'122'
'123'
'124'
['68', '122', '123', '124']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="14" ssid="7">There is twice as much language modelling data, since training data for the machine translation system is filtered against sentences of length larger than 40 words.</S><S sid="27" ssid="20">Microsoft&#8217;s approach uses dependency trees, others use hierarchical phrase models.</S><S sid="35" ssid="1">For the automatic evaluation, we used BLEU, since it is the most established metric in the field.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'14'", "'27'", "'35'"]
'13'
'14'
'27'
'35'
['13', '14', '27', '35']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S><S sid="139" ssid="32">Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'62'", "'139'", "'140'"]
'38'
'62'
'139'
'140'
['38', '62', '139', '140']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="58" ssid="24">We divide up each test set into blocks of 20 sentences (100 blocks for the in-domain test set, 53 blocks for the out-of-domain test set), check for each block, if one system has a higher BLEU score than the other, and then use the sign test.</S><S sid="106" ssid="22">Automatic scores are computed on a larger tested than manual scores (3064 sentences vs. 300&#8211;400 sentences). collected manual judgements, we do not necessarily have the same sentence judged for both systems (judges evaluate 5 systems out of the 8&#8211;10 participating systems).</S><S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'58'", "'106'", "'126'"]
'17'
'58'
'106'
'126'
['17', '58', '106', '126']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="9">The test data was again drawn from a segment of the Europarl corpus from the fourth quarter of 2000, which is excluded from the training data.</S><S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S><S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'17'", "'18'", "'126'"]
'16'
'17'
'18'
'126'
['16', '17', '18', '126']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'38'", "'64'", "'170'"]
'13'
'38'
'64'
'170'
['13', '38', '64', '170']
parsed_discourse_facet ['method_citation']
<S sid="63" ssid="2">Many human evaluation metrics have been proposed.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S><S sid="155" ssid="48">For instance, in the recent IWSLT evaluation, first fluency annotations were solicited (while withholding the source sentence), and then adequacy annotations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'63'", "'64'", "'68'", "'155'"]
'63'
'64'
'68'
'155'
['63', '64', '68', '155']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .</S><S sid="7" ssid="5">We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="65" ssid="4">The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'7'", "'64'", "'65'"]
'1'
'7'
'64'
'65'
['1', '7', '64', '65']
parsed_discourse_facet ['aim_citation']
dict_values(['We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.'])
dict_values(['Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.', 'Hence, we use the bootstrap resampling method described by Koehn (2004).', 'The bootstrap method has been critized by Riezler and Maxwell (2005) and Collins et al. (2005), as being too optimistic in deciding for statistical significant difference between systems.', 'We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:55', 'F:0']
dict_values(['The evaluation framework for the shared task is similar to the one used in last year&#8217;s shared task.'])
dict_values(['We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.', 'Most of these groups follow a phrase-based statistical approach to machine translation.', 'The other half was replaced by other participants, so we ended up with roughly the same number.', 'The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:666', 'P:45', 'F:0']
dict_values(['Training and testing is based on the Europarl corpus.'])
dict_values(['Training and testing is based on the Europarl corpus.', 'We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.', 'Out-of-domain test data is from the Project Syndicate web site, a compendium of political commentary.', 'In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01161', '(95%-conf.int.', '0.01161', '-', '0.01161)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.02296', '(95%-conf.int.', '0.02296', '-', '0.02296)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:10', 'F:10']
dict_values(['The BLEU metric, as all currently proposed automatic metrics, is occasionally suspected to be biased towards statistical systems, especially the phrase-based systems currently in use.'])
dict_values(['The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).', 'While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.', 'Another way to view the judgements is that they are less quality judgements of machine translation systems per se, but rankings of machine translation systems.', 'We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00694', '(95%-conf.int.', '0.00694', '-', '0.00694)']
['system', 'ROUGE-S*', 'Average_P:', '0.17949', '(95%-conf.int.', '0.17949', '-', '0.17949)']
['system', 'ROUGE-S*', 'Average_F:', '0.01337', '(95%-conf.int.', '0.01337', '-', '0.01337)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:78', 'F:14']
dict_values(['Training and testing is based on the Europarl corpus.'])
dict_values(['Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .', 'Training and testing is based on the Europarl corpus.', 'Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.', 'However, ince we extracted the test corpus automatically from web sources, the reference translation was not always accurate &#8212; due to sentence alignment errors, or because translators did not adhere to a strict sentence-by-sentence translation (say, using pronouns when referring to entities mentioned in the previous sentence).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00001', '(95%-conf.int.', '0.00001', '-', '0.00001)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00002', '(95%-conf.int.', '0.00002', '-', '0.00002)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1054878', 'P:10', 'F:10']
dict_values(['We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.'])
dict_values(['However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.', 'Hence, we use the bootstrap resampling method described by Koehn (2004).', 'We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.', 'One annotator suggested that this was the case for as much as 10% of our test sentences.'])
['system', 'ROUGE-S*', 'Average_R:', '0.14773', '(95%-conf.int.', '0.14773', '-', '0.14773)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.25743', '(95%-conf.int.', '0.25743', '-', '0.25743)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:528', 'P:78', 'F:78']
dict_values(['The human judges were presented with the following definition of adequacy and fluency, but no additional instructions:'])
dict_values(['We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.', 'While the Bootstrap method is slightly more sensitive, it is very much in line with the sign test on text blocks.', 'For the manual scoring, we can distinguish only half of the systems, both in terms of fluency and adequacy.', 'More judgements would have enabled us to make better distinctions, but it is not clear what the upper limit is.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00427', '(95%-conf.int.', '0.00427', '-', '0.00427)']
['system', 'ROUGE-S*', 'Average_P:', '0.10714', '(95%-conf.int.', '0.10714', '-', '0.10714)']
['system', 'ROUGE-S*', 'Average_F:', '0.00821', '(95%-conf.int.', '0.00821', '-', '0.00821)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:703', 'P:28', 'F:3']
dict_values(['To lower the barrier of entrance to the competition, we provided a complete baseline MT system, along with data resources.'])
dict_values(['We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.', 'There is twice as much language modelling data, since training data for the machine translation system is filtered against sentences of length larger than 40 words.', 'Microsoft&#8217;s approach uses dependency trees, others use hierarchical phrase models.', 'For the automatic evaluation, we used BLEU, since it is the most established metric in the field.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00366', '(95%-conf.int.', '0.00366', '-', '0.00366)']
['system', 'ROUGE-S*', 'Average_P:', '0.05455', '(95%-conf.int.', '0.05455', '-', '0.05455)']
['system', 'ROUGE-S*', 'Average_F:', '0.00686', '(95%-conf.int.', '0.00686', '-', '0.00686)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:55', 'F:3']
dict_values(['We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.'])
dict_values(['The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).', 'While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.', 'Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.', 'We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03325', '(95%-conf.int.', '0.03325', '-', '0.03325)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.06436', '(95%-conf.int.', '0.06436', '-', '0.06436)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:78', 'F:78']
dict_values(['Out-of-domain test data is from the Project Syndicate web site, a compendium of political commentary.'])
dict_values(['The test data was again drawn from a segment of the Europarl corpus from the fourth quarter of 2000, which is excluded from the training data.', 'Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.', 'In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.', 'The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00510', '(95%-conf.int.', '0.00510', '-', '0.00510)']
['system', 'ROUGE-S*', 'Average_P:', '0.13333', '(95%-conf.int.', '0.13333', '-', '0.13333)']
['system', 'ROUGE-S*', 'Average_F:', '0.00983', '(95%-conf.int.', '0.00983', '-', '0.00983)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:45', 'F:6']
dict_values(['The evaluation framework for the shared task is similar to the one used in last year&#8217;s shared task.'])
dict_values(['We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.', 'The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).', 'Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.', 'We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00169', '(95%-conf.int.', '0.00169', '-', '0.00169)']
['system', 'ROUGE-S*', 'Average_P:', '0.06667', '(95%-conf.int.', '0.06667', '-', '0.06667)']
['system', 'ROUGE-S*', 'Average_F:', '0.00331', '(95%-conf.int.', '0.00331', '-', '0.00331)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:45', 'F:3']
dict_values(['Another way to view the judgements is that they are less quality judgements of machine translation systems per se, but rankings of machine translation systems.'])
dict_values(['Many human evaluation metrics have been proposed.', 'Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.', 'We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.', 'For instance, in the recent IWSLT evaluation, first fluency annotations were solicited (while withholding the source sentence), and then adequacy annotations.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00245', '(95%-conf.int.', '0.00245', '-', '0.00245)']
['system', 'ROUGE-S*', 'Average_P:', '0.04545', '(95%-conf.int.', '0.04545', '-', '0.04545)']
['system', 'ROUGE-S*', 'Average_F:', '0.00465', '(95%-conf.int.', '0.00465', '-', '0.00465)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:66', 'F:3']
dict_values(['&#8226; We evaluated translation from English, in addition to into English.', 'English was again paired with German, French, and Spanish.'])
dict_values(['Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .', 'We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.', 'Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.', 'The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00003', '(95%-conf.int.', '0.00003', '-', '0.00003)']
['system', 'ROUGE-S*', 'Average_P:', '0.65455', '(95%-conf.int.', '0.65455', '-', '0.65455)']
['system', 'ROUGE-S*', 'Average_F:', '0.00007', '(95%-conf.int.', '0.00007', '-', '0.00007)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1053426', 'P:55', 'F:36']
0.4031676892064024 0.01667230756405917 0.030082307460905323





input/ref/Task1/W06-3114_swastika.csv
input/res/Task1/W06-3114.annv3.csv
parsing: input/ref/Task1/W06-3114_swastika.csv
<S sid="47" ssid="13">Because of this, we retokenized and lowercased submitted output with our own tokenizer, which was also used to prepare the training and test data.</S>
original cit marker offset is 0
new cit marker offset is 0



['47']
47
['47']
parsed_discourse_facet ['method_citation']
    <S sid="8" ssid="1">The evaluation framework for the shared task is similar to the one used in last year&#8217;s shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



['8']
8
['8']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



['18']
18
['18']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



['18']
18
['18']
parsed_discourse_facet ['method_citation']
<S sid="144" ssid="37">Our suspicion is that BLEU is very sensitive to jargon, to selecting exactly the right words, and not synonyms that human judges may appreciate as equally good.</S>
original cit marker offset is 0
new cit marker offset is 0



['144']
144
['144']
parsed_discourse_facet ['result_citation']
<S sid="145" ssid="38">This is can not be the only explanation, since the discrepancy still holds, for instance, for out-of-domain French-English, where Systran receives among the best adequacy and fluency scores, but a worse BLEU score than all but one statistical system.</S>
original cit marker offset is 0
new cit marker offset is 0



['145']
145
['145']
parsed_discourse_facet ['result_citation']
    <S sid="103" ssid="19">Given a set of n sentences, we can compute the sample mean x&#65533; and sample variance s2 of the individual sentence judgements xi: The extend of the confidence interval [x&#8722;d, x+df can be computed by d = 1.96 &#183;&#65533;n (6) Pairwise Comparison: As for the automatic evaluation metric, we want to be able to rank different systems against each other, for which we need assessments of statistical significance on the differences between a pair of systems.</S>
original cit marker offset is 0
new cit marker offset is 0



['103']
103
['103']
parsed_discourse_facet ['method_citation']
<S sid="50" ssid="16">Following this method, we repeatedly &#8212; say, 1000 times &#8212; sample sets of sentences from the output of each system, measure their BLEU score, and use these 1000 BLEU scores as basis for estimating a confidence interval.</S>
original cit marker offset is 0
new cit marker offset is 0



['50']
50
['50']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S>
original cit marker offset is 0
new cit marker offset is 0



['68']
68
['68']
parsed_discourse_facet ['method_citation']
<S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



['170']
170
['170']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



['18']
18
['18']
parsed_discourse_facet ['method_citation']
<S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



['170']
170
['170']
parsed_discourse_facet ['method_citation']
<S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



['170']
170
['170']
parsed_discourse_facet ['method_citation']
<S sid="92" ssid="8">The way judgements are collected, human judges tend to use the scores to rank systems against each other.</S>
original cit marker offset is 0
new cit marker offset is 0



['92']
92
['92']
parsed_discourse_facet ['result_citation']
<S sid="145" ssid="38">This is can not be the only explanation, since the discrepancy still holds, for instance, for out-of-domain French-English, where Systran receives among the best adequacy and fluency scores, but a worse BLEU score than all but one statistical system.</S>
original cit marker offset is 0
new cit marker offset is 0



['145']
145
['145']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W06-3114.annv3.csv
<S sid="48" ssid="14">Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="56" ssid="22">The bootstrap method has been critized by Riezler and Maxwell (2005) and Collins et al. (2005), as being too optimistic in deciding for statistical significant difference between systems.</S><S sid="57" ssid="23">We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'56'", "'57'"]
'48'
'49'
'56'
'57'
['48', '49', '56', '57']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="5">We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.</S><S sid="26" ssid="19">Most of these groups follow a phrase-based statistical approach to machine translation.</S><S sid="30" ssid="23">The other half was replaced by other participants, so we ended up with roughly the same number.</S><S sid="65" ssid="4">The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'26'", "'30'", "'65'"]
'7'
'26'
'30'
'65'
['7', '26', '30', '65']
parsed_discourse_facet ['hypothesis_citation']
<S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S><S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="15" ssid="8">Out-of-domain test data is from the Project Syndicate web site, a compendium of political commentary.</S><S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'13'", "'15'", "'18'"]
'9'
'13'
'15'
'18'
['9', '13', '15', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S><S sid="90" ssid="6">Another way to view the judgements is that they are less quality judgements of machine translation systems per se, but rankings of machine translation systems.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'62'", "'90'", "'140'"]
'38'
'62'
'90'
'140'
['38', '62', '90', '140']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .</S><S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S><S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="165" ssid="58">However, ince we extracted the test corpus automatically from web sources, the reference translation was not always accurate &#8212; due to sentence alignment errors, or because translators did not adhere to a strict sentence-by-sentence translation (say, using pronouns when referring to entities mentioned in the previous sentence).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'17'", "'165'"]
'1'
'9'
'17'
'165'
['1', '9', '17', '165']
parsed_discourse_facet ['results_citation']
<S sid="37" ssid="3">It rewards matches of n-gram sequences, but measures only at most indirectly overall grammatical coherence.</S><S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'64'", "'140'"]
'37'
'39'
'64'
'140'
['37', '39', '64', '140']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="3">It rewards matches of n-gram sequences, but measures only at most indirectly overall grammatical coherence.</S><S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="139" ssid="32">Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'139'", "'140'"]
'37'
'39'
'139'
'140'
['37', '39', '139', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="47" ssid="13">Because of this, we retokenized and lowercased submitted output with our own tokenizer, which was also used to prepare the training and test data.</S><S sid="83" ssid="22">The number of judgements is additionally fragmented by our breakup of sentences into in-domain and out-of-domain.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'47'", "'83'", "'140'"]
'39'
'47'
'83'
'140'
['39', '47', '83', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S><S sid="167" ssid="60">One annotator suggested that this was the case for as much as 10% of our test sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'49'", "'140'", "'167'"]
'39'
'49'
'140'
'167'
['39', '49', '140', '167']
parsed_discourse_facet ['method_citation']
<S sid="48" ssid="14">Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="57" ssid="23">We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.</S><S sid="58" ssid="24">We divide up each test set into blocks of 20 sentences (100 blocks for the in-domain test set, 53 blocks for the out-of-domain test set), check for each block, if one system has a higher BLEU score than the other, and then use the sign test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'57'", "'58'"]
'48'
'49'
'57'
'58'
['48', '49', '57', '58']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S><S sid="122" ssid="15">While the Bootstrap method is slightly more sensitive, it is very much in line with the sign test on text blocks.</S><S sid="123" ssid="16">For the manual scoring, we can distinguish only half of the systems, both in terms of fluency and adequacy.</S><S sid="124" ssid="17">More judgements would have enabled us to make better distinctions, but it is not clear what the upper limit is.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'122'", "'123'", "'124'"]
'68'
'122'
'123'
'124'
['68', '122', '123', '124']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="14" ssid="7">There is twice as much language modelling data, since training data for the machine translation system is filtered against sentences of length larger than 40 words.</S><S sid="27" ssid="20">Microsoft&#8217;s approach uses dependency trees, others use hierarchical phrase models.</S><S sid="35" ssid="1">For the automatic evaluation, we used BLEU, since it is the most established metric in the field.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'14'", "'27'", "'35'"]
'13'
'14'
'27'
'35'
['13', '14', '27', '35']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S><S sid="139" ssid="32">Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'62'", "'139'", "'140'"]
'38'
'62'
'139'
'140'
['38', '62', '139', '140']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="58" ssid="24">We divide up each test set into blocks of 20 sentences (100 blocks for the in-domain test set, 53 blocks for the out-of-domain test set), check for each block, if one system has a higher BLEU score than the other, and then use the sign test.</S><S sid="106" ssid="22">Automatic scores are computed on a larger tested than manual scores (3064 sentences vs. 300&#8211;400 sentences). collected manual judgements, we do not necessarily have the same sentence judged for both systems (judges evaluate 5 systems out of the 8&#8211;10 participating systems).</S><S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'58'", "'106'", "'126'"]
'17'
'58'
'106'
'126'
['17', '58', '106', '126']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="9">The test data was again drawn from a segment of the Europarl corpus from the fourth quarter of 2000, which is excluded from the training data.</S><S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S><S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'17'", "'18'", "'126'"]
'16'
'17'
'18'
'126'
['16', '17', '18', '126']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'38'", "'64'", "'170'"]
'13'
'38'
'64'
'170'
['13', '38', '64', '170']
parsed_discourse_facet ['method_citation']
<S sid="63" ssid="2">Many human evaluation metrics have been proposed.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S><S sid="155" ssid="48">For instance, in the recent IWSLT evaluation, first fluency annotations were solicited (while withholding the source sentence), and then adequacy annotations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'63'", "'64'", "'68'", "'155'"]
'63'
'64'
'68'
'155'
['63', '64', '68', '155']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .</S><S sid="7" ssid="5">We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="65" ssid="4">The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'7'", "'64'", "'65'"]
'1'
'7'
'64'
'65'
['1', '7', '64', '65']
parsed_discourse_facet ['aim_citation']
dict_values(['Because of this, we retokenized and lowercased submitted output with our own tokenizer, which was also used to prepare the training and test data.'])
dict_values(['Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.', 'Hence, we use the bootstrap resampling method described by Koehn (2004).', 'The bootstrap method has been critized by Riezler and Maxwell (2005) and Collins et al. (2005), as being too optimistic in deciding for statistical significant difference between systems.', 'We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:36', 'F:0']
dict_values(['The evaluation framework for the shared task is similar to the one used in last year&#8217;s shared task.'])
dict_values(['We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.', 'Most of these groups follow a phrase-based statistical approach to machine translation.', 'The other half was replaced by other participants, so we ended up with roughly the same number.', 'The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:666', 'P:45', 'F:0']
dict_values(['In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.'])
dict_values(['Training and testing is based on the Europarl corpus.', 'We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.', 'Out-of-domain test data is from the Project Syndicate web site, a compendium of political commentary.', 'In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.'])
['system', 'ROUGE-S*', 'Average_R:', '0.10569', '(95%-conf.int.', '0.10569', '-', '0.10569)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.19118', '(95%-conf.int.', '0.19118', '-', '0.19118)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:91', 'F:91']
dict_values(['In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.'])
dict_values(['Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .', 'Training and testing is based on the Europarl corpus.', 'Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.', 'However, ince we extracted the test corpus automatically from web sources, the reference translation was not always accurate &#8212; due to sentence alignment errors, or because translators did not adhere to a strict sentence-by-sentence translation (say, using pronouns when referring to entities mentioned in the previous sentence).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.04396', '(95%-conf.int.', '0.04396', '-', '0.04396)']
['system', 'ROUGE-S*', 'Average_F:', '0.00001', '(95%-conf.int.', '0.00001', '-', '0.00001)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1054878', 'P:91', 'F:4']
dict_values(['Given a set of n sentences, we can compute the sample mean x&#65533; and sample variance s2 of the individual sentence judgements xi: The extend of the confidence interval [x&#8722;d, x+df can be computed by d = 1.96 &#183;&#65533;n (6) Pairwise Comparison: As for the automatic evaluation metric, we want to be able to rank different systems against each other, for which we need assessments of statistical significance on the differences between a pair of systems.'])
dict_values(['However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.', 'Hence, we use the bootstrap resampling method described by Koehn (2004).', 'We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.', 'One annotator suggested that this was the case for as much as 10% of our test sentences.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:528', 'P:630', 'F:0']
dict_values(['We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.'])
dict_values(['We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.', 'While the Bootstrap method is slightly more sensitive, it is very much in line with the sign test on text blocks.', 'For the manual scoring, we can distinguish only half of the systems, both in terms of fluency and adequacy.', 'More judgements would have enabled us to make better distinctions, but it is not clear what the upper limit is.'])
['system', 'ROUGE-S*', 'Average_R:', '0.12945', '(95%-conf.int.', '0.12945', '-', '0.12945)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.22922', '(95%-conf.int.', '0.22922', '-', '0.22922)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:703', 'P:91', 'F:91']
dict_values(['We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.'])
dict_values(['We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.', 'There is twice as much language modelling data, since training data for the machine translation system is filtered against sentences of length larger than 40 words.', 'Microsoft&#8217;s approach uses dependency trees, others use hierarchical phrase models.', 'For the automatic evaluation, we used BLEU, since it is the most established metric in the field.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00244', '(95%-conf.int.', '0.00244', '-', '0.00244)']
['system', 'ROUGE-S*', 'Average_P:', '0.03636', '(95%-conf.int.', '0.03636', '-', '0.03636)']
['system', 'ROUGE-S*', 'Average_F:', '0.00457', '(95%-conf.int.', '0.00457', '-', '0.00457)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:55', 'F:2']
dict_values(['We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.'])
dict_values(['The test data was again drawn from a segment of the Europarl corpus from the fourth quarter of 2000, which is excluded from the training data.', 'Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.', 'In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.', 'The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:55', 'F:0']
dict_values(['We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.'])
dict_values(['We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.', 'The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).', 'Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.', 'We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03107', '(95%-conf.int.', '0.03107', '-', '0.03107)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.06027', '(95%-conf.int.', '0.06027', '-', '0.06027)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:55', 'F:55']
dict_values(['The way judgements are collected, human judges tend to use the scores to rank systems against each other.'])
dict_values(['Many human evaluation metrics have been proposed.', 'Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.', 'We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.', 'For instance, in the recent IWSLT evaluation, first fluency annotations were solicited (while withholding the source sentence), and then adequacy annotations.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00082', '(95%-conf.int.', '0.00082', '-', '0.00082)']
['system', 'ROUGE-S*', 'Average_P:', '0.03571', '(95%-conf.int.', '0.03571', '-', '0.03571)']
['system', 'ROUGE-S*', 'Average_F:', '0.00160', '(95%-conf.int.', '0.00160', '-', '0.00160)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:28', 'F:1']
dict_values(['This is can not be the only explanation, since the discrepancy still holds, for instance, for out-of-domain French-English, where Systran receives among the best adequacy and fluency scores, but a worse BLEU score than all but one statistical system.'])
dict_values(['Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .', 'We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.', 'Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.', 'The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00003', '(95%-conf.int.', '0.00003', '-', '0.00003)']
['system', 'ROUGE-S*', 'Average_P:', '0.25735', '(95%-conf.int.', '0.25735', '-', '0.25735)']
['system', 'ROUGE-S*', 'Average_F:', '0.00007', '(95%-conf.int.', '0.00007', '-', '0.00007)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1053426', 'P:136', 'F:35']
0.3066709063029918 0.024499999777272727 0.04426545414304133





input/ref/Task1/W06-3114_sweta.csv
input/res/Task1/W06-3114.annv3.csv
parsing: input/ref/Task1/W06-3114_sweta.csv
 <S sid="108" ssid="1">The results of the manual and automatic evaluation of the participating system translations is detailed in the figures at the end of this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["108'"]
108'
['108']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="27">For more on the participating systems, please refer to the respective system description in the proceedings of the workshop.</S>
original cit marker offset is 0
new cit marker offset is 0



["34'"]
34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["18'"]
18'
['18']
parsed_discourse_facet ['method_citation']
 <S sid="151" ssid="44">The statistical systems seem to still lag behind the commercial rule-based competition when translating into morphological rich languages, as demonstrated by the results for English-German and English-French.</S>
original cit marker offset is 0
new cit marker offset is 0



["151'"]
151'
['151']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="9">The test data was again drawn from a segment of the Europarl corpus from the fourth quarter of 2000, which is excluded from the training data.</S>
original cit marker offset is 0
new cit marker offset is 0



["16'"]
16'
['16']
parsed_discourse_facet ['method_citation']
 <S sid="172" ssid="3">Due to many similarly performing systems, we are not able to draw strong conclusions on the question of correlation of manual and automatic evaluation metrics.</S>
original cit marker offset is 0
new cit marker offset is 0



["172'"]
172'
['172']
parsed_discourse_facet ['method_citation']
 <S sid="36" ssid="2">The BLEU metric, as all currently proposed automatic metrics, is occasionally suspected to be biased towards statistical systems, especially the phrase-based systems currently in use.</S>
original cit marker offset is 0
new cit marker offset is 0



["36'"]
36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="103" ssid="19">Given a set of n sentences, we can compute the sample mean x&#65533; and sample variance s2 of the individual sentence judgements xi: The extend of the confidence interval [x&#8722;d, x+df can be computed by d = 1.96 &#183;&#65533;n (6) Pairwise Comparison: As for the automatic evaluation metric, we want to be able to rank different systems against each other, for which we need assessments of statistical significance on the differences between a pair of systems.</S>
original cit marker offset is 0
new cit marker offset is 0



["103'"]
103'
['103']
parsed_discourse_facet ['method_citation']
<S sid="167" ssid="60">One annotator suggested that this was the case for as much as 10% of our test sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["167'"]
167'
['167']
parsed_discourse_facet ['method_citation']
<S sid="102" ssid="18">Confidence Interval: To estimate confidence intervals for the average mean scores for the systems, we use standard significance testing.</S>
original cit marker offset is 0
new cit marker offset is 0



["102'"]
102'
['102']
parsed_discourse_facet ['method_citation']
<S sid="123" ssid="16">For the manual scoring, we can distinguish only half of the systems, both in terms of fluency and adequacy.</S>
original cit marker offset is 0
new cit marker offset is 0



["123'"]
123'
['123']
parsed_discourse_facet ['method_citation']
<S sid="34" ssid="27">For more on the participating systems, please refer to the respective system description in the proceedings of the workshop.</S>
original cit marker offset is 0
new cit marker offset is 0



["34'"]
34'
['34']
parsed_discourse_facet ['method_citation']
<S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S>
original cit marker offset is 0
new cit marker offset is 0



["62'"]
62'
['62']
parsed_discourse_facet ['method_citation']
<S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["126'"]
126'
['126']
parsed_discourse_facet ['method_citation']
<S sid="173" ssid="4">The bias of automatic methods in favor of statistical systems seems to be less pronounced on out-of-domain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["173'"]
173'
['173']
parsed_discourse_facet ['method_citation']
 <S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["170'"]
170'
['170']
parsed_discourse_facet ['method_citation']
<S sid="84" ssid="23">The human judges were presented with the following definition of adequacy and fluency, but no additional instructions:</S>
original cit marker offset is 0
new cit marker offset is 0



["84'"]
84'
['84']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="1">The evaluation framework for the shared task is similar to the one used in last year&#8217;s shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["8'"]
8'
['8']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W06-3114.annv3.csv
<S sid="48" ssid="14">Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="56" ssid="22">The bootstrap method has been critized by Riezler and Maxwell (2005) and Collins et al. (2005), as being too optimistic in deciding for statistical significant difference between systems.</S><S sid="57" ssid="23">We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'56'", "'57'"]
'48'
'49'
'56'
'57'
['48', '49', '56', '57']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="5">We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.</S><S sid="26" ssid="19">Most of these groups follow a phrase-based statistical approach to machine translation.</S><S sid="30" ssid="23">The other half was replaced by other participants, so we ended up with roughly the same number.</S><S sid="65" ssid="4">The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'26'", "'30'", "'65'"]
'7'
'26'
'30'
'65'
['7', '26', '30', '65']
parsed_discourse_facet ['hypothesis_citation']
<S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S><S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="15" ssid="8">Out-of-domain test data is from the Project Syndicate web site, a compendium of political commentary.</S><S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'13'", "'15'", "'18'"]
'9'
'13'
'15'
'18'
['9', '13', '15', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S><S sid="90" ssid="6">Another way to view the judgements is that they are less quality judgements of machine translation systems per se, but rankings of machine translation systems.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'62'", "'90'", "'140'"]
'38'
'62'
'90'
'140'
['38', '62', '90', '140']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .</S><S sid="9" ssid="2">Training and testing is based on the Europarl corpus.</S><S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="165" ssid="58">However, ince we extracted the test corpus automatically from web sources, the reference translation was not always accurate &#8212; due to sentence alignment errors, or because translators did not adhere to a strict sentence-by-sentence translation (say, using pronouns when referring to entities mentioned in the previous sentence).</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'17'", "'165'"]
'1'
'9'
'17'
'165'
['1', '9', '17', '165']
parsed_discourse_facet ['results_citation']
<S sid="37" ssid="3">It rewards matches of n-gram sequences, but measures only at most indirectly overall grammatical coherence.</S><S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'64'", "'140'"]
'37'
'39'
'64'
'140'
['37', '39', '64', '140']
parsed_discourse_facet ['method_citation']
<S sid="37" ssid="3">It rewards matches of n-gram sequences, but measures only at most indirectly overall grammatical coherence.</S><S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="139" ssid="32">Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'37'", "'39'", "'139'", "'140'"]
'37'
'39'
'139'
'140'
['37', '39', '139', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="47" ssid="13">Because of this, we retokenized and lowercased submitted output with our own tokenizer, which was also used to prepare the training and test data.</S><S sid="83" ssid="22">The number of judgements is additionally fragmented by our breakup of sentences into in-domain and out-of-domain.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'47'", "'83'", "'140'"]
'39'
'47'
'83'
'140'
['39', '47', '83', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="5">However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S><S sid="167" ssid="60">One annotator suggested that this was the case for as much as 10% of our test sentences.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'49'", "'140'", "'167'"]
'39'
'49'
'140'
'167'
['39', '49', '140', '167']
parsed_discourse_facet ['method_citation']
<S sid="48" ssid="14">Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.</S><S sid="49" ssid="15">Hence, we use the bootstrap resampling method described by Koehn (2004).</S><S sid="57" ssid="23">We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.</S><S sid="58" ssid="24">We divide up each test set into blocks of 20 sentences (100 blocks for the in-domain test set, 53 blocks for the out-of-domain test set), check for each block, if one system has a higher BLEU score than the other, and then use the sign test.</S>
original cit marker offset is 0
new cit marker offset is 0



["'48'", "'49'", "'57'", "'58'"]
'48'
'49'
'57'
'58'
['48', '49', '57', '58']
parsed_discourse_facet ['method_citation']
<S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S><S sid="122" ssid="15">While the Bootstrap method is slightly more sensitive, it is very much in line with the sign test on text blocks.</S><S sid="123" ssid="16">For the manual scoring, we can distinguish only half of the systems, both in terms of fluency and adequacy.</S><S sid="124" ssid="17">More judgements would have enabled us to make better distinctions, but it is not clear what the upper limit is.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'122'", "'123'", "'124'"]
'68'
'122'
'123'
'124'
['68', '122', '123', '124']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="14" ssid="7">There is twice as much language modelling data, since training data for the machine translation system is filtered against sentences of length larger than 40 words.</S><S sid="27" ssid="20">Microsoft&#8217;s approach uses dependency trees, others use hierarchical phrase models.</S><S sid="35" ssid="1">For the automatic evaluation, we used BLEU, since it is the most established metric in the field.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'14'", "'27'", "'35'"]
'13'
'14'
'27'
'35'
['13', '14', '27', '35']
parsed_discourse_facet ['method_citation']
<S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="62" ssid="1">While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.</S><S sid="139" ssid="32">Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.</S><S sid="140" ssid="33">We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'", "'62'", "'139'", "'140'"]
'38'
'62'
'139'
'140'
['38', '62', '139', '140']
parsed_discourse_facet ['method_citation']
<S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="58" ssid="24">We divide up each test set into blocks of 20 sentences (100 blocks for the in-domain test set, 53 blocks for the out-of-domain test set), check for each block, if one system has a higher BLEU score than the other, and then use the sign test.</S><S sid="106" ssid="22">Automatic scores are computed on a larger tested than manual scores (3064 sentences vs. 300&#8211;400 sentences). collected manual judgements, we do not necessarily have the same sentence judged for both systems (judges evaluate 5 systems out of the 8&#8211;10 participating systems).</S><S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'17'", "'58'", "'106'", "'126'"]
'17'
'58'
'106'
'126'
['17', '58', '106', '126']
parsed_discourse_facet ['method_citation']
<S sid="16" ssid="9">The test data was again drawn from a segment of the Europarl corpus from the fourth quarter of 2000, which is excluded from the training data.</S><S sid="17" ssid="10">Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.</S><S sid="18" ssid="11">In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.</S><S sid="126" ssid="19">The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'17'", "'18'", "'126'"]
'16'
'17'
'18'
'126'
['16', '17', '18', '126']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="6">We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.</S><S sid="38" ssid="4">The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="170" ssid="1">We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'38'", "'64'", "'170'"]
'13'
'38'
'64'
'170'
['13', '38', '64', '170']
parsed_discourse_facet ['method_citation']
<S sid="63" ssid="2">Many human evaluation metrics have been proposed.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="68" ssid="7">We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.</S><S sid="155" ssid="48">For instance, in the recent IWSLT evaluation, first fluency annotations were solicited (while withholding the source sentence), and then adequacy annotations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'63'", "'64'", "'68'", "'155'"]
'63'
'64'
'68'
'155'
['63', '64', '68', '155']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .</S><S sid="7" ssid="5">We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.</S><S sid="64" ssid="3">Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.</S><S sid="65" ssid="4">The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'7'", "'64'", "'65'"]
'1'
'7'
'64'
'65'
['1', '7', '64', '65']
parsed_discourse_facet ['aim_citation']
dict_values(['The results of the manual and automatic evaluation of the participating system translations is detailed in the figures at the end of this paper.'])
dict_values(['Confidence Interval: Since BLEU scores are not computed on the sentence level, traditional methods to compute statistical significance and confidence intervals do not apply.', 'Hence, we use the bootstrap resampling method described by Koehn (2004).', 'The bootstrap method has been critized by Riezler and Maxwell (2005) and Collins et al. (2005), as being too optimistic in deciding for statistical significant difference between systems.', 'We are therefore applying a different method, which has been used at the 2005 DARPA/NIST evaluation.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:55', 'F:0']
dict_values(['For more on the participating systems, please refer to the respective system description in the proceedings of the workshop.'])
dict_values(['We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.', 'Most of these groups follow a phrase-based statistical approach to machine translation.', 'The other half was replaced by other participants, so we ended up with roughly the same number.', 'The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:666', 'P:28', 'F:0']
dict_values(['In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.'])
dict_values(['Training and testing is based on the Europarl corpus.', 'We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.', 'Out-of-domain test data is from the Project Syndicate web site, a compendium of political commentary.', 'In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.'])
['system', 'ROUGE-S*', 'Average_R:', '0.10569', '(95%-conf.int.', '0.10569', '-', '0.10569)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.19118', '(95%-conf.int.', '0.19118', '-', '0.19118)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:91', 'F:91']
dict_values(['The statistical systems seem to still lag behind the commercial rule-based competition when translating into morphological rich languages, as demonstrated by the results for English-German and English-French.'])
dict_values(['The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).', 'While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.', 'Another way to view the judgements is that they are less quality judgements of machine translation systems per se, but rankings of machine translation systems.', 'We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00397', '(95%-conf.int.', '0.00397', '-', '0.00397)']
['system', 'ROUGE-S*', 'Average_P:', '0.05882', '(95%-conf.int.', '0.05882', '-', '0.05882)']
['system', 'ROUGE-S*', 'Average_F:', '0.00743', '(95%-conf.int.', '0.00743', '-', '0.00743)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:136', 'F:8']
dict_values(['The test data was again drawn from a segment of the Europarl corpus from the fourth quarter of 2000, which is excluded from the training data.'])
dict_values(['Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .', 'Training and testing is based on the Europarl corpus.', 'Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.', 'However, ince we extracted the test corpus automatically from web sources, the reference translation was not always accurate &#8212; due to sentence alignment errors, or because translators did not adhere to a strict sentence-by-sentence translation (say, using pronouns when referring to entities mentioned in the previous sentence).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00001', '(95%-conf.int.', '0.00001', '-', '0.00001)']
['system', 'ROUGE-S*', 'Average_P:', '0.15152', '(95%-conf.int.', '0.15152', '-', '0.15152)']
['system', 'ROUGE-S*', 'Average_F:', '0.00002', '(95%-conf.int.', '0.00002', '-', '0.00002)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1054878', 'P:66', 'F:10']
dict_values(['One annotator suggested that this was the case for as much as 10% of our test sentences.'])
dict_values(['However, a recent study (Callison-Burch et al., 2006), pointed out that this correlation may not always be strong.', 'Hence, we use the bootstrap resampling method described by Koehn (2004).', 'We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.', 'One annotator suggested that this was the case for as much as 10% of our test sentences.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02841', '(95%-conf.int.', '0.02841', '-', '0.02841)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.05525', '(95%-conf.int.', '0.05525', '-', '0.05525)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:528', 'P:15', 'F:15']
dict_values(['For the manual scoring, we can distinguish only half of the systems, both in terms of fluency and adequacy.'])
dict_values(['We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.', 'While the Bootstrap method is slightly more sensitive, it is very much in line with the sign test on text blocks.', 'For the manual scoring, we can distinguish only half of the systems, both in terms of fluency and adequacy.', 'More judgements would have enabled us to make better distinctions, but it is not clear what the upper limit is.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03983', '(95%-conf.int.', '0.03983', '-', '0.03983)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.07661', '(95%-conf.int.', '0.07661', '-', '0.07661)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:703', 'P:28', 'F:28']
dict_values(['For more on the participating systems, please refer to the respective system description in the proceedings of the workshop.'])
dict_values(['We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.', 'There is twice as much language modelling data, since training data for the machine translation system is filtered against sentences of length larger than 40 words.', 'Microsoft&#8217;s approach uses dependency trees, others use hierarchical phrase models.', 'For the automatic evaluation, we used BLEU, since it is the most established metric in the field.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00122', '(95%-conf.int.', '0.00122', '-', '0.00122)']
['system', 'ROUGE-S*', 'Average_P:', '0.03571', '(95%-conf.int.', '0.03571', '-', '0.03571)']
['system', 'ROUGE-S*', 'Average_F:', '0.00236', '(95%-conf.int.', '0.00236', '-', '0.00236)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:28', 'F:1']
dict_values(['While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.'])
dict_values(['The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).', 'While automatic measures are an invaluable tool for the day-to-day development of machine translation systems, they are only a imperfect substitute for human assessment of translation quality, or as the acronym BLEU puts it, a bilingual evaluation understudy.', 'Given the closeness of most systems and the wide over-lapping confidence intervals it is hard to make strong statements about the correlation between human judgements and automatic scoring methods such as BLEU.', 'We confirm the finding by Callison-Burch et al. (2006) that the rule-based system of Systran is not adequately appreciated by BLEU.'])
['system', 'ROUGE-S*', 'Average_R:', '0.09847', '(95%-conf.int.', '0.09847', '-', '0.09847)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.17928', '(95%-conf.int.', '0.17928', '-', '0.17928)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2346', 'P:231', 'F:231']
dict_values(['The bias of automatic methods in favor of statistical systems seems to be less pronounced on out-of-domain test data.'])
dict_values(['The test data was again drawn from a segment of the Europarl corpus from the fourth quarter of 2000, which is excluded from the training data.', 'Participants were also provided with two sets of 2,000 sentences of parallel text to be used for system development and tuning.', 'In addition to the Europarl test set, we also collected 29 editorials from the Project Syndicate website2, which are published in all the four languages of the shared task.', 'The test set included 2000 sentences from the Europarl corpus, but also 1064 sentences out-ofdomain test data.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00255', '(95%-conf.int.', '0.00255', '-', '0.00255)']
['system', 'ROUGE-S*', 'Average_P:', '0.06667', '(95%-conf.int.', '0.06667', '-', '0.06667)']
['system', 'ROUGE-S*', 'Average_F:', '0.00491', '(95%-conf.int.', '0.00491', '-', '0.00491)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:45', 'F:3']
dict_values(['We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.'])
dict_values(['We are currently working on a complete open source implementation of a training and decoding system, which should become available over the summer. pus, from which also the in-domain test set is taken.', 'The BLEU score has been shown to correlate well with human judgement, when statistical machine translation systems are compared (Doddington, 2002; Przybocki, 2004; Li, 2005).', 'Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.', 'We carried out an extensive manual and automatic evaluation of machine translation performance on European language pairs.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03107', '(95%-conf.int.', '0.03107', '-', '0.03107)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.06027', '(95%-conf.int.', '0.06027', '-', '0.06027)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1770', 'P:55', 'F:55']
dict_values(['The human judges were presented with the following definition of adequacy and fluency, but no additional instructions:'])
dict_values(['Many human evaluation metrics have been proposed.', 'Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.', 'We asked participants to each judge 200&#8211;300 sentences in terms of fluency and adequacy, the most commonly used manual evaluation metrics.', 'For instance, in the recent IWSLT evaluation, first fluency annotations were solicited (while withholding the source sentence), and then adequacy annotations.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00490', '(95%-conf.int.', '0.00490', '-', '0.00490)']
['system', 'ROUGE-S*', 'Average_P:', '0.21429', '(95%-conf.int.', '0.21429', '-', '0.21429)']
['system', 'ROUGE-S*', 'Average_F:', '0.00958', '(95%-conf.int.', '0.00958', '-', '0.00958)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:28', 'F:6']
dict_values(['The evaluation framework for the shared task is similar to the one used in last year&#8217;s shared task.'])
dict_values(['Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-8) (1-6) lcc (1-6) (1-7) (1-4) utd (1-7) (1-6) (2-7) upc-mr (1-8) (1-6) (1-7) nrc (1-7) (2-6) (8) ntt (1-8) (2-8) (1-7) cmu (3-7) (4-8) (2-7) rali (5-8) (3-9) (3-7) systran (9) (8-9) (10) upv (10) (10) (9) Spanish-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-7) (1-6) (1-5) ntt (1-7) (1-8) (1-5) lcc (1-8) (2-8) (1-4) utd (1-8) (2-7) (1-5) nrc (2-8) (1-9) (6) upc-mr (1-8) (1-6) (7) uedin-birch (1-8) (2-10) (8) rali (3-9) (3-9) (2-5) upc-jg (7-9) (6-9) (9) upv (10) (9-10) (10) German-English (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) uedin-phi (1-2) (1) (1) lcc (2-7) (2-7) (2) nrc (2-7) (2-6) (5-7) utd (3-7) (2-8) (3-4) ntt (2-9) (2-8) (3-4) upc-mr (3-9) (6-9) (8) rali (4-9) (3-9) (5-7) upc-jmc (2-9) (3-9) (5-7) systran (3-9) (3-9) (10) upv (10) (10) (9) Figure 7: Evaluation of translation to English on in-domain test data 112 English-French (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) nrc (1-5) (1-5) (1-6) upc-mr (1-4) (1-5) (1-6) upc-jmc (1-6) (1-6) (1-5) systran (2-7) (1-6) (7) utd (3-7) (3-7) (3-6) rali (1-7) (2-7) (1-6) ntt (4-7) (4-7) (1-5) English-Spanish (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) ms (1-5) (1-7) (7-8) upc-mr (1-4) (1-5) (1-4) utd (1-5) (1-6) (1-4) nrc (2-7) (1-6) (5-6) ntt (3-7) (1-6) (1-4) upc-jmc (2-7) (2-7) (1-4) rali (5-8) (6-8) (5-6) uedin-birch (6-9) (6-10) (7-8) upc-jg (9) (8-10) (9) upv (9-10) (8-10) (10) English-German (In Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-5) (3-5) ntt (1-5) (2-6) (1-3) upc-jmc (1-5) (1-4) (1-3) nrc (2-4) (1-5) (4-5) rali (3-6) (2-6) (1-4) systran (5-6) (3-6) (7) upv (7) (7) (6) Figure 8: Evaluation of translation from English on in-domain test data 113 French-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-5) (1-8) (1-4) cmu (1-8) (1-9) (4-7) systran (1-8) (1-7) (9) lcc (1-9) (1-9) (1-5) upc-mr (2-8) (1-7) (1-3) utd (1-9) (1-8) (3-7) ntt (3-9) (1-9) (3-7) nrc (3-8) (3-9) (3-7) rali (4-9) (5-9) (8) upv (10) (10) (10) Spanish-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-jmc (1-2) (1-6) (1-3) uedin-birch (1-7) (1-6) (5-8) nrc (2-8) (1-8) (5-7) ntt (2-7) (2-6) (3-4) upc-mr (2-8) (1-7) (5-8) lcc (4-9) (3-7) (1-4) utd (2-9) (2-8) (1-3) upc-jg (4-9) (7-9) (9) rali (4-9) (6-9) (6-8) upv (10) (10) (10) German-English (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1-4) (1-4) (7-9) uedin-phi (1-6) (1-7) (1) lcc (1-6) (1-7) (2-3) utd (2-7) (2-6) (4-6) ntt (1-9) (1-7) (3-5) nrc (3-8) (2-8) (7-8) upc-mr (4-8) (6-8) (4-6) upc-jmc (4-8) (3-9) (2-5) rali (8-9) (8-9) (8-9) upv (10) (10) (10) Figure 9: Evaluation of translation to English on out-of-domain test data 114 English-French (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1) (1) upc-jmc (2-5) (2-4) (2-6) upc-mr (2-4) (2-4) (2-6) utd (2-6) (2-6) (7) rali (4-7) (5-7) (2-6) nrc (4-7) (4-7) (2-5) ntt (4-7) (4-7) (3-6) English-Spanish (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) upc-mr (1-3) (1-6) (1-2) ms (1-7) (1-8) (6-7) utd (2-6) (1-7) (3-5) nrc (1-6) (2-7) (3-5) upc-jmc (2-7) (1-6) (3-5) ntt (2-7) (1-7) (1-2) rali (6-8) (4-8) (6-8) uedin-birch (6-10) (5-9) (7-8) upc-jg (8-9) (9-10) (9) upv (9) (8-9) (10) English-German (Out of Domain) Adequacy (rank) Fluency (rank) BLEU (rank) systran (1) (1-2) (1-6) upc-mr (2-3) (1-3) (1-5) upc-jmc (2-3) (3-6) (1-6) rali (4-6) (4-6) (1-6) nrc (4-6) (2-6) (2-6) ntt (4-6) (3-5) (1-6) upv (7) (7) (7) Figure 10: Evaluation of translation from English on out-of-domain test data 115 French-English In domain Out of Domain Adequacy Adequacy 0.3 0.3 &#8226; 0.2 0.2 0.1 0.1 -0.0 -0.0 -0.1 -0.1 -0.2 -0.2 -0.3 -0.3 -0.4 -0.4 -0.5 -0.5 -0.6 -0.6 -0.7 -0.7 &#8226;upv -0.8 -0.8 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 &#8226;upv &#8226;systran upcntt &#8226; rali upc-jmc &#8226; cc Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upv -0.5 &#8226;systran &#8226;upv upc -jmc &#8226; Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 &#8226; &#8226; &#8226; td t cc upc- &#8226; rali 21 22 23 24 25 26 27 28 29 30 31 15 16 17 18 19 20 21 22 Figure 11: Correlation between manual and automatic scores for French-English 116 Spanish-English Figure 12: Correlation between manual and automatic scores for Spanish-English -0.3 -0.4 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 &#8226;upv -0.4 &#8226;upv -0.3 In Domain &#8226;upc-jg Adequacy 0.3 0.2 0.1 -0.0 -0.1 -0.2 Out of Domain &#8226;upc-jmc &#8226;nrc &#8226;ntt Adequacy upc-jmc &#8226; &#8226; &#8226;lcc &#8226; rali &#8226; &#8226;rali -0.7 -0.5 -0.6 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 &#8226; &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 ntt &#8226; upc-mr &#8226;lcc &#8226;utd &#8226;upc-jg &#8226;rali Fluency 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;upc-jmc &#8226; uedin-birch -0.5 -0.5 &#8226;upv 23 24 25 26 27 28 29 30 31 32 19 20 21 22 23 24 25 26 27 28 117 In Domain Out of Domain Adequacy Adequacy German-English 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 lcc &#8226; upc-jmc &#8226;systran &#8226;upv Fluency &#8226;ula &#8226;upc-mr &#8226;lcc 15 16 17 18 19 20 21 22 23 24 25 26 27 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 -0.3 -0.4 &#8226;systran &#8226;upv &#8226;uedin-phi -jmc &#8226;rali &#8226;systran -0.3 -0.4 -0.5 -0.6 &#8226;upv 12 13 14 15 16 17 18 19 20 0.4 0.3 0.2 0.1 -0.0 -0.1 -0.2 Fluency uedin-phi &#8226; &#8226; &#8226;utd &#8226;upc-jmc &#8226;upc-mr 0.4 &#8226;rali -0.3 -0.4 -0.5 &#8226;upv 12 13 14 15 16 17 18 19 20 0.3 0.2 0.1 -0.0 -0.1 -0.2 English-French In Domain Out of Domain Adequacy Adequacy .', 'We dropped, however, one of the languages, Finnish, partly to keep the number of tracks manageable, partly because we assumed that it would be hard to find enough Finnish speakers for the manual evaluation.', 'Also, the argument has been made that machine translation performance should be evaluated via task-based evaluation metrics, i.e. how much it assists performing a useful task, such as supporting human translators or aiding the analysis of texts.', 'The main disadvantage of manual evaluation is that it is time-consuming and thus too expensive to do frequently.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.06667', '(95%-conf.int.', '0.06667', '-', '0.06667)']
['system', 'ROUGE-S*', 'Average_F:', '0.00001', '(95%-conf.int.', '0.00001', '-', '0.00001)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1053426', 'P:45', 'F:3']
0.4302830736132072 0.024316922889869825 0.04514615349887574





input/ref/Task1/W11-2123_aakansha.csv
input/res/Task1/W11-2123.annv3.csv
parsing: input/ref/Task1/W11-2123_aakansha.csv
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'"]
'7'
['7']
parsed_discourse_facet ['method_citation']
<S sid="45" ssid="23">The PROBING data structure is a rather straightforward application of these hash tables to store Ngram language models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'45'"]
'45'
['45']
parsed_discourse_facet ['method_citation']
<S sid="136" ssid="8">We offer a state function s(wn1) = wn&#65533; where substring wn&#65533; is guaranteed to extend (to the right) in the same way that wn1 does for purposes of language modeling.</S>
original cit marker offset is 0
new cit marker offset is 0



["'136'"]
'136'
['136']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'"]
'7'
['7']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="3">Queries take the form p(wn|wn&#8722;1 1 ) where wn1 is an n-gram.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="205" ssid="24">We evaluate the time and memory consumption of each data structure by computing perplexity on 4 billion tokens from the English Gigaword corpus (Parker et al., 2009).</S>
original cit marker offset is 0
new cit marker offset is 0



["'205'"]
'205'
['205']
parsed_discourse_facet ['method_citation']
<S sid="274" ssid="1">We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.</S>
original cit marker offset is 0
new cit marker offset is 0



["'274'"]
'274'
['274']
parsed_discourse_facet ['method_citation']
<S sid="204" ssid="23">For RandLM, we used the settings in the documentation: 8 bits per value and false positive probability 1 256.</S>
original cit marker offset is 0
new cit marker offset is 0



["'204'"]
'204'
['204']
parsed_discourse_facet ['method_citation']
<S sid="274" ssid="1">We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.</S>
original cit marker offset is 0
new cit marker offset is 0



["'274'"]
'274'
['274']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="229" ssid="48">Then we ran binary search to determine the least amount of memory with which it would run.</S>
original cit marker offset is 0
new cit marker offset is 0



["'229'"]
'229'
['229']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="93" ssid="71">The cost of storing these averages, in bits, is Because there are comparatively few unigrams, we elected to store them byte-aligned and unquantized, making every query faster.</S>
original cit marker offset is 0
new cit marker offset is 0



["'93'"]
'93'
['93']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'199'"]
'199'
['199']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W11-2123.annv3.csv
<S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'21'", "'98'", "'199'"]
'12'
'21'
'98'
'199'
['12', '21', '98', '199']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="102" ssid="6">The PROBING model was designed to improve upon SRILM by using linear probing hash tables (though not arranged in a trie), allocating memory all at once (eliminating the need for full pointers), and being easy to compile.</S><S sid="223" ssid="42">The binary language model from Section 5.2 and text phrase table were forced into disk cache before each run.</S><S sid="244" ssid="63">Time for Moses itself to load, including loading the language model and phrase table, is included.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'102'", "'223'", "'244'"]
'0'
'102'
'223'
'244'
['0', '102', '223', '244']
parsed_discourse_facet ['results_citation']
<S sid="135" ssid="7">Therefore, we want state to encode the minimum amount of information necessary to properly compute language model scores, so that the decoder will be faster and make fewer search errors.</S><S sid="136" ssid="8">We offer a state function s(wn1) = wn&#65533; where substring wn&#65533; is guaranteed to extend (to the right) in the same way that wn1 does for purposes of language modeling.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'135'", "'136'", "'152'", "'199'"]
'135'
'136'
'152'
'199'
['135', '136', '152', '199']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S><S sid="268" ssid="10">For example, syntactic decoders (Koehn et al., 2007; Dyer et al., 2010; Li et al., 2009) perform dynamic programming parametrized by both backward- and forward-looking state.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'21'", "'129'", "'268'"]
'1'
'21'
'129'
'268'
['1', '21', '129', '268']
parsed_discourse_facet ['results_citation']
<S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'21'", "'51'", "'199'"]
'12'
'21'
'51'
'199'
['12', '21', '51', '199']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="25" ssid="3">An important subproblem of language model storage is therefore sparse mapping: storing values for sparse keys using little memory then retrieving values given keys using little time.</S><S sid="130" ssid="2">Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'25'", "'130'", "'199'"]
'0'
'25'
'130'
'199'
['0', '25', '130', '199']
parsed_discourse_facet ['results_citation']
<S sid="68" ssid="46">The trie data structure is commonly used for language modeling.</S><S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S><S sid="130" ssid="2">Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.</S><S sid="274" ssid="1">We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'129'", "'130'", "'274'"]
'68'
'129'
'130'
'274'
['68', '129', '130', '274']
parsed_discourse_facet ['method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="2" ssid="2">The structure uses linear probing hash tables and is designed for speed.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'21'", "'199'"]
'0'
'2'
'21'
'199'
['0', '2', '21', '199']
parsed_discourse_facet ['hypothesis_citation']
<S sid="44" ssid="22">Further, the special hash 0 suffices to flag empty buckets.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="264" ssid="6">For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'51'", "'98'", "'264'"]
'44'
'51'
'98'
'264'
['44', '51', '98', '264']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="16" ssid="11">BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.</S><S sid="35" ssid="13">Non-empty buckets contain an entry belonging to them or to a preceding bucket where a conflict occurred.</S><S sid="92" ssid="70">To quantize, we use the binning method (Federico and Bertoldi, 2006) that sorts values, divides into equally sized bins, and averages within each bin.</S><S sid="204" ssid="23">For RandLM, we used the settings in the documentation: 8 bits per value and false positive probability 1 256.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'35'", "'92'", "'204'"]
'16'
'35'
'92'
'204'
['16', '35', '92', '204']
parsed_discourse_facet ['hypothesis_citation']
<S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="263" ssid="5">Quantization can be improved by jointly encoding probability and backoff.</S><S sid="264" ssid="6">For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'98'", "'263'", "'264'"]
'51'
'98'
'263'
'264'
['51', '98', '263', '264']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="254" ssid="73">We used this data to build an unpruned ARPA file with IRSTLM&#8217;s improved-kneser-ney option and the default three pieces.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'51'", "'254'"]
'0'
'1'
'51'
'254'
['0', '1', '51', '254']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="6" ssid="1">Language models are widely applied in natural language processing, and applications such as machine translation make very frequent queries.</S><S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'6'", "'7'", "'103'"]
'1'
'6'
'7'
'103'
['1', '6', '7', '103']
parsed_discourse_facet ['hypothesis_citation']
<S sid="5" ssid="5">This paper describes the several performance techniques used and presents benchmarks against alternative implementations.</S><S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'12'", "'21'", "'199'"]
'5'
'12'
'21'
'199'
['5', '12', '21', '199']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S><S sid="14" ssid="9">MITLM 0.4 (Hsu and Glass, 2008) is mostly designed for accurate model estimation, but can also compute perplexity.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'7'", "'14'"]
'0'
'1'
'7'
'14'
['0', '1', '7', '14']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">The structure uses linear probing hash tables and is designed for speed.</S><S sid="11" ssid="6">Many packages perform language model queries.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'11'", "'152'", "'199'"]
'2'
'11'
'152'
'199'
['2', '11', '152', '199']
parsed_discourse_facet ['results_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="131" ssid="3">Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N &#8722; 1 preceding words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'103'", "'131'"]
'0'
'1'
'103'
'131'
['0', '1', '103', '131']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="11">BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.</S><S sid="141" ssid="13">Syntactic decoders, such as cdec (Dyer et al., 2010), build state from null context then store it in the hypergraph node for later extension.</S><S sid="164" ssid="36">This makes memory usage comparable to our PROBING model.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'141'", "'164'", "'199'"]
'16'
'141'
'164'
'199'
['16', '141', '164', '199']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="137" ssid="9">The state function is integrated into the query process so that, in lieu of the query p(wnjwn&#8722;1 1 ), the application issues query p(wnjs(wn&#8722;1 1 )) which also returns s(wn1 ).</S><S sid="198" ssid="17">Memory usage is the same as with binary search and lower than with set.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'103'", "'137'", "'198'", "'199'"]
'103'
'137'
'198'
'199'
['103', '137', '198', '199']
parsed_discourse_facet ['method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'103'", "'152'"]
'0'
'1'
'103'
'152'
['0', '1', '103', '152']
parsed_discourse_facet ['results_citation']
dict_values(['This paper presents methods to query N-gram language models, minimizing time and space costs.'])
dict_values(['Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00195', '(95%-conf.int.', '0.00195', '-', '0.00195)']
['system', 'ROUGE-S*', 'Average_P:', '0.10909', '(95%-conf.int.', '0.10909', '-', '0.10909)']
['system', 'ROUGE-S*', 'Average_F:', '0.00383', '(95%-conf.int.', '0.00383', '-', '0.00383)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3081', 'P:55', 'F:6']
dict_values(['The PROBING data structure is a rather straightforward application of these hash tables to store Ngram language models.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'The PROBING model was designed to improve upon SRILM by using linear probing hash tables (though not arranged in a trie), allocating memory all at once (eliminating the need for full pointers), and being easy to compile.', 'The binary language model from Section 5.2 and text phrase table were forced into disk cache before each run.', 'Time for Moses itself to load, including loading the language model and phrase table, is included.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00925', '(95%-conf.int.', '0.00925', '-', '0.00925)']
['system', 'ROUGE-S*', 'Average_P:', '0.18182', '(95%-conf.int.', '0.18182', '-', '0.18182)']
['system', 'ROUGE-S*', 'Average_F:', '0.01761', '(95%-conf.int.', '0.01761', '-', '0.01761)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1081', 'P:55', 'F:10']
dict_values(['We offer a state function s(wn1) = wn&#65533; where substring wn&#65533; is guaranteed to extend (to the right) in the same way that wn1 does for purposes of language modeling.'])
dict_values(['Therefore, we want state to encode the minimum amount of information necessary to properly compute language model scores, so that the decoder will be faster and make fewer search errors.', 'We offer a state function s(wn1) = wn&#65533; where substring wn&#65533; is guaranteed to extend (to the right) in the same way that wn1 does for purposes of language modeling.', 'All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03684', '(95%-conf.int.', '0.03684', '-', '0.03684)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.07107', '(95%-conf.int.', '0.07107', '-', '0.07107)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2850', 'P:105', 'F:105']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.', 'For example, syntactic decoders (Koehn et al., 2007; Dyer et al., 2010; Li et al., 2009) perform dynamic programming parametrized by both backward- and forward-looking state.'])
['system', 'ROUGE-S*', 'Average_R:', '0.04262', '(95%-conf.int.', '0.04262', '-', '0.04262)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.08176', '(95%-conf.int.', '0.08176', '-', '0.08176)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:78', 'F:78']
dict_values(['This paper presents methods to query N-gram language models, minimizing time and space costs.'])
dict_values(['Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00241', '(95%-conf.int.', '0.00241', '-', '0.00241)']
['system', 'ROUGE-S*', 'Average_P:', '0.10909', '(95%-conf.int.', '0.10909', '-', '0.10909)']
['system', 'ROUGE-S*', 'Average_F:', '0.00472', '(95%-conf.int.', '0.00472', '-', '0.00472)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2485', 'P:55', 'F:6']
dict_values(['Queries take the form p(wn|wn&#8722;1 1 ) where wn1 is an n-gram.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'An important subproblem of language model storage is therefore sparse mapping: storing values for sparse keys using little memory then retrieving values given keys using little time.', 'Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00060', '(95%-conf.int.', '0.00060', '-', '0.00060)']
['system', 'ROUGE-S*', 'Average_P:', '0.02778', '(95%-conf.int.', '0.02778', '-', '0.02778)']
['system', 'ROUGE-S*', 'Average_F:', '0.00118', '(95%-conf.int.', '0.00118', '-', '0.00118)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:36', 'F:1']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['The trie data structure is commonly used for language modeling.', 'In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.', 'Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.', 'We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03153', '(95%-conf.int.', '0.03153', '-', '0.03153)']
['system', 'ROUGE-S*', 'Average_P:', '0.26923', '(95%-conf.int.', '0.26923', '-', '0.26923)']
['system', 'ROUGE-S*', 'Average_F:', '0.05645', '(95%-conf.int.', '0.05645', '-', '0.05645)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:666', 'P:78', 'F:21']
dict_values(['We evaluate the time and memory consumption of each data structure by computing perplexity on 4 billion tokens from the English Gigaword corpus (Parker et al., 2009).'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'The structure uses linear probing hash tables and is designed for speed.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00726', '(95%-conf.int.', '0.00726', '-', '0.00726)']
['system', 'ROUGE-S*', 'Average_P:', '0.08824', '(95%-conf.int.', '0.08824', '-', '0.08824)']
['system', 'ROUGE-S*', 'Average_F:', '0.01342', '(95%-conf.int.', '0.01342', '-', '0.01342)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:136', 'F:12']
dict_values(['We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.'])
dict_values(['This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.', 'It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.', 'Quantization can be improved by jointly encoding probability and backoff.', 'For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1431', 'P:45', 'F:0']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.', 'We used this data to build an unpruned ARPA file with IRSTLM&#8217;s improved-kneser-ney option and the default three pieces.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07879', '(95%-conf.int.', '0.07879', '-', '0.07879)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.14607', '(95%-conf.int.', '0.14607', '-', '0.14607)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:990', 'P:78', 'F:78']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'Language models are widely applied in natural language processing, and applications such as machine translation make very frequent queries.', 'This paper presents methods to query N-gram language models, minimizing time and space costs.', 'IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.'])
['system', 'ROUGE-S*', 'Average_R:', '0.06915', '(95%-conf.int.', '0.06915', '-', '0.06915)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.12935', '(95%-conf.int.', '0.12935', '-', '0.12935)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1128', 'P:78', 'F:78']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['This paper describes the several performance techniques used and presents benchmarks against alternative implementations.', 'Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00280', '(95%-conf.int.', '0.00280', '-', '0.00280)']
['system', 'ROUGE-S*', 'Average_P:', '0.07692', '(95%-conf.int.', '0.07692', '-', '0.07692)']
['system', 'ROUGE-S*', 'Average_F:', '0.00540', '(95%-conf.int.', '0.00540', '-', '0.00540)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:78', 'F:6']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'This paper presents methods to query N-gram language models, minimizing time and space costs.', 'MITLM 0.4 (Hsu and Glass, 2008) is mostly designed for accurate model estimation, but can also compute perplexity.'])
['system', 'ROUGE-S*', 'Average_R:', '0.09059', '(95%-conf.int.', '0.09059', '-', '0.09059)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.16613', '(95%-conf.int.', '0.16613', '-', '0.16613)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:78', 'F:78']
dict_values(['Then we ran binary search to determine the least amount of memory with which it would run.'])
dict_values(['The structure uses linear probing hash tables and is designed for speed.', 'Many packages perform language model queries.', 'All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:21', 'F:0']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.', 'Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N &#8722; 1 preceding words.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07879', '(95%-conf.int.', '0.07879', '-', '0.07879)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.14607', '(95%-conf.int.', '0.14607', '-', '0.14607)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:990', 'P:78', 'F:78']
dict_values(['The cost of storing these averages, in bits, is Because there are comparatively few unigrams, we elected to store them byte-aligned and unquantized, making every query faster.'])
dict_values(['BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.', 'Syntactic decoders, such as cdec (Dyer et al., 2010), build state from null context then store it in the hypergraph node for later extension.', 'This makes memory usage comparable to our PROBING model.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00109', '(95%-conf.int.', '0.00109', '-', '0.00109)']
['system', 'ROUGE-S*', 'Average_P:', '0.02198', '(95%-conf.int.', '0.02198', '-', '0.02198)']
['system', 'ROUGE-S*', 'Average_F:', '0.00208', '(95%-conf.int.', '0.00208', '-', '0.00208)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:91', 'F:2']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.', 'The state function is integrated into the query process so that, in lieu of the query p(wnjwn&#8722;1 1 ), the application issues query p(wnjs(wn&#8722;1 1 )) which also returns s(wn1 ).', 'Memory usage is the same as with binary search and lower than with set.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00149', '(95%-conf.int.', '0.00149', '-', '0.00149)']
['system', 'ROUGE-S*', 'Average_P:', '0.03846', '(95%-conf.int.', '0.03846', '-', '0.03846)']
['system', 'ROUGE-S*', 'Average_F:', '0.00287', '(95%-conf.int.', '0.00287', '-', '0.00287)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:78', 'F:3']
dict_values(['For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.', 'All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01190', '(95%-conf.int.', '0.01190', '-', '0.01190)']
['system', 'ROUGE-S*', 'Average_P:', '0.04308', '(95%-conf.int.', '0.04308', '-', '0.04308)']
['system', 'ROUGE-S*', 'Average_F:', '0.01865', '(95%-conf.int.', '0.01865', '-', '0.01865)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:325', 'F:14']
0.3869827756278734 0.025947777633623454 0.04814777751029012





input/ref/Task1/W11-2123_swastika.csv
input/res/Task1/W11-2123.annv3.csv
parsing: input/ref/Task1/W11-2123_swastika.csv
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="52" ssid="30">Our implementation permits jumping to any n-gram of any length with a single lookup; this appears to be unique among language model implementations.</S>
original cit marker offset is 0
new cit marker offset is 0



['52']
52
['52']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
<S sid="177" ssid="49">However, TRIE partitions storage by n-gram length, so walking the trie reads N disjoint pages.</S>
original cit marker offset is 0
new cit marker offset is 0



['177']
177
['177']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['1']
1
['1']
parsed_discourse_facet ['aim_citation']
<S sid="200" ssid="19">The model was built with open vocabulary, modified Kneser-Ney smoothing, and default pruning settings that remove singletons of order 3 and higher.</S>
original cit marker offset is 0
new cit marker offset is 0



['200']
200
['200']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
<S sid="200" ssid="19">The model was built with open vocabulary, modified Kneser-Ney smoothing, and default pruning settings that remove singletons of order 3 and higher.</S>
original cit marker offset is 0
new cit marker offset is 0



['200']
200
['200']
parsed_discourse_facet ['method_citation']
<S sid="200" ssid="19">The model was built with open vocabulary, modified Kneser-Ney smoothing, and default pruning settings that remove singletons of order 3 and higher.</S>
original cit marker offset is 0
new cit marker offset is 0



['200']
200
['200']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
<S sid="278" ssid="5">We attain these results using several optimizations: hashing, custom lookup tables, bit-level packing, and state for left-to-right query patterns.</S>
original cit marker offset is 0
new cit marker offset is 0



['278']
278
['278']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
<S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
parsing: input/res/Task1/W11-2123.annv3.csv
<S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'21'", "'98'", "'199'"]
'12'
'21'
'98'
'199'
['12', '21', '98', '199']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="102" ssid="6">The PROBING model was designed to improve upon SRILM by using linear probing hash tables (though not arranged in a trie), allocating memory all at once (eliminating the need for full pointers), and being easy to compile.</S><S sid="223" ssid="42">The binary language model from Section 5.2 and text phrase table were forced into disk cache before each run.</S><S sid="244" ssid="63">Time for Moses itself to load, including loading the language model and phrase table, is included.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'102'", "'223'", "'244'"]
'0'
'102'
'223'
'244'
['0', '102', '223', '244']
parsed_discourse_facet ['results_citation']
<S sid="135" ssid="7">Therefore, we want state to encode the minimum amount of information necessary to properly compute language model scores, so that the decoder will be faster and make fewer search errors.</S><S sid="136" ssid="8">We offer a state function s(wn1) = wn&#65533; where substring wn&#65533; is guaranteed to extend (to the right) in the same way that wn1 does for purposes of language modeling.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'135'", "'136'", "'152'", "'199'"]
'135'
'136'
'152'
'199'
['135', '136', '152', '199']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S><S sid="268" ssid="10">For example, syntactic decoders (Koehn et al., 2007; Dyer et al., 2010; Li et al., 2009) perform dynamic programming parametrized by both backward- and forward-looking state.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'21'", "'129'", "'268'"]
'1'
'21'
'129'
'268'
['1', '21', '129', '268']
parsed_discourse_facet ['results_citation']
<S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'21'", "'51'", "'199'"]
'12'
'21'
'51'
'199'
['12', '21', '51', '199']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="25" ssid="3">An important subproblem of language model storage is therefore sparse mapping: storing values for sparse keys using little memory then retrieving values given keys using little time.</S><S sid="130" ssid="2">Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'25'", "'130'", "'199'"]
'0'
'25'
'130'
'199'
['0', '25', '130', '199']
parsed_discourse_facet ['results_citation']
<S sid="68" ssid="46">The trie data structure is commonly used for language modeling.</S><S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S><S sid="130" ssid="2">Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.</S><S sid="274" ssid="1">We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'129'", "'130'", "'274'"]
'68'
'129'
'130'
'274'
['68', '129', '130', '274']
parsed_discourse_facet ['method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="2" ssid="2">The structure uses linear probing hash tables and is designed for speed.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'21'", "'199'"]
'0'
'2'
'21'
'199'
['0', '2', '21', '199']
parsed_discourse_facet ['hypothesis_citation']
<S sid="44" ssid="22">Further, the special hash 0 suffices to flag empty buckets.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="264" ssid="6">For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'51'", "'98'", "'264'"]
'44'
'51'
'98'
'264'
['44', '51', '98', '264']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="16" ssid="11">BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.</S><S sid="35" ssid="13">Non-empty buckets contain an entry belonging to them or to a preceding bucket where a conflict occurred.</S><S sid="92" ssid="70">To quantize, we use the binning method (Federico and Bertoldi, 2006) that sorts values, divides into equally sized bins, and averages within each bin.</S><S sid="204" ssid="23">For RandLM, we used the settings in the documentation: 8 bits per value and false positive probability 1 256.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'35'", "'92'", "'204'"]
'16'
'35'
'92'
'204'
['16', '35', '92', '204']
parsed_discourse_facet ['hypothesis_citation']
<S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="263" ssid="5">Quantization can be improved by jointly encoding probability and backoff.</S><S sid="264" ssid="6">For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'98'", "'263'", "'264'"]
'51'
'98'
'263'
'264'
['51', '98', '263', '264']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="254" ssid="73">We used this data to build an unpruned ARPA file with IRSTLM&#8217;s improved-kneser-ney option and the default three pieces.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'51'", "'254'"]
'0'
'1'
'51'
'254'
['0', '1', '51', '254']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="6" ssid="1">Language models are widely applied in natural language processing, and applications such as machine translation make very frequent queries.</S><S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'6'", "'7'", "'103'"]
'1'
'6'
'7'
'103'
['1', '6', '7', '103']
parsed_discourse_facet ['hypothesis_citation']
<S sid="5" ssid="5">This paper describes the several performance techniques used and presents benchmarks against alternative implementations.</S><S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'12'", "'21'", "'199'"]
'5'
'12'
'21'
'199'
['5', '12', '21', '199']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S><S sid="14" ssid="9">MITLM 0.4 (Hsu and Glass, 2008) is mostly designed for accurate model estimation, but can also compute perplexity.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'7'", "'14'"]
'0'
'1'
'7'
'14'
['0', '1', '7', '14']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">The structure uses linear probing hash tables and is designed for speed.</S><S sid="11" ssid="6">Many packages perform language model queries.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'11'", "'152'", "'199'"]
'2'
'11'
'152'
'199'
['2', '11', '152', '199']
parsed_discourse_facet ['results_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="131" ssid="3">Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N &#8722; 1 preceding words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'103'", "'131'"]
'0'
'1'
'103'
'131'
['0', '1', '103', '131']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="11">BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.</S><S sid="141" ssid="13">Syntactic decoders, such as cdec (Dyer et al., 2010), build state from null context then store it in the hypergraph node for later extension.</S><S sid="164" ssid="36">This makes memory usage comparable to our PROBING model.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'141'", "'164'", "'199'"]
'16'
'141'
'164'
'199'
['16', '141', '164', '199']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="137" ssid="9">The state function is integrated into the query process so that, in lieu of the query p(wnjwn&#8722;1 1 ), the application issues query p(wnjs(wn&#8722;1 1 )) which also returns s(wn1 ).</S><S sid="198" ssid="17">Memory usage is the same as with binary search and lower than with set.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'103'", "'137'", "'198'", "'199'"]
'103'
'137'
'198'
'199'
['103', '137', '198', '199']
parsed_discourse_facet ['method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'103'", "'152'"]
'0'
'1'
'103'
'152'
['0', '1', '103', '152']
parsed_discourse_facet ['results_citation']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00097', '(95%-conf.int.', '0.00097', '-', '0.00097)']
['system', 'ROUGE-S*', 'Average_P:', '0.03846', '(95%-conf.int.', '0.03846', '-', '0.03846)']
['system', 'ROUGE-S*', 'Average_F:', '0.00190', '(95%-conf.int.', '0.00190', '-', '0.00190)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3081', 'P:78', 'F:3']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'The PROBING model was designed to improve upon SRILM by using linear probing hash tables (though not arranged in a trie), allocating memory all at once (eliminating the need for full pointers), and being easy to compile.', 'The binary language model from Section 5.2 and text phrase table were forced into disk cache before each run.', 'Time for Moses itself to load, including loading the language model and phrase table, is included.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00925', '(95%-conf.int.', '0.00925', '-', '0.00925)']
['system', 'ROUGE-S*', 'Average_P:', '0.12821', '(95%-conf.int.', '0.12821', '-', '0.12821)']
['system', 'ROUGE-S*', 'Average_F:', '0.01726', '(95%-conf.int.', '0.01726', '-', '0.01726)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1081', 'P:78', 'F:10']
dict_values(['This paper presents methods to query N-gram language models, minimizing time and space costs.'])
dict_values(['Therefore, we want state to encode the minimum amount of information necessary to properly compute language model scores, so that the decoder will be faster and make fewer search errors.', 'We offer a state function s(wn1) = wn&#65533; where substring wn&#65533; is guaranteed to extend (to the right) in the same way that wn1 does for purposes of language modeling.', 'All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00211', '(95%-conf.int.', '0.00211', '-', '0.00211)']
['system', 'ROUGE-S*', 'Average_P:', '0.10909', '(95%-conf.int.', '0.10909', '-', '0.10909)']
['system', 'ROUGE-S*', 'Average_F:', '0.00413', '(95%-conf.int.', '0.00413', '-', '0.00413)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2850', 'P:55', 'F:6']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.', 'For example, syntactic decoders (Koehn et al., 2007; Dyer et al., 2010; Li et al., 2009) perform dynamic programming parametrized by both backward- and forward-looking state.'])
['system', 'ROUGE-S*', 'Average_R:', '0.04262', '(95%-conf.int.', '0.04262', '-', '0.04262)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.08176', '(95%-conf.int.', '0.08176', '-', '0.08176)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:78', 'F:78']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00121', '(95%-conf.int.', '0.00121', '-', '0.00121)']
['system', 'ROUGE-S*', 'Average_P:', '0.03846', '(95%-conf.int.', '0.03846', '-', '0.03846)']
['system', 'ROUGE-S*', 'Average_F:', '0.00234', '(95%-conf.int.', '0.00234', '-', '0.00234)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2485', 'P:78', 'F:3']
dict_values(['Our implementation permits jumping to any n-gram of any length with a single lookup; this appears to be unique among language model implementations.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'An important subproblem of language model storage is therefore sparse mapping: storing values for sparse keys using little memory then retrieving values given keys using little time.', 'Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00181', '(95%-conf.int.', '0.00181', '-', '0.00181)']
['system', 'ROUGE-S*', 'Average_P:', '0.04545', '(95%-conf.int.', '0.04545', '-', '0.04545)']
['system', 'ROUGE-S*', 'Average_F:', '0.00349', '(95%-conf.int.', '0.00349', '-', '0.00349)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:66', 'F:3']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['The trie data structure is commonly used for language modeling.', 'In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.', 'Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.', 'We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.'])
['system', 'ROUGE-S*', 'Average_R:', '0.03153', '(95%-conf.int.', '0.03153', '-', '0.03153)']
['system', 'ROUGE-S*', 'Average_P:', '0.26923', '(95%-conf.int.', '0.26923', '-', '0.26923)']
['system', 'ROUGE-S*', 'Average_F:', '0.05645', '(95%-conf.int.', '0.05645', '-', '0.05645)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:666', 'P:78', 'F:21']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'The structure uses linear probing hash tables and is designed for speed.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00544', '(95%-conf.int.', '0.00544', '-', '0.00544)']
['system', 'ROUGE-S*', 'Average_P:', '0.11538', '(95%-conf.int.', '0.11538', '-', '0.11538)']
['system', 'ROUGE-S*', 'Average_F:', '0.01040', '(95%-conf.int.', '0.01040', '-', '0.01040)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:78', 'F:9']
dict_values(['This paper presents methods to query N-gram language models, minimizing time and space costs.'])
dict_values(['This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.', 'It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.', 'Quantization can be improved by jointly encoding probability and backoff.', 'For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1431', 'P:55', 'F:0']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.', 'We used this data to build an unpruned ARPA file with IRSTLM&#8217;s improved-kneser-ney option and the default three pieces.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07879', '(95%-conf.int.', '0.07879', '-', '0.07879)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.14607', '(95%-conf.int.', '0.14607', '-', '0.14607)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:990', 'P:78', 'F:78']
dict_values(['The model was built with open vocabulary, modified Kneser-Ney smoothing, and default pruning settings that remove singletons of order 3 and higher.'])
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'Language models are widely applied in natural language processing, and applications such as machine translation make very frequent queries.', 'This paper presents methods to query N-gram language models, minimizing time and space costs.', 'IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00089', '(95%-conf.int.', '0.00089', '-', '0.00089)']
['system', 'ROUGE-S*', 'Average_P:', '0.00833', '(95%-conf.int.', '0.00833', '-', '0.00833)']
['system', 'ROUGE-S*', 'Average_F:', '0.00160', '(95%-conf.int.', '0.00160', '-', '0.00160)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1128', 'P:120', 'F:1']
dict_values(['This paper presents methods to query N-gram language models, minimizing time and space costs.'])
dict_values(['This paper describes the several performance techniques used and presents benchmarks against alternative implementations.', 'Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00466', '(95%-conf.int.', '0.00466', '-', '0.00466)']
['system', 'ROUGE-S*', 'Average_P:', '0.18182', '(95%-conf.int.', '0.18182', '-', '0.18182)']
['system', 'ROUGE-S*', 'Average_F:', '0.00909', '(95%-conf.int.', '0.00909', '-', '0.00909)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:55', 'F:10']
dict_values(['The model was built with open vocabulary, modified Kneser-Ney smoothing, and default pruning settings that remove singletons of order 3 and higher.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'This paper presents methods to query N-gram language models, minimizing time and space costs.', 'MITLM 0.4 (Hsu and Glass, 2008) is mostly designed for accurate model estimation, but can also compute perplexity.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:120', 'F:0']
dict_values(['The model was built with open vocabulary, modified Kneser-Ney smoothing, and default pruning settings that remove singletons of order 3 and higher.'])
dict_values(['The structure uses linear probing hash tables and is designed for speed.', 'Many packages perform language model queries.', 'All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00063', '(95%-conf.int.', '0.00063', '-', '0.00063)']
['system', 'ROUGE-S*', 'Average_P:', '0.00833', '(95%-conf.int.', '0.00833', '-', '0.00833)']
['system', 'ROUGE-S*', 'Average_F:', '0.00117', '(95%-conf.int.', '0.00117', '-', '0.00117)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:120', 'F:1']
dict_values(['This paper presents methods to query N-gram language models, minimizing time and space costs.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.', 'Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N &#8722; 1 preceding words.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01919', '(95%-conf.int.', '0.01919', '-', '0.01919)']
['system', 'ROUGE-S*', 'Average_P:', '0.34545', '(95%-conf.int.', '0.34545', '-', '0.34545)']
['system', 'ROUGE-S*', 'Average_F:', '0.03636', '(95%-conf.int.', '0.03636', '-', '0.03636)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:990', 'P:55', 'F:19']
dict_values(['We attain these results using several optimizations: hashing, custom lookup tables, bit-level packing, and state for left-to-right query patterns.'])
dict_values(['BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.', 'Syntactic decoders, such as cdec (Dyer et al., 2010), build state from null context then store it in the hypergraph node for later extension.', 'This makes memory usage comparable to our PROBING model.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00164', '(95%-conf.int.', '0.00164', '-', '0.00164)']
['system', 'ROUGE-S*', 'Average_P:', '0.03297', '(95%-conf.int.', '0.03297', '-', '0.03297)']
['system', 'ROUGE-S*', 'Average_F:', '0.00312', '(95%-conf.int.', '0.00312', '-', '0.00312)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:91', 'F:3']
dict_values(['This paper presents methods to query N-gram language models, minimizing time and space costs.'])
dict_values(['IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.', 'The state function is integrated into the query process so that, in lieu of the query p(wnjwn&#8722;1 1 ), the application issues query p(wnjs(wn&#8722;1 1 )) which also returns s(wn1 ).', 'Memory usage is the same as with binary search and lower than with set.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00298', '(95%-conf.int.', '0.00298', '-', '0.00298)']
['system', 'ROUGE-S*', 'Average_P:', '0.10909', '(95%-conf.int.', '0.10909', '-', '0.10909)']
['system', 'ROUGE-S*', 'Average_F:', '0.00579', '(95%-conf.int.', '0.00579', '-', '0.00579)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:55', 'F:6']
dict_values(['This paper presents methods to query N-gram language models, minimizing time and space costs.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.', 'All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01276', '(95%-conf.int.', '0.01276', '-', '0.01276)']
['system', 'ROUGE-S*', 'Average_P:', '0.27273', '(95%-conf.int.', '0.27273', '-', '0.27273)']
['system', 'ROUGE-S*', 'Average_F:', '0.02437', '(95%-conf.int.', '0.02437', '-', '0.02437)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:55', 'F:15']
0.205722221079321 0.012026666599851852 0.02251666654157407





input/ref/Task1/W11-2123_vardha.csv
input/res/Task1/W11-2123.annv3.csv
parsing: input/ref/Task1/W11-2123_vardha.csv
    <S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'"]
'12'
['12']
parsed_discourse_facet ['method_citation']
 <S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'"]
'7'
['7']
parsed_discourse_facet ['method_citation']
 <S sid="131" ssid="3">Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N &#8722; 1 preceding words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'131'"]
'131'
['131']
parsed_discourse_facet ['method_citation']
 <S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
 <S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'"]
'21'
['21']
parsed_discourse_facet ['method_citation']
<S sid="108" ssid="12">Compared with SRILM, IRSTLM adds several features: lower memory consumption, a binary file format with memory mapping, caching to increase speed, and quantization.</S>
original cit marker offset is 0
new cit marker offset is 0



["'108'"]
'108'
['108']
parsed_discourse_facet ['method_citation']
    <S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S>
original cit marker offset is 0
new cit marker offset is 0



["'129'"]
'129'
['129']
parsed_discourse_facet ['method_citation']
    <S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'199'"]
'199'
['199']
parsed_discourse_facet ['method_citation']
    <S sid="52" ssid="30">Our implementation permits jumping to any n-gram of any length with a single lookup; this appears to be unique among language model implementations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'"]
'52'
['52']
parsed_discourse_facet ['method_citation']
    <S sid="263" ssid="5">Quantization can be improved by jointly encoding probability and backoff.</S>
original cit marker offset is 0
new cit marker offset is 0



["'263'"]
'263'
['263']
parsed_discourse_facet ['method_citation']
    <S sid="52" ssid="30">Our implementation permits jumping to any n-gram of any length with a single lookup; this appears to be unique among language model implementations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'52'"]
'52'
['52']
parsed_discourse_facet ['method_citation']
    <S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'"]
'1'
['1']
parsed_discourse_facet ['method_citation']
<S sid="145" ssid="17">If the context wnf will never extend to the right (i.e. wnf v is not present in the model for all words v) then no subsequent query will match the full context.</S>
original cit marker offset is 0
new cit marker offset is 0



["'145'"]
'145'
['145']
parsed_discourse_facet ['method_citation']
 <S sid="182" ssid="1">This section measures performance on shared tasks in order of increasing complexity: sparse lookups, evaluating perplexity of a large file, and translation with Moses.</S>
original cit marker offset is 0
new cit marker offset is 0



["'182'"]
'182'
['182']
parsed_discourse_facet ['method_citation']
    <S sid="274" ssid="1">We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.</S>
original cit marker offset is 0
new cit marker offset is 0



["'274'"]
'274'
['274']
parsed_discourse_facet ['method_citation']
    <S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'"]
'12'
['12']
parsed_discourse_facet ['method_citation']
    <S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'"]
'7'
['7']
parsed_discourse_facet ['method_citation']
    <S sid="140" ssid="12">We have modified Moses (Koehn et al., 2007) to keep our state with hypotheses; to conserve memory, phrases do not keep state.</S>
original cit marker offset is 0
new cit marker offset is 0



["'140'"]
'140'
['140']
parsed_discourse_facet ['method_citation']
 <S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'199'"]
'199'
['199']
parsed_discourse_facet ['method_citation']
 <S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'199'"]
'199'
['199']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W11-2123.annv3.csv
<S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'21'", "'98'", "'199'"]
'12'
'21'
'98'
'199'
['12', '21', '98', '199']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="102" ssid="6">The PROBING model was designed to improve upon SRILM by using linear probing hash tables (though not arranged in a trie), allocating memory all at once (eliminating the need for full pointers), and being easy to compile.</S><S sid="223" ssid="42">The binary language model from Section 5.2 and text phrase table were forced into disk cache before each run.</S><S sid="244" ssid="63">Time for Moses itself to load, including loading the language model and phrase table, is included.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'102'", "'223'", "'244'"]
'0'
'102'
'223'
'244'
['0', '102', '223', '244']
parsed_discourse_facet ['results_citation']
<S sid="135" ssid="7">Therefore, we want state to encode the minimum amount of information necessary to properly compute language model scores, so that the decoder will be faster and make fewer search errors.</S><S sid="136" ssid="8">We offer a state function s(wn1) = wn&#65533; where substring wn&#65533; is guaranteed to extend (to the right) in the same way that wn1 does for purposes of language modeling.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'135'", "'136'", "'152'", "'199'"]
'135'
'136'
'152'
'199'
['135', '136', '152', '199']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S><S sid="268" ssid="10">For example, syntactic decoders (Koehn et al., 2007; Dyer et al., 2010; Li et al., 2009) perform dynamic programming parametrized by both backward- and forward-looking state.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'21'", "'129'", "'268'"]
'1'
'21'
'129'
'268'
['1', '21', '129', '268']
parsed_discourse_facet ['results_citation']
<S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'12'", "'21'", "'51'", "'199'"]
'12'
'21'
'51'
'199'
['12', '21', '51', '199']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="25" ssid="3">An important subproblem of language model storage is therefore sparse mapping: storing values for sparse keys using little memory then retrieving values given keys using little time.</S><S sid="130" ssid="2">Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'25'", "'130'", "'199'"]
'0'
'25'
'130'
'199'
['0', '25', '130', '199']
parsed_discourse_facet ['results_citation']
<S sid="68" ssid="46">The trie data structure is commonly used for language modeling.</S><S sid="129" ssid="1">In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.</S><S sid="130" ssid="2">Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.</S><S sid="274" ssid="1">We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.</S>
original cit marker offset is 0
new cit marker offset is 0



["'68'", "'129'", "'130'", "'274'"]
'68'
'129'
'130'
'274'
['68', '129', '130', '274']
parsed_discourse_facet ['method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="2" ssid="2">The structure uses linear probing hash tables and is designed for speed.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'2'", "'21'", "'199'"]
'0'
'2'
'21'
'199'
['0', '2', '21', '199']
parsed_discourse_facet ['hypothesis_citation']
<S sid="44" ssid="22">Further, the special hash 0 suffices to flag empty buckets.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="264" ssid="6">For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'44'", "'51'", "'98'", "'264'"]
'44'
'51'
'98'
'264'
['44', '51', '98', '264']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="16" ssid="11">BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.</S><S sid="35" ssid="13">Non-empty buckets contain an entry belonging to them or to a preceding bucket where a conflict occurred.</S><S sid="92" ssid="70">To quantize, we use the binning method (Federico and Bertoldi, 2006) that sorts values, divides into equally sized bins, and averages within each bin.</S><S sid="204" ssid="23">For RandLM, we used the settings in the documentation: 8 bits per value and false positive probability 1 256.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'35'", "'92'", "'204'"]
'16'
'35'
'92'
'204'
['16', '35', '92', '204']
parsed_discourse_facet ['hypothesis_citation']
<S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="98" ssid="2">It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.</S><S sid="263" ssid="5">Quantization can be improved by jointly encoding probability and backoff.</S><S sid="264" ssid="6">For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'", "'98'", "'263'", "'264'"]
'51'
'98'
'263'
'264'
['51', '98', '263', '264']
parsed_discourse_facet ['method_citation', 'hypothesis_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="51" ssid="29">This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.</S><S sid="254" ssid="73">We used this data to build an unpruned ARPA file with IRSTLM&#8217;s improved-kneser-ney option and the default three pieces.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'51'", "'254'"]
'0'
'1'
'51'
'254'
['0', '1', '51', '254']
parsed_discourse_facet ['results_citation']
<S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="6" ssid="1">Language models are widely applied in natural language processing, and applications such as machine translation make very frequent queries.</S><S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'6'", "'7'", "'103'"]
'1'
'6'
'7'
'103'
['1', '6', '7', '103']
parsed_discourse_facet ['hypothesis_citation']
<S sid="5" ssid="5">This paper describes the several performance techniques used and presents benchmarks against alternative implementations.</S><S sid="12" ssid="7">Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.</S><S sid="21" ssid="16">Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'12'", "'21'", "'199'"]
'5'
'12'
'21'
'199'
['5', '12', '21', '199']
parsed_discourse_facet ['hypothesis_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="7" ssid="2">This paper presents methods to query N-gram language models, minimizing time and space costs.</S><S sid="14" ssid="9">MITLM 0.4 (Hsu and Glass, 2008) is mostly designed for accurate model estimation, but can also compute perplexity.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'7'", "'14'"]
'0'
'1'
'7'
'14'
['0', '1', '7', '14']
parsed_discourse_facet ['method_citation', 'aim_citation']
<S sid="2" ssid="2">The structure uses linear probing hash tables and is designed for speed.</S><S sid="11" ssid="6">Many packages perform language model queries.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'11'", "'152'", "'199'"]
'2'
'11'
'152'
'199'
['2', '11', '152', '199']
parsed_discourse_facet ['results_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="131" ssid="3">Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N &#8722; 1 preceding words.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'103'", "'131'"]
'0'
'1'
'103'
'131'
['0', '1', '103', '131']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="11">BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.</S><S sid="141" ssid="13">Syntactic decoders, such as cdec (Dyer et al., 2010), build state from null context then store it in the hypergraph node for later extension.</S><S sid="164" ssid="36">This makes memory usage comparable to our PROBING model.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'141'", "'164'", "'199'"]
'16'
'141'
'164'
'199'
['16', '141', '164', '199']
parsed_discourse_facet ['aim_citation', 'hypothesis_citation']
<S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="137" ssid="9">The state function is integrated into the query process so that, in lieu of the query p(wnjwn&#8722;1 1 ), the application issues query p(wnjs(wn&#8722;1 1 )) which also returns s(wn1 ).</S><S sid="198" ssid="17">Memory usage is the same as with binary search and lower than with set.</S><S sid="199" ssid="18">For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.</S>
original cit marker offset is 0
new cit marker offset is 0



["'103'", "'137'", "'198'", "'199'"]
'103'
'137'
'198'
'199'
['103', '137', '198', '199']
parsed_discourse_facet ['method_citation']
<S sid="0">KenLM: Faster and Smaller Language Model Queries</S><S sid="1" ssid="1">We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.</S><S sid="103" ssid="7">IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.</S><S sid="152" ssid="24">All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'0'", "'1'", "'103'", "'152'"]
'0'
'1'
'103'
'152'
['0', '1', '103', '152']
parsed_discourse_facet ['results_citation']
dict_values(['Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.'])
dict_values(['Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02532', '(95%-conf.int.', '0.02532', '-', '0.02532)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.04938', '(95%-conf.int.', '0.04938', '-', '0.04938)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:3081', 'P:78', 'F:78']
dict_values(['This paper presents methods to query N-gram language models, minimizing time and space costs.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'The PROBING model was designed to improve upon SRILM by using linear probing hash tables (though not arranged in a trie), allocating memory all at once (eliminating the need for full pointers), and being easy to compile.', 'The binary language model from Section 5.2 and text phrase table were forced into disk cache before each run.', 'Time for Moses itself to load, including loading the language model and phrase table, is included.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00555', '(95%-conf.int.', '0.00555', '-', '0.00555)']
['system', 'ROUGE-S*', 'Average_P:', '0.10909', '(95%-conf.int.', '0.10909', '-', '0.10909)']
['system', 'ROUGE-S*', 'Average_F:', '0.01056', '(95%-conf.int.', '0.01056', '-', '0.01056)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1081', 'P:55', 'F:6']
dict_values(['Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N &#8722; 1 preceding words.'])
dict_values(['Therefore, we want state to encode the minimum amount of information necessary to properly compute language model scores, so that the decoder will be faster and make fewer search errors.', 'We offer a state function s(wn1) = wn&#65533; where substring wn&#65533; is guaranteed to extend (to the right) in the same way that wn1 does for purposes of language modeling.', 'All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00211', '(95%-conf.int.', '0.00211', '-', '0.00211)']
['system', 'ROUGE-S*', 'Average_P:', '0.05714', '(95%-conf.int.', '0.05714', '-', '0.05714)']
['system', 'ROUGE-S*', 'Average_F:', '0.00406', '(95%-conf.int.', '0.00406', '-', '0.00406)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2850', 'P:105', 'F:6']
dict_values(['Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.'])
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.', 'For example, syntactic decoders (Koehn et al., 2007; Dyer et al., 2010; Li et al., 2009) perform dynamic programming parametrized by both backward- and forward-looking state.'])
['system', 'ROUGE-S*', 'Average_R:', '0.09344', '(95%-conf.int.', '0.09344', '-', '0.09344)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.17091', '(95%-conf.int.', '0.17091', '-', '0.17091)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:171', 'F:171']
dict_values(['Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.'])
dict_values(['Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.06881', '(95%-conf.int.', '0.06881', '-', '0.06881)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.12877', '(95%-conf.int.', '0.12877', '-', '0.12877)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2485', 'P:171', 'F:171']
dict_values(['Compared with SRILM, IRSTLM adds several features: lower memory consumption, a binary file format with memory mapping, caching to increase speed, and quantization.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'An important subproblem of language model storage is therefore sparse mapping: storing values for sparse keys using little memory then retrieving values given keys using little time.', 'Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:136', 'F:0']
dict_values(['In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.'])
dict_values(['The trie data structure is commonly used for language modeling.', 'In addition to the optimizations specific to each datastructure described in Section 2, we implement several general optimizations for language modeling.', 'Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.', 'We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.'])
['system', 'ROUGE-S*', 'Average_R:', '0.08258', '(95%-conf.int.', '0.08258', '-', '0.08258)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.15257', '(95%-conf.int.', '0.15257', '-', '0.15257)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:666', 'P:55', 'F:55']
dict_values(['For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'The structure uses linear probing hash tables and is designed for speed.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.19661', '(95%-conf.int.', '0.19661', '-', '0.19661)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.32861', '(95%-conf.int.', '0.32861', '-', '0.32861)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1653', 'P:325', 'F:325']
dict_values(['Our implementation permits jumping to any n-gram of any length with a single lookup; this appears to be unique among language model implementations.'])
dict_values(['This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.', 'It is generally considered to be fast (Pauls 29 &#8722; 1 probabilities and 2\\ &#8722; 2 non-zero backoffs. and Klein, 2011), with a default implementation based on hash tables within each trie node.', 'Quantization can be improved by jointly encoding probability and backoff.', 'For even larger models, storing counts (Talbot and Osborne, 2007; Pauls and Klein, 2011; Guthrie and Hepple, 2010) is a possibility.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00140', '(95%-conf.int.', '0.00140', '-', '0.00140)']
['system', 'ROUGE-S*', 'Average_P:', '0.03030', '(95%-conf.int.', '0.03030', '-', '0.03030)']
['system', 'ROUGE-S*', 'Average_F:', '0.00267', '(95%-conf.int.', '0.00267', '-', '0.00267)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1431', 'P:66', 'F:2']
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'This differs from other implementations (Stolcke, 2002; Pauls and Klein, 2011) that use hash tables as nodes in a trie, as explained in the next section.', 'We used this data to build an unpruned ARPA file with IRSTLM&#8217;s improved-kneser-ney option and the default three pieces.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07879', '(95%-conf.int.', '0.07879', '-', '0.07879)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.14607', '(95%-conf.int.', '0.14607', '-', '0.14607)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:990', 'P:78', 'F:78']
dict_values(['If the context wnf will never extend to the right (i.e. wnf v is not present in the model for all words v) then no subsequent query will match the full context.'])
dict_values(['We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'Language models are widely applied in natural language processing, and applications such as machine translation make very frequent queries.', 'This paper presents methods to query N-gram language models, minimizing time and space costs.', 'IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00266', '(95%-conf.int.', '0.00266', '-', '0.00266)']
['system', 'ROUGE-S*', 'Average_P:', '0.04545', '(95%-conf.int.', '0.04545', '-', '0.04545)']
['system', 'ROUGE-S*', 'Average_F:', '0.00503', '(95%-conf.int.', '0.00503', '-', '0.00503)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1128', 'P:66', 'F:3']
dict_values(['This section measures performance on shared tasks in order of increasing complexity: sparse lookups, evaluating perplexity of a large file, and translation with Moses.'])
dict_values(['This paper describes the several performance techniques used and presents benchmarks against alternative implementations.', 'Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.', 'Performance improvements transfer to the Moses (Koehn et al., 2007), cdec (Dyer et al., 2010), and Joshua (Li et al., 2009) translation systems where our code has been integrated.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00280', '(95%-conf.int.', '0.00280', '-', '0.00280)']
['system', 'ROUGE-S*', 'Average_P:', '0.05000', '(95%-conf.int.', '0.05000', '-', '0.05000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00530', '(95%-conf.int.', '0.00530', '-', '0.00530)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2145', 'P:120', 'F:6']
dict_values(['We have described two data structures for language modeling that achieve substantial reductions in time and memory cost.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'This paper presents methods to query N-gram language models, minimizing time and space costs.', 'MITLM 0.4 (Hsu and Glass, 2008) is mostly designed for accurate model estimation, but can also compute perplexity.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01742', '(95%-conf.int.', '0.01742', '-', '0.01742)']
['system', 'ROUGE-S*', 'Average_P:', '0.33333', '(95%-conf.int.', '0.33333', '-', '0.33333)']
['system', 'ROUGE-S*', 'Average_F:', '0.03311', '(95%-conf.int.', '0.03311', '-', '0.03311)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:861', 'P:45', 'F:15']
dict_values(['Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke, 2002) is a popular toolkit based on tries used in several decoders.'])
dict_values(['The structure uses linear probing hash tables and is designed for speed.', 'Many packages perform language model queries.', 'All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00251', '(95%-conf.int.', '0.00251', '-', '0.00251)']
['system', 'ROUGE-S*', 'Average_P:', '0.05128', '(95%-conf.int.', '0.05128', '-', '0.05128)']
['system', 'ROUGE-S*', 'Average_F:', '0.00478', '(95%-conf.int.', '0.00478', '-', '0.00478)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:78', 'F:4']
dict_values(['This paper presents methods to query N-gram language models, minimizing time and space costs.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.', 'Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N &#8722; 1 preceding words.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01919', '(95%-conf.int.', '0.01919', '-', '0.01919)']
['system', 'ROUGE-S*', 'Average_P:', '0.34545', '(95%-conf.int.', '0.34545', '-', '0.34545)']
['system', 'ROUGE-S*', 'Average_F:', '0.03636', '(95%-conf.int.', '0.03636', '-', '0.03636)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:990', 'P:55', 'F:19']
dict_values(['We have modified Moses (Koehn et al., 2007) to keep our state with hypotheses; to conserve memory, phrases do not keep state.'])
dict_values(['BerkeleyLM revision 152 (Pauls and Klein, 2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.', 'Syntactic decoders, such as cdec (Dyer et al., 2010), build state from null context then store it in the hypergraph node for later extension.', 'This makes memory usage comparable to our PROBING model.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00164', '(95%-conf.int.', '0.00164', '-', '0.00164)']
['system', 'ROUGE-S*', 'Average_P:', '0.05455', '(95%-conf.int.', '0.05455', '-', '0.05455)']
['system', 'ROUGE-S*', 'Average_F:', '0.00318', '(95%-conf.int.', '0.00318', '-', '0.00318)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:55', 'F:3']
dict_values(['For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
dict_values(['IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.', 'The state function is integrated into the query process so that, in lieu of the query p(wnjwn&#8722;1 1 ), the application issues query p(wnjs(wn&#8722;1 1 )) which also returns s(wn1 ).', 'Memory usage is the same as with binary search and lower than with set.', 'For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
['system', 'ROUGE-S*', 'Average_R:', '0.16121', '(95%-conf.int.', '0.16121', '-', '0.16121)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.27766', '(95%-conf.int.', '0.27766', '-', '0.27766)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:325', 'F:325']
dict_values(['For the perplexity and translation tasks, we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn, 2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.'])
dict_values(['KenLM: Faster and Smaller Language Model Queries', 'We present KenLM, a library that implements two data structures for efficient language model queries, reducing both time and costs.', 'IRSTLM (Federico et al., 2008) is an open-source toolkit for building and querying language models.', 'All language model queries issued by machine translation decoders follow a left-to-right pattern, starting with either the begin of sentence token or null context for mid-sentence fragments.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01190', '(95%-conf.int.', '0.01190', '-', '0.01190)']
['system', 'ROUGE-S*', 'Average_P:', '0.04308', '(95%-conf.int.', '0.04308', '-', '0.04308)']
['system', 'ROUGE-S*', 'Average_F:', '0.01865', '(95%-conf.int.', '0.01865', '-', '0.01865)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1176', 'P:325', 'F:14']
0.4510927752717067 0.042996666427796294 0.07653722179701543





input/ref/Task1/W99-0613_aakansha.csv
input/res/Task1/W99-0613.annv3.csv
parsing: input/ref/Task1/W99-0613_aakansha.csv
<S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
<S sid="36" ssid="30">Roughly speaking, the new algorithm presented in this paper performs a similar search, but instead minimizes a bound on the number of (unlabeled) examples on which two classifiers disagree.</S>
original cit marker offset is 0
new cit marker offset is 0



["'36'"]
'36'
['36']
parsed_discourse_facet ['method_citation']
<S sid="137" ssid="4">The new algorithm, which we call CoBoost, uses labeled and unlabeled data and builds two classifiers in parallel.</S>
original cit marker offset is 0
new cit marker offset is 0



["'137'"]
'137'
['137']
parsed_discourse_facet ['method_citation']
<S sid="79" ssid="12">2 We now introduce a new algorithm for learning from unlabeled examples, which we will call DLCoTrain (DL stands for decision list, the term Cotrain is taken from (Blum and Mitchell 98)).</S>
original cit marker offset is 0
new cit marker offset is 0



["'79'"]
'79'
['79']
parsed_discourse_facet ['method_citation']
<S sid="10" ssid="4">The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'"]
'10'
['10']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="12">But we will show that the use of unlabeled data can drastically reduce the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'"]
'18'
['18']
parsed_discourse_facet ['method_citation']
<S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S>
    <S sid="237" ssid="4">The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'236'", "'237'"]
'236'
'237'
['236', '237']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S>
    <S sid="10" ssid="4">The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'10'"]
'9'
'10'
['9', '10']
parsed_discourse_facet ['method_citation']
<S sid="137" ssid="4">The new algorithm, which we call CoBoost, uses labeled and unlabeled data and builds two classifiers in parallel.</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S>
original cit marker offset is 0
new cit marker offset is 0



["'137'", "'39'"]
'137'
'39'
['137', '39']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="20">We present two algorithms.</S>
    <S sid="27" ssid="21">The first method builds on results from (Yarowsky 95) and (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'"]
'26'
'27'
['26', '27']
parsed_discourse_facet ['method_citation']
<S sid="18" ssid="12">But we will show that the use of unlabeled data can drastically reduce the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'18'"]
'18'
['18']
parsed_discourse_facet ['method_citation']
<S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'85'"]
'85'
['85']
parsed_discourse_facet ['method_citation']
<S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S>
    <S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'", "'9'"]
'8'
'9'
['8', '9']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W99-0613.annv3.csv
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="28" ssid="22">(Yarowsky 95) describes an algorithm for word-sense disambiguation that exploits redundancy in contextual features, and gives impressive performance.</S><S sid="30" ssid="24">(Blum and Mitchell 98) offer a promising formulation of redundancy, also prove some results about how the use of unlabeled examples can help classification, and suggest an objective function when training with unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'7'", "'28'", "'30'"]
'5'
'7'
'28'
'30'
['5', '7', '28', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="27">The second algorithm builds on a boosting algorithm called AdaBoost (Freund and Schapire 97; Schapire and Singer 98).</S><S sid="34" ssid="28">The AdaBoost algorithm was developed for supervised learning.</S><S sid="173" ssid="40">(3)), with one term for each classifier.</S><S sid="175" ssid="42">Put another way, the minimum of Equ.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'173'", "'175'"]
'33'
'34'
'173'
'175'
['33', '34', '173', '175']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S><S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'138'", "'139'", "'203'"]
'91'
'138'
'139'
'203'
['91', '138', '139', '203']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="14" ssid="8">A contextual rule considers words surrounding the string in the sentence in which it appears (e.g., a rule that any proper name modified by an appositive whose head is president is a person).</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="254" ssid="5">Future work should also extend the approach to build a complete named entity extractor - a method that pulls proper names from text and then classifies them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'14'", "'47'", "'254'"]
'2'
'14'
'47'
'254'
['2', '14', '47', '254']
parsed_discourse_facet ['hypothesis_citation']
<S sid="10" ssid="4">The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.</S><S sid="77" ssid="10">In this paper k = 3 (the three labels are person, organization, location), and we set a = 0.1.</S><S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S><S sid="237" ssid="4">The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'77'", "'236'", "'237'"]
'10'
'77'
'236'
'237'
['10', '77', '236', '237']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="18" ssid="12">But we will show that the use of unlabeled data can drastically reduce the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'18'"]
'1'
'2'
'8'
'18'
['1', '2', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="202" ssid="69">The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'47'", "'202'"]
'1'
'9'
'47'
'202'
['1', '9', '47', '202']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="10">Supervised methods have been applied quite successfully to the full MUC named-entity task (Bikel et al. 97).</S><S sid="29" ssid="23">Unfortunately, Yarowsky\s method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.</S><S sid="56" ssid="10">In the appositive case, the contextual predictor was the head of the modifying appositive (president in the Maury Cooper example); in the second case, the contextual predictor was the preposition together with the noun it modifies (plant_in in the Georgia example).</S><S sid="232" ssid="11">For example, the independence assumptions mean that the model fails to capture the dependence between specific and more general features (for example the fact that the feature full.-string=New_York is always seen with the features contains (New) and The baseline method tags all entities as the most frequent class type (organization). contains (York) and is never seen with a feature such as contains (Group) ).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'29'", "'56'", "'232'"]
'16'
'29'
'56'
'232'
['16', '29', '56', '232']
parsed_discourse_facet ['hypothesis_citation']
<S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="219" ssid="86">Finally, we would like to note that it is possible to devise similar algorithms based with other objective functions than the one given in Equ.</S><S sid="251" ssid="2">In addition to a heuristic based on decision list learning, we also presented a boosting-like framework that builds on ideas from (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'", "'139'", "'219'", "'251'"]
'138'
'139'
'219'
'251'
['138', '139', '219', '251']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="6" ssid="6">The second algorithm extends ideas from boosting algorithms, designed for supervised learning tasks, to the framework suggested by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="31" ssid="25">Our first algorithm is similar to Yarowsky\s, but with some important modifications motivated by (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'6'", "'7'", "'31'"]
'5'
'6'
'7'
'31'
['5', '6', '7', '31']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="141" ssid="8">For a description of the application of AdaBoost to various NLP problems see the paper by Abney, Schapire, and Singer in this volume.</S><S sid="153" ssid="20">Schapire and Singer show that the training error is bounded above by Thus, in order to greedily minimize an upper bound on training error, on each iteration we should search for the weak hypothesis ht and the weight at that minimize Z.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'141'", "'153'", "'203'"]
'7'
'141'
'153'
'203'
['7', '141', '153', '203']
parsed_discourse_facet ['hypothesis_citation']
<S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="82" ssid="15">In the named entity domain these rules were Each of these rules was given a strength of 0.9999.</S><S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'60'", "'82'", "'85'", "'140'"]
'60'
'82'
'85'
'140'
['60', '82', '85', '140']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'8'", "'60'", "'140'"]
'5'
'8'
'60'
'140'
['5', '8', '60', '140']
parsed_discourse_facet ['results_citation']
dict_values(['Roughly speaking, the new algorithm presented in this paper performs a similar search, but instead minimizes a bound on the number of (unlabeled) examples on which two classifiers disagree.'])
dict_values(['The second algorithm builds on a boosting algorithm called AdaBoost (Freund and Schapire 97; Schapire and Singer 98).', 'The AdaBoost algorithm was developed for supervised learning.', '(3)), with one term for each classifier.', 'Put another way, the minimum of Equ.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00395', '(95%-conf.int.', '0.00395', '-', '0.00395)']
['system', 'ROUGE-S*', 'Average_P:', '0.00952', '(95%-conf.int.', '0.00952', '-', '0.00952)']
['system', 'ROUGE-S*', 'Average_F:', '0.00559', '(95%-conf.int.', '0.00559', '-', '0.00559)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:253', 'P:105', 'F:1']
dict_values(['The new algorithm, which we call CoBoost, uses labeled and unlabeled data and builds two classifiers in parallel.'])
dict_values(['There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.', '(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\\s (Valiant 84) Probably Approximately Correct (PAC) model.)', 'This section describes AdaBoost, which is the basis for the CoBoost algorithm.', 'Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00185', '(95%-conf.int.', '0.00185', '-', '0.00185)']
['system', 'ROUGE-S*', 'Average_P:', '0.05556', '(95%-conf.int.', '0.05556', '-', '0.05556)']
['system', 'ROUGE-S*', 'Average_F:', '0.00358', '(95%-conf.int.', '0.00358', '-', '0.00358)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1081', 'P:36', 'F:2']
dict_values(['The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.'])
dict_values(['The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.', 'In this paper k = 3 (the three labels are person, organization, location), and we set a = 0.1.', 'We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.', 'The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.'])
['system', 'ROUGE-S*', 'Average_R:', '0.09512', '(95%-conf.int.', '0.09512', '-', '0.09512)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.17372', '(95%-conf.int.', '0.17372', '-', '0.17372)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:78', 'F:78']
dict_values(['But we will show that the use of unlabeled data can drastically reduce the need for supervision.'])
dict_values(['This paper discusses the use of unlabeled examples for the problem of named entity classification.', 'A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &quot;seed&quot; rules.', 'Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.', 'But we will show that the use of unlabeled data can drastically reduce the need for supervision.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01010', '(95%-conf.int.', '0.01010', '-', '0.01010)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.02000', '(95%-conf.int.', '0.02000', '-', '0.02000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:15', 'F:15']
dict_values(['We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.', 'The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.'])
dict_values(['This paper discusses the use of unlabeled examples for the problem of named entity classification.', 'This paper discusses the use of unlabeled examples for the problem of named entity classification.', '971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).', 'The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1431', 'P:171', 'F:0']
dict_values(['This paper discusses the use of unlabeled examples for the problem of named entity classification.', 'The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.'])
dict_values(['Supervised methods have been applied quite successfully to the full MUC named-entity task (Bikel et al. 97).', 'Unfortunately, Yarowsky\\s method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.', 'In the appositive case, the contextual predictor was the head of the modifying appositive (president in the Maury Cooper example); in the second case, the contextual predictor was the preposition together with the noun it modifies (plant_in in the Georgia example).', 'For example, the independence assumptions mean that the model fails to capture the dependence between specific and more general features (for example the fact that the feature full.-string=New_York is always seen with the features contains (New) and The baseline method tags all entities as the most frequent class type (organization). contains (York) and is never seen with a feature such as contains (Group) ).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01369', '(95%-conf.int.', '0.01369', '-', '0.01369)']
['system', 'ROUGE-S*', 'Average_P:', '0.16667', '(95%-conf.int.', '0.16667', '-', '0.16667)']
['system', 'ROUGE-S*', 'Average_F:', '0.02531', '(95%-conf.int.', '0.02531', '-', '0.02531)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2556', 'P:210', 'F:35']
dict_values(['The new algorithm, which we call CoBoost, uses labeled and unlabeled data and builds two classifiers in parallel.', 'This section describes AdaBoost, which is the basis for the CoBoost algorithm.'])
dict_values(['(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\\s (Valiant 84) Probably Approximately Correct (PAC) model.)', 'This section describes AdaBoost, which is the basis for the CoBoost algorithm.', 'Finally, we would like to note that it is possible to devise similar algorithms based with other objective functions than the one given in Equ.', 'In addition to a heuristic based on decision list learning, we also presented a boosting-like framework that builds on ideas from (Blum and Mitchell 98).'])
['system', 'ROUGE-S*', 'Average_R:', '0.02899', '(95%-conf.int.', '0.02899', '-', '0.02899)']
['system', 'ROUGE-S*', 'Average_P:', '0.28571', '(95%-conf.int.', '0.28571', '-', '0.28571)']
['system', 'ROUGE-S*', 'Average_F:', '0.05263', '(95%-conf.int.', '0.05263', '-', '0.05263)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:105', 'F:30']
dict_values(['We present two algorithms.', 'The first method builds on results from (Yarowsky 95) and (Blum and Mitchell 98).'])
dict_values(['The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).', 'The second algorithm extends ideas from boosting algorithms, designed for supervised learning tasks, to the framework suggested by (Blum and Mitchell 98).', 'Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.', 'Our first algorithm is similar to Yarowsky\\s, but with some important modifications motivated by (Blum and Mitchell 98).'])
['system', 'ROUGE-S*', 'Average_R:', '0.02204', '(95%-conf.int.', '0.02204', '-', '0.02204)']
['system', 'ROUGE-S*', 'Average_P:', '0.49091', '(95%-conf.int.', '0.49091', '-', '0.49091)']
['system', 'ROUGE-S*', 'Average_F:', '0.04219', '(95%-conf.int.', '0.04219', '-', '0.04219)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:55', 'F:27']
dict_values(['(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.'])
dict_values(['In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.', 'In the named entity domain these rules were Each of these rules was given a strength of 0.9999.', '(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.', 'AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.'])
['system', 'ROUGE-S*', 'Average_R:', '0.25352', '(95%-conf.int.', '0.25352', '-', '0.25352)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.40449', '(95%-conf.int.', '0.40449', '-', '0.40449)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2485', 'P:630', 'F:630']
dict_values(['Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.', 'This paper discusses the use of unlabeled examples for the problem of named entity classification.'])
dict_values(['The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).', 'Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.', 'In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.', 'AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.'])
['system', 'ROUGE-S*', 'Average_R:', '0.09071', '(95%-conf.int.', '0.09071', '-', '0.09071)']
['system', 'ROUGE-S*', 'Average_P:', '0.49407', '(95%-conf.int.', '0.49407', '-', '0.49407)']
['system', 'ROUGE-S*', 'Average_F:', '0.15328', '(95%-conf.int.', '0.15328', '-', '0.15328)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:253', 'F:125']
0.45024399549756 0.051996999480030004 0.08807899911921002





input/ref/Task1/W99-0613_swastika.csv
input/res/Task1/W99-0613.annv3.csv
parsing: input/ref/Task1/W99-0613_swastika.csv
<S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S>
original cit marker offset is 0
new cit marker offset is 0



['9']
9
['9']
parsed_discourse_facet ['aim_citation']
<S sid="159" ssid="26">To prevent this we &amp;quot;smooth&amp;quot; the confidence by adding a small value, e, to both W+ and W_, giving at = Plugging the value of at from Equ.</S>
original cit marker offset is 0
new cit marker offset is 0



['159']
159
['159']
parsed_discourse_facet ['method_citation']
<S sid="137" ssid="4">The new algorithm, which we call CoBoost, uses labeled and unlabeled data and builds two classifiers in parallel.</S>
original cit marker offset is 0
new cit marker offset is 0



['137']
137
['137']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S>
original cit marker offset is 0
new cit marker offset is 0



['91']
91
['91']
parsed_discourse_facet ['method_citation']
<S sid="213" ssid="80">Thus at each iteration the algorithm is forced to pick features for the location, person and organization in turn for the classifier being trained.</S>
original cit marker offset is 0
new cit marker offset is 0



['213']
213
['213']
parsed_discourse_facet ['method_citation']
 <S sid="250" ssid="1">Unlabeled examples in the named-entity classification problem can reduce the need for supervision to a handful of seed rules.</S>
original cit marker offset is 0
new cit marker offset is 0



['250']
250
['250']
parsed_discourse_facet ['result_citation']
<S sid="213" ssid="80">Thus at each iteration the algorithm is forced to pick features for the location, person and organization in turn for the classifier being trained.</S>
original cit marker offset is 0
new cit marker offset is 0



['213']
213
['213']
parsed_discourse_facet ['method_citation']
<S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S>
original cit marker offset is 0
new cit marker offset is 0



['9']
9
['9']
parsed_discourse_facet ['aim_citation']
    <S sid="36" ssid="30">Roughly speaking, the new algorithm presented in this paper performs a similar search, but instead minimizes a bound on the number of (unlabeled) examples on which two classifiers disagree.</S>
original cit marker offset is 0
new cit marker offset is 0



['36']
36
['36']
parsed_discourse_facet ['result_citation']
<S sid="29" ssid="23">Unfortunately, Yarowsky's method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.</S>
original cit marker offset is 0
new cit marker offset is 0



['29']
29
['29']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S>
original cit marker offset is 0
new cit marker offset is 0



['7']
7
['7']
parsed_discourse_facet ['aim_citation']
    <S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



['85']
85
['85']
parsed_discourse_facet ['method_citation']
    <S sid="95" ssid="28">(Specifically, the limit n starts at 5 and increases by 5 at each iteration.)</S>
original cit marker offset is 0
new cit marker offset is 0



['95']
95
['95']
parsed_discourse_facet ['method_citation']
<S sid="213" ssid="80">Thus at each iteration the algorithm is forced to pick features for the location, person and organization in turn for the classifier being trained.</S>
original cit marker offset is 0
new cit marker offset is 0



['213']
213
['213']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W99-0613.annv3.csv
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="28" ssid="22">(Yarowsky 95) describes an algorithm for word-sense disambiguation that exploits redundancy in contextual features, and gives impressive performance.</S><S sid="30" ssid="24">(Blum and Mitchell 98) offer a promising formulation of redundancy, also prove some results about how the use of unlabeled examples can help classification, and suggest an objective function when training with unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'7'", "'28'", "'30'"]
'5'
'7'
'28'
'30'
['5', '7', '28', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="27">The second algorithm builds on a boosting algorithm called AdaBoost (Freund and Schapire 97; Schapire and Singer 98).</S><S sid="34" ssid="28">The AdaBoost algorithm was developed for supervised learning.</S><S sid="173" ssid="40">(3)), with one term for each classifier.</S><S sid="175" ssid="42">Put another way, the minimum of Equ.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'173'", "'175'"]
'33'
'34'
'173'
'175'
['33', '34', '173', '175']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S><S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'138'", "'139'", "'203'"]
'91'
'138'
'139'
'203'
['91', '138', '139', '203']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="14" ssid="8">A contextual rule considers words surrounding the string in the sentence in which it appears (e.g., a rule that any proper name modified by an appositive whose head is president is a person).</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="254" ssid="5">Future work should also extend the approach to build a complete named entity extractor - a method that pulls proper names from text and then classifies them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'14'", "'47'", "'254'"]
'2'
'14'
'47'
'254'
['2', '14', '47', '254']
parsed_discourse_facet ['hypothesis_citation']
<S sid="10" ssid="4">The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.</S><S sid="77" ssid="10">In this paper k = 3 (the three labels are person, organization, location), and we set a = 0.1.</S><S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S><S sid="237" ssid="4">The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'77'", "'236'", "'237'"]
'10'
'77'
'236'
'237'
['10', '77', '236', '237']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="18" ssid="12">But we will show that the use of unlabeled data can drastically reduce the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'18'"]
'1'
'2'
'8'
'18'
['1', '2', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="202" ssid="69">The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'47'", "'202'"]
'1'
'9'
'47'
'202'
['1', '9', '47', '202']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="10">Supervised methods have been applied quite successfully to the full MUC named-entity task (Bikel et al. 97).</S><S sid="29" ssid="23">Unfortunately, Yarowsky\s method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.</S><S sid="56" ssid="10">In the appositive case, the contextual predictor was the head of the modifying appositive (president in the Maury Cooper example); in the second case, the contextual predictor was the preposition together with the noun it modifies (plant_in in the Georgia example).</S><S sid="232" ssid="11">For example, the independence assumptions mean that the model fails to capture the dependence between specific and more general features (for example the fact that the feature full.-string=New_York is always seen with the features contains (New) and The baseline method tags all entities as the most frequent class type (organization). contains (York) and is never seen with a feature such as contains (Group) ).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'29'", "'56'", "'232'"]
'16'
'29'
'56'
'232'
['16', '29', '56', '232']
parsed_discourse_facet ['hypothesis_citation']
<S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="219" ssid="86">Finally, we would like to note that it is possible to devise similar algorithms based with other objective functions than the one given in Equ.</S><S sid="251" ssid="2">In addition to a heuristic based on decision list learning, we also presented a boosting-like framework that builds on ideas from (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'", "'139'", "'219'", "'251'"]
'138'
'139'
'219'
'251'
['138', '139', '219', '251']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="6" ssid="6">The second algorithm extends ideas from boosting algorithms, designed for supervised learning tasks, to the framework suggested by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="31" ssid="25">Our first algorithm is similar to Yarowsky\s, but with some important modifications motivated by (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'6'", "'7'", "'31'"]
'5'
'6'
'7'
'31'
['5', '6', '7', '31']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="141" ssid="8">For a description of the application of AdaBoost to various NLP problems see the paper by Abney, Schapire, and Singer in this volume.</S><S sid="153" ssid="20">Schapire and Singer show that the training error is bounded above by Thus, in order to greedily minimize an upper bound on training error, on each iteration we should search for the weak hypothesis ht and the weight at that minimize Z.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'141'", "'153'", "'203'"]
'7'
'141'
'153'
'203'
['7', '141', '153', '203']
parsed_discourse_facet ['hypothesis_citation']
<S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="82" ssid="15">In the named entity domain these rules were Each of these rules was given a strength of 0.9999.</S><S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'60'", "'82'", "'85'", "'140'"]
'60'
'82'
'85'
'140'
['60', '82', '85', '140']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'8'", "'60'", "'140'"]
'5'
'8'
'60'
'140'
['5', '8', '60', '140']
parsed_discourse_facet ['results_citation']
dict_values(['To prevent this we &quot;smooth&quot; the confidence by adding a small value, e, to both W+ and W_, giving at = Plugging the value of at from Equ.'])
dict_values(['The second algorithm builds on a boosting algorithm called AdaBoost (Freund and Schapire 97; Schapire and Singer 98).', 'The AdaBoost algorithm was developed for supervised learning.', '(3)), with one term for each classifier.', 'Put another way, the minimum of Equ.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:253', 'P:45', 'F:0']
dict_values(['The new algorithm, which we call CoBoost, uses labeled and unlabeled data and builds two classifiers in parallel.'])
dict_values(['There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.', '(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\\s (Valiant 84) Probably Approximately Correct (PAC) model.)', 'This section describes AdaBoost, which is the basis for the CoBoost algorithm.', 'Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00185', '(95%-conf.int.', '0.00185', '-', '0.00185)']
['system', 'ROUGE-S*', 'Average_P:', '0.05556', '(95%-conf.int.', '0.05556', '-', '0.05556)']
['system', 'ROUGE-S*', 'Average_F:', '0.00358', '(95%-conf.int.', '0.00358', '-', '0.00358)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1081', 'P:36', 'F:2']
dict_values(['Thus at each iteration the algorithm is forced to pick features for the location, person and organization in turn for the classifier being trained.'])
dict_values(['The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.', 'In this paper k = 3 (the three labels are person, organization, location), and we set a = 0.1.', 'We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.', 'The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00366', '(95%-conf.int.', '0.00366', '-', '0.00366)']
['system', 'ROUGE-S*', 'Average_P:', '0.05455', '(95%-conf.int.', '0.05455', '-', '0.05455)']
['system', 'ROUGE-S*', 'Average_F:', '0.00686', '(95%-conf.int.', '0.00686', '-', '0.00686)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:55', 'F:3']
dict_values(['Unlabeled examples in the named-entity classification problem can reduce the need for supervision to a handful of seed rules.'])
dict_values(['This paper discusses the use of unlabeled examples for the problem of named entity classification.', 'A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &quot;seed&quot; rules.', 'Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.', 'But we will show that the use of unlabeled data can drastically reduce the need for supervision.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02828', '(95%-conf.int.', '0.02828', '-', '0.02828)']
['system', 'ROUGE-S*', 'Average_P:', '0.76364', '(95%-conf.int.', '0.76364', '-', '0.76364)']
['system', 'ROUGE-S*', 'Average_F:', '0.05455', '(95%-conf.int.', '0.05455', '-', '0.05455)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:55', 'F:42']
dict_values(['Thus at each iteration the algorithm is forced to pick features for the location, person and organization in turn for the classifier being trained.'])
dict_values(['This paper discusses the use of unlabeled examples for the problem of named entity classification.', 'This paper discusses the use of unlabeled examples for the problem of named entity classification.', '971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).', 'The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1431', 'P:55', 'F:0']
dict_values(['This paper discusses the use of unlabeled examples for the problem of named entity classification.'])
dict_values(['Supervised methods have been applied quite successfully to the full MUC named-entity task (Bikel et al. 97).', 'Unfortunately, Yarowsky\\s method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.', 'In the appositive case, the contextual predictor was the head of the modifying appositive (president in the Maury Cooper example); in the second case, the contextual predictor was the preposition together with the noun it modifies (plant_in in the Georgia example).', 'For example, the independence assumptions mean that the model fails to capture the dependence between specific and more general features (for example the fact that the feature full.-string=New_York is always seen with the features contains (New) and The baseline method tags all entities as the most frequent class type (organization). contains (York) and is never seen with a feature such as contains (Group) ).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00078', '(95%-conf.int.', '0.00078', '-', '0.00078)']
['system', 'ROUGE-S*', 'Average_P:', '0.07143', '(95%-conf.int.', '0.07143', '-', '0.07143)']
['system', 'ROUGE-S*', 'Average_F:', '0.00155', '(95%-conf.int.', '0.00155', '-', '0.00155)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2556', 'P:28', 'F:2']
dict_values(["Unfortunately, Yarowsky's method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function."])
dict_values(['The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).', 'The second algorithm extends ideas from boosting algorithms, designed for supervised learning tasks, to the framework suggested by (Blum and Mitchell 98).', 'Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.', 'Our first algorithm is similar to Yarowsky\\s, but with some important modifications motivated by (Blum and Mitchell 98).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00408', '(95%-conf.int.', '0.00408', '-', '0.00408)']
['system', 'ROUGE-S*', 'Average_P:', '0.04167', '(95%-conf.int.', '0.04167', '-', '0.04167)']
['system', 'ROUGE-S*', 'Average_F:', '0.00743', '(95%-conf.int.', '0.00743', '-', '0.00743)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:120', 'F:5']
dict_values(['(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.'])
dict_values(['In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.', 'In the named entity domain these rules were Each of these rules was given a strength of 0.9999.', '(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.', 'AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.'])
['system', 'ROUGE-S*', 'Average_R:', '0.25352', '(95%-conf.int.', '0.25352', '-', '0.25352)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.40449', '(95%-conf.int.', '0.40449', '-', '0.40449)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2485', 'P:630', 'F:630']
dict_values(['Thus at each iteration the algorithm is forced to pick features for the location, person and organization in turn for the classifier being trained.'])
dict_values(['The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).', 'Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.', 'In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.', 'AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00073', '(95%-conf.int.', '0.00073', '-', '0.00073)']
['system', 'ROUGE-S*', 'Average_P:', '0.01818', '(95%-conf.int.', '0.01818', '-', '0.01818)']
['system', 'ROUGE-S*', 'Average_F:', '0.00140', '(95%-conf.int.', '0.00140', '-', '0.00140)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:55', 'F:1']
0.22278110863576547 0.03254444408283952 0.05331777718535804





input/ref/Task1/W99-0613_sweta.csv
input/res/Task1/W99-0613.annv3.csv
parsing: input/ref/Task1/W99-0613_sweta.csv
<S sid="121" ssid="54">They also describe an application of cotraining to classifying web pages (the to feature sets are the words on the page, and other pages pointing to the page).</S>
original cit marker offset is 0
new cit marker offset is 0



["121'"]
121'
['121']
parsed_discourse_facet ['method_citation']
<S sid="252" ssid="3">The method uses a &amp;quot;soft&amp;quot; measure of the agreement between two classifiers as an objective function; we described an algorithm which directly optimizes this function.</S>
original cit marker offset is 0
new cit marker offset is 0



["252'"]
252'
['252']
parsed_discourse_facet ['method_citation']
 <S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S>
original cit marker offset is 0
new cit marker offset is 0



["91'"]
91'
['91']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S>
original cit marker offset is 0
new cit marker offset is 0



["91'"]
91'
['91']
parsed_discourse_facet ['method_citation']
 <S sid="213" ssid="80">Thus at each iteration the algorithm is forced to pick features for the location, person and organization in turn for the classifier being trained.</S>
original cit marker offset is 0
new cit marker offset is 0



["213'"]
213'
['213']
parsed_discourse_facet ['method_citation']
 <S sid="250" ssid="1">Unlabeled examples in the named-entity classification problem can reduce the need for supervision to a handful of seed rules.</S>
original cit marker offset is 0
new cit marker offset is 0



["250'"]
250'
['250']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="33">(Brin 98) ,describes a system for extracting (author, book-title) pairs from the World Wide Web using an approach that bootstraps from an initial seed set of examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["39'"]
39'
['39']
parsed_discourse_facet ['method_citation']
<S sid="202" ssid="69">The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.</S>
original cit marker offset is 0
new cit marker offset is 0



["202'"]
202'
['202']
parsed_discourse_facet ['method_citation']
<S sid="61" ssid="15">The following features were used: full-string=x The full string (e.g., for Maury Cooper, full- s tring=Maury_Cooper). contains(x) If the spelling contains more than one word, this feature applies for any words that the string contains (e.g., Maury Cooper contributes two such features, contains (Maury) and contains (Cooper) . allcapl This feature appears if the spelling is a single word which is all capitals (e.g., IBM would contribute this feature). allcap2 This feature appears if the spelling is a single word which is all capitals or full periods, and contains at least one period.</S>
original cit marker offset is 0
new cit marker offset is 0



["61'"]
61'
['61']
parsed_discourse_facet ['method_citation']
<S sid="176" ssid="43">(7) is at 0 when: 1) Vi : sign(gi (xi)) = sign(g2 (xi)); 2) Ig3(xi)l oo; and 3) sign(gi (xi)) = yi for i = 1, , m. In fact, Zco provides a bound on the sum of the classification error of the labeled examples and the number of disagreements between the two classifiers on the unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["176'"]
176'
['176']
parsed_discourse_facet ['method_citation']
 <S sid="108" ssid="41">In the cotraining case, (Blum and Mitchell 98) argue that the task should be to induce functions Ii and f2 such that So Ii and 12 must (1) correctly classify the labeled examples, and (2) must agree with each other on the unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["108'"]
108'
['108']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="21">The first method builds on results from (Yarowsky 95) and (Blum and Mitchell 98).</S>
    <S sid="28" ssid="22">(Yarowsky 95) describes an algorithm for word-sense disambiguation that exploits redundancy in contextual features, and gives impressive performance.</S>
original cit marker offset is 0
new cit marker offset is 0



["27'", "'28'"]
27'
'28'
['27', '28']
parsed_discourse_facet ['method_citation']
<S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["7'"]
7'
['7']
parsed_discourse_facet ['method_citation']
 <S sid="172" ssid="39">To see this, note thai the first two terms in the above equation correspond to the function that AdaBoost attempts to minimize in the standard supervised setting (Equ.</S>
original cit marker offset is 0
new cit marker offset is 0



["172'"]
172'
['172']
parsed_discourse_facet ['method_citation']
<S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["85'"]
85'
['85']
parsed_discourse_facet ['method_citation']
 <S sid="214" ssid="81">This modification brings the method closer to the DL-CoTrain algorithm described earlier, and is motivated by the intuition that all three labels should be kept healthily populated in the unlabeled examples, preventing one label from dominating &#8212; this deserves more theoretical investigation.</S>
original cit marker offset is 0
new cit marker offset is 0



["214'"]
214'
['214']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W99-0613.annv3.csv
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="28" ssid="22">(Yarowsky 95) describes an algorithm for word-sense disambiguation that exploits redundancy in contextual features, and gives impressive performance.</S><S sid="30" ssid="24">(Blum and Mitchell 98) offer a promising formulation of redundancy, also prove some results about how the use of unlabeled examples can help classification, and suggest an objective function when training with unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'7'", "'28'", "'30'"]
'5'
'7'
'28'
'30'
['5', '7', '28', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="27">The second algorithm builds on a boosting algorithm called AdaBoost (Freund and Schapire 97; Schapire and Singer 98).</S><S sid="34" ssid="28">The AdaBoost algorithm was developed for supervised learning.</S><S sid="173" ssid="40">(3)), with one term for each classifier.</S><S sid="175" ssid="42">Put another way, the minimum of Equ.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'173'", "'175'"]
'33'
'34'
'173'
'175'
['33', '34', '173', '175']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S><S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'138'", "'139'", "'203'"]
'91'
'138'
'139'
'203'
['91', '138', '139', '203']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="14" ssid="8">A contextual rule considers words surrounding the string in the sentence in which it appears (e.g., a rule that any proper name modified by an appositive whose head is president is a person).</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="254" ssid="5">Future work should also extend the approach to build a complete named entity extractor - a method that pulls proper names from text and then classifies them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'14'", "'47'", "'254'"]
'2'
'14'
'47'
'254'
['2', '14', '47', '254']
parsed_discourse_facet ['hypothesis_citation']
<S sid="10" ssid="4">The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.</S><S sid="77" ssid="10">In this paper k = 3 (the three labels are person, organization, location), and we set a = 0.1.</S><S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S><S sid="237" ssid="4">The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'77'", "'236'", "'237'"]
'10'
'77'
'236'
'237'
['10', '77', '236', '237']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="18" ssid="12">But we will show that the use of unlabeled data can drastically reduce the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'18'"]
'1'
'2'
'8'
'18'
['1', '2', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="202" ssid="69">The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'47'", "'202'"]
'1'
'9'
'47'
'202'
['1', '9', '47', '202']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="10">Supervised methods have been applied quite successfully to the full MUC named-entity task (Bikel et al. 97).</S><S sid="29" ssid="23">Unfortunately, Yarowsky\s method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.</S><S sid="56" ssid="10">In the appositive case, the contextual predictor was the head of the modifying appositive (president in the Maury Cooper example); in the second case, the contextual predictor was the preposition together with the noun it modifies (plant_in in the Georgia example).</S><S sid="232" ssid="11">For example, the independence assumptions mean that the model fails to capture the dependence between specific and more general features (for example the fact that the feature full.-string=New_York is always seen with the features contains (New) and The baseline method tags all entities as the most frequent class type (organization). contains (York) and is never seen with a feature such as contains (Group) ).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'29'", "'56'", "'232'"]
'16'
'29'
'56'
'232'
['16', '29', '56', '232']
parsed_discourse_facet ['hypothesis_citation']
<S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="219" ssid="86">Finally, we would like to note that it is possible to devise similar algorithms based with other objective functions than the one given in Equ.</S><S sid="251" ssid="2">In addition to a heuristic based on decision list learning, we also presented a boosting-like framework that builds on ideas from (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'", "'139'", "'219'", "'251'"]
'138'
'139'
'219'
'251'
['138', '139', '219', '251']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="6" ssid="6">The second algorithm extends ideas from boosting algorithms, designed for supervised learning tasks, to the framework suggested by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="31" ssid="25">Our first algorithm is similar to Yarowsky\s, but with some important modifications motivated by (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'6'", "'7'", "'31'"]
'5'
'6'
'7'
'31'
['5', '6', '7', '31']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="141" ssid="8">For a description of the application of AdaBoost to various NLP problems see the paper by Abney, Schapire, and Singer in this volume.</S><S sid="153" ssid="20">Schapire and Singer show that the training error is bounded above by Thus, in order to greedily minimize an upper bound on training error, on each iteration we should search for the weak hypothesis ht and the weight at that minimize Z.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'141'", "'153'", "'203'"]
'7'
'141'
'153'
'203'
['7', '141', '153', '203']
parsed_discourse_facet ['hypothesis_citation']
<S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="82" ssid="15">In the named entity domain these rules were Each of these rules was given a strength of 0.9999.</S><S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'60'", "'82'", "'85'", "'140'"]
'60'
'82'
'85'
'140'
['60', '82', '85', '140']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'8'", "'60'", "'140'"]
'5'
'8'
'60'
'140'
['5', '8', '60', '140']
parsed_discourse_facet ['results_citation']
dict_values(['The method uses a &quot;soft&quot; measure of the agreement between two classifiers as an objective function; we described an algorithm which directly optimizes this function.'])
dict_values(['The second algorithm builds on a boosting algorithm called AdaBoost (Freund and Schapire 97; Schapire and Singer 98).', 'The AdaBoost algorithm was developed for supervised learning.', '(3)), with one term for each classifier.', 'Put another way, the minimum of Equ.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:253', 'P:78', 'F:0']
dict_values(['There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.'])
dict_values(['There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.', '(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\\s (Valiant 84) Probably Approximately Correct (PAC) model.)', 'This section describes AdaBoost, which is the basis for the CoBoost algorithm.', 'Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).'])
['system', 'ROUGE-S*', 'Average_R:', '0.07216', '(95%-conf.int.', '0.07216', '-', '0.07216)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.13460', '(95%-conf.int.', '0.13460', '-', '0.13460)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1081', 'P:78', 'F:78']
dict_values(['Thus at each iteration the algorithm is forced to pick features for the location, person and organization in turn for the classifier being trained.'])
dict_values(['The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.', 'In this paper k = 3 (the three labels are person, organization, location), and we set a = 0.1.', 'We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.', 'The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00366', '(95%-conf.int.', '0.00366', '-', '0.00366)']
['system', 'ROUGE-S*', 'Average_P:', '0.05455', '(95%-conf.int.', '0.05455', '-', '0.05455)']
['system', 'ROUGE-S*', 'Average_F:', '0.00686', '(95%-conf.int.', '0.00686', '-', '0.00686)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:55', 'F:3']
dict_values(['Unlabeled examples in the named-entity classification problem can reduce the need for supervision to a handful of seed rules.'])
dict_values(['This paper discusses the use of unlabeled examples for the problem of named entity classification.', 'A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &quot;seed&quot; rules.', 'Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.', 'But we will show that the use of unlabeled data can drastically reduce the need for supervision.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02828', '(95%-conf.int.', '0.02828', '-', '0.02828)']
['system', 'ROUGE-S*', 'Average_P:', '0.76364', '(95%-conf.int.', '0.76364', '-', '0.76364)']
['system', 'ROUGE-S*', 'Average_F:', '0.05455', '(95%-conf.int.', '0.05455', '-', '0.05455)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:55', 'F:42']
dict_values(['The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.'])
dict_values(['This paper discusses the use of unlabeled examples for the problem of named entity classification.', 'This paper discusses the use of unlabeled examples for the problem of named entity classification.', '971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).', 'The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.'])
['system', 'ROUGE-S*', 'Average_R:', '0.06359', '(95%-conf.int.', '0.06359', '-', '0.06359)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.11958', '(95%-conf.int.', '0.11958', '-', '0.11958)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1431', 'P:91', 'F:91']
dict_values(['The following features were used: full-string=x The full string (e.g., for Maury Cooper, full- s tring=Maury_Cooper). contains(x) If the spelling contains more than one word, this feature applies for any words that the string contains (e.g., Maury Cooper contributes two such features, contains (Maury) and contains (Cooper) . allcapl This feature appears if the spelling is a single word which is all capitals (e.g., IBM would contribute this feature). allcap2 This feature appears if the spelling is a single word which is all capitals or full periods, and contains at least one period.'])
dict_values(['Supervised methods have been applied quite successfully to the full MUC named-entity task (Bikel et al. 97).', 'Unfortunately, Yarowsky\\s method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.', 'In the appositive case, the contextual predictor was the head of the modifying appositive (president in the Maury Cooper example); in the second case, the contextual predictor was the preposition together with the noun it modifies (plant_in in the Georgia example).', 'For example, the independence assumptions mean that the model fails to capture the dependence between specific and more general features (for example the fact that the feature full.-string=New_York is always seen with the features contains (New) and The baseline method tags all entities as the most frequent class type (organization). contains (York) and is never seen with a feature such as contains (Group) ).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01721', '(95%-conf.int.', '0.01721', '-', '0.01721)']
['system', 'ROUGE-S*', 'Average_P:', '0.04873', '(95%-conf.int.', '0.04873', '-', '0.04873)']
['system', 'ROUGE-S*', 'Average_F:', '0.02544', '(95%-conf.int.', '0.02544', '-', '0.02544)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2556', 'P:903', 'F:44']
dict_values(['In the cotraining case, (Blum and Mitchell 98) argue that the task should be to induce functions Ii and f2 such that So Ii and 12 must (1) correctly classify the labeled examples, and (2) must agree with each other on the unlabeled examples.'])
dict_values(['(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\\s (Valiant 84) Probably Approximately Correct (PAC) model.)', 'This section describes AdaBoost, which is the basis for the CoBoost algorithm.', 'Finally, we would like to note that it is possible to devise similar algorithms based with other objective functions than the one given in Equ.', 'In addition to a heuristic based on decision list learning, we also presented a boosting-like framework that builds on ideas from (Blum and Mitchell 98).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00290', '(95%-conf.int.', '0.00290', '-', '0.00290)']
['system', 'ROUGE-S*', 'Average_P:', '0.01299', '(95%-conf.int.', '0.01299', '-', '0.01299)']
['system', 'ROUGE-S*', 'Average_F:', '0.00474', '(95%-conf.int.', '0.00474', '-', '0.00474)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:231', 'F:3']
dict_values(['The first method builds on results from (Yarowsky 95) and (Blum and Mitchell 98).', '(Yarowsky 95) describes an algorithm for word-sense disambiguation that exploits redundancy in contextual features, and gives impressive performance.'])
dict_values(['The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).', 'The second algorithm extends ideas from boosting algorithms, designed for supervised learning tasks, to the framework suggested by (Blum and Mitchell 98).', 'Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.', 'Our first algorithm is similar to Yarowsky\\s, but with some important modifications motivated by (Blum and Mitchell 98).'])
['system', 'ROUGE-S*', 'Average_R:', '0.03020', '(95%-conf.int.', '0.03020', '-', '0.03020)']
['system', 'ROUGE-S*', 'Average_P:', '0.16017', '(95%-conf.int.', '0.16017', '-', '0.16017)']
['system', 'ROUGE-S*', 'Average_F:', '0.05082', '(95%-conf.int.', '0.05082', '-', '0.05082)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:231', 'F:37']
dict_values(['(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.'])
dict_values(['In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.', 'In the named entity domain these rules were Each of these rules was given a strength of 0.9999.', '(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.', 'AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.'])
['system', 'ROUGE-S*', 'Average_R:', '0.25352', '(95%-conf.int.', '0.25352', '-', '0.25352)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.40449', '(95%-conf.int.', '0.40449', '-', '0.40449)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2485', 'P:630', 'F:630']
dict_values(['This modification brings the method closer to the DL-CoTrain algorithm described earlier, and is motivated by the intuition that all three labels should be kept healthily populated in the unlabeled examples, preventing one label from dominating &#8212; this deserves more theoretical investigation.'])
dict_values(['The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).', 'Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.', 'In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.', 'AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00581', '(95%-conf.int.', '0.00581', '-', '0.00581)']
['system', 'ROUGE-S*', 'Average_P:', '0.03463', '(95%-conf.int.', '0.03463', '-', '0.03463)']
['system', 'ROUGE-S*', 'Average_F:', '0.00994', '(95%-conf.int.', '0.00994', '-', '0.00994)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:231', 'F:8']
0.40747099592529 0.04773299952267001 0.08110199918898





input/ref/Task1/W99-0613_vardha.csv
input/res/Task1/W99-0613.annv3.csv
parsing: input/ref/Task1/W99-0613_vardha.csv
    <S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'"]
'9'
['9']
parsed_discourse_facet ['method_citation']
    <S sid="35" ssid="29">AdaBoost finds a weighted combination of simple (weak) classifiers, where the weights are chosen to minimize a function that bounds the classification error on a set of training examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'35'"]
'35'
['35']
parsed_discourse_facet ['method_citation']
    <S sid="134" ssid="1">This section describes an algorithm based on boosting algorithms, which were previously developed for supervised machine learning problems.</S>
original cit marker offset is 0
new cit marker offset is 0



["'134'"]
'134'
['134']
parsed_discourse_facet ['method_citation']
    <S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S>
original cit marker offset is 0
new cit marker offset is 0



["'236'"]
'236'
['236']
parsed_discourse_facet ['method_citation']
    <S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'8'"]
'8'
['8']
parsed_discourse_facet ['method_citation']
    <S sid="42" ssid="36">(Riloff and Shepherd 97) describe a bootstrapping approach for acquiring nouns in particular categories (such as &amp;quot;vehicle&amp;quot; or &amp;quot;weapon&amp;quot; categories).</S>
original cit marker offset is 0
new cit marker offset is 0



["'42'"]
'42'
['42']
parsed_discourse_facet ['method_citation']
    <S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S>
original cit marker offset is 0
new cit marker offset is 0



["'236'"]
'236'
['236']
parsed_discourse_facet ['method_citation']
    <S sid="222" ssid="1">The Expectation Maximization (EM) algorithm (Dempster, Laird and Rubin 77) is a common approach for unsupervised training; in this section we describe its application to the named entity problem.</S>
original cit marker offset is 0
new cit marker offset is 0



["'222'"]
'222'
['222']
parsed_discourse_facet ['method_citation']
    <S sid="30" ssid="24">(Blum and Mitchell 98) offer a promising formulation of redundancy, also prove some results about how the use of can help classification, and suggest an objective function when training with unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'30'"]
'30'
['30']
parsed_discourse_facet ['method_citation']
 <S sid="26" ssid="20">We present two algorithms.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'"]
'26'
['26']
parsed_discourse_facet ['method_citation']
    <S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'"]
'7'
['7']
parsed_discourse_facet ['method_citation']
    <S sid="32" ssid="26">The algorithm can be viewed as heuristically optimizing an objective function suggested by (Blum and Mitchell 98); empirically it is shown to be quite successful in optimizing this criterion.</S>
original cit marker offset is 0
new cit marker offset is 0



["'32'"]
'32'
['32']
parsed_discourse_facet ['method_citation']
    <S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S>
original cit marker offset is 0
new cit marker offset is 0



["'47'"]
'47'
['47']
parsed_discourse_facet ['method_citation']
    <S sid="127" ssid="60">The DL-CoTrain algorithm can be motivated as being a greedy method of satisfying the above 2 constraints.</S>
original cit marker offset is 0
new cit marker offset is 0



["'127'"]
'127'
['127']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W99-0613.annv3.csv
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="28" ssid="22">(Yarowsky 95) describes an algorithm for word-sense disambiguation that exploits redundancy in contextual features, and gives impressive performance.</S><S sid="30" ssid="24">(Blum and Mitchell 98) offer a promising formulation of redundancy, also prove some results about how the use of unlabeled examples can help classification, and suggest an objective function when training with unlabeled examples.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'7'", "'28'", "'30'"]
'5'
'7'
'28'
'30'
['5', '7', '28', '30']
parsed_discourse_facet ['hypothesis_citation']
<S sid="33" ssid="27">The second algorithm builds on a boosting algorithm called AdaBoost (Freund and Schapire 97; Schapire and Singer 98).</S><S sid="34" ssid="28">The AdaBoost algorithm was developed for supervised learning.</S><S sid="173" ssid="40">(3)), with one term for each classifier.</S><S sid="175" ssid="42">Put another way, the minimum of Equ.</S>
original cit marker offset is 0
new cit marker offset is 0



["'33'", "'34'", "'173'", "'175'"]
'33'
'34'
'173'
'175'
['33', '34', '173', '175']
parsed_discourse_facet ['method_citation']
<S sid="91" ssid="24">There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.</S><S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'91'", "'138'", "'139'", "'203'"]
'91'
'138'
'139'
'203'
['91', '138', '139', '203']
parsed_discourse_facet ['method_citation']
<S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="14" ssid="8">A contextual rule considers words surrounding the string in the sentence in which it appears (e.g., a rule that any proper name modified by an appositive whose head is president is a person).</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="254" ssid="5">Future work should also extend the approach to build a complete named entity extractor - a method that pulls proper names from text and then classifies them.</S>
original cit marker offset is 0
new cit marker offset is 0



["'2'", "'14'", "'47'", "'254'"]
'2'
'14'
'47'
'254'
['2', '14', '47', '254']
parsed_discourse_facet ['hypothesis_citation']
<S sid="10" ssid="4">The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.</S><S sid="77" ssid="10">In this paper k = 3 (the three labels are person, organization, location), and we set a = 0.1.</S><S sid="236" ssid="3">We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.</S><S sid="237" ssid="4">The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.</S>
original cit marker offset is 0
new cit marker offset is 0



["'10'", "'77'", "'236'", "'237'"]
'10'
'77'
'236'
'237'
['10', '77', '236', '237']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="2" ssid="2">A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &amp;quot;seed&amp;quot; rules.</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="18" ssid="12">But we will show that the use of unlabeled data can drastically reduce the need for supervision.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'2'", "'8'", "'18'"]
'1'
'2'
'8'
'18'
['1', '2', '8', '18']
parsed_discourse_facet ['hypothesis_citation']
<S sid="1" ssid="1">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="9" ssid="3">This paper discusses the use of unlabeled examples for the problem of named entity classification.</S><S sid="47" ssid="1">971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).</S><S sid="202" ssid="69">The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'9'", "'47'", "'202'"]
'1'
'9'
'47'
'202'
['1', '9', '47', '202']
parsed_discourse_facet ['hypothesis_citation']
<S sid="16" ssid="10">Supervised methods have been applied quite successfully to the full MUC named-entity task (Bikel et al. 97).</S><S sid="29" ssid="23">Unfortunately, Yarowsky\s method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.</S><S sid="56" ssid="10">In the appositive case, the contextual predictor was the head of the modifying appositive (president in the Maury Cooper example); in the second case, the contextual predictor was the preposition together with the noun it modifies (plant_in in the Georgia example).</S><S sid="232" ssid="11">For example, the independence assumptions mean that the model fails to capture the dependence between specific and more general features (for example the fact that the feature full.-string=New_York is always seen with the features contains (New) and The baseline method tags all entities as the most frequent class type (organization). contains (York) and is never seen with a feature such as contains (Group) ).</S>
original cit marker offset is 0
new cit marker offset is 0



["'16'", "'29'", "'56'", "'232'"]
'16'
'29'
'56'
'232'
['16', '29', '56', '232']
parsed_discourse_facet ['hypothesis_citation']
<S sid="138" ssid="5">(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\s (Valiant 84) Probably Approximately Correct (PAC) model.)</S><S sid="139" ssid="6">This section describes AdaBoost, which is the basis for the CoBoost algorithm.</S><S sid="219" ssid="86">Finally, we would like to note that it is possible to devise similar algorithms based with other objective functions than the one given in Equ.</S><S sid="251" ssid="2">In addition to a heuristic based on decision list learning, we also presented a boosting-like framework that builds on ideas from (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'138'", "'139'", "'219'", "'251'"]
'138'
'139'
'219'
'251'
['138', '139', '219', '251']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="6" ssid="6">The second algorithm extends ideas from boosting algorithms, designed for supervised learning tasks, to the framework suggested by (Blum and Mitchell 98).</S><S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="31" ssid="25">Our first algorithm is similar to Yarowsky\s, but with some important modifications motivated by (Blum and Mitchell 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'6'", "'7'", "'31'"]
'5'
'6'
'7'
'31'
['5', '6', '7', '31']
parsed_discourse_facet ['hypothesis_citation']
<S sid="7" ssid="1">Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.</S><S sid="141" ssid="8">For a description of the application of AdaBoost to various NLP problems see the paper by Abney, Schapire, and Singer in this volume.</S><S sid="153" ssid="20">Schapire and Singer show that the training error is bounded above by Thus, in order to greedily minimize an upper bound on training error, on each iteration we should search for the weak hypothesis ht and the weight at that minimize Z.</S><S sid="203" ssid="70">Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).</S>
original cit marker offset is 0
new cit marker offset is 0



["'7'", "'141'", "'153'", "'203'"]
'7'
'141'
'153'
'203'
['7', '141', '153', '203']
parsed_discourse_facet ['hypothesis_citation']
<S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="82" ssid="15">In the named entity domain these rules were Each of these rules was given a strength of 0.9999.</S><S sid="85" ssid="18">(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'60'", "'82'", "'85'", "'140'"]
'60'
'82'
'85'
'140'
['60', '82', '85', '140']
parsed_discourse_facet ['method_citation']
<S sid="5" ssid="5">The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).</S><S sid="8" ssid="2">Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.</S><S sid="60" ssid="14">In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.</S><S sid="140" ssid="7">AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.</S>
original cit marker offset is 0
new cit marker offset is 0



["'5'", "'8'", "'60'", "'140'"]
'5'
'8'
'60'
'140'
['5', '8', '60', '140']
parsed_discourse_facet ['results_citation']
dict_values(['AdaBoost finds a weighted combination of simple (weak) classifiers, where the weights are chosen to minimize a function that bounds the classification error on a set of training examples.'])
dict_values(['The second algorithm builds on a boosting algorithm called AdaBoost (Freund and Schapire 97; Schapire and Singer 98).', 'The AdaBoost algorithm was developed for supervised learning.', '(3)), with one term for each classifier.', 'Put another way, the minimum of Equ.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00395', '(95%-conf.int.', '0.00395', '-', '0.00395)']
['system', 'ROUGE-S*', 'Average_P:', '0.00735', '(95%-conf.int.', '0.00735', '-', '0.00735)']
['system', 'ROUGE-S*', 'Average_F:', '0.00514', '(95%-conf.int.', '0.00514', '-', '0.00514)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:253', 'P:136', 'F:1']
dict_values(['This section describes an algorithm based on boosting algorithms, which were previously developed for supervised machine learning problems.'])
dict_values(['There are two differences between this method and the DL-CoTrain algorithm: spelling and contextual features, alternating between labeling and learning with the two types of features.', '(We would like to note though that unlike previous boosting algorithms, the CoBoost algorithm presented here is not a boosting algorithm under Valiant\\s (Valiant 84) Probably Approximately Correct (PAC) model.)', 'This section describes AdaBoost, which is the basis for the CoBoost algorithm.', 'Several extensions of AdaBoost for multiclass problems have been suggested (Freund and Schapire 97; Schapire and Singer 98).'])
['system', 'ROUGE-S*', 'Average_R:', '0.01203', '(95%-conf.int.', '0.01203', '-', '0.01203)']
['system', 'ROUGE-S*', 'Average_P:', '0.19697', '(95%-conf.int.', '0.19697', '-', '0.19697)']
['system', 'ROUGE-S*', 'Average_F:', '0.02267', '(95%-conf.int.', '0.02267', '-', '0.02267)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1081', 'P:66', 'F:13']
dict_values(['We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.'])
dict_values(['The task is to learn a function from an input string (proper name) to its type, which we will assume to be one of the categories Person, Organization, or Location.', 'In this paper k = 3 (the three labels are person, organization, location), and we set a = 0.1.', 'We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.', 'The numbers falling into the location, person, organization categories were 186, 289 and 402 respectively.'])
['system', 'ROUGE-S*', 'Average_R:', '0.05488', '(95%-conf.int.', '0.05488', '-', '0.05488)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.10405', '(95%-conf.int.', '0.10405', '-', '0.10405)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:820', 'P:45', 'F:45']
dict_values(['Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.'])
dict_values(['This paper discusses the use of unlabeled examples for the problem of named entity classification.', 'A large number of rules is needed for coverage of the domain, suggesting that a fairly large number of labeled examples should be required to train a classi- However, we show that the use of data can reduce the requirements for supervision to just 7 simple &quot;seed&quot; rules.', 'Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.', 'But we will show that the use of unlabeled data can drastically reduce the need for supervision.'])
['system', 'ROUGE-S*', 'Average_R:', '0.07071', '(95%-conf.int.', '0.07071', '-', '0.07071)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.13208', '(95%-conf.int.', '0.13208', '-', '0.13208)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1485', 'P:105', 'F:105']
dict_values(['We chose one of four labels for each example: location, person, organization, or noise where the noise category was used for items that were outside the three categories.'])
dict_values(['This paper discusses the use of unlabeled examples for the problem of named entity classification.', 'This paper discusses the use of unlabeled examples for the problem of named entity classification.', '971,746 sentences of New York Times text were parsed using the parser of (Collins 96).1 Word sequences that met the following criteria were then extracted as named entity examples: whose head is a singular noun (tagged NN).', 'The CoBoost algorithm just described is for the case where there are two labels: for the named entity task there are three labels, and in general it will be useful to generalize the CoBoost algorithm to the multiclass case.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1431', 'P:45', 'F:0']
dict_values(['The Expectation Maximization (EM) algorithm (Dempster, Laird and Rubin 77) is a common approach for unsupervised training; in this section we describe its application to the named entity problem.'])
dict_values(['Supervised methods have been applied quite successfully to the full MUC named-entity task (Bikel et al. 97).', 'Unfortunately, Yarowsky\\s method is not well understood from a theoretical viewpoint: we would like to formalize the notion of redundancy in unlabeled data, and set up the learning task as optimization of some appropriate objective function.', 'In the appositive case, the contextual predictor was the head of the modifying appositive (president in the Maury Cooper example); in the second case, the contextual predictor was the preposition together with the noun it modifies (plant_in in the Georgia example).', 'For example, the independence assumptions mean that the model fails to capture the dependence between specific and more general features (for example the fact that the feature full.-string=New_York is always seen with the features contains (New) and The baseline method tags all entities as the most frequent class type (organization). contains (York) and is never seen with a feature such as contains (Group) ).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00039', '(95%-conf.int.', '0.00039', '-', '0.00039)']
['system', 'ROUGE-S*', 'Average_P:', '0.00654', '(95%-conf.int.', '0.00654', '-', '0.00654)']
['system', 'ROUGE-S*', 'Average_F:', '0.00074', '(95%-conf.int.', '0.00074', '-', '0.00074)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2556', 'P:153', 'F:1']
dict_values(['We present two algorithms.'])
dict_values(['The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).', 'The second algorithm extends ideas from boosting algorithms, designed for supervised learning tasks, to the framework suggested by (Blum and Mitchell 98).', 'Many statistical or machine-learning approaches for natural language problems require a relatively large amount of supervision, in the form of labeled training examples.', 'Our first algorithm is similar to Yarowsky\\s, but with some important modifications motivated by (Blum and Mitchell 98).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1225', 'P:1', 'F:0']
dict_values(['The algorithm can be viewed as heuristically optimizing an objective function suggested by (Blum and Mitchell 98); empirically it is shown to be quite successful in optimizing this criterion.'])
dict_values(['In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.', 'In the named entity domain these rules were Each of these rules was given a strength of 0.9999.', '(If fewer than n rules have Precision greater than pin, we 3Note that taking tlie top n most frequent rules already makes the method robut to low count events, hence we do not use smoothing, allowing low-count high-precision features to be chosen on later iterations. keep only those rules which exceed the precision threshold.) pm,n was fixed at 0.95 in all experiments in this paper.', 'AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_P:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00000', '(95%-conf.int.', '0.00000', '-', '0.00000)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2485', 'P:105', 'F:0']
dict_values(['The DL-CoTrain algorithm can be motivated as being a greedy method of satisfying the above 2 constraints.'])
dict_values(['The first method uses a similar algorithm to that of (Yarowsky 95), with modifications motivated by (Blum and Mitchell 98).', 'Recent results (e.g., (Yarowsky 95; Brill 95; Blum and Mitchell 98)) have suggested that unlabeled data can be used quite profitably in reducing the need for supervision.', 'In principle a feature could be an arbitrary predicate of the (spelling, context) pair; for reasons that will become clear, features are limited to querying either the spelling or context alone.', 'AdaBoost was first introduced in (Freund and Schapire 97); (Schapire and Singer 98) gave a generalization of AdaBoost which we will use in this paper.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00073', '(95%-conf.int.', '0.00073', '-', '0.00073)']
['system', 'ROUGE-S*', 'Average_P:', '0.02778', '(95%-conf.int.', '0.02778', '-', '0.02778)']
['system', 'ROUGE-S*', 'Average_F:', '0.00141', '(95%-conf.int.', '0.00141', '-', '0.00141)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1378', 'P:36', 'F:1']
0.24873777501402475 0.015854444268283956 0.029565555227049393





input/ref/Task1/W99-0623_swastika.csv
input/res/Task1/W99-0623.annv3.csv
parsing: input/ref/Task1/W99-0623_swastika.csv
<S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



['85']
85
['85']
parsed_discourse_facet ['aim_citation']
<S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



['120']
120
['120']
parsed_discourse_facet ['result_citation']
<S sid="25" ssid="11">In our particular case the majority requires the agreement of only two parsers because we have only three.</S>
original cit marker offset is 0
new cit marker offset is 0



['25']
25
['25']
parsed_discourse_facet ['method_citation']
<S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



['120']
120
['120']
parsed_discourse_facet ['result_citation']
<S sid="38" ssid="24">Under certain conditions the constituent voting and na&#239;ve Bayes constituent combination techniques are guaranteed to produce sets of constituents with no crossing brackets.</S>
original cit marker offset is 0
new cit marker offset is 0



['38']
38
['38']
parsed_discourse_facet ['result_citation']
<S sid="91" ssid="20">Features and context were initially introduced into the models, but they refused to offer any gains in performance.</S>
original cit marker offset is 0
new cit marker offset is 0



['91']
91
['91']
parsed_discourse_facet ['method_citation']
<S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



['120']
120
['120']
parsed_discourse_facet ['result_citation']
<S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



['120']
120
['120']
parsed_discourse_facet ['result_citation']
<S sid="139" ssid="1">We have presented two general approaches to studying parser combination: parser switching and parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



['139']
139
['139']
parsed_discourse_facet ['result_citation']
<S sid="25" ssid="11">In our particular case the majority requires the agreement of only two parsers because we have only three.</S>
original cit marker offset is 0
new cit marker offset is 0



['25']
25
['25']
parsed_discourse_facet ['method_citation']
<S sid="103" ssid="32">The counts represent portions of the approximately 44000 constituents hypothesized by the parsers in the development set.</S>
original cit marker offset is 0
new cit marker offset is 0



['103']
103
['103']
parsed_discourse_facet ['method_citation']
<S sid="139" ssid="1">We have presented two general approaches to studying parser combination: parser switching and parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



['139']
139
['139']
parsed_discourse_facet ['result_citation']
<S sid="70" ssid="56">In this case we are interested in finding' the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



['70']
70
['70']
parsed_discourse_facet ['aim_citation']
<S sid="140" ssid="2">For each experiment we gave an nonparametric and a parametric technique for combining parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



['140']
140
['140']
parsed_discourse_facet ['method_citation']
<S sid="70" ssid="56">In this case we are interested in finding' the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



['70']
70
['70']
parsed_discourse_facet ['aim_citation']
<S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



['85']
85
['85']
parsed_discourse_facet ['result_citation']
<S sid="70" ssid="56">In this case we are interested in finding' the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



['70']
70
['70']
parsed_discourse_facet ['aim_citation']
parsing: input/res/Task1/W99-0623.annv3.csv
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S><S sid="86" ssid="15">Finally we show the combining techniques degrade very little when a poor parser is added to the set.</S><S sid="146" ssid="1">We would like to thank Eugene Charniak, Michael Collins, and Adwait Ratnaparkhi for enabling all of this research by providing us with their parsers and helpful comments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'85'", "'86'", "'146'"]
'1'
'85'
'86'
'146'
['1', '85', '86', '146']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="41" ssid="27">IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.</S><S sid="105" ssid="34">Similarly Figures 1 and 2 show how the isolated constituent precision varies by sentence length and the size of the span of the hypothesized constituent.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'41'", "'105'", "'120'"]
'39'
'41'
'105'
'120'
['39', '41', '105', '120']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="12">This technique has the advantage of requiring no training, but it has the disadvantage of treating all parsers equally even though they may have differing accuracies or may specialize in modeling different phenomena.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="93" ssid="22">Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.</S><S sid="94" ssid="23">This is the only important case, because otherwise the simple majority combining technique would pick the correct constituent.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'", "'93'", "'94'"]
'26'
'27'
'93'
'94'
['26', '27', '93', '94']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="40" ssid="26">Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'27'", "'39'", "'40'"]
'23'
'27'
'39'
'40'
['23', '27', '39', '40']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="32" ssid="18">In Equations 1 through 3 we develop the model for constructing our parse using na&#239;ve Bayes classification.</S><S sid="118" ssid="47">The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.</S><S sid="140" ssid="2">For each experiment we gave an nonparametric and a parametric technique for combining parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'32'", "'118'", "'140'"]
'27'
'32'
'118'
'140'
['27', '32', '118', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="92" ssid="21">While we cannot prove there are no such useful features on which one should condition trust, we can give some insight into why the features we explored offered no gain.</S><S sid="93" ssid="22">Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'92'", "'93'", "'120'"]
'39'
'92'
'93'
'120'
['39', '92', '93', '120']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S><S sid="40" ssid="26">Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.</S><S sid="41" ssid="27">IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'40'", "'41'", "'120'"]
'13'
'40'
'41'
'120'
['13', '40', '41', '120']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="9" ssid="5">Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).</S><S sid="12" ssid="8">The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).</S><S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="135" ssid="64">The average individual parser accuracy was reduced by more than 5% when we added this new parser, but the precision of the constituent voting technique was the only result that decreased significantly.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'12'", "'23'", "'135'"]
'9'
'12'
'23'
'135'
['9', '12', '23', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="21" ssid="7">One hybridization strategy is to let the parsers vote on constituents\ membership in the hypothesized set.</S><S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S><S sid="95" ssid="24">One side of the decision making process is when we choose to believe a constituent should be in the parse, even though only one parser suggests it.</S><S sid="96" ssid="25">We call such a constituent an isolated constituent.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'51'", "'95'", "'96'"]
'21'
'51'
'95'
'96'
['21', '51', '95', '96']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S><S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'13'", "'85'", "'120'"]
'1'
'13'
'85'
'120'
['1', '13', '85', '120']
parsed_discourse_facet ['hypothesis_citation']
<S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S><S sid="88" ssid="17">For example, one parser could be more accurate at predicting noun phrases than the other parsers.</S><S sid="89" ssid="18">None of the models we have presented utilize features associated with a particular constituent (i.e. the label, span, parent label, etc.) to influence parser preference.</S><S sid="108" ssid="37">From this we see that a finer-grained model for parser combination, at least for the features we have examined, will not give us any additional power.</S>
original cit marker offset is 0
new cit marker offset is 0



["'87'", "'88'", "'89'", "'108'"]
'87'
'88'
'89'
'108'
['87', '88', '89', '108']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="21" ssid="7">One hybridization strategy is to let the parsers vote on constituents\ membership in the hypothesized set.</S><S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S><S sid="55" ssid="41">We have developed a general approach for combining parsers when preserving the entire structure of a parse tree is important.</S><S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'51'", "'55'", "'87'"]
'21'
'51'
'55'
'87'
['21', '51', '55', '87']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S><S sid="78" ssid="7">The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'77'", "'78'", "'98'"]
'1'
'77'
'78'
'98'
['1', '77', '78', '98']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="6">Since our goal is to perform well under these measures we will similarly treat constituents as the minimal substructures for combination.</S><S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="145" ssid="7">We plan to explore more powerful techniques for exploiting the diversity of parsing methods.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'23'", "'27'", "'145'"]
'20'
'23'
'27'
'145'
['20', '23', '27', '145']
parsed_discourse_facet ['method_citation']
<S sid="70" ssid="56">In this case we are interested in finding\ the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S><S sid="99" ssid="28">Consider for a set of constituents the isolated constituent precision parser metric, the portion of isolated constituents that are correctly hypothesized.</S><S sid="118" ssid="47">The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["'70'", "'98'", "'99'", "'118'"]
'70'
'98'
'99'
'118'
['70', '98', '99', '118']
parsed_discourse_facet ['method_citation']
<S sid="6" ssid="2">The machine learning community has been in a similar situation and has studied the combination of multiple classifiers (Wolpert, 1992; Heath et al., 1996).</S><S sid="9" ssid="5">Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).</S><S sid="12" ssid="8">The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).</S><S sid="54" ssid="40">If the parse contains productions from outside our grammar the machine has no direct method for handling them (e.g. the resulting database query may be syntactically malformed).</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'9'", "'12'", "'54'"]
'6'
'9'
'12'
'54'
['6', '9', '12', '54']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S><S sid="78" ssid="7">The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'77'", "'78'", "'98'"]
'1'
'77'
'78'
'98'
['1', '77', '78', '98']
parsed_discourse_facet ['method_citation', 'aim_citation']
dict_values(['The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.'])
dict_values(['There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.', 'IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.', 'Similarly Figures 1 and 2 show how the isolated constituent precision varies by sentence length and the size of the span of the hypothesized constituent.', 'The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.'])
['system', 'ROUGE-S*', 'Average_R:', '0.16393', '(95%-conf.int.', '0.16393', '-', '0.16393)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.28169', '(95%-conf.int.', '0.28169', '-', '0.28169)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:300', 'F:300']
dict_values(['In our particular case the majority requires the agreement of only two parsers because we have only three.'])
dict_values(['This technique has the advantage of requiring no training, but it has the disadvantage of treating all parsers equally even though they may have differing accuracies or may specialize in modeling different phenomena.', 'Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.', 'Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.', 'This is the only important case, because otherwise the simple majority combining technique would pick the correct constituent.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00193', '(95%-conf.int.', '0.00193', '-', '0.00193)']
['system', 'ROUGE-S*', 'Average_P:', '0.20000', '(95%-conf.int.', '0.20000', '-', '0.20000)']
['system', 'ROUGE-S*', 'Average_F:', '0.00383', '(95%-conf.int.', '0.00383', '-', '0.00383)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:10', 'F:2']
dict_values(['The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.'])
dict_values(['These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).', 'Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.', 'IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.', 'The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.'])
['system', 'ROUGE-S*', 'Average_R:', '0.14881', '(95%-conf.int.', '0.14881', '-', '0.14881)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.25907', '(95%-conf.int.', '0.25907', '-', '0.25907)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:300', 'F:300']
dict_values(['The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.'])
dict_values(['Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).', 'The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).', 'We call this technique constituent voting.', 'The average individual parser accuracy was reduced by more than 5% when we added this new parser, but the precision of the constituent voting technique was the only result that decreased significantly.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02725', '(95%-conf.int.', '0.02725', '-', '0.02725)']
['system', 'ROUGE-S*', 'Average_P:', '0.13000', '(95%-conf.int.', '0.13000', '-', '0.13000)']
['system', 'ROUGE-S*', 'Average_F:', '0.04506', '(95%-conf.int.', '0.04506', '-', '0.04506)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1431', 'P:300', 'F:39']
dict_values(['The counts represent portions of the approximately 44000 constituents hypothesized by the parsers in the development set.'])
dict_values(['It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.', 'For example, one parser could be more accurate at predicting noun phrases than the other parsers.', 'None of the models we have presented utilize features associated with a particular constituent (i.e. the label, span, parent label, etc.) to influence parser preference.', 'From this we see that a finer-grained model for parser combination, at least for the features we have examined, will not give us any additional power.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00142', '(95%-conf.int.', '0.00142', '-', '0.00142)']
['system', 'ROUGE-S*', 'Average_P:', '0.02222', '(95%-conf.int.', '0.02222', '-', '0.02222)']
['system', 'ROUGE-S*', 'Average_F:', '0.00267', '(95%-conf.int.', '0.00267', '-', '0.00267)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:703', 'P:45', 'F:1']
dict_values(['We have presented two general approaches to studying parser combination: parser switching and parse hybridization.'])
dict_values(['One hybridization strategy is to let the parsers vote on constituents\\ membership in the hypothesized set.', 'One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.', 'We have developed a general approach for combining parsers when preserving the entire structure of a parse tree is important.', 'It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01449', '(95%-conf.int.', '0.01449', '-', '0.01449)']
['system', 'ROUGE-S*', 'Average_P:', '0.33333', '(95%-conf.int.', '0.33333', '-', '0.33333)']
['system', 'ROUGE-S*', 'Average_F:', '0.02778', '(95%-conf.int.', '0.02778', '-', '0.02778)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:45', 'F:15']
dict_values(["In this case we are interested in finding' the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers."])
dict_values(['In this case we are interested in finding\\ the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.', 'Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.', 'Consider for a set of constituents the isolated constituent precision parser metric, the portion of isolated constituents that are correctly hypothesized.', 'The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.'])
['system', 'ROUGE-S*', 'Average_R:', '0.13158', '(95%-conf.int.', '0.13158', '-', '0.13158)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.23256', '(95%-conf.int.', '0.23256', '-', '0.23256)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:210', 'F:210']
dict_values(['We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.'])
dict_values(['The machine learning community has been in a similar situation and has studied the combination of multiple classifiers (Wolpert, 1992; Heath et al., 1996).', 'Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).', 'The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).', 'If the parse contains productions from outside our grammar the machine has no direct method for handling them (e.g. the resulting database query may be syntactically malformed).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00164', '(95%-conf.int.', '0.00164', '-', '0.00164)']
['system', 'ROUGE-S*', 'Average_P:', '0.08333', '(95%-conf.int.', '0.08333', '-', '0.08333)']
['system', 'ROUGE-S*', 'Average_F:', '0.00322', '(95%-conf.int.', '0.00322', '-', '0.00322)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:36', 'F:3']
dict_values(["In this case we are interested in finding' the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers."])
dict_values(['Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.', 'Each parse is converted into a set of constituents represented as a tuples: (label, start, end).', 'The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.', 'Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00648', '(95%-conf.int.', '0.00648', '-', '0.00648)']
['system', 'ROUGE-S*', 'Average_P:', '0.03333', '(95%-conf.int.', '0.03333', '-', '0.03333)']
['system', 'ROUGE-S*', 'Average_F:', '0.01084', '(95%-conf.int.', '0.01084', '-', '0.01084)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1081', 'P:210', 'F:7']
0.42246777308369143 0.05528111049687655 0.09630222115219754





input/ref/Task1/W99-0623_sweta.csv
input/res/Task1/W99-0623.annv3.csv
parsing: input/ref/Task1/W99-0623_sweta.csv
 <S sid="144" ssid="6">Combining multiple highly-accurate independent parsers yields promising results.</S>
original cit marker offset is 0
new cit marker offset is 0



["144'"]
144'
['144']
parsed_discourse_facet ['method_citation']
 <S sid="125" ssid="54">The constituent voting and na&#239;ve Bayes techniques are equivalent because the parameters learned in the training set did not sufficiently discriminate between the three parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["125'"]
125'
['125']
parsed_discourse_facet ['method_citation']
<S sid="125" ssid="54">The constituent voting and na&#239;ve Bayes techniques are equivalent because the parameters learned in the training set did not sufficiently discriminate between the three parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["125'"]
125'
['125']
parsed_discourse_facet ['method_citation']
    <S sid="48" ssid="34">&#8226; Similarly, when the na&#239;ve Bayes classifier is configured such that the constituents require estimated probabilities strictly larger than 0.5 to be accepted, there is not enough probability mass remaining on crossing brackets for them to be included in the hypothesis.</S>
original cit marker offset is 0
new cit marker offset is 0



["48'"]
48'
['48']
parsed_discourse_facet ['method_citation']
 <S sid="139" ssid="1">We have presented two general approaches to studying parser combination: parser switching and parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["139'"]
139'
['139']
parsed_discourse_facet ['method_citation']
<S sid="134" ssid="63">As seen by the drop in average individual parser performance baseline, the introduced parser does not perform very well.</S>
original cit marker offset is 0
new cit marker offset is 0



["134'"]
134'
['134']
parsed_discourse_facet ['method_citation']
 <S sid="38" ssid="24">Under certain conditions the constituent voting and na&#239;ve Bayes constituent combination techniques are guaranteed to produce sets of constituents with no crossing brackets.</S>
original cit marker offset is 0
new cit marker offset is 0



["38'"]
38'
['38']
parsed_discourse_facet ['method_citation']
    <S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["120'"]
120'
['120']
parsed_discourse_facet ['method_citation']
<S sid="139" ssid="1">We have presented two general approaches to studying parser combination: parser switching and parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["139'"]
139'
['139']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S>
original cit marker offset is 0
new cit marker offset is 0



["13'"]
13'
['13']
parsed_discourse_facet ['method_citation']
<S sid="108" ssid="37">From this we see that a finer-grained model for parser combination, at least for the features we have examined, will not give us any additional power.</S>
original cit marker offset is 0
new cit marker offset is 0



["108'"]
108'
['108']
parsed_discourse_facet ['method_citation']
<S sid="139" ssid="1">We have presented two general approaches to studying parser combination: parser switching and parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["139'"]
139'
['139']
parsed_discourse_facet ['method_citation']
<S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["98'"]
98'
['98']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S>
original cit marker offset is 0
new cit marker offset is 0



["27'"]
27'
['27']
parsed_discourse_facet ['method_citation']
<S sid="80" ssid="9">For our experiments we also report the mean of precision and recall, which we denote by (P + R)I2 and F-measure.</S>
    <S sid="81" ssid="10">F-measure is the harmonic mean of precision and recall, 2PR/(P + R).</S>
    <S sid="82" ssid="11">It is closer to the smaller value of precision and recall when there is a large skew in their values.</S>
original cit marker offset is 0
new cit marker offset is 0



["80'", "'81'", "'82'"]
80'
'81'
'82'
['80', '81', '82']
parsed_discourse_facet ['method_citation']
<S sid="49" ssid="35">In general, the lemma of the previous section does not ensure that all the productions in the combined parse are found in the grammars of the member parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["49'"]
49'
['49']
parsed_discourse_facet ['method_citation']
<S sid="11" ssid="7">Similar advances have been made in machine translation (Frederking and Nirenburg, 1994), speech recognition (Fiscus, 1997) and named entity recognition (Borthwick et al., 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["11'"]
11'
['11']
parsed_discourse_facet ['method_citation']
<S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["98'"]
98'
['98']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W99-0623.annv3.csv
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S><S sid="86" ssid="15">Finally we show the combining techniques degrade very little when a poor parser is added to the set.</S><S sid="146" ssid="1">We would like to thank Eugene Charniak, Michael Collins, and Adwait Ratnaparkhi for enabling all of this research by providing us with their parsers and helpful comments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'85'", "'86'", "'146'"]
'1'
'85'
'86'
'146'
['1', '85', '86', '146']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="41" ssid="27">IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.</S><S sid="105" ssid="34">Similarly Figures 1 and 2 show how the isolated constituent precision varies by sentence length and the size of the span of the hypothesized constituent.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'41'", "'105'", "'120'"]
'39'
'41'
'105'
'120'
['39', '41', '105', '120']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="12">This technique has the advantage of requiring no training, but it has the disadvantage of treating all parsers equally even though they may have differing accuracies or may specialize in modeling different phenomena.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="93" ssid="22">Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.</S><S sid="94" ssid="23">This is the only important case, because otherwise the simple majority combining technique would pick the correct constituent.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'", "'93'", "'94'"]
'26'
'27'
'93'
'94'
['26', '27', '93', '94']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="40" ssid="26">Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'27'", "'39'", "'40'"]
'23'
'27'
'39'
'40'
['23', '27', '39', '40']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="32" ssid="18">In Equations 1 through 3 we develop the model for constructing our parse using na&#239;ve Bayes classification.</S><S sid="118" ssid="47">The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.</S><S sid="140" ssid="2">For each experiment we gave an nonparametric and a parametric technique for combining parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'32'", "'118'", "'140'"]
'27'
'32'
'118'
'140'
['27', '32', '118', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="92" ssid="21">While we cannot prove there are no such useful features on which one should condition trust, we can give some insight into why the features we explored offered no gain.</S><S sid="93" ssid="22">Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'92'", "'93'", "'120'"]
'39'
'92'
'93'
'120'
['39', '92', '93', '120']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S><S sid="40" ssid="26">Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.</S><S sid="41" ssid="27">IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'40'", "'41'", "'120'"]
'13'
'40'
'41'
'120'
['13', '40', '41', '120']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="9" ssid="5">Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).</S><S sid="12" ssid="8">The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).</S><S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="135" ssid="64">The average individual parser accuracy was reduced by more than 5% when we added this new parser, but the precision of the constituent voting technique was the only result that decreased significantly.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'12'", "'23'", "'135'"]
'9'
'12'
'23'
'135'
['9', '12', '23', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="21" ssid="7">One hybridization strategy is to let the parsers vote on constituents\ membership in the hypothesized set.</S><S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S><S sid="95" ssid="24">One side of the decision making process is when we choose to believe a constituent should be in the parse, even though only one parser suggests it.</S><S sid="96" ssid="25">We call such a constituent an isolated constituent.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'51'", "'95'", "'96'"]
'21'
'51'
'95'
'96'
['21', '51', '95', '96']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S><S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'13'", "'85'", "'120'"]
'1'
'13'
'85'
'120'
['1', '13', '85', '120']
parsed_discourse_facet ['hypothesis_citation']
<S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S><S sid="88" ssid="17">For example, one parser could be more accurate at predicting noun phrases than the other parsers.</S><S sid="89" ssid="18">None of the models we have presented utilize features associated with a particular constituent (i.e. the label, span, parent label, etc.) to influence parser preference.</S><S sid="108" ssid="37">From this we see that a finer-grained model for parser combination, at least for the features we have examined, will not give us any additional power.</S>
original cit marker offset is 0
new cit marker offset is 0



["'87'", "'88'", "'89'", "'108'"]
'87'
'88'
'89'
'108'
['87', '88', '89', '108']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="21" ssid="7">One hybridization strategy is to let the parsers vote on constituents\ membership in the hypothesized set.</S><S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S><S sid="55" ssid="41">We have developed a general approach for combining parsers when preserving the entire structure of a parse tree is important.</S><S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'51'", "'55'", "'87'"]
'21'
'51'
'55'
'87'
['21', '51', '55', '87']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S><S sid="78" ssid="7">The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'77'", "'78'", "'98'"]
'1'
'77'
'78'
'98'
['1', '77', '78', '98']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="6">Since our goal is to perform well under these measures we will similarly treat constituents as the minimal substructures for combination.</S><S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="145" ssid="7">We plan to explore more powerful techniques for exploiting the diversity of parsing methods.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'23'", "'27'", "'145'"]
'20'
'23'
'27'
'145'
['20', '23', '27', '145']
parsed_discourse_facet ['method_citation']
<S sid="70" ssid="56">In this case we are interested in finding\ the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S><S sid="99" ssid="28">Consider for a set of constituents the isolated constituent precision parser metric, the portion of isolated constituents that are correctly hypothesized.</S><S sid="118" ssid="47">The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["'70'", "'98'", "'99'", "'118'"]
'70'
'98'
'99'
'118'
['70', '98', '99', '118']
parsed_discourse_facet ['method_citation']
<S sid="6" ssid="2">The machine learning community has been in a similar situation and has studied the combination of multiple classifiers (Wolpert, 1992; Heath et al., 1996).</S><S sid="9" ssid="5">Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).</S><S sid="12" ssid="8">The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).</S><S sid="54" ssid="40">If the parse contains productions from outside our grammar the machine has no direct method for handling them (e.g. the resulting database query may be syntactically malformed).</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'9'", "'12'", "'54'"]
'6'
'9'
'12'
'54'
['6', '9', '12', '54']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S><S sid="78" ssid="7">The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'77'", "'78'", "'98'"]
'1'
'77'
'78'
'98'
['1', '77', '78', '98']
parsed_discourse_facet ['method_citation', 'aim_citation']
dict_values(['The constituent voting and na&#239;ve Bayes techniques are equivalent because the parameters learned in the training set did not sufficiently discriminate between the three parsers.'])
dict_values(['There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.', 'IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.', 'Similarly Figures 1 and 2 show how the isolated constituent precision varies by sentence length and the size of the span of the hypothesized constituent.', 'The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00492', '(95%-conf.int.', '0.00492', '-', '0.00492)']
['system', 'ROUGE-S*', 'Average_P:', '0.08571', '(95%-conf.int.', '0.08571', '-', '0.08571)']
['system', 'ROUGE-S*', 'Average_F:', '0.00930', '(95%-conf.int.', '0.00930', '-', '0.00930)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:105', 'F:9']
dict_values(['The constituent voting and na&#239;ve Bayes techniques are equivalent because the parameters learned in the training set did not sufficiently discriminate between the three parsers.'])
dict_values(['This technique has the advantage of requiring no training, but it has the disadvantage of treating all parsers equally even though they may have differing accuracies or may specialize in modeling different phenomena.', 'Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.', 'Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.', 'This is the only important case, because otherwise the simple majority combining technique would pick the correct constituent.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01836', '(95%-conf.int.', '0.01836', '-', '0.01836)']
['system', 'ROUGE-S*', 'Average_P:', '0.18095', '(95%-conf.int.', '0.18095', '-', '0.18095)']
['system', 'ROUGE-S*', 'Average_F:', '0.03333', '(95%-conf.int.', '0.03333', '-', '0.03333)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:105', 'F:19']
dict_values(['Under certain conditions the constituent voting and na&#239;ve Bayes constituent combination techniques are guaranteed to produce sets of constituents with no crossing brackets.'])
dict_values(['These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).', 'Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.', 'IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.', 'The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00694', '(95%-conf.int.', '0.00694', '-', '0.00694)']
['system', 'ROUGE-S*', 'Average_P:', '0.11667', '(95%-conf.int.', '0.11667', '-', '0.11667)']
['system', 'ROUGE-S*', 'Average_F:', '0.01311', '(95%-conf.int.', '0.01311', '-', '0.01311)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:120', 'F:14']
dict_values(['The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.'])
dict_values(['Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).', 'The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).', 'We call this technique constituent voting.', 'The average individual parser accuracy was reduced by more than 5% when we added this new parser, but the precision of the constituent voting technique was the only result that decreased significantly.'])
['system', 'ROUGE-S*', 'Average_R:', '0.02725', '(95%-conf.int.', '0.02725', '-', '0.02725)']
['system', 'ROUGE-S*', 'Average_P:', '0.13000', '(95%-conf.int.', '0.13000', '-', '0.13000)']
['system', 'ROUGE-S*', 'Average_F:', '0.04506', '(95%-conf.int.', '0.04506', '-', '0.04506)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1431', 'P:300', 'F:39']
dict_values(['From this we see that a finer-grained model for parser combination, at least for the features we have examined, will not give us any additional power.'])
dict_values(['It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.', 'For example, one parser could be more accurate at predicting noun phrases than the other parsers.', 'None of the models we have presented utilize features associated with a particular constituent (i.e. the label, span, parent label, etc.) to influence parser preference.', 'From this we see that a finer-grained model for parser combination, at least for the features we have examined, will not give us any additional power.'])
['system', 'ROUGE-S*', 'Average_R:', '0.06401', '(95%-conf.int.', '0.06401', '-', '0.06401)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.12032', '(95%-conf.int.', '0.12032', '-', '0.12032)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:703', 'P:45', 'F:45']
dict_values(['We have presented two general approaches to studying parser combination: parser switching and parse hybridization.'])
dict_values(['One hybridization strategy is to let the parsers vote on constituents\\ membership in the hypothesized set.', 'One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.', 'We have developed a general approach for combining parsers when preserving the entire structure of a parse tree is important.', 'It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.'])
['system', 'ROUGE-S*', 'Average_R:', '0.01449', '(95%-conf.int.', '0.01449', '-', '0.01449)']
['system', 'ROUGE-S*', 'Average_P:', '0.33333', '(95%-conf.int.', '0.33333', '-', '0.33333)']
['system', 'ROUGE-S*', 'Average_F:', '0.02778', '(95%-conf.int.', '0.02778', '-', '0.02778)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:45', 'F:15']
dict_values(['For our experiments we also report the mean of precision and recall, which we denote by (P + R)I2 and F-measure.', 'F-measure is the harmonic mean of precision and recall, 2PR/(P + R).', 'It is closer to the smaller value of precision and recall when there is a large skew in their values.'])
dict_values(['In this case we are interested in finding\\ the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.', 'Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.', 'Consider for a set of constituents the isolated constituent precision parser metric, the portion of isolated constituents that are correctly hypothesized.', 'The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00501', '(95%-conf.int.', '0.00501', '-', '0.00501)']
['system', 'ROUGE-S*', 'Average_P:', '0.04678', '(95%-conf.int.', '0.04678', '-', '0.04678)']
['system', 'ROUGE-S*', 'Average_F:', '0.00905', '(95%-conf.int.', '0.00905', '-', '0.00905)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:171', 'F:8']
dict_values(['In general, the lemma of the previous section does not ensure that all the productions in the combined parse are found in the grammars of the member parsers.'])
dict_values(['The machine learning community has been in a similar situation and has studied the combination of multiple classifiers (Wolpert, 1992; Heath et al., 1996).', 'Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).', 'The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).', 'If the parse contains productions from outside our grammar the machine has no direct method for handling them (e.g. the resulting database query may be syntactically malformed).'])
['system', 'ROUGE-S*', 'Average_R:', '0.00219', '(95%-conf.int.', '0.00219', '-', '0.00219)']
['system', 'ROUGE-S*', 'Average_P:', '0.06061', '(95%-conf.int.', '0.06061', '-', '0.06061)']
['system', 'ROUGE-S*', 'Average_F:', '0.00422', '(95%-conf.int.', '0.00422', '-', '0.00422)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:66', 'F:4']
dict_values(['Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.'])
dict_values(['Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.', 'Each parse is converted into a set of constituents represented as a tuples: (label, start, end).', 'The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.', 'Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.'])
['system', 'ROUGE-S*', 'Average_R:', '0.09713', '(95%-conf.int.', '0.09713', '-', '0.09713)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.17707', '(95%-conf.int.', '0.17707', '-', '0.17707)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1081', 'P:105', 'F:105']
0.32822777413080256 0.026699999703333338 0.048804443902172846





input/ref/Task1/W99-0623_vardha.csv
input/res/Task1/W99-0623.annv3.csv
parsing: input/ref/Task1/W99-0623_vardha.csv
    <S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'85'"]
'85'
['85']
parsed_discourse_facet ['method_citation']
<S sid="117" ssid="46">Another way to interpret this is that less than 5% of the correct constituents are missing from the hypotheses generated by the union of the three parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'117'"]
'117'
['117']
parsed_discourse_facet ['method_citation']
<S sid="72" ssid="1">The three parsers were trained and tuned by their creators on various sections of the WSJ portion of the Penn Treebank, leaving only sections 22 and 23 completely untouched during the development of any of the parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'72'"]
'72'
['72']
parsed_discourse_facet ['method_citation']
    <S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'120'"]
'120'
['120']
parsed_discourse_facet ['method_citation']
  <S sid="139" ssid="1">We have presented two general approaches to studying parser combination: parser switching and parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["'139'"]
'139'
['139']
parsed_discourse_facet ['method_citation']
 <S sid="84" ssid="13">The first shows how constituent features and context do not help in deciding which parser to trust.</S>
original cit marker offset is 0
new cit marker offset is 0



["'84'"]
'84'
['84']
parsed_discourse_facet ['method_citation']
    <S sid="76" ssid="5">The standard measures for evaluating Penn Treebank parsing performance are precision and recall of the predicted constituents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'76'"]
'76'
['76']
parsed_discourse_facet ['method_citation']
 <S sid="38" ssid="24">Under certain conditions the constituent voting and na&#239;ve Bayes constituent combination techniques are guaranteed to produce sets of constituents with no crossing brackets.</S>
original cit marker offset is 0
new cit marker offset is 0



["'38'"]
'38'
['38']
parsed_discourse_facet ['method_citation']
  <S sid="25" ssid="11">In our particular case the majority requires the agreement of only two parsers because we have only three.</S>
original cit marker offset is 0
new cit marker offset is 0



["'25'"]
'25'
['25']
parsed_discourse_facet ['method_citation']
 <S sid="72" ssid="1">The three parsers were trained and tuned by their creators on various sections of the WSJ portion of the Penn Treebank, leaving only sections 22 and 23 completely untouched during the development of any of the parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'72'"]
'72'
['72']
parsed_discourse_facet ['method_citation']
    <S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'87'"]
'87'
['87']
parsed_discourse_facet ['method_citation']
    <S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S>
original cit marker offset is 0
new cit marker offset is 0



["'51'"]
'51'
['51']
parsed_discourse_facet ['method_citation']
    <S sid="79" ssid="8">Precision is the portion of hypothesized constituents that are correct and recall is the portion of the Treebank constituents that are hypothesized.</S>
original cit marker offset is 0
new cit marker offset is 0



["'79'"]
'79'
['79']
parsed_discourse_facet ['method_citation']
  <S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'"]
'27'
['27']
parsed_discourse_facet ['method_citation']
 <S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S>
original cit marker offset is 0
new cit marker offset is 0



["'77'"]
'77'
['77']
parsed_discourse_facet ['method_citation']
  <S sid="11" ssid="7">Similar advances have been made in machine translation (Frederking and Nirenburg, 1994), speech recognition (Fiscus, 1997) and named entity recognition (Borthwick et al., 1998).</S>
original cit marker offset is 0
new cit marker offset is 0



["'11'"]
'11'
['11']
parsed_discourse_facet ['method_citation']
  <S sid="116" ssid="45">The maximum precision row is the upper bound on accuracy if we could pick exactly the correct constituents from among the constituents suggested by the three parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'116'"]
'116'
['116']
parsed_discourse_facet ['method_citation']
parsing: input/res/Task1/W99-0623.annv3.csv
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S><S sid="86" ssid="15">Finally we show the combining techniques degrade very little when a poor parser is added to the set.</S><S sid="146" ssid="1">We would like to thank Eugene Charniak, Michael Collins, and Adwait Ratnaparkhi for enabling all of this research by providing us with their parsers and helpful comments.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'85'", "'86'", "'146'"]
'1'
'85'
'86'
'146'
['1', '85', '86', '146']
parsed_discourse_facet ['hypothesis_citation', 'aim_citation']
<S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="41" ssid="27">IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.</S><S sid="105" ssid="34">Similarly Figures 1 and 2 show how the isolated constituent precision varies by sentence length and the size of the span of the hypothesized constituent.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'41'", "'105'", "'120'"]
'39'
'41'
'105'
'120'
['39', '41', '105', '120']
parsed_discourse_facet ['method_citation']
<S sid="26" ssid="12">This technique has the advantage of requiring no training, but it has the disadvantage of treating all parsers equally even though they may have differing accuracies or may specialize in modeling different phenomena.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="93" ssid="22">Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.</S><S sid="94" ssid="23">This is the only important case, because otherwise the simple majority combining technique would pick the correct constituent.</S>
original cit marker offset is 0
new cit marker offset is 0



["'26'", "'27'", "'93'", "'94'"]
'26'
'27'
'93'
'94'
['26', '27', '93', '94']
parsed_discourse_facet ['method_citation']
<S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="40" ssid="26">Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.</S>
original cit marker offset is 0
new cit marker offset is 0



["'23'", "'27'", "'39'", "'40'"]
'23'
'27'
'39'
'40'
['23', '27', '39', '40']
parsed_discourse_facet ['method_citation']
<S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="32" ssid="18">In Equations 1 through 3 we develop the model for constructing our parse using na&#239;ve Bayes classification.</S><S sid="118" ssid="47">The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.</S><S sid="140" ssid="2">For each experiment we gave an nonparametric and a parametric technique for combining parsers.</S>
original cit marker offset is 0
new cit marker offset is 0



["'27'", "'32'", "'118'", "'140'"]
'27'
'32'
'118'
'140'
['27', '32', '118', '140']
parsed_discourse_facet ['method_citation']
<S sid="39" ssid="25">There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.</S><S sid="92" ssid="21">While we cannot prove there are no such useful features on which one should condition trust, we can give some insight into why the features we explored offered no gain.</S><S sid="93" ssid="22">Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'39'", "'92'", "'93'", "'120'"]
'39'
'92'
'93'
'120'
['39', '92', '93', '120']
parsed_discourse_facet ['method_citation']
<S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S><S sid="40" ssid="26">Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.</S><S sid="41" ssid="27">IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'13'", "'40'", "'41'", "'120'"]
'13'
'40'
'41'
'120'
['13', '40', '41', '120']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="9" ssid="5">Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).</S><S sid="12" ssid="8">The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).</S><S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="135" ssid="64">The average individual parser accuracy was reduced by more than 5% when we added this new parser, but the precision of the constituent voting technique was the only result that decreased significantly.</S>
original cit marker offset is 0
new cit marker offset is 0



["'9'", "'12'", "'23'", "'135'"]
'9'
'12'
'23'
'135'
['9', '12', '23', '135']
parsed_discourse_facet ['hypothesis_citation', 'method_citation']
<S sid="21" ssid="7">One hybridization strategy is to let the parsers vote on constituents\ membership in the hypothesized set.</S><S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S><S sid="95" ssid="24">One side of the decision making process is when we choose to believe a constituent should be in the parse, even though only one parser suggests it.</S><S sid="96" ssid="25">We call such a constituent an isolated constituent.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'51'", "'95'", "'96'"]
'21'
'51'
'95'
'96'
['21', '51', '95', '96']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="13" ssid="9">These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).</S><S sid="85" ssid="14">We then show that the combining techniques presented above give better parsing accuracy than any of the individual parsers.</S><S sid="120" ssid="49">The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'13'", "'85'", "'120'"]
'1'
'13'
'85'
'120'
['1', '13', '85', '120']
parsed_discourse_facet ['hypothesis_citation']
<S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S><S sid="88" ssid="17">For example, one parser could be more accurate at predicting noun phrases than the other parsers.</S><S sid="89" ssid="18">None of the models we have presented utilize features associated with a particular constituent (i.e. the label, span, parent label, etc.) to influence parser preference.</S><S sid="108" ssid="37">From this we see that a finer-grained model for parser combination, at least for the features we have examined, will not give us any additional power.</S>
original cit marker offset is 0
new cit marker offset is 0



["'87'", "'88'", "'89'", "'108'"]
'87'
'88'
'89'
'108'
['87', '88', '89', '108']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="21" ssid="7">One hybridization strategy is to let the parsers vote on constituents\ membership in the hypothesized set.</S><S sid="51" ssid="37">One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.</S><S sid="55" ssid="41">We have developed a general approach for combining parsers when preserving the entire structure of a parse tree is important.</S><S sid="87" ssid="16">It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.</S>
original cit marker offset is 0
new cit marker offset is 0



["'21'", "'51'", "'55'", "'87'"]
'21'
'51'
'55'
'87'
['21', '51', '55', '87']
parsed_discourse_facet ['method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S><S sid="78" ssid="7">The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'77'", "'78'", "'98'"]
'1'
'77'
'78'
'98'
['1', '77', '78', '98']
parsed_discourse_facet ['hypothesis_citation']
<S sid="20" ssid="6">Since our goal is to perform well under these measures we will similarly treat constituents as the minimal substructures for combination.</S><S sid="23" ssid="9">We call this technique constituent voting.</S><S sid="27" ssid="13">Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.</S><S sid="145" ssid="7">We plan to explore more powerful techniques for exploiting the diversity of parsing methods.</S>
original cit marker offset is 0
new cit marker offset is 0



["'20'", "'23'", "'27'", "'145'"]
'20'
'23'
'27'
'145'
['20', '23', '27', '145']
parsed_discourse_facet ['method_citation']
<S sid="70" ssid="56">In this case we are interested in finding\ the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S><S sid="99" ssid="28">Consider for a set of constituents the isolated constituent precision parser metric, the portion of isolated constituents that are correctly hypothesized.</S><S sid="118" ssid="47">The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.</S>
original cit marker offset is 0
new cit marker offset is 0



["'70'", "'98'", "'99'", "'118'"]
'70'
'98'
'99'
'118'
['70', '98', '99', '118']
parsed_discourse_facet ['method_citation']
<S sid="6" ssid="2">The machine learning community has been in a similar situation and has studied the combination of multiple classifiers (Wolpert, 1992; Heath et al., 1996).</S><S sid="9" ssid="5">Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).</S><S sid="12" ssid="8">The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).</S><S sid="54" ssid="40">If the parse contains productions from outside our grammar the machine has no direct method for handling them (e.g. the resulting database query may be syntactically malformed).</S>
original cit marker offset is 0
new cit marker offset is 0



["'6'", "'9'", "'12'", "'54'"]
'6'
'9'
'12'
'54'
['6', '9', '12', '54']
parsed_discourse_facet ['results_citation', 'method_citation']
<S sid="1" ssid="1">Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.</S><S sid="77" ssid="6">Each parse is converted into a set of constituents represented as a tuples: (label, start, end).</S><S sid="78" ssid="7">The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.</S><S sid="98" ssid="27">Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.</S>
original cit marker offset is 0
new cit marker offset is 0



["'1'", "'77'", "'78'", "'98'"]
'1'
'77'
'78'
'98'
['1', '77', '78', '98']
parsed_discourse_facet ['method_citation', 'aim_citation']
dict_values(['Another way to interpret this is that less than 5% of the correct constituents are missing from the hypotheses generated by the union of the three parsers.'])
dict_values(['There are simply not enough votes remaining to allow any of the crossing structures to enter the hypothesized constituent set.', 'IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.', 'Similarly Figures 1 and 2 show how the isolated constituent precision varies by sentence length and the size of the span of the hypothesized constituent.', 'The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00164', '(95%-conf.int.', '0.00164', '-', '0.00164)']
['system', 'ROUGE-S*', 'Average_P:', '0.08333', '(95%-conf.int.', '0.08333', '-', '0.08333)']
['system', 'ROUGE-S*', 'Average_F:', '0.00322', '(95%-conf.int.', '0.00322', '-', '0.00322)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1830', 'P:36', 'F:3']
dict_values(['The three parsers were trained and tuned by their creators on various sections of the WSJ portion of the Penn Treebank, leaving only sections 22 and 23 completely untouched during the development of any of the parsers.'])
dict_values(['This technique has the advantage of requiring no training, but it has the disadvantage of treating all parsers equally even though they may have differing accuracies or may specialize in modeling different phenomena.', 'Another technique for parse hybridization is to use a na&#239;ve Bayes classifier to determine which constituents to include in the parse.', 'Because we are working with only three parsers, the only situation in which context will help us is when it can indicate we should choose to believe a single parser that disagrees with the majority hypothesis instead of the majority hypothesis itself.', 'This is the only important case, because otherwise the simple majority combining technique would pick the correct constituent.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00193', '(95%-conf.int.', '0.00193', '-', '0.00193)']
['system', 'ROUGE-S*', 'Average_P:', '0.01471', '(95%-conf.int.', '0.01471', '-', '0.01471)']
['system', 'ROUGE-S*', 'Average_F:', '0.00342', '(95%-conf.int.', '0.00342', '-', '0.00342)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:136', 'F:2']
dict_values(['The standard measures for evaluating Penn Treebank parsing performance are precision and recall of the predicted constituents.'])
dict_values(['These three parsers have given the best reported parsing results on the Penn Treebank Wall Street Journal corpus (Marcus et al., 1993).', 'Lemma: If the number of votes required by constituent voting is greater than half of the parsers under consideration the resulting structure has no crossing constituents.', 'IL+-1Proof: Assume a pair of crossing constituents appears in the output of the constituent voting technique using k parsers.', 'The precision and recall of similarity switching and constituent voting are both significantly better than the best individual parser, and constituent voting is significantly better than parser switching in precision.4 Constituent voting gives the highest accuracy for parsing the Penn Treebank reported to date.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00744', '(95%-conf.int.', '0.00744', '-', '0.00744)']
['system', 'ROUGE-S*', 'Average_P:', '0.27273', '(95%-conf.int.', '0.27273', '-', '0.27273)']
['system', 'ROUGE-S*', 'Average_F:', '0.01449', '(95%-conf.int.', '0.01449', '-', '0.01449)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:2016', 'P:55', 'F:15']
dict_values(['Under certain conditions the constituent voting and na&#239;ve Bayes constituent combination techniques are guaranteed to produce sets of constituents with no crossing brackets.'])
dict_values(['Recently, combination techniques have been investigated for part of speech tagging with positive results (van Halteren et al., 1998; Brill and Wu, 1998).', 'The corpus-based statistical parsing community has many fast and accurate automated parsing systems, including systems produced by Collins (1997), Charniak (1997) and Ratnaparkhi (1997).', 'We call this technique constituent voting.', 'The average individual parser accuracy was reduced by more than 5% when we added this new parser, but the precision of the constituent voting technique was the only result that decreased significantly.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00839', '(95%-conf.int.', '0.00839', '-', '0.00839)']
['system', 'ROUGE-S*', 'Average_P:', '0.10000', '(95%-conf.int.', '0.10000', '-', '0.10000)']
['system', 'ROUGE-S*', 'Average_F:', '0.01547', '(95%-conf.int.', '0.01547', '-', '0.01547)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1431', 'P:120', 'F:12']
dict_values(['It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.'])
dict_values(['It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.', 'For example, one parser could be more accurate at predicting noun phrases than the other parsers.', 'None of the models we have presented utilize features associated with a particular constituent (i.e. the label, span, parent label, etc.) to influence parser preference.', 'From this we see that a finer-grained model for parser combination, at least for the features we have examined, will not give us any additional power.'])
['system', 'ROUGE-S*', 'Average_R:', '0.06401', '(95%-conf.int.', '0.06401', '-', '0.06401)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.12032', '(95%-conf.int.', '0.12032', '-', '0.12032)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:703', 'P:45', 'F:45']
dict_values(['One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.'])
dict_values(['One hybridization strategy is to let the parsers vote on constituents\\ membership in the hypothesized set.', 'One can trivially create situations in which strictly binary-branching trees are combined to create a tree with only the root node and the terminal nodes, a completely flat structure.', 'We have developed a general approach for combining parsers when preserving the entire structure of a parse tree is important.', 'It is possible one could produce better models by introducing features describing constituents and their contexts because one parser could be much better than the majority of the others in particular situations.'])
['system', 'ROUGE-S*', 'Average_R:', '0.13140', '(95%-conf.int.', '0.13140', '-', '0.13140)']
['system', 'ROUGE-S*', 'Average_P:', '1.00000', '(95%-conf.int.', '1.00000', '-', '1.00000)']
['system', 'ROUGE-S*', 'Average_F:', '0.23228', '(95%-conf.int.', '0.23228', '-', '0.23228)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1035', 'P:136', 'F:136']
dict_values(['Each parse is converted into a set of constituents represented as a tuples: (label, start, end).'])
dict_values(['In this case we are interested in finding\\ the maximum probability parse, ri, and Mi is the set of relevant (binary) parsing decisions made by parser i. ri is a parse selected from among the outputs of the individual parsers.', 'Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.', 'Consider for a set of constituents the isolated constituent precision parser metric, the portion of isolated constituents that are correctly hypothesized.', 'The maximum precision oracle is an upper bound on the possible gain we can achieve by parse hybridization.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00188', '(95%-conf.int.', '0.00188', '-', '0.00188)']
['system', 'ROUGE-S*', 'Average_P:', '0.08333', '(95%-conf.int.', '0.08333', '-', '0.08333)']
['system', 'ROUGE-S*', 'Average_F:', '0.00368', '(95%-conf.int.', '0.00368', '-', '0.00368)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1596', 'P:36', 'F:3']
dict_values(['The maximum precision row is the upper bound on accuracy if we could pick exactly the correct constituents from among the constituents suggested by the three parsers.'])
dict_values(['Three state-of-the-art statistical parsers are combined to produce more accurate parses, as well as new bounds on achievable Treebank parsing accuracy.', 'Each parse is converted into a set of constituents represented as a tuples: (label, start, end).', 'The set is then compared with the set generated from the Penn Treebank parse to determine the precision and recall.', 'Adding the isolated constituents to our hypothesis parse could increase our expected recall, but in the cases we investigated it would invariably hurt our precision more than we would gain on recall.'])
['system', 'ROUGE-S*', 'Average_R:', '0.00648', '(95%-conf.int.', '0.00648', '-', '0.00648)']
['system', 'ROUGE-S*', 'Average_P:', '0.10606', '(95%-conf.int.', '0.10606', '-', '0.10606)']
['system', 'ROUGE-S*', 'Average_F:', '0.01221', '(95%-conf.int.', '0.01221', '-', '0.01221)']
['system', 'ROUGE-S*', 'Eval', 'test.system', 'R:1081', 'P:66', 'F:7']
0.33251999584350006 0.02789624965129688 0.05063624936704689
creating setting: abstract
else part task 2
eval: abstract
['system', 'ROUGE-1', 'Average_R:', '0.55873', '(95%-conf.int.', '0.48421', '-', '0.63906)']
['system', 'ROUGE-1', 'Average_P:', '0.21631', '(95%-conf.int.', '0.15852', '-', '0.27257)']
['system', 'ROUGE-1', 'Average_F:', '0.31123', '(95%-conf.int.', '0.23964', '-', '0.37574)']
['system', 'ROUGE-1', 'Eval', 'A00-2018.system', 'R:82', 'P:146', 'F:48']
['system', 'ROUGE-1', 'Eval', 'A00-2030.system', 'R:31', 'P:135', 'F:13']
['system', 'ROUGE-1', 'Eval', 'A97-1014.system', 'R:36', 'P:130', 'F:15']
['system', 'ROUGE-1', 'Eval', 'D09-1092.system', 'R:50', 'P:349', 'F:7']
['system', 'ROUGE-1', 'Eval', 'D10-1044.system', 'R:44', 'P:148', 'F:22']
['system', 'ROUGE-1', 'Eval', 'E03-1005.system', 'R:53', 'P:139', 'F:38']
['system', 'ROUGE-1', 'Eval', 'J01-2004.system', 'R:90', 'P:133', 'F:38']
['system', 'ROUGE-1', 'Eval', 'P04-1036.system', 'R:87', 'P:120', 'F:40']
['system', 'ROUGE-1', 'Eval', 'P05-1013.system', 'R:52', 'P:160', 'F:47']
['system', 'ROUGE-1', 'Eval', 'P08-1028.system', 'R:40', 'P:132', 'F:25']
['system', 'ROUGE-1', 'Eval', 'P08-1043.system', 'R:67', 'P:154', 'F:46']
['system', 'ROUGE-1', 'Eval', 'P08-1102.system', 'R:62', 'P:144', 'F:21']
['system', 'ROUGE-1', 'Eval', 'P11-1060.system', 'R:63', 'P:159', 'F:53']
['system', 'ROUGE-1', 'Eval', 'P11-1061.system', 'R:70', 'P:149', 'F:42']
['system', 'ROUGE-1', 'Eval', 'P87-1015.system', 'R:60', 'P:114', 'F:51']
['system', 'ROUGE-1', 'Eval', 'W06-2932.system', 'R:53', 'P:146', 'F:31']
['system', 'ROUGE-1', 'Eval', 'W06-3114.system', 'R:24', 'P:122', 'F:11']
['system', 'ROUGE-1', 'Eval', 'W11-2123.system', 'R:79', 'P:153', 'F:30']
['system', 'ROUGE-1', 'Eval', 'W99-0613.system', 'R:77', 'P:142', 'F:49']
['system', 'ROUGE-1', 'Eval', 'W99-0623.system', 'R:32', 'P:129', 'F:20']
['system', 'ROUGE-2', 'Average_R:', '0.32629', '(95%-conf.int.', '0.22602', '-', '0.43911)']
yay
['system', 'ROUGE-2', 'Average_P:', '0.12504', '(95%-conf.int.', '0.07664', '-', '0.17699)']
yay
['system', 'ROUGE-2', 'Average_F:', '0.18042', '(95%-conf.int.', '0.11526', '-', '0.24870)']
yay
['system', 'ROUGE-2', 'Eval', 'A00-2018.system', 'R:81', 'P:145', 'F:31']
yay
['system', 'ROUGE-2', 'Eval', 'A00-2030.system', 'R:30', 'P:134', 'F:4']
yay
['system', 'ROUGE-2', 'Eval', 'A97-1014.system', 'R:35', 'P:129', 'F:2']
yay
['system', 'ROUGE-2', 'Eval', 'D09-1092.system', 'R:49', 'P:348', 'F:0']
yay
['system', 'ROUGE-2', 'Eval', 'D10-1044.system', 'R:43', 'P:147', 'F:4']
yay
['system', 'ROUGE-2', 'Eval', 'E03-1005.system', 'R:52', 'P:138', 'F:29']
yay
['system', 'ROUGE-2', 'Eval', 'J01-2004.system', 'R:89', 'P:132', 'F:11']
yay
['system', 'ROUGE-2', 'Eval', 'P04-1036.system', 'R:86', 'P:119', 'F:19']
yay
['system', 'ROUGE-2', 'Eval', 'P05-1013.system', 'R:51', 'P:159', 'F:42']
yay
['system', 'ROUGE-2', 'Eval', 'P08-1028.system', 'R:39', 'P:131', 'F:6']
yay
['system', 'ROUGE-2', 'Eval', 'P08-1043.system', 'R:66', 'P:153', 'F:38']
yay
['system', 'ROUGE-2', 'Eval', 'P08-1102.system', 'R:61', 'P:143', 'F:4']
yay
['system', 'ROUGE-2', 'Eval', 'P11-1060.system', 'R:62', 'P:158', 'F:49']
yay
['system', 'ROUGE-2', 'Eval', 'P11-1061.system', 'R:69', 'P:148', 'F:31']
yay
['system', 'ROUGE-2', 'Eval', 'P87-1015.system', 'R:59', 'P:113', 'F:42']
yay
['system', 'ROUGE-2', 'Eval', 'W06-2932.system', 'R:52', 'P:145', 'F:10']
yay
['system', 'ROUGE-2', 'Eval', 'W06-3114.system', 'R:23', 'P:121', 'F:3']
yay
['system', 'ROUGE-2', 'Eval', 'W11-2123.system', 'R:78', 'P:152', 'F:7']
yay
['system', 'ROUGE-2', 'Eval', 'W99-0613.system', 'R:76', 'P:141', 'F:28']
yay
['system', 'ROUGE-2', 'Eval', 'W99-0623.system', 'R:31', 'P:128', 'F:14']
yay
['system', 'ROUGE-SU*', 'Average_R:', '0.29552', '(95%-conf.int.', '0.21686', '-', '0.38888)']
['system', 'ROUGE-SU*', 'Average_P:', '0.04605', '(95%-conf.int.', '0.02398', '-', '0.07137)']
['system', 'ROUGE-SU*', 'Average_F:', '0.07915', '(95%-conf.int.', '0.04342', '-', '0.11793)']
['system', 'ROUGE-SU*', 'Eval', 'A00-2018.system', 'R:3402', 'P:10730', 'F:798']
['system', 'ROUGE-SU*', 'Eval', 'A00-2030.system', 'R:495', 'P:9179', 'F:57']
['system', 'ROUGE-SU*', 'Eval', 'A97-1014.system', 'R:665', 'P:8514', 'F:110']
['system', 'ROUGE-SU*', 'Eval', 'D09-1092.system', 'R:1274', 'P:61074', 'F:30']
['system', 'ROUGE-SU*', 'Eval', 'D10-1044.system', 'R:989', 'P:11025', 'F:213']
['system', 'ROUGE-SU*', 'Eval', 'E03-1005.system', 'R:1430', 'P:9729', 'F:725']
['system', 'ROUGE-SU*', 'Eval', 'J01-2004.system', 'R:4094', 'P:8910', 'F:661']
['system', 'ROUGE-SU*', 'Eval', 'P04-1036.system', 'R:3827', 'P:7259', 'F:733']
['system', 'ROUGE-SU*', 'Eval', 'P05-1013.system', 'R:1377', 'P:12879', 'F:1053']
['system', 'ROUGE-SU*', 'Eval', 'P08-1028.system', 'R:819', 'P:8777', 'F:269']
['system', 'ROUGE-SU*', 'Eval', 'P08-1043.system', 'R:2277', 'P:11934', 'F:1060']
['system', 'ROUGE-SU*', 'Eval', 'P08-1102.system', 'R:1952', 'P:10439', 'F:209']
['system', 'ROUGE-SU*', 'Eval', 'P11-1060.system', 'R:2015', 'P:12719', 'F:1390']
['system', 'ROUGE-SU*', 'Eval', 'P11-1061.system', 'R:2484', 'P:11174', 'F:839']
['system', 'ROUGE-SU*', 'Eval', 'P87-1015.system', 'R:1829', 'P:6554', 'F:1172']
['system', 'ROUGE-SU*', 'Eval', 'W06-2932.system', 'R:1430', 'P:10730', 'F:452']
['system', 'ROUGE-SU*', 'Eval', 'W06-3114.system', 'R:299', 'P:7502', 'F:64']
['system', 'ROUGE-SU*', 'Eval', 'W11-2123.system', 'R:3159', 'P:11780', 'F:299']
['system', 'ROUGE-SU*', 'Eval', 'W99-0613.system', 'R:3002', 'P:10152', 'F:754']
['system', 'ROUGE-SU*', 'Eval', 'W99-0623.system', 'R:527', 'P:8384', 'F:206']
creating setting: community
else part task 2
eval: community
['system', 'ROUGE-1', 'Average_R:', '0.31494', '(95%-conf.int.', '0.28068', '-', '0.34311)']
['system', 'ROUGE-1', 'Average_P:', '0.52087', '(95%-conf.int.', '0.40047', '-', '0.61052)']
['system', 'ROUGE-1', 'Average_F:', '0.39194', '(95%-conf.int.', '0.33484', '-', '0.43737)']
['system', 'ROUGE-1', 'Eval', 'A00-2018.system', 'R:762', 'P:438', 'F:252']
['system', 'ROUGE-1', 'Eval', 'A00-2030.system', 'R:684', 'P:405', 'F:258']
['system', 'ROUGE-1', 'Eval', 'A97-1014.system', 'R:447', 'P:390', 'F:135']
['system', 'ROUGE-1', 'Eval', 'D09-1092.system', 'R:690', 'P:1047', 'F:57']
['system', 'ROUGE-1', 'Eval', 'D10-1044.system', 'R:933', 'P:444', 'F:348']
['system', 'ROUGE-1', 'Eval', 'E03-1005.system', 'R:819', 'P:417', 'F:267']
['system', 'ROUGE-1', 'Eval', 'J01-2004.system', 'R:996', 'P:399', 'F:198']
['system', 'ROUGE-1', 'Eval', 'P04-1036.system', 'R:868', 'P:480', 'F:264']
['system', 'ROUGE-1', 'Eval', 'P05-1013.system', 'R:945', 'P:480', 'F:327']
['system', 'ROUGE-1', 'Eval', 'P08-1028.system', 'R:690', 'P:396', 'F:249']
['system', 'ROUGE-1', 'Eval', 'P08-1043.system', 'R:1131', 'P:462', 'F:321']
['system', 'ROUGE-1', 'Eval', 'P08-1102.system', 'R:792', 'P:432', 'F:204']
['system', 'ROUGE-1', 'Eval', 'P11-1060.system', 'R:828', 'P:477', 'F:246']
['system', 'ROUGE-1', 'Eval', 'P11-1061.system', 'R:846', 'P:447', 'F:306']
['system', 'ROUGE-1', 'Eval', 'P87-1015.system', 'R:570', 'P:342', 'F:225']
['system', 'ROUGE-1', 'Eval', 'W06-2932.system', 'R:846', 'P:438', 'F:261']
['system', 'ROUGE-1', 'Eval', 'W06-3114.system', 'R:423', 'P:366', 'F:153']
['system', 'ROUGE-1', 'Eval', 'W11-2123.system', 'R:687', 'P:459', 'F:279']
['system', 'ROUGE-1', 'Eval', 'W99-0613.system', 'R:724', 'P:568', 'F:272']
['system', 'ROUGE-1', 'Eval', 'W99-0623.system', 'R:648', 'P:387', 'F:231']
['system', 'ROUGE-2', 'Average_R:', '0.18526', '(95%-conf.int.', '0.15576', '-', '0.21175)']
yay
['system', 'ROUGE-2', 'Average_P:', '0.30754', '(95%-conf.int.', '0.22969', '-', '0.38028)']
yay
['system', 'ROUGE-2', 'Average_F:', '0.23088', '(95%-conf.int.', '0.18652', '-', '0.27075)']
yay
['system', 'ROUGE-2', 'Eval', 'A00-2018.system', 'R:759', 'P:435', 'F:171']
yay
['system', 'ROUGE-2', 'Eval', 'A00-2030.system', 'R:681', 'P:402', 'F:147']
yay
['system', 'ROUGE-2', 'Eval', 'A97-1014.system', 'R:444', 'P:387', 'F:51']
yay
['system', 'ROUGE-2', 'Eval', 'D09-1092.system', 'R:687', 'P:1044', 'F:15']
yay
['system', 'ROUGE-2', 'Eval', 'D10-1044.system', 'R:930', 'P:441', 'F:240']
yay
['system', 'ROUGE-2', 'Eval', 'E03-1005.system', 'R:816', 'P:414', 'F:96']
yay
['system', 'ROUGE-2', 'Eval', 'J01-2004.system', 'R:993', 'P:396', 'F:108']
yay
['system', 'ROUGE-2', 'Eval', 'P04-1036.system', 'R:864', 'P:476', 'F:168']
yay
['system', 'ROUGE-2', 'Eval', 'P05-1013.system', 'R:942', 'P:477', 'F:222']
yay
['system', 'ROUGE-2', 'Eval', 'P08-1028.system', 'R:687', 'P:393', 'F:168']
yay
['system', 'ROUGE-2', 'Eval', 'P08-1043.system', 'R:1128', 'P:459', 'F:207']
yay
['system', 'ROUGE-2', 'Eval', 'P08-1102.system', 'R:789', 'P:429', 'F:69']
yay
['system', 'ROUGE-2', 'Eval', 'P11-1060.system', 'R:825', 'P:474', 'F:144']
yay
['system', 'ROUGE-2', 'Eval', 'P11-1061.system', 'R:843', 'P:444', 'F:207']
yay
['system', 'ROUGE-2', 'Eval', 'P87-1015.system', 'R:567', 'P:339', 'F:117']
yay
['system', 'ROUGE-2', 'Eval', 'W06-2932.system', 'R:843', 'P:435', 'F:183']
yay
['system', 'ROUGE-2', 'Eval', 'W06-3114.system', 'R:420', 'P:363', 'F:60']
yay
['system', 'ROUGE-2', 'Eval', 'W11-2123.system', 'R:684', 'P:456', 'F:183']
yay
['system', 'ROUGE-2', 'Eval', 'W99-0613.system', 'R:720', 'P:564', 'F:156']
yay
['system', 'ROUGE-2', 'Eval', 'W99-0623.system', 'R:645', 'P:384', 'F:144']
yay
['system', 'ROUGE-SU*', 'Average_R:', '0.09057', '(95%-conf.int.', '0.07565', '-', '0.10586)']
['system', 'ROUGE-SU*', 'Average_P:', '0.24389', '(95%-conf.int.', '0.13946', '-', '0.34413)']
['system', 'ROUGE-SU*', 'Average_F:', '0.13093', '(95%-conf.int.', '0.10027', '-', '0.15902)']
['system', 'ROUGE-SU*', 'Eval', 'A00-2018.system', 'R:97152', 'P:32190', 'F:8250']
['system', 'ROUGE-SU*', 'Eval', 'A00-2030.system', 'R:78315', 'P:27537', 'F:9969']
['system', 'ROUGE-SU*', 'Eval', 'A97-1014.system', 'R:33522', 'P:25542', 'F:2253']
['system', 'ROUGE-SU*', 'Eval', 'D09-1092.system', 'R:79692', 'P:183222', 'F:546']
['system', 'ROUGE-SU*', 'Eval', 'D10-1044.system', 'R:145545', 'P:33075', 'F:18414']
['system', 'ROUGE-SU*', 'Eval', 'E03-1005.system', 'R:112200', 'P:29187', 'F:10875']
['system', 'ROUGE-SU*', 'Eval', 'J01-2004.system', 'R:165831', 'P:26730', 'F:7005']
['system', 'ROUGE-SU*', 'Eval', 'P04-1036.system', 'R:94608', 'P:29036', 'F:8204']
['system', 'ROUGE-SU*', 'Eval', 'P05-1013.system', 'R:149307', 'P:38637', 'F:15618']
['system', 'ROUGE-SU*', 'Eval', 'P08-1028.system', 'R:79692', 'P:26331', 'F:7254']
['system', 'ROUGE-SU*', 'Eval', 'P08-1043.system', 'R:213756', 'P:35802', 'F:14658']
['system', 'ROUGE-SU*', 'Eval', 'P08-1102.system', 'R:104937', 'P:31317', 'F:7194']
['system', 'ROUGE-SU*', 'Eval', 'P11-1060.system', 'R:114675', 'P:38157', 'F:8931']
['system', 'ROUGE-SU*', 'Eval', 'P11-1061.system', 'R:119706', 'P:33522', 'F:13767']
['system', 'ROUGE-SU*', 'Eval', 'P87-1015.system', 'R:54432', 'P:19662', 'F:7746']
['system', 'ROUGE-SU*', 'Eval', 'W06-2932.system', 'R:119706', 'P:32190', 'F:10812']
['system', 'ROUGE-SU*', 'Eval', 'W06-3114.system', 'R:30030', 'P:22506', 'F:2142']
['system', 'ROUGE-SU*', 'Eval', 'W11-2123.system', 'R:79002', 'P:35340', 'F:12801']
['system', 'ROUGE-SU*', 'Eval', 'W99-0613.system', 'R:65880', 'P:40608', 'F:8172']
['system', 'ROUGE-SU*', 'Eval', 'W99-0623.system', 'R:70305', 'P:25152', 'F:8604']
creating setting: human
else part task 2
eval: human
['system', 'ROUGE-1', 'Average_R:', '0.45674', '(95%-conf.int.', '0.39236', '-', '0.51461)']
['system', 'ROUGE-1', 'Average_P:', '0.28380', '(95%-conf.int.', '0.21464', '-', '0.34125)']
['system', 'ROUGE-1', 'Average_F:', '0.34954', '(95%-conf.int.', '0.27891', '-', '0.40774)']
['system', 'ROUGE-1', 'Eval', 'A00-2018.system', 'R:336', 'P:438', 'F:171']
['system', 'ROUGE-1', 'Eval', 'A00-2030.system', 'R:252', 'P:405', 'F:162']
['system', 'ROUGE-1', 'Eval', 'A97-1014.system', 'R:228', 'P:390', 'F:87']
['system', 'ROUGE-1', 'Eval', 'D09-1092.system', 'R:267', 'P:1047', 'F:27']
['system', 'ROUGE-1', 'Eval', 'D10-1044.system', 'R:381', 'P:444', 'F:174']
['system', 'ROUGE-1', 'Eval', 'E03-1005.system', 'R:309', 'P:417', 'F:177']
['system', 'ROUGE-1', 'Eval', 'J01-2004.system', 'R:336', 'P:399', 'F:144']
['system', 'ROUGE-1', 'Eval', 'P04-1036.system', 'R:344', 'P:480', 'F:136']
['system', 'ROUGE-1', 'Eval', 'P05-1013.system', 'R:243', 'P:480', 'F:144']
['system', 'ROUGE-1', 'Eval', 'P08-1028.system', 'R:333', 'P:396', 'F:114']
['system', 'ROUGE-1', 'Eval', 'P08-1043.system', 'R:288', 'P:462', 'F:153']
['system', 'ROUGE-1', 'Eval', 'P08-1102.system', 'R:318', 'P:432', 'F:75']
['system', 'ROUGE-1', 'Eval', 'P11-1060.system', 'R:276', 'P:477', 'F:153']
['system', 'ROUGE-1', 'Eval', 'P11-1061.system', 'R:414', 'P:447', 'F:195']
['system', 'ROUGE-1', 'Eval', 'P87-1015.system', 'R:285', 'P:342', 'F:159']
['system', 'ROUGE-1', 'Eval', 'W06-2932.system', 'R:219', 'P:438', 'F:105']
['system', 'ROUGE-1', 'Eval', 'W06-3114.system', 'R:213', 'P:366', 'F:72']
['system', 'ROUGE-1', 'Eval', 'W11-2123.system', 'R:252', 'P:459', 'F:186']
['system', 'ROUGE-1', 'Eval', 'W99-0613.system', 'R:256', 'P:568', 'F:164']
['system', 'ROUGE-1', 'Eval', 'W99-0623.system', 'R:207', 'P:387', 'F:51']
['system', 'ROUGE-2', 'Average_R:', '0.23134', '(95%-conf.int.', '0.17347', '-', '0.29042)']
yay
['system', 'ROUGE-2', 'Average_P:', '0.14308', '(95%-conf.int.', '0.09948', '-', '0.18709)']
yay
['system', 'ROUGE-2', 'Average_F:', '0.17653', '(95%-conf.int.', '0.12756', '-', '0.22400)']
yay
['system', 'ROUGE-2', 'Eval', 'A00-2018.system', 'R:333', 'P:435', 'F:93']
yay
['system', 'ROUGE-2', 'Eval', 'A00-2030.system', 'R:249', 'P:402', 'F:93']
yay
['system', 'ROUGE-2', 'Eval', 'A97-1014.system', 'R:225', 'P:387', 'F:21']
yay
['system', 'ROUGE-2', 'Eval', 'D09-1092.system', 'R:264', 'P:1044', 'F:0']
yay
['system', 'ROUGE-2', 'Eval', 'D10-1044.system', 'R:378', 'P:441', 'F:90']
yay
['system', 'ROUGE-2', 'Eval', 'E03-1005.system', 'R:306', 'P:414', 'F:102']
yay
['system', 'ROUGE-2', 'Eval', 'J01-2004.system', 'R:333', 'P:396', 'F:78']
yay
['system', 'ROUGE-2', 'Eval', 'P04-1036.system', 'R:340', 'P:476', 'F:64']
yay
['system', 'ROUGE-2', 'Eval', 'P05-1013.system', 'R:240', 'P:477', 'F:90']
yay
['system', 'ROUGE-2', 'Eval', 'P08-1028.system', 'R:330', 'P:393', 'F:15']
yay
['system', 'ROUGE-2', 'Eval', 'P08-1043.system', 'R:285', 'P:459', 'F:117']
yay
['system', 'ROUGE-2', 'Eval', 'P08-1102.system', 'R:315', 'P:429', 'F:21']
yay
['system', 'ROUGE-2', 'Eval', 'P11-1060.system', 'R:273', 'P:474', 'F:96']
yay
['system', 'ROUGE-2', 'Eval', 'P11-1061.system', 'R:411', 'P:444', 'F:90']
yay
['system', 'ROUGE-2', 'Eval', 'P87-1015.system', 'R:282', 'P:339', 'F:66']
yay
['system', 'ROUGE-2', 'Eval', 'W06-2932.system', 'R:216', 'P:435', 'F:27']
yay
['system', 'ROUGE-2', 'Eval', 'W06-3114.system', 'R:210', 'P:363', 'F:18']
yay
['system', 'ROUGE-2', 'Eval', 'W11-2123.system', 'R:249', 'P:456', 'F:141']
yay
['system', 'ROUGE-2', 'Eval', 'W99-0613.system', 'R:252', 'P:564', 'F:104']
yay
['system', 'ROUGE-2', 'Eval', 'W99-0623.system', 'R:204', 'P:384', 'F:9']
yay
['system', 'ROUGE-SU*', 'Average_R:', '0.19742', '(95%-conf.int.', '0.15836', '-', '0.23562)']
['system', 'ROUGE-SU*', 'Average_P:', '0.07461', '(95%-conf.int.', '0.04100', '-', '0.10851)']
['system', 'ROUGE-SU*', 'Average_F:', '0.10737', '(95%-conf.int.', '0.06603', '-', '0.14518)']
['system', 'ROUGE-SU*', 'Eval', 'A00-2018.system', 'R:18981', 'P:32190', 'F:3465']
['system', 'ROUGE-SU*', 'Eval', 'A00-2030.system', 'R:10707', 'P:27537', 'F:4140']
['system', 'ROUGE-SU*', 'Eval', 'A97-1014.system', 'R:8775', 'P:25542', 'F:1137']
['system', 'ROUGE-SU*', 'Eval', 'D09-1092.system', 'R:12012', 'P:183222', 'F:141']
['system', 'ROUGE-SU*', 'Eval', 'D10-1044.system', 'R:24381', 'P:33075', 'F:4251']
['system', 'ROUGE-SU*', 'Eval', 'E03-1005.system', 'R:16065', 'P:29187', 'F:4536']
['system', 'ROUGE-SU*', 'Eval', 'J01-2004.system', 'R:18981', 'P:26730', 'F:3399']
['system', 'ROUGE-SU*', 'Eval', 'P04-1036.system', 'R:14960', 'P:29036', 'F:2300']
['system', 'ROUGE-SU*', 'Eval', 'P05-1013.system', 'R:9960', 'P:38637', 'F:3216']
['system', 'ROUGE-SU*', 'Eval', 'P08-1028.system', 'R:18645', 'P:26331', 'F:2178']
['system', 'ROUGE-SU*', 'Eval', 'P08-1043.system', 'R:13965', 'P:35802', 'F:3393']
['system', 'ROUGE-SU*', 'Eval', 'P08-1102.system', 'R:17010', 'P:31317', 'F:912']
['system', 'ROUGE-SU*', 'Eval', 'P11-1060.system', 'R:12831', 'P:38157', 'F:3648']
['system', 'ROUGE-SU*', 'Eval', 'P11-1061.system', 'R:28770', 'P:33522', 'F:6024']
['system', 'ROUGE-SU*', 'Eval', 'P87-1015.system', 'R:13677', 'P:19662', 'F:3834']
['system', 'ROUGE-SU*', 'Eval', 'W06-2932.system', 'R:8100', 'P:32190', 'F:1521']
['system', 'ROUGE-SU*', 'Eval', 'W06-3114.system', 'R:7665', 'P:22506', 'F:675']
['system', 'ROUGE-SU*', 'Eval', 'W11-2123.system', 'R:10707', 'P:35340', 'F:4248']
['system', 'ROUGE-SU*', 'Eval', 'W99-0613.system', 'R:8316', 'P:40608', 'F:2780']
['system', 'ROUGE-SU*', 'Eval', 'W99-0623.system', 'R:7242', 'P:25152', 'F:384']
